{
  "articles/UserManual/Services.html": {
    "href": "articles/UserManual/Services.html",
    "title": "Services | Intent Architect",
    "keywords": "Services This screen allows to describe your services. As with all the meta data describing DSLs this data is technology agnotic and can be extending using your own custom meta data through the stereotype system. 1. Incomplete Incomplete"
  },
  "articles/UserManual/Dto.html": {
    "href": "articles/UserManual/Dto.html",
    "title": "Data Contracts | Intent Architect",
    "keywords": "Data Contracts This screen allows to describe your data contracts or data transfer objects. As with all the meta data describing DSLs this data is technology agnotic and can be extending using your own custom meta data through the stereotype system. 1. Incomplete Incomplete"
  },
  "modules/RoslynWeaver/Overview.html": {
    "href": "modules/RoslynWeaver/Overview.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Overview Roslyn Weaver allows developers to change or extend generated code files with their own custom code. Templates designed to work with this extension are far more powerful than traditional code generation, they allow hand written code to be introduced into the generated code. These template still maintaining the ability to continue changing and executing without losing the hand written code. In summary it allows generated code and custom written code to live symbiotically in a single file. The primary driver behind Roslyn Weaver is to overcome one of the biggest limitations of traditional code generation systems which is that they are typically ' all or nothing '. That is to to say you have to use the generated code as is for all scenarios and there is a very limit scope for extensibility. Any extensibility is typically done through inheritance or partial classes. While these traditional methods are available and may be great to use for some scenarios Roslyn Weaver introduces a wide new range of possibilities. Due to the Roslyn Weaver's ability to integate non-generated with generated code there are many new possibilities for extensibility beyond those of traditional code generation techniques. Some extensibilty techniques may include, (but not limited to) Creating custom code extention points in your templates Roslyn Weaver allows explicit deviation from the template, by the developer, for exceptional scenarios Template outputs are more open to change by the developer Some of the design goals behind Roslyn Weaver Feel and look like normal code, generated code is often easy to spot and terrible to read or maintain, Roslyn Weaver wants to be part of your dev team. Respect the developers code, try to maintain formatting and white space as much as possible. Try to be unintrusive, code should look and fell like code you would traditionally hand write. Terminology How Roslyn Weaver works Roslyn Weaver for Template Designers Roslyn Weaver for Template Consumers Roslyn Weaver Attributes Code Migrations Gotchas Appendix"
  },
  "modules/RoslynWeaver/Terminology.html": {
    "href": "modules/RoslynWeaver/Terminology.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Terminology Terms Term Description Roslyn Weaver Intent Architect plugin designed to merge existing code (Solution Code) with generated code (Tempate Output) to provide a more powerful and interactive code generation experience. Code Element The refers to a code fragment, e.g a method or property, within a code file which can be targeted for code weaving. List of Code Elements Mode This describes the strategy the Roslyn Weaver will use for weaving a specific code element when it is processing it. Output Transformer This is a plugin type supported by Intent Architect. This plugin type allows for the modification of the code being generated, it occurs after template execution but before peristence of the solution file. Roslyn Weaver is an example of such a plugin. Solution Code File Refers to a code file in a solution. These are the actual code files you would compile to produce your software product. The outputs from Intent Architect, i.e. the generated code, are typically solution code files. Within the context of the Roslyn Weaver it is important to note that these are also inputs, as the previous Intent Architects executions outputs become inputs to the following execution. Template Output Refers the generated code produced by Intent Architect. The Roslyn Weaver will weave this output with it's corresponding Solution Code Files to produce a new versions of the Solution Code Files. Weaving The process of taking a 2 pieces of code and merging them together to form a single piece of code."
  },
  "modules/RoslynWeaver/Appendix.html": {
    "href": "modules/RoslynWeaver/Appendix.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Appendix List of Roslyn Weave Code Elements Classes Constructors Enums Fields Interfaces Methods Properties Roslyn Weave Modes Mode Description Fully The generated code element will be used. Ignore The non-generated element code will be used. Merge The code elemeents from both sources will be merged together. Code Element mode specifics Code Element Signatue Body Class The class header i.e. every thing before the first {. The class body i.e. every thing after the first {. Constructor The signature of the constructor, i.e. every thing before the first {. The body of the constructor, i.e. every thing after the first { Enum The enum header i.e. every thing before the first {. The enum body i.e. every thing after the first {. Field The field declaration. N/A Interface The interface header i.e. every thing before the first {. The interface body i.e. every thing after the first {. Method The signature of the method, i.e. every thing before the first {. The body of the mthod, i.e. every thing after the first { Property The signature of the property, i.e. every thing before the first {. The body of the property, i.e. every thing after the first {"
  },
  "modules/RoslynWeaver/HowItWorks.html": {
    "href": "modules/RoslynWeaver/HowItWorks.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver How it works The Roslyn Weaver is an Intent Architect extension, more specifically an Output Transformer. The Roslyn Weaver works by modfiying the standard Intent Architect process. Simplyfied Intent Architect execution process Roslyn weavers intercepts the template output, finds the existing solution file ( if present) and weaves them together, typically preserving the non-generated code and merging in the generated template output. Roslyn Weaver's modified Intent Architect execution process As you can imagine the process of merging the code is complex, having said that developers do it all the time. Roslyn Weaver merges the code by allowing developers to annotate the code with attributes which dictate how the merging should be performed. These attributes are typically used in one of two ways:- By template designers to degin extend points in their templates, i.e. the \"put your code here\" scenario. Roslyn Weaver for Template Designers By developers consuming the templates to extend or deviate from the templatised pattern. Roslyn Weaver for Template Consumers"
  },
  "modules/RoslynWeaver/CodeMigrations.html": {
    "href": "modules/RoslynWeaver/CodeMigrations.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Code Migrations"
  },
  "modules/RoslynWeaver/HowToWorkWith.html": {
    "href": "modules/RoslynWeaver/HowToWorkWith.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Working with Roslyn Weaver templates Roslyn Weaver provides several code based attributes ( Roslyn Weaver attributes ) which can used to control or change the code weaving process. As a developer working with the generated output, you will find that while the generated output is typically what you want ocassionally you may need to change or extend the output for exceptional circumstances. Note if you are doing this often you should consider upgrading or changing the templates themselves. Modifying the solution code file involves introducing, or changing exisitng, IntentManged attributes to fine tune the Roslyn Weavers behaviour to respect the non-generated code. Below are several examples of doing this. Turning off the code generation Assuming we have a generated solution code file, as per the code example below. ... using System; [assembly: IntentTemplate(\"MyFirstTemplate\", Version = \"1.0\")] public class MyGeneratedClass { ... } We could introduce the DefaultIntentManaged attribute to turn of the code generation for this specific file. ... using System; [assembly: DefaultIntentManaged(Mode.Ignore)] [assembly: IntentTemplate(\"MyFirstTemplate\", Version = \"1.0\")] public class MyGeneratedClass { ... } Note this does not techincally turn off the code generation is rather instructing the Roslyn Weaver to ignore all the code elements by default. Changing a classes signature Assuming we want to change a classes signature, e.g. Introduce a new attribute or an interface, given we have a generated output as below. ... using System; [assembly: DefaultIntentManaged(Mode.Fully)] [assembly: IntentTemplate(\"MyFirstTemplate\", Version = \"1.0\")] public class MyGeneratedClass { ... } There are several ways we could achieve this, adding any one of the IntentManaged attributes listed below to the class would allow you to modify the signature. ... using System; [assembly: DefaultIntentManaged(Mode.Fully)] [assembly: IntentTemplate(\"MyFirstTemplate\", Version = \"1.0\")] [IntentManaged(Mode.Merge, Signature=Mode.Ignore, Body=Mode.Fully)] // OR [IntentManaged(Mode.Merge, Signature=Mode.Merge, Body=Mode.Fully)] // OR [IntentManaged(Mode.Merge, Signature=Mode.Merge, Body=Mode.Merge)] // OR //This is equivelant to the line above [IntentManaged(Mode.Merge)] this is equivelant to the line above [MyManualAttribute] public class MyGeneratedClass : MyManualBaseClass, IMyManualInterface { ... } Changing a method implementation Assuming we want to change the implementation of a generated method, looking at the example below. ... public class MyGeneratedClass { public void MyMethod(string arg1) { } } We can modify the method using any of the IntentManaged attributes below. ... public class MyGeneratedClass { [IntentManaged(Mode.Ignore)] // OR [IntentManaged(Mode.Merge, Signature=Mode.Fully, Body=Mode.Ignore)] public void MyMethod(string arg1) { //My Implementation } }"
  },
  "modules/RoslynWeaver/Attributes.html": {
    "href": "modules/RoslynWeaver/Attributes.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Roslyn Weaver Attributes Full list of Attributes IntentTemplate IntentManaged DefaultIntentManaged IntentInitialGen IntentTemplate Attribute Overview This attribute is added by the Roslyn Weaver automatically to all generated code, this attribute is used for. Determining which template, and version of the template, produced the solution code Code Migrations Usage This attribute is managed by the Roslyn Weaver which introduces it to the generated output based on the executing template. This attribute should not be used or introduced to a file directly by the developer, as it is managed by the Roslyn Weaver. This attribute is an assembly level attribute, as it applies to the file rather than any specific artifact within the file. Properties Name Description Id Corresponds to the Template Id of the template which produced this code file. Version Corresponds to the version of template which produced this code file. Example A generated file, using a template with Id : MyFirstTemplate would contain the following code. ... using Intent.CodeGen; [assembly: IntentTemplate(\"MyFirstTemplate\", Version = \"1.0\")] ... IntentManaged Attribute Overview This attribute can be added to a code element to control how the Roslyn Weaver merges the code. The merge behaviour is determined by the mode which is specified. Usage This attiribute can be introduced into generated code to alter the behaviour of the Roslyn Weaver. The typical scenario would be to allow you to introduce custom code into a generated code file. This attribute is typically used by developers to modify the template output, it typically should not be used in templates themselves, templates should typically using DefaultIntentManaged if they want to control the Roslyn Weavers behaviour. This attribute is will override DefaultIntentManaged if both are targeting the same code element. This attribute can be applied to any of the following. Class Constructor Enum Field Interface Method Property Properties Name Description ElementMode Specified the mode under which the code element should be merged Body Specified the mode under which the body of the code element should be merged. This is only required if the mode for the Body differs from the element mode. Signature Specified the mode under which the signature of the code element should be merged. This is only required if the mode for the Signature differs from the element mode Examples Using Ignore mode to change or add functionality In the code below a ToString could be newly introduced or changed from the version which was being generated. Either way the method is now in the developers control. Generated Code File ... [IntentManaged(Mode.Ignore)] public override string ToString() { return this.Id; } ... Fine tuning the mode The code example below is simlar to the one above, how ever in this example the method signature is running fully under code gen while the body of the method is under the developers control. Generated Code File ... [IntentManaged(Mode.Fully, Body = Mode.Ignore)] public override string ToString() { return this.Id; } ... DefaultIntentManaged Attribute Overview This attibute can be used to specify the default mode for 1 or more code elements. Usage The attribute is scoped based on were it is declared, i.e. if it is declared at an assembly level it's scope is the entire file, if it is declared on a class or interface it's scope is that class or interface. The code elements the attribute applies to work as follows. If Targets is specified the mode is applied to all code elements of the listed targets. e.g. Targets.Properties | Targets.Methods would apply the mode to all properties and methods within it's scope. If AccessModifiers is specified the mode is applied to all code elements with any of the listed access modifiers. e.g. AccessModifier.Public would apply the mode to all public code elements within it's scope. If both Targets and AccessModifiers are specified the mode will apply to any code elements which match any of the target AND any of the access modifiers. e.g. AccessModifier.Public and Targets.Properties | Targets.Methods would be all public methods and all public properties. If neither Targets or AccessModifiers is specified the mode will be applied to all code elements within the attributes scope. This attribute can be applied to any of the following. Assembly Class Interface Properties Name Description Element Mode Specified the mode under which the targeted code element should be merged Body Specified the mode under which the body of the targeted code element should be merged. This is only required if the mode for the body differs from the element mode. Signature Specified the mode under which the signature of the targeted code element should be merged. This is only required if the mode for the signature differs from the element mode. Targets Allows for targeting specifc code elements which the mode must apply to. Multiple targets can be specified using the | syntax. The valid targets are Classes, Constructors, Enums, Fields, Interfaces, Methods and Properties AccessModifiers This property can be used to target code elements based on access modifiers. Multiple access modifiers can be specified using the | syntax. The valid access modifiers are internal, private, protected and public. Examples Letting the code gen explictly control all public members of a class TODO Template Code File ... [DefaultIntentManaged(Mode.Fully, Body = Mode.Ignore, Targets = Targets.Methods | Targets.Properties, AccessModifiers = AccessModifiers.Public)] public MyClass() { ... } ... IntentInitialGen Attribute Overview This attribute can be used by developers creating templates to indicate code elements which are generated once off when the template is initally run. These code elements are typically stubs or default implementations for developers to complete or enrich. From the Roslyn Weavers perspective this code is seen as manual code, it just happens to get added in by the template as opposed to a developer. Usage This attribute should only be used in templates and does not make sense to exist in generated code. The Roslyn Weaver will remove these attributes from the generated code. Any templates using this attribute should be desined in such a way that the code targeted by these attributes is in a managed mode of Ignore or Merge . If the code element is under fully mode it will be removed on a subsequent execution of the template. This attribute can be applied to any of the following. Constructor Field Property Method Properties N/A Examples Adding an initial constructor The code below would add a default constructor to the class, with a compile time warning indicating that the constructor needs to be implemented. Template Code File ... [IntentInitialGen] public MyClass() { #warning please implement 1 or more meaningful non-anemic constructors } ... Generated Code File ... public MyClass() { #warning please implement 1 or more meaningful non-anemic constructors } ... Note the generated code is not seem as part of the template, hance if it is runnng under Fully managed mode, the code will be removed on a subsequent run."
  },
  "modules/RoslynWeaver/Gotchas.html": {
    "href": "modules/RoslynWeaver/Gotchas.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Gotchas The process is bias favouring Output Trivia is only ever added when there is none Single namespace assumption Template Default Intent - Only introduced if not in Solution (Assrmbly level) using clauses and namespaces Code element equivelenacy Method matching"
  },
  "modules/index.html": {
    "href": "modules/index.html",
    "title": "Modules | Intent Architect",
    "keywords": "Modules"
  },
  "modules/RoslynWeaver/HowToImplement.html": {
    "href": "modules/RoslynWeaver/HowToImplement.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver How to implement Roslyn Weaver in your templates Enabling you templates to work with the Rosyln Weaver module is as simple as implementing the IRoslynMerge interface. Alternativly you can inherit you template from the IntentRoslynProjectItemTemplateBase base class which implements this interface already, as well as several other quality of life features. using Intent.SoftwareFactory.Templates; //NOTE IRoslynMerge Interface public class MyTemplate : ITemplate, IRoslynMerge { ... public RoslynMergeConfig ConfigureRoslynMerger() { return new RoslynMergeConfig(new TemplateMetaData(Id, \"1.0\")); } ... } There are typically 3 types of templates, these can be categorized by the nature of their output Largely Generated content Largely Hand coded content Event split of generated and hand coded content To Do Use Partial Classes (With or without code behind), inheritance, composition Mention Code MIgrations InitialCodeGen"
  },
  "modules/RoslynWeaver/Modes.html": {
    "href": "modules/RoslynWeaver/Modes.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Roslyn Weaver Modes The Roslyn Weaver goes through all the code elements in the existing solution file and merges in all code elements from the template output. The way in which the code elements are weaved is determined by the mode specified for the code element. The mode under which a code element is operating is controlled by using either the IntentManaged or DefaultIntentManaged attributes. A code element can be operating under one of three modes as detailed below. Mode Meaning Fully The code element from the Template Output will be used and the code element from the Solution Code File will be discarded. If the code element exists in the Solution Code File but not in the Template Output the code element will be removed. Ignore The code element from the Solution Code File will be used and the code element from the Template Output will be discarded. Merge The code element existing in both the Template Output and the Solution Code File the code elements will be merged to produce a new code element. How the merging occurs is code element specific and can be further controller by specifying a Signature and/or Body mode. If either side does not have a version of the code element it will be introduced, in this way merge mode is always addative code will typically not be removed by the weaver. If a code element is running under Merge mode you can further fine tune the weaving by specifying specific modes for the signature and body of the code element. By default the body and signature modes will be the same as the code element node i.e. Merge . Detailed description of what the signature and body of each code element ."
  },
  "articles/UserManual/SoftwareFactoryExecution.html": {
    "href": "articles/UserManual/SoftwareFactoryExecution.html",
    "title": "Software Factory Execution | Intent Architect",
    "keywords": "Software Factory Execution This screen shows the execution of the software factory, it provides detailed information about what is happening in Intent Architect's code generation process. This screen also shows the user what code changes will be made and allows for reviewing these changes. Console tab 1. Console Tab This tab shows the details of the code generation execution process. 2. Search Filter Use this search to filter the console messages. 3. Category Filter These toggleable buttons allow for filtering of console messages based on their category. 4. Console Messages These messages are the output from the code generation process. These can be useful for giving insight into the code generation process, should it be required. 5. Apply Changes Apply changes will commit the \"Checked\" changes / outputs of the code generatation process, i.e. write the output to disk, this will overwrite files if they exist on the hard drive. 6. Cancel This will cancel the process, no output will be written to disk, i.e. no changes will occur to your existing code base. Changes tab 1. Changes Tab This tab shows the details of the output from the code generation execution process. 2. Search Filter Use this search to filter the changes messages. 3. Category Filter These toggleable buttons allow for filtering of changes messages based on their category. 4. Bulk output selector This allows for the bulk checking and unchecking of changes. 5. Change Messages This is a list of all file based changes which Intent Architect would like to make. 6. Individual Change Message Each line represents a file which will change. This line contains the following:- Check box - unchecking this box will prevent this change from occuring when clicking Apply Changes. Category Indicator (Created, Updated, Deleted) Compare Changes icon (magnifying glass) Name of the file which is changing. This file name is relativly pathed from the iSln file. 7. Apply Changes Apply changes will commit the \"Checked\" changes / outputs of the code generatation process, i.e. write the output to disk, this will overwrite files if they exist on the hard drive. 8. Cancel This will cancel the process, no output will be written to disk, i.e. no changes will occur to your existing code base."
  },
  "articles/GettingStarted/intro.html": {
    "href": "articles/GettingStarted/intro.html",
    "title": "Add your introductions here! | Intent Architect",
    "keywords": "Add your introductions here!"
  },
  "articles/UserManual/Shell.html": {
    "href": "articles/UserManual/Shell.html",
    "title": "The Shell | Intent Architect",
    "keywords": "The Shell 1. Home Screen Area There is no place like home. 2. Solution drop down This list contains a complete list of all you Intent Architect solutions. This drop down can be used to switch between solutions. 3. Debug button This button is equivelant to clicking the Play button, the difference being this button will also attach the Visual Studio debugger to the execution, allowing you to debug your modules. Don't forget to include the PDB files into your module if you want to debug them. 4. Play button This almighty button runs the software factory for the application you currently have open. This will typically result in Intent Architect generating source code into your solution. 5. User context Show the currently logged in user and provides access to all user related functionality. 6. Context specific menu This area typically contains a menu of actions applicable to your current context. 7. Content Region The region contains the content you are currently passionately engaged with."
  },
  "articles/UserManual/ApplicationConfiguration.html": {
    "href": "articles/UserManual/ApplicationConfiguration.html",
    "title": "Application Configuration | Intent Architect",
    "keywords": "Application Configuration The screen is where you configure / describe your applications code project structure. 1. Save Save your changes, save the world. 2. Project Add one or more projects, these projects represent the physcial code projects you are generating code for. These projects can either be created by Intent Architect or be existing projects. Projects have project types, project type are dynmic and available in Intent Architect through modules. 3. Assigned Roles These are the Roles currently assigned to this specific projects. Code generating modules, typically specify which role their output should target. In this way you are essentially mapping the code generation outputs to your projects. 4. Unassigned Roles This is a list of roles, which have been registerd with Intent Architect through the modules you have added to your application, which are currently not mapped onto a project. These roles need to be mapped to a specific project. 5. Properties Show the properties of the currently selected item, and typically allows them to be edited."
  },
  "articles/UserManual/HomeScreen.html": {
    "href": "articles/UserManual/HomeScreen.html",
    "title": "Home Screen | Intent Architect",
    "keywords": "Home Screen The home screen is a general landing page, it allows you to create new solutions, provides short cuts to your recently accessed applications, and solutions, as well as keeping you updated with our rivoting news feed. 1. Create New Solution Allows you to create a new solution, as stated. Solutions are just a named grouping for one or more applciations. 2. Open Existing Solution Find and open a previously created solution. These would be files with the .isln extension. 3. Recent Contains a list of recently accessed solution and applications. 4. Recently Accessed Solution Click me to open this recently accessed solution. 5. Recently Accessed Applciation Click me to open this recently accessed application. 6. Show All Shows all the applications within the recently access solution, not just the recently accessed applciations. 7. News Feed Our new feed, hopefully containing links and information you may find useful."
  },
  "articles/Extensibility/CreateAModule.html": {
    "href": "articles/Extensibility/CreateAModule.html",
    "title": "Coming Soon | Intent Architect",
    "keywords": "Coming Soon"
  },
  "articles/UserManual/RepositoryConfiguration.html": {
    "href": "articles/UserManual/RepositoryConfiguration.html",
    "title": "Repository Configuration | Intent Architect",
    "keywords": "Repository Configuration This screen allows you to configure the Asset Repositories for your application. These repositories are the sources of Application Templates and Modules. 1. Current Repository This control allows you to change / choose your chosen default repository 2. Add New Allows you to add new repositories, i.e. new sources of Appllications Templates and Modules. These can either be URLs to services or simply a folder location. 3. Address This is Uri for the repository, it can eithe be in the form of a URL to a service or a folder location on your hard drive. 4. Ordering These arrows allow you to order the list of repositories in order of preferene, with the top most repository being the most prefered. Whenever cascading actions / searches mu be performed accross the repositories they will be performed against them in the order you have specified here. 5. Edit Modify the details of the repository. 6. Delete Remove the repository."
  },
  "articles/UserManual/NewApplicationWizard.html": {
    "href": "articles/UserManual/NewApplicationWizard.html",
    "title": "New Application Wizard | Intent Architect",
    "keywords": "New Application Wizard This wizard creates new applciations with in the current solution. 1. Repository Configuration This allows you to configure your repositories, i.e. where Intent Architect is discovereing your application templates and other discoverable plugins. 2. Application Templates This is a list of application templates you can base your application on. Application templates pre-configure your application according to the template. Application Template simply initialize you application to a pre-defined state, everything the Application Template does can be done manually through the UI. 3. Application Template description This section provides more detailed information about the application template and it's intentions, this information is supplied by the template's creator. 4. Icon Selection Associate an Icon with you application. This icon is used purley for visual purposes within Intent Architect and is meant to make it easier to visually see which application you are working with, for users who work with many applications. 5. Location This is the folder where you would like the application and it's associated data to be stored. 6. Create Will create the application based on your selections."
  },
  "articles/UserManual/SolutionScreen.html": {
    "href": "articles/UserManual/SolutionScreen.html",
    "title": "Solution Screen | Intent Architect",
    "keywords": "Solution Screen Ths screen allows for the creation / maintainenance a solution. A solution simply represents a named logical grouping of applications. 1. Edit Solution Details Enough said. 2. Add New Applcation Adds a new application to this solution. 3. Edit Application Edit the application 4. Delete Application Delete this application"
  },
  "articles/UserManual/ApplicationModules.html": {
    "href": "articles/UserManual/ApplicationModules.html",
    "title": "Application Modules | Intent Architect",
    "keywords": "Application Modules This screen allows to manage which modules are applicable to your applications. These modules are typically packaged templates generating your selected patterns, but can also be other types of modules i.e. IDE Integration, Code Weavers, etc. 1. Repository Configuration This allows you to configure your repositories, i.e. where Intent Architect is discovereing your application templates and other discoverable plugins. 2. Module Filter This controls what modules you are seeing in the modules list. Browse - All modules availble from you currently selected repository. Installed - All modules installed for current application. Update - All modules installed for current application which have updates available. 3. Search Finds what you looking for. 4. Module List Displays a list of modules based on your current repository, filters and search input. 5. Module List Item This gives an overview of a Module. This would include a name, the author, brief description and version information. If the module is currently installed for the applciation there is an icon indicating it is installed, the colour of the icon denotes additional information. Colour Description Green You have the latested version of the module installed. Blue There is a newer version of the installed module available. Red This module is installed but Intent Architect is unable to locate module in the configured repositories. 6. Module Details This section contains detailed information about the module, the ability to install, update, uninstall the module, as well as the ability to configure installed modules. 7. Module Commands This panel is dynamic and changes based on whether or not the module is installed. It allows for installing the module, uninstalling the module and changing the version of a currently installed module. 8. Module Meta Data Provides meta data about the module including authoring information, modules dependancies, etc. 9. Module Configuration This section provides technical details about the various plugins present in the modules, typically this would be the list of templates the modules contains but it can also contain other plugin types. These plugins can be enabled or disabled using the check box. These plugins can be configured through the cog."
  },
  "articles/UserManual/Domain.html": {
    "href": "articles/UserManual/Domain.html",
    "title": "Domain | Intent Architect",
    "keywords": "Domain Overview This screen allows to describe your business domain through the use of UML class diagrams. As with all the meta data describing DSLs this data is technology agnostic and can be extending using your own custom meta data through the stereotype system. 1. Toolbar These are the controls which allow you to perfrom high level interactions with the current UML Diagram. 2. Uml Editor This is the UML visualization of the currently selected UML diagram. The diagram as well as the unlying model can be edited in this view. 3. Tree Model This view shows the model in it's entirety :- Views of the domain model Actual domain model Type definitions Stereotypes 4. Properties This is a basic property editor for the currently selected item. Toolbar Allows for high level interaction with the current UML View within the UML Editor region. 1. Save Saves your changed. 2. Add Class Adds a new class to you current view, this class is also added to the domain model. 3. Add Attribute Add an attribute to a class. 4. Add Operation Add an operation to a class. 5. Add Association Add an association between the two classes you select. 6. Add Inheritance Add an inheritance relationship between the two classes you select. Uml Editor Model you domain or a sub view of it using UML. This supports standard UML functionality as well as the concept of stereotypes which allow you to annotated any custom meta data you wish, to any aspect of the model. Note the editor has an short cut keys and context menu. 1. Class A UML Class. 2. Stereotypes An example of a stereotype being applied to a class, note stereotypes can be applied to any aspect of the model attributes, properties, etc. 3. Attributes List of classes attributes. 4. Operations List of classes operations. 5. Association An association between classes. Tree Model This tree view contains the entire domain model, as opposed to the UML editor which showing you a specific view of the model. 1. Views These are the views of the domain model, or sub section of the domain model. This tool allows for mutliple views to be created ontop a single domain model. This allows for creating simplified views or perspective based views ontop of the unlying model. 2. Domain Model Artifacts These artifacts would be the basic model i.e. the UML Classes and their properties, plus the associations between them. 3. Folders This tool supports a dynamic folder structure allowing you store your domain model artifacts in a structure which makes sense to you. 4. Supporting Model Artifacts These would be the extensions to the UML model, namely custom data types, enumerations and stereotype definitions. Property Window This shows, and allows for editing, the properties of the currently selected item. 1. Item Type Type indicator for the selected item. 2. Properties The properties of the selected item. 3. Stereotypes Stereotypes which are on the currently selected item."
  },
  "articles/UserManual/ApplicationScreen.html": {
    "href": "articles/UserManual/ApplicationScreen.html",
    "title": "Application Screen | Intent Architect",
    "keywords": "Application Screen The screen is where you configure / describe your application and generate your application. 1. Solution This is the solution the application belongs too. 2. Current Application This drop down indicates which application you are currently working with. You can swap between the various applications within a solution using this drop down. 3. Configuration This section allows you to configure how you would like your applications code to be structured. It allows you describe your code projects structures and map the code generation onto that project structure. 4. Modules This section allows you to manages your applications modules. This modules can be many things but typically are your patterns you would like applied to your Meta Data. 5. Domain This DSL allows you to describe your applications domain model using UML modeling. 6. DTO This DSL allows you to describe your applications data contracts. This DSL also supports concepts like describing your contracts with reference to your domain allowing weakly coupled integrity checking. 7. Services This DSL allows you to describe your applications services. 8. Events Not implemented yet. This DSL will allow for describing inbound and outbound application events. 9. Shell All the functions in this area are described in Shell ."
  }
}