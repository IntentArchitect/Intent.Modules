{
  "articles/GettingStarted/QuickStart.html": {
    "href": "articles/GettingStarted/QuickStart.html",
    "title": "Quick Start | Intent Architect",
    "keywords": "Quick Start Tooling in software helps us build more robust, maintainable applications faster then we could doing it all by hand. Intent Architect is an IDE-like tool which helps you better capture your design intent and uses that intent to build out aspects of your application as per your 'blueprints' . The goal of this guide is to give you a feel for the tool, illustrating how it works and what it can do for you. In this guide we're going to create a \"full stack\" ASP.NET WebApi 2.2 server with persistence and domain patterns in place. Once completed, you'll have a basic understanding of how Intent Architect works and a foundation to begin exploring how to it can make your development world better. 1. Setup the development environment Get Intent Architect up and running in 3 easy steps. Sign up at https://intentarchitect.com/ . Download the latest version of Intent Architect. Double clicking the downloaded .exe automatically, installs, creates shortcuts for, and starts Intent Architect, ready for you to begin working with it. 2. Create a New Solution A Solution is a logical grouping of Applications (components) of your system. Modern systems are typically composed of multiple cohesive applications which communicate with each other through well defined interfaces. Click on Create New Solution , either in the body of the Home screen or from the Solutions drop down at the top of the screen. Create Solution Dialog Field Description Icon This is an icon which will be associated with the Solution . By default a random icon is chosen, but it can be changed at any time. Name The name of your solution. This name should be alpha-numeric with no special characters or spaces. Description Any description or comments about this solution for yourself (or your team). Location The folder where Intent Architect will save data for the solution. This should point to a path under the same Source Control Management as your normal source code, so that it can be versioned and shared amongst the development team in the same way. Intent Architect does not append any additional sub directories, the directory selected will be the directory used. You will be presented with the Create Solution Dialog. Tip Good names for Solutions would typically be things like the client name, your product name, business area / unit or your organization name. Fill out the dialog and press Save . 3. Create a new Application Next we will create an Application . As you would expect, in Intent Architect an Application is a single application of your overall system, for example, it could be a website including it's frontend along with backing services and infrastructure like database persistance. Click the New Application tile. You will now be presented with a two-step wizard to create your application. Select an Application Template. Capture some basic details for the Application. Select an Application Template Each Application Template is pre-configured initial state of an application. They can install Modules, populate Metadata and anything else that can be manually configured through the front end. Intent Architect has a gallery of templates available online which will be added to over time. For the purposes of this guide, we will choose the Full Stack ASP.NET WebAPI 2.2 Application Template . Select the Full Stack ASP.NET WebAPI 2.2 Application Template and click Next . Capture Application Details Field Description Name The name of the application. This name should be alpha-numeric with no special characters or spaces. Icon This is an icon which will be associated with the application . By default a random icon is chosen, but it can be changed at any time. Location The folder where your application's data will be persisted. By default this will be in a sub-folder of the solution named after the Application name. Description A description of the Application. After capturing the details, press Create . 4. Push the Play button Your Application is now created, and pre-configured with various Modules and Metadata from the Application Template. Application View Click the Play button, in the top right hand corner. The Run Software Factory dialogue will appear, providing feedback of and interaction with the code generation process. Not worrying too much about the presented Console entries, once the Software Factory has run, the Changes tab is presented showing a list of all pending code changes. Reviewing the list, we can see it is wanting to create a Visual Studio solution, made up of the .sln file as well as csproj and various other infrastructura files. Software Factory execution 'Changes' Click the Apply Changes button. At this point the software factory applies all the pending code changes from the list and then downloads and installs any required NuGet packages, depending on your computer and internet speed, this may take a little while. These NuGet packages were installed based on the configured Module dependencies, once downloaded and installed, they will not need to be downloaded or installed again on future presses of the Play button. Click the Close button. At this point you can navigate to the folder on your hard drive which you specified for your application and you should see something like this: Generated outputs Open the solution in Visual Studio 2015/2017 (output will be in the location chosen for your application). Compile and run (hit F5). What just happened? What may not obvious at this point is what caused the code to be generated, and why it was generated like that. If you look at the Modules section of you application, on the installed tab you should see something similar to this: Installed Modules Here you can see there are a collection of modules which have been installed by the application template. Each of these modules is affecting what code is generated as well as how it is generated. You can try uninstall and reinstalling Modules, then pressing the Play button to see what affect they have on the code generation. In a less contrived scenario you would hand pick which modules you wished to use or create your own. Another aspect which is affecting the code generation is the Application Configuration. If you go the Configuration section, you will see the following: Application project configuration This is Metadata describing how you want your actual source code to be structured in addition to where you would like the code generation from installed modules to go. This is done by mapping Target Roles from the Modules onto your project structure. Note The project types available are again supplied by modules, in this case specifically, from the Intent.VisualStudio Module. New project types can be added through the Modules system. Add additional Metadata to describe your Application Play around in Intent Architect by adding Services, Domain classes and DTOs, each time pressing Play to see how the patterns are realized in your codebase."
  },
  "modules/RoslynWeaver/Attributes.html": {
    "href": "modules/RoslynWeaver/Attributes.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Roslyn Weaver Attributes Full list of Attributes IntentTemplate IntentManaged DefaultIntentManaged IntentInitialGen IntentTemplate Attribute Overview This attribute is added by the Roslyn Weaver automatically to all generated code, this attribute is used for. Determining which template, and version of the template, produced the solution code Code Migrations Usage This attribute is managed by the Roslyn Weaver which introduces it to the generated output based on the executing template. This attribute should not be used or introduced to a file directly by the developer, as it is managed by the Roslyn Weaver. This attribute is an assembly level attribute, as it applies to the file rather than any specific artifact within the file. Properties Name Description Id Corresponds to the Template Id of the template which produced this code file. Version Corresponds to the version of template which produced this code file. Example A generated file, using a template with Id : MyFirstTemplate would contain the following code. ... using Intent.CodeGen; [assembly: IntentTemplate(\"MyFirstTemplate\", Version = \"1.0\")] ... IntentManaged Attribute Overview This attribute can be added to a code element to control how the Roslyn Weaver merges the code. The merge behaviour is determined by the mode which is specified. Usage This attriibute can be introduced into generated code to alter the behaviour of the Roslyn Weaver. The typical scenario would be to allow you to introduce custom code into a generated code file. This attribute is typically used by developers to modify the template output, it typically should not be used in templates themselves, templates should typically using DefaultIntentManaged if they want to control the Roslyn Weavers behaviour. This attribute is will override DefaultIntentManaged if both are targeting the same code element. This attribute can be applied to any of the following. Class Constructor Enum Field Interface Method Property Properties Name Description ElementMode Specified the mode under which the code element should be merged Body Specified the mode under which the body of the code element should be merged. This is only required if the mode for the Body differs from the element mode. Signature Specified the mode under which the signature of the code element should be merged. This is only required if the mode for the Signature differs from the element mode Examples Using Ignore mode to change or add functionality In the code below a ToString could be newly introduced or changed from the version which was being generated. Either way the method is now in the developers control. Generated Code File ... [IntentManaged(Mode.Ignore)] public override string ToString() { return this.Id; } ... Fine tuning the mode The code example below is similar to the one above, how ever in this example the method signature is running fully under code gen while the body of the method is under the developers control. Generated Code File ... [IntentManaged(Mode.Fully, Body = Mode.Ignore)] public override string ToString() { return this.Id; } ... DefaultIntentManaged Attribute Overview This attribute can be used to specify the default mode for 1 or more code elements. Usage The attribute is scoped based on were it is declared, i.e. if it is declared at an assembly level it's scope is the entire file, if it is declared on a class or interface it's scope is that class or interface. The code elements the attribute applies to work as follows. If Targets is specified the mode is applied to all code elements of the listed targets. e.g. Targets.Properties | Targets.Methods would apply the mode to all properties and methods within it's scope. If AccessModifiers is specified the mode is applied to all code elements with any of the listed access modifiers. e.g. AccessModifier.Public would apply the mode to all public code elements within it's scope. If both Targets and AccessModifiers are specified the mode will apply to any code elements which match any of the target AND any of the access modifiers. e.g. AccessModifier.Public and Targets.Properties | Targets.Methods would be all public methods and all public properties. If neither Targets or AccessModifiers is specified the mode will be applied to all code elements within the attributes scope. This attribute can be applied to any of the following. Assembly Class Interface Properties Name Description Element Mode Specified the mode under which the targeted code element should be merged Body Specified the mode under which the body of the targeted code element should be merged. This is only required if the mode for the body differs from the element mode. Signature Specified the mode under which the signature of the targeted code element should be merged. This is only required if the mode for the signature differs from the element mode. Targets Allows for targeting specific code elements which the mode must apply to. Multiple targets can be specified using the | syntax. The valid targets are Classes, Constructors, Enums, Fields, Interfaces, Methods and Properties AccessModifiers This property can be used to target code elements based on access modifiers. Multiple access modifiers can be specified using the | syntax. The valid access modifiers are internal, private, protected and public. Examples Letting the code gen explicitly control all public members of a class TODO Template Code File ... [DefaultIntentManaged(Mode.Fully, Body = Mode.Ignore, Targets = Targets.Methods | Targets.Properties, AccessModifiers = AccessModifiers.Public)] public MyClass() { ... } ... IntentInitialGen Attribute Overview This attribute can be used by developers creating templates to indicate code elements which are generated once off when the template is initially run. These code elements are typically stubs or default implementations for developers to complete or enrich. From the Roslyn Weavers perspective this code is seen as manual code, it just happens to get added in by the template as opposed to a developer. Usage This attribute should only be used in templates and does not make sense to exist in generated code. The Roslyn Weaver will remove these attributes from the generated code. Any templates using this attribute should be designed in such a way that the code targeted by these attributes is in a managed mode of Ignore or Merge . If the code element is under fully mode it will be removed on a subsequent execution of the template. This attribute can be applied to any of the following. Constructor Field Property Method Properties N/A Examples Adding an initial constructor The code below would add a default constructor to the class, with a compile time warning indicating that the constructor needs to be implemented. Template Code File ... [IntentInitialGen] public MyClass() { #warning please implement 1 or more meaningful non-anemic constructors } ... Generated Code File ... public MyClass() { #warning please implement 1 or more meaningful non-anemic constructors } ... Note the generated code is not seem as part of the template, hance if it is running under Fully managed mode, the code will be removed on a subsequent run."
  },
  "modules/RoslynWeaver/HowItWorks.html": {
    "href": "modules/RoslynWeaver/HowItWorks.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver How it works The Roslyn Weaver is an Intent Architect extension, more specifically an Output Transformer. The Roslyn Weaver works by modifying the standard Intent Architect process. Simplified Intent Architect execution process Roslyn weavers intercepts the template output, finds the existing solution file ( if present) and weaves them together, typically preserving the non-generated code and merging in the generated template output. Roslyn Weaver's modified Intent Architect execution process As you can imagine the process of merging the code is complex, having said that developers do it all the time. Roslyn Weaver merges the code by allowing developers to annotate the code with attributes which dictate how the merging should be performed. These attributes are typically used in one of two ways:- By template designers to design extend points in their templates, i.e. the \"put your code here\" scenario. Roslyn Weaver for Template Designers By developers consuming the templates to extend or deviate from the templatized pattern. Roslyn Weaver for Template Consumers"
  },
  "articles/Extensibility/CreateAModule.html": {
    "href": "articles/Extensibility/CreateAModule.html",
    "title": "Create a Module | Intent Architect",
    "keywords": "Create a Module Coming Soon (tm)"
  },
  "modules/RoslynWeaver/Terminology.html": {
    "href": "modules/RoslynWeaver/Terminology.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Terminology Terms Term Description Roslyn Weaver Intent Architect plugin designed to merge existing code (Solution Code) with generated code (Template Output) to provide a more powerful and interactive code generation experience. Code Element The refers to a code fragment, e.g a method or property, within a code file which can be targeted for code weaving. List of Code Elements Mode This describes the strategy the Roslyn Weaver will use for weaving a specific code element when it is processing it. Output Transformer This is a plugin type supported by Intent Architect. This plugin type allows for the modification of the code being generated, it occurs after template execution but before persistence of the solution file. Roslyn Weaver is an example of such a plugin. Solution Code File Refers to a code file in a solution. These are the actual code files you would compile to produce your software product. The outputs from Intent Architect, i.e. the generated code, are typically solution code files. Within the context of the Roslyn Weaver it is important to note that these are also inputs, as the previous Intent Architects executions outputs become inputs to the following execution. Template Output Refers the generated code produced by Intent Architect. The Roslyn Weaver will weave this output with it's corresponding Solution Code Files to produce a new versions of the Solution Code Files. Weaving The process of taking a 2 pieces of code and merging them together to form a single piece of code."
  },
  "modules/RoslynWeaver/CodeMigrations.html": {
    "href": "modules/RoslynWeaver/CodeMigrations.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Code Migrations Coming Soon (tm)"
  },
  "modules/RoslynWeaver/Gotchas.html": {
    "href": "modules/RoslynWeaver/Gotchas.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Gotchas Coming Soon (tm) The process is bias favouring Output Trivia is only ever added when there is none Single namespace assumption Template Default Intent Managed attribute in template - Only introduced if not in Solution (Assembly level) using clauses and namespaces Code element equivalency Method matching"
  },
  "modules/RoslynWeaver/HowToImplement.html": {
    "href": "modules/RoslynWeaver/HowToImplement.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver How to implement Roslyn Weaver in your templates Enabling you templates to work with the Roslyn Weaver module is as simple as implementing the IRoslynMerge interface. Alternatively you can inherit you template from the IntentRoslynProjectItemTemplateBase base class which implements this interface already, as well as several other quality of life features. using Intent.SoftwareFactory.Templates; //NOTE IRoslynMerge Interface public class MyTemplate : ITemplate, IRoslynMerge { ... public RoslynMergeConfig ConfigureRoslynMerger() { return new RoslynMergeConfig(new TemplateMetaData(Id, \"1.0\")); } ... } There are typically 3 types of templates, these can be categorized by the nature of their output Largely Generated content Largely Hand coded content Event split of generated and hand coded content Coming Soon (tm) Use Partial Classes (With or without code behind), inheritance, composition Mention Code Migrations InitialCodeGen"
  },
  "modules/RoslynWeaver/HowToWorkWith.html": {
    "href": "modules/RoslynWeaver/HowToWorkWith.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Working with Roslyn Weaver templates Roslyn Weaver provides several code based attributes ( Roslyn Weaver attributes ) which can used to control or change the code weaving process. As a developer working with the generated output, you will find that while the generated output is typically what you want occasionally you may need to change or extend the output for exceptional circumstances. Note if you are doing this often you should consider upgrading or changing the templates themselves. Modifying the solution code file involves introducing, or changing existing, IntentManged attributes to fine tune the Roslyn Weavers behaviour to respect the non-generated code. Below are several examples of doing this. Turning off the code generation Assuming we have a generated solution code file, as per the code example below. ... using System; [assembly: IntentTemplate(\"MyFirstTemplate\", Version = \"1.0\")] public class MyGeneratedClass { ... } We could introduce the DefaultIntentManaged attribute to turn of the code generation for this specific file. ... using System; [assembly: DefaultIntentManaged(Mode.Ignore)] [assembly: IntentTemplate(\"MyFirstTemplate\", Version = \"1.0\")] public class MyGeneratedClass { ... } Note this does not technically turn off the code generation is rather instructing the Roslyn Weaver to ignore all the code elements by default. Changing a classes signature Assuming we want to change a classes signature, e.g. Introduce a new attribute or an interface, given we have a generated output as below. ... using System; [assembly: DefaultIntentManaged(Mode.Fully)] [assembly: IntentTemplate(\"MyFirstTemplate\", Version = \"1.0\")] public class MyGeneratedClass { ... } There are several ways we could achieve this, adding any one of the IntentManaged attributes listed below to the class would allow you to modify the signature. ... using System; [assembly: DefaultIntentManaged(Mode.Fully)] [assembly: IntentTemplate(\"MyFirstTemplate\", Version = \"1.0\")] [IntentManaged(Mode.Merge, Signature=Mode.Ignore, Body=Mode.Fully)] // OR [IntentManaged(Mode.Merge, Signature=Mode.Merge, Body=Mode.Fully)] // OR [IntentManaged(Mode.Merge, Signature=Mode.Merge, Body=Mode.Merge)] // OR //This is equivalent to the line above [IntentManaged(Mode.Merge)] this is equivalent to the line above [MyManualAttribute] public class MyGeneratedClass : MyManualBaseClass, IMyManualInterface { ... } Changing a method implementation Assuming we want to change the implementation of a generated method, looking at the example below. ... public class MyGeneratedClass { public void MyMethod(string arg1) { } } We can modify the method using any of the IntentManaged attributes below. ... public class MyGeneratedClass { [IntentManaged(Mode.Ignore)] // OR [IntentManaged(Mode.Merge, Signature=Mode.Fully, Body=Mode.Ignore)] public void MyMethod(string arg1) { //My Implementation } }"
  },
  "modules/RoslynWeaver/Modes.html": {
    "href": "modules/RoslynWeaver/Modes.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Roslyn Weaver Modes The Roslyn Weaver goes through all the code elements in the existing solution file and merges in all code elements from the template output. The way in which the code elements are weaved is determined by the mode specified for the code element. The mode under which a code element is operating is controlled by using either the IntentManaged or DefaultIntentManaged attributes. A code element can be operating under one of three modes as detailed below. Mode Meaning Fully The code element from the Template Output will be used and the code element from the Solution Code File will be discarded. If the code element exists in the Solution Code File but not in the Template Output the code element will be removed. Ignore The code element from the Solution Code File will be used and the code element from the Template Output will be discarded. Merge The code element existing in both the Template Output and the Solution Code File the code elements will be merged to produce a new code element. How the merging occurs is code element specific and can be further controller by specifying a Signature and/or Body mode. If either side does not have a version of the code element it will be introduced, in this way merge mode is always additive code will typically not be removed by the weaver. If a code element is running under Merge mode you can further fine tune the weaving by specifying specific modes for the signature and body of the code element. By default the body and signature modes will be the same as the code element node i.e. Merge . Detailed description of what the signature and body of each code element ."
  },
  "modules/RoslynWeaver/Overview.html": {
    "href": "modules/RoslynWeaver/Overview.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Overview Roslyn Weaver allows developers to change or extend generated code files with their own custom code. Templates designed to work with this extension are far more powerful than traditional code generation, they allow hand written code to be introduced into the generated code. These template still maintaining the ability to continue changing and executing without losing the hand written code. In summary it allows generated code and custom written code to live symbiotically in a single file. The primary driver behind Roslyn Weaver is to overcome one of the biggest limitations of traditional code generation systems which is that they are typically ' all or nothing '. That is to to say you have to use the generated code as is for all scenarios and there is a very limit scope for extensibility. Any extensibility is typically done through inheritance or partial classes. While these traditional methods are available and may be great to use for some scenarios Roslyn Weaver introduces a wide new range of possibilities. Due to the Roslyn Weaver's ability to integrate non-generated with generated code there are many new possibilities for extensibility beyond those of traditional code generation techniques. Some extensibility techniques may include, (but not limited to) Creating custom code extension points in your templates Roslyn Weaver allows explicit deviation from the template, by the developer, for exceptional scenarios Template outputs are more open to change by the developer Some of the design goals behind Roslyn Weaver Feel and look like normal code, generated code is often easy to spot and terrible to read or maintain, Roslyn Weaver wants to be part of your dev team. Respect the developers code, try to maintain formatting and white space as much as possible. Try to be unintrusive, code should look and fell like code you would traditionally hand write. Terminology How Roslyn Weaver works Roslyn Weaver for Template Designers Roslyn Weaver for Template Consumers Roslyn Weaver Attributes Code Migrations Gotchas Appendix"
  },
  "articles/GettingStarted/Intro.html": {
    "href": "articles/GettingStarted/Intro.html",
    "title": "Welcome to Intent Architect | Intent Architect",
    "keywords": "Welcome to Intent Architect What is Intent Architect? Intent Architect is a coding automation tool for software developers. It's based on the principles of a software factory, and provides a platform for design and pattern reuse. Build Faster - Allow Intent Architect to manage the tedious and repetitive tasks that take up most of your time, freeing you up to focus on meaningful value-adding development. Quality Assured - Create your patterns, and then rest easy, knowing that they are applied consistently and correctly throughout your codebase. Agile Architecture - Future-proof your architecture! Effortlessly upgrade (or even swap out) your technologies and design patterns at the push of a button - mitigating technical risk has never been easier. How does it work? All software systems, and this is particularly true of large enterprise systems, are composed of patterns. This code behind these patterns is often referred to as boilerplate code or plumbing. The more patternized a system is the more maintainable and robust it is. This is fairly well known and understood in the the software development industry. The real challenges comes in around things like:- How to make sure the pattern is implemented consistently , this often breaks down when people don't understand the original intent of the pattern, the technology, or simply implement it lazily. Refactoring the pattern , once a pattern is implemented, refactoring the pattern can be an expensive exercise as you may need to change every instance of the pattern rather than the pattern itself. Changing technologies , often changes in technologies result in changes to the supporting patterns themselves, this problem is analogous to \"Refactoring the pattern\" above. Doing the easy thing as opposed to the right thing , sometimes we take shortcuts in design because we know that the implementation would be too onerous. Intent Architect is a continuous code generation tool which allows you to capture your application design and integrates that design back to your solution code to help you build better applications. It directly addresses the issues described above by allowing you to maintain and refactor your design directly, as opposed to hard coding it into your solutions. In this way you can maintain the design itself rather than the many fragmented and disjointed instances of your design present in your application. Conceptually Intent Architect works in 3 steps:- Describe your application through Metadata Choose your patterns and their backing technologies through Modules Run the Software Factory Overview of how Intent Architect work In practice you would apply these steps organically and iteratively as you build out your solution, describing your application and refining its design as you model your business domain, patternizing your application's architecture. So what is involved in these 3 steps? Describe your application through Metadata In this step you can describe your application or aspects of your application in a technology agnostic way. Some of the typical things you might want to describe about your application are:- Domain model Service Contracts Services Inbound and outbound events ANY other aspect of your application that you feel is appropriate Am I not just documenting my design? In principle yes, but unlike traditional documentation this is a living document which integrates into your actual source code. As you change your design (Metadata) your application source code changes. Through this process you capture the design intent of your application, rather than hard coding it into your application source code as it is traditionally done. This decoupling of the design intent from the actual source code makes refactoring or changing your designs easier. This is because you are literally changing the design rather then having to reverse engineer the design out of the source code and then refactor it. Intent Architect has several Domain Specific Languages (DSLs) which you can use to model the application concepts described above. An example of such a DSL would be our integrated visual UML editor, which would typically be used to model your application domain. UML Modelling DSL example All the DSLs are fully extensible though a custom metadata extension system simply referred to as stereotypes . Stereotypes allow you to extend existing models and add your own custom data to the existing Metadata model. This would typically be data that is specific to your application or design. Should you wish to describe other aspects of your application, that Intent Architect does not have a DSL for, you can provide your own Metadata models. These Metadata models can be in whatever format you like, some examples may include JSON, XML or .NET source code. This can be done through creating your own MetadataLoader plugin. It is important to note you do not have to describe your entire application upfront, you can describe your application iteratively as you uncover the domain you are building for. Choose your patterns and their backing technologies through Modules When capturing Metadata you are really describing what you want to build, in this step you are specifying how you want it built. Specifying the how is choosing which design patterns you want to use in your application. As an application architect this is no different to choosing which design patterns you will be using in your application. To be clear, these design patterns literally describe what source code is to be generated to solve a specific aspect of your application, things like:- Domain model persistence Service accessibility Application event propagation Connection Management Any patterns that you, as the application architect, would like to see realized in your application The way you choose your patterns in Intent Architect is by installing Modules. Theses Modules typically contain coded templates which will generate these design patterns into your solution based on the Metadata you have previously described. You can reuse someone else's Module or build your own. Installed Modules example Some additional points on modules:- Modules are technically more than just collections of patterns and can be used to extend or enhance the code generation process. Modules support configuration, allowing the developer to fine tune how and what they execute. The outputs of the Modules can be mapping into your solutions using the application configuration screen. These design patterns are often backed by a specific technology, a powerful side effect of this approach is that you have a clean loose coupling between your application and the underlying technologies through these Modules. Run the Software Factory So this step..., really is that easy. Clicking the play button in Intent Architect will execute the software factory. Intent Architect will take your Metadata, patterns, configuration and then generate your application accordingly. What this means practically is that source code, as per your design, will be generated. It is important to note at this point that Intent Architect is designed to work with continuous code generation in mind, i.e. whenever you change your design or patterns, simply clicking play will update your application accordingly. Software Factory execution example When running the Software Factory, feedback about its execution is provided in the Console tab. The Changes tab provides comprehensive information about the code changes that Intent Architect wants to apply. These changes can be reviewed and then applied, or discarded if required. And that in a nutshell is how it works Describe your application Choose your patterns Let us build that for you Why is this a better way to build software? There are many benefits to building software this way, here are some of the core design principles behind Intent Architect which result in a better software building experience. Contract First While it may not be obvious at first glance, in principle when you are using Intent Architect you are applying the principle of contract first design, not only to your services, but to every aspect of your architecture that you model. Contracting is fundamental to many modern software patterns e.g. SOA, Microservices, Dependency Injection. While you flesh out your models in as much detail as you like, you are principally describing the contracts for your application architecture. \"Loose coupling in your application design.\" Raising the level of abstraction Most significant improvements in the world of software development have occurred through this principle, some examples would be:- Assembly programming Imperative programming Object Orientated programming Domain Specific Languages (DSLs) Intent Architect allows you to capture your designs using DSLs and/or Metadata. These designs can then be realized into code artifacts. This technique has been used many times in the history of computer science to improve the way developers and machines interface, allowing developers to express powerful concepts simply or more intuitively. \"Large sweeping changes to be made at a design level, closer to the business concepts, rather than at a code level.\" Truly patternized solutions While many systems are patternized either explicitly or implicitly, this patternization is heavily dependant on developers implementing these patterns inline with whatever the original pattern designer's vision was. This typically leads to variances or unintended deviations in the patterns, which often leads to bugs and architectural decay. From our experience in these scenarios, more often than not the incorrect pattern implementation is the one which propagates. This is mitigated when using Intent Architect as your patterns are fully implemented as per your design. It is important to note that Intent Architect does support pattern deviation for exceptions, but it needs to be done explicitly. Explicit deviation for exceptional scenarios is a far better and maintainable practice. \"Developers can focus on the patterns rather than their scattered implementations. This principle also talks to architectural governance and explicit variation.\" Agile architecture What does agile architecture mean? Literally the ability to refactor/change the architecture of your application. This is very hard to do in traditional applications and when the requirement comes up, you typically hear things like \"we need to rewrite the system\" or \"the system was not designed to do that, it's not possible\". When using Intent Architect your application architecture is merely a realization of your design intent, which can be easily changed, the architecture is inherently refactor-able. The reason this is not possible in traditional development is that all the design intent has been lost and hard coded into the application. \"This principle speaks to the ability to make architectural application refactors, which are typically impossible or onerous.\" Encapsulated technology stacks Technology stacks or frameworks along with their supporting patterns are introduced to your application's architecture through Modules. A side effect of this is that the technology is now loosely coupled into to your application through the module and Intent Architect. The technology stack in encapsulated in the Module and can be managed through the Module, removing the Module removes the technology. The dependency between the various generated code artifacts and the module is maintained by Intent Architect. Traditionally the technology would be hard coded throughout your application with no easy way to remove it, short of manually tracking down every piece of code and removing it. \"Technologies or Frameworks can be encapsulated through Modules, making them easier to change, upgrade or swap out.\" Design visualization Being able to visualize your application design, without having to trawl through code, makes it simpler to :- Reason about the design Change the design Explain the design Understand the design Collaborate around the design As they say, a picture says a thousand words. \"Better understanding and visibility of the applications design.\" Managed Code Managed code is a term we like to use for all the code that Intent Architect is generating into your applications. What you find is that this code instantly becomes code you that don't worry about as it's being managed for you by Intent Architect. What this effectively means is that the code base that you as a developer have to maintain is smaller. Smaller code bases are simpler to understand and maintain. From our experience it is possible to generate 30% - 70% of your code base depending on your architecture. If you do need to change Managed code you are changing the pattern rather than all the instances in your code base, making the code maintenance significantly simpler. \"Less code to maintain, less complexity to manage.\" DRY (Don't repeat yourself) Intent Architect allows you to achieve the DRY principle to 2 areas that are traditionally hard to do:- Boilerplate code Design and Implementation Boilerplate code As the boilerplate code is now generated from your design pattern, all this code is written and maintained in one place, namely, the pattern, regardless of how many instances of the pattern there are in the solution. Design and Implementation Documentation of the design is typically done side by side with the implementation, i.e. we document the design, and separately we implement the design. The problem with this approach is that the two are completely detached and it's inevitable that the design and the implementation will go out of sync. Using Intent Architect the design flows directly into the implementation, so there is no need to repeat the design in the implementation. \"Design once, and have that design realized as intended.\" No Magic - The code is right there There are several techniques that developers use to try and minimize the coding of this boilerplate code, some of these techniques would include Aspect-Oriented Programming (AOP), dynamic proxies, mix-ins or runtime weaving. While all these techniques are perfectly acceptable, they often add in the element of magic which makes it harder for developers who are unfamiliar with the implementation to understand what is going on, or even follow the logic. While it's important to note that Intent Architect doesn't prohibit you from using these approaches, it offers you a new technique, which is simply to generate the boilerplate code as you would have traditionally hand coded it. In this way the code is easy to read, debug and understand, but you don't have to write / maintain all the boilerplate code. \"Code that's easier to follow and debug is easier to maintain.\" No lock-in Intent Architect is built to be a design time tool, just like your favourite IDE. There is no coupling between it and your application. This means you can stop using it at any point with no impact on your project. This is different from most other similar tools, which would have some form of lock-in. For example, Intent Architect has:- No runtime that your code must execute in. No proprietary framework dependencies . No generated code that is unmaintainable due to being unwieldy or poorly implemented, such that it's obviously not what a developer would have coded. \"Use the tool because it's adding value to you, not because your past decisions are holding you captive.\" By developers, for developers The ideas and concepts present in Intent Architect have been developed, shaped and envisioned by developers trying to solve real world problems. The tool is in no way trying to diminish the development experience, it simply allows developers to better capture their design intent rather than hard coding it into their applications. \"We are developers and we believe this tool takes our projects to the next level.\" Code generation done right Collectively through our careers, we have had a lot of experience with various code generation tools and techniques, with mixed results. In Intent Architect we have taken these learnings and tried to create a seamless code generation experience. Some of the factors we believe that set us apart include:- Continuous generation, as opposed to once off code generation. At any point you can run the code generation and your application will update to reflect your design accordingly, even in existing code files. Managed outputs, most code generation tools work in a purely additive fashion i.e. only adding to, or overwriting, files in your code base. Intent Architect tracks the generated outputs and removes those which are no longer relevant. Code Weaving, we support advanced weaving systems which allow for manual code to be introduced into generated code files, and for that non generated code to be retained on subsequent generations of the code. Code as you would write it, this is really up to module implementors, but in principle and from our experience, there is no reason for the generated code to look any different to hand written code. IDE integration, the code generation understands your IDE and automatically adds generated code files to your project/solution. Any IDE can have this kind of integration, for example one can add the Intent.VisualStudio.Projects module to your Intent Architect application to have generated code files and projects automatically appear in your Visual Studio solution. \"Intent Architect wants to be a productive developer on your team, and not get in your way.\""
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to Intent Architect documentation. | Intent Architect",
    "keywords": "Welcome to Intent Architect documentation. Where would you like to start ? Overview of Intent Architect Quick Start User Manual"
  },
  "articles/GettingStarted/MakeYourOwnModule.html": {
    "href": "articles/GettingStarted/MakeYourOwnModule.html",
    "title": "Make Your Own Module - Complete Example - ASP.NET Web API Controllers | Intent Architect",
    "keywords": "Make Your Own Module - Complete Example - ASP.NET Web API Controllers This tutorial will walk you through creating an Intent Architect module which will generate ASP.NET WebApi controllers based on the Services visual DSL in Intent Architect. Intent Architect is designed to work on both new and existing projects. In this tutorial we will have the template add additional WebApi Controllers to an existing application. Make a new Visual Studio Solution and Project We will create a WebApi project using Visual Studio's scaffolding feature. Open Visual Studio Create New Project Under Visual C# , Web , choose ASP.NET Web Application (.NET Framework) Name: MyApplication.WebApi Location: C:\\Dev\\MySolution Solution name: MyApplication Press OK Use Web API template Leave default boxes checked (just MVC and Web API ) (Optional) Press the Change Authentication button and choose No Authentication if you don't want to worry about authentication right now. Press OK Make a new Intent Architect Solution and Application In Intent Architect, we will make a new solution in the same folder as our Visual Studio solution and project above. Open Intent Architect Make a new Solution: Name: MySolution Path: C:\\Dev\\MySolution Make a new Application Use the Empty Application template Give it name of MyApplication Go to Modules Search for Intent.VisualStudio.Projects and install the module Search for Intent.NuGet.Installer and install the module Search for Intent.OutputManager.RoslynWeaver and install the module Go to Configuration Right-click Projects and select New Project Select the WebApi entry Give it a name of MyApplication.WebApi . Use the play button to generate your application. Press Apply Changes when done. Creating the Module In a new instance of Visual Studio we are going to make a new project from which our Intent Architect Module will be packaged. Open a new instance of Visual Studio Under Visual C# , Windows , choose Class Library . Name: Module.Example.WebApi Location: C:\\Dev\\MySolution Solution name: MySolution.Automation Add the following Nuget packages: Intent.IntentArchitectPackager Intent.SoftwareFactory.MetaModel (which will install Intent.SoftwareFactory.SDK as a dependency) Add following new items to the project (right-click Module.Example.WebApi , Add , New Item ): Module Specification File: A module specification, or rather, .imodspec files are very similar to NuGet .nuspec files and are used by the module packager and Intent Architect to understand the contents of a module, including what templates, decorators and settings it has available. Visual Studio Project item type: XML File Name: Module.Example.WebApi.imodpec Content: xml <?xml version=`1.0` encoding=`utf-8`?> <package> <id>$id$</id> <version>0.0.1</version> <templates> <template id=`Module.Example.WebApi.WebApiController`> <role>Distribution.WebApi</role> </template> </templates> </package> Template A convenient and powerful templating engine for the Intent Architect's Software Factory is T4. Visual Studio has support and tooling for T4 out the box and it provides a convenient way to mix code and text together through .tt files. By using a Runtime Text Template , normal C# code is created each time the .tt file is saved. By making the .tt inherit from an Intent Architect base templating class, Intent Architect's Software Factory automatically captures the template output during the Software Factory run. Visual Studio Project item type: Runtime Text Template (search in top right, or can be found under Visual C# Items , General ) Name: WebApiControllerTemplate.tt Content: <#@ template language=`C#` inherits=`IntentRoslynProjectItemTemplateBase<IServiceModel>`#> <#@ assembly name=`System.Core` #> <#@ import namespace=`Intent.MetaModel.Service` #> <#@ import namespace=`Intent.SoftwareFactory.Templates` #> <#@ import namespace=`System.Linq` #> <#@ import namespace=`System.Text` #> <#@ import namespace=`System.Collections.Generic` #> using Intent.CodeGen; [assembly: DefaultIntentManaged(Mode.Merge)] // Simple comment as output Template's Partal File: T4 Runtime Text Template files re-generate a .cs file with a class inside it each time the .tt file is saved. These generated classes are partial which allows us to make other corresponding partial classes. By creating a partial class which is just another .cs file to Visual Studio, unlike .tt files, full Visual Studio IntelliSense and other C# features available to them. This makes partial classes the ideal place to put more complicated backing logic for our templates, such as constructors, utility methods, etc. Visual Studio Project item type: Class Name: WebApiControllerTemplatePartial.cs Content: using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using Intent.MetaModel.Service; using Intent.SoftwareFactory.Engine; using Intent.SoftwareFactory.Templates; using Intent.SoftwareFactory.VisualStudio; namespace Module.Example.WebApi { public partial class WebApiControllerTemplate { public const string Identifier = \"Module.Example.WebApi.WebApiController\"; public WebApiControllerTemplate(IProject project, IServiceModel model) : base(Identifier, project, model) { } public override RoslynMergeConfig ConfigureRoslynMerger() { return new RoslynMergeConfig(new TemplateMetaData(Id, `1.0`)); } protected override RoslynDefaultFileMetaData DefineRoslynDefaultFileMetaData() { return new RoslynDefaultFileMetaData( overwriteBehaviour: OverwriteBehaviour.Always, fileName: Model.Name + `Controller`, fileExtension: `cs`, defaultLocationInProject: @`Controllers`, className: `${Name}Controller`, @namespace: `${Project.Name}.Controllers`); } } } Registration file: Intent Architect's Software Factory loads module assemblies and using reflection locates available templates by finding classes which implement ITemplateRegistration and then initializes the templates defined inside. Visual Studio Project item type: Class Name: WebApiControllerTemplateRegistration.cs Content: using System; using System.Collections.Generic; using System.Linq; using Intent.MetaModel.Service; using Intent.SoftwareFactory; using Intent.SoftwareFactory.Engine; using Intent.SoftwareFactory.Templates; using Intent.SoftwareFactory.Templates.Registrations; namespace Module.Example.WebApi { public class WebApiControllerTemplateRegistration : ModelTemplateRegistrationBase<IServiceModel> { private readonly IMetaDataManager _metaDataManager; public WebApiControllerTemplateRegistration(IMetaDataManager metaDataManager) { _metaDataManager = metaDataManager; } public override ITemplate CreateTemplateInstance(IProject project, IServiceModel model) { return new WebApiControllerTemplate(project, model); } public override IEnumerable<IServiceModel> GetModels(IApplication application) { return _metaDataManager.GetMetaData<IServiceModel>(new MetaDataType(`Service`)).Where(x => x.Application.Name == application.ApplicationName).ToList(); } public override string TemplateId => WebApiControllerTemplate.Identifier; } } Build the Visual Studio Solution project and in Visual Studio's build output you should see the following line: Successfully created package Module.Example.WebApi.0.0.1.imod When you added the Intent.IntentArchitectPackager NuGet package to the project, it injected a task into the build action of the project to package up the module for you. This module file is placed in your $(SolutionFolder)\\Intent.Modules folder. Add the Module to your Intent Architect Application and Start Using It This example module is now ready to be used within Intent Architect. Go to Modules : Add your own repository By adding 'File System' based repository to our application, Intent Architect will be able to search for and install modules from your file system, much like it does so through the official Intent Architect repository. Press the cog icon near the top right Press Add New Name: My Repository Address: C:\\Dev\\MySolution\\MySolution.Automation\\Intent.Modules Press Save From the drop down on the top right, ensure that My Repository is selected. Press Search You should see your module Module.Example.WebApi , select it and press Install Go to Configuration Drag the Distribution.WebApi role onto your MyApplication.WebApi project, note how its icon changes to be green and checked. Go to Services Make a few services Now run the software factory and observe the changes generated. You can see that for each service you defined in Intent Architect, it has created a new controller in your Visual Studio project. Right now though these controllers have no real content, we're still going to have to add some more content to them. Force re-install of rebuilt module Once Intent Architect has downloaded and installed a module, it won't try re-download it again. This creates a problem in that whenever you make a change and rebuild your module while devloping it, you won't see you changes apply unless you uninstall and re-install the module in Intent Architect. Having to re-install your module every time gets tedious very fast, fortunately though there is a way to automate this re-install during the build process of your module. In Visual Studio, right-click the Module.Example.WebApi project and select Properties . Select the Build Events section and in the Post-build event command line box put the following: if exist \"C:\\Dev\\MySolution\\Intent.Modules\\Module.Example.WebApi.0.0.1\" rmdir \"C:\\Dev\\MySolution\\Intent.Modules\\Module.Example.WebApi.0.0.1\" /s /q What this does is delete the module from your Intent Architect's Intent.Modules folder each time your module builds, then later when the Software Factory runs, it will see the module is missing and automatically re-download the missing package. You will see in the log during the software factory run that the module is being restored. Now we can move back to improving our template. Have the template generate a class in a namespace Let's make our template generate class names and their namespaces. Change the content of the WebApiControllerTemplate.tt file to the following: <#@ template language=`C#` inherits=`IntentRoslynProjectItemTemplateBase<IServiceModel>`#> <#@ assembly name=`System.Core` #> <#@ import namespace=`Intent.MetaModel.Service` #> <#@ import namespace=`Intent.SoftwareFactory.Templates` #> <#@ import namespace=`System.Linq` #> <#@ import namespace=`System.Text` #> <#@ import namespace=`System.Collections.Generic` #> using System; using Intent.CodeGen; [assembly: DefaultIntentManaged(Mode.Merge)] namespace <#= Namespace #> { public class <#= ClassName #> { } } Build your module, run the software factory and observe that it now applies a namespace and class name to your controllers. Make the generated class extend ASP.NET WebApi's ApiController class Change the content of the WebApiControllerTemplate.tt file to the following: <#@ template language=`C#` inherits=`IntentRoslynProjectItemTemplateBase<IServiceModel>`#> <#@ assembly name=`System.Core` #> <#@ import namespace=`Intent.MetaModel.Service` #> <#@ import namespace=`Intent.SoftwareFactory.Templates` #> <#@ import namespace=`System.Linq` #> <#@ import namespace=`System.Text` #> <#@ import namespace=`System.Collections.Generic` #> using System; using System.Web.Http; using Intent.CodeGen; [assembly: DefaultIntentManaged(Mode.Merge)] namespace <#= Namespace #> { public class <#= ClassName #> : ApiController { } } Build your module, run the software factory and observe that the generated classes now derive from ApiController . Add operations to the generated class If you haven't done so already, in Intent Architect ensure you have a service with at least one operation and the operation has at least one parameter and a return type. Change the content of the WebApiControllerTemplatePartial.cs file to the following: using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using Intent.MetaModel.Service; using Intent.SoftwareFactory.Engine; using Intent.SoftwareFactory.Templates; using Intent.SoftwareFactory.VisualStudio; namespace Module.Example.WebApi { public partial class WebApiControllerTemplate { public const string Identifier = `Module.Example.WebApi.WebApiController`; public WebApiControllerTemplate(IProject project, IServiceModel model) : base(Identifier, project, model) { } public override RoslynMergeConfig ConfigureRoslynMerger() { return new RoslynMergeConfig(new TemplateMetaData(Id, `1.0`)); } protected override RoslynDefaultFileMetaData DefineRoslynDefaultFileMetaData() { return new RoslynDefaultFileMetaData( overwriteBehaviour: OverwriteBehaviour.Always, fileName: Model.Name + `Controller`, fileExtension: `cs`, defaultLocationInProject: @`Controllers`, className: `${Name}Controller`, @namespace: `${Project.Name}.Controllers`); } // A helper method used by the template: private string GetOperationReturnType(IOperationModel o) { return o.ReturnType == null ? `void` : o.ReturnType.TypeReference.Name; } // A helper method used by the template: private string GetParameters(IOperationModel o) { return o.Parameters .Select(x => $`{x.TypeReference.Name} {x.Name}`) .Aggregate((x, y) => x + `, ` + y); } } } Change the content of the WebApiControllerTemplate.tt file to the following: <#@ template language=`C#` inherits=`IntentRoslynProjectItemTemplateBase<IServiceModel>`#> <#@ assembly name=`System.Core` #> <#@ import namespace=`Intent.MetaModel.Service` #> <#@ import namespace=`Intent.SoftwareFactory.Templates` #> <#@ import namespace=`System.Linq` #> <#@ import namespace=`System.Text` #> <#@ import namespace=`System.Collections.Generic` #> using System; using System.Web.Http; using Intent.CodeGen; [assembly: DefaultIntentManaged(Mode.Merge)] namespace <#= Namespace #> { public class <#= ClassName #> : ApiController { <# foreach (var operation in Model.Operations) { #> [IntentManaged(Mode.Merge, Body = Mode.Ignore)] [AcceptVerbs(`GET`)] public <#= GetOperationReturnType(operation) #> <#= operation.Name #>(<#= GetParameters(operation) #>) { throw new NotImplementedException(); } <# } #> } } Build your module, run the software factory and observe that the generated classes now have operations generated in them."
  },
  "articles/GettingStarted/FAQ.html": {
    "href": "articles/GettingStarted/FAQ.html",
    "title": "Frequently Asked Questions | Intent Architect",
    "keywords": "Frequently Asked Questions If I use Intent Architect, am I locked into your product? No , this is one of our fundamental design principles. Intent Architect is built to be a design time tool, just like your favourite IDE. There is no coupling between it and your application or production environments. This means you can stop using Intent Architect at any point with zero impact to your applications. This is different from most other similar tools, which would have some form of lock-in. For example, Intent Architect has:- No runtime that your code must execute in. No proprietary framework dependencies . No generated code that is unmaintainable due to being unwieldy or poorly implemented, such that it's obviously not what a developer would have coded. Does this tool replace traditional software development? No , it complements it. Intent Architect is built by developers for developers, we are in no way trying to diminish the development experience. The tool frees developers from performing many menial tasks, such as implementing boilerplate code, allowing them to focus on application design and solving business problems. Does my solution/application need to be Microsoft .NET based? No, Intent Architect itself is built in .NET technologies, but the code it generates can be whatever you like. We already have several Modules available to improve the process for .NET, development for example:- Visual Studio Integration NuGet Integration Roslyn Weaver, for advanced code weaving scenarios These Modules are written outside of Intent Architect as plugins, and similar Modules can be produced for other development environments. If you are interested in doing this or need some helping doing so, please contact us. How do I create my own patterns / modules? Make your own Module Do I need to use T4 templates for my patterns? There is no requirement to use T4 templates. We typically use T4 templates ourselves and our SDK supplies T4 base classes templates, but you can use any other technology you like, you simply need to implement the ITemplate interface. Isn't code generation fundamentally evil? We must admit we were initially very surprised to find there are people who have negative views on code generation, we have been exposed to various code generation techniques over the past 15 years and have generally had positive experiences. Out view is that it a tool, and just like any tool you need to know where it is appropriate to use and how to get the best use out of the tool. From the people we have spoken to, and from our own experience, code generation becomes problematic in the following scenarios:- Prescriptive code generated , in these scenarios you have no control over the code being generated, it's a take it or leave it scenario. The code being generated is bad , bad code is bad code, whether it is generated or not. Many code generation tools are very generic, resulting in poor code, it's obvious to spot the code wasn't hand written. Once off code generation , this scenario isn't necessarily inherently bad, where it can be problematic is if you generate a lot of code which you later on realise you want/need to refactor. It's not obvious that code generation is the problem here as you could have hand coded it all, only to find yourself in the same position, some people will argue manually coding it might have forced you to rethink your implementation. All or nothing code generation , here it is difficult to deal with exceptional scenarios, which happen. With Intent Architect we have taken these learnings and tried to create a seamless code generation experience. Some of the factors which we believe set us apart include:- You control the content. The code that is generated is completely within your control. Continuous code generation. At any point you can run the code generation and your application will update to reflect your design accordingly, even in existing code files. Managed generated outputs. Most code generation tools work in a purely additive fashion i.e. only adding to or overwriting files in your code base, Intent Architect tracks the generated outputs and removes generated outputs which are no longer relevant. Code Weaving. We support advanced weaving systems which allow for manual code to be introduced into generated code files, and for that code to be maintained on subsequent generations of the code. Code as you would write it. This is really up to module implementors but in principle, and from our experience, there is no reason for the generated code to look any different to hand written code. IDE integration. The generated code is integrated into your IDE, no need to manually add or removed generated code files in your IDE. (We currently have an implementation for Visual Studio, but Intent Architect is extensible and there is no reason it can not be integrated into your IDE of choice) Code generation is simply a tool, the benefit you get out of it is up to you. In the world of code generation tools, Intent Architect is a power tool, giving you new and better ways to solve your software problems."
  },
  "articles/UserManual/ApplicationConfiguration.html": {
    "href": "articles/UserManual/ApplicationConfiguration.html",
    "title": "Application Configuration | Intent Architect",
    "keywords": "Application Configuration Describe your application's code project structure. Here you conceptually lay out how the physical code structure you would like, or how it actually is if you are using Intent Architect against an existing code base. The are 2 main purposes behind describing this structure:- Flexibility, allowing you to map out where you would like the generated code outputs to go. Generate and/or manage your actual code projects and solutions Generated code is mapped to the projects through a role system. Templates in Modules target roles (defined by the Template creator), when such a module is added to your application those roles becomes available on this screen for assignment. Assigning a role to a project is effectively saying 'Place all generated output related to this role into this project'. It is recommended to use standard conventions for roles e.g. Domain, Persistence, UI, Services, Contracts, etc. 1. Save Save your application configuration, save the world. 2. Project Add one or more projects, these projects represent the actual code projects of your code solution. These projects can either be created by Intent Architect or be existing projects. Projects have project types, project types are dynamic and available in Intent Architect through modules. Our Visual Studio module ships with several standard .Net project types. 3. Assigned Roles These are the roles currently assigned to this specific projects. These roles mean that any generated code targeting these roles will be placed in this project. 4. Unassigned Roles This is a list of roles which have been registered, through the modules you have added to your application, which are currently not mapped onto a project. These roles need to be mapped to the desired projects. 5. Properties window Show the properties of the currently selected item, and typically allows them to be edited. There is also a context menu available on items for editing."
  },
  "articles/UserManual/Domain.html": {
    "href": "articles/UserManual/Domain.html",
    "title": "Domain | Intent Architect",
    "keywords": "Domain Overview This screen allows to describe your business domain through the use of UML class diagrams. Here you can describe complex business concepts and their relationships, partitioning them into simpler to consume views (if required). As with all the meta data describing DSLs this data is technology agnostic and can be extending using your own custom meta data through the stereotype system. 1. Toolbar These are the controls which allow you to perform high level interactions with the current UML view. 2. Uml Editor This is the UML visualization of the currently selected UML view. The view as well as the underlying model are edited. 3. Tree Model This tree shows the model in it's entirety :- Views of the domain model Domain model Type definitions Stereotype Definitions 4. Properties This is a basic property editor for the currently selected item. Toolbar Allows for high level interaction with the current UML View within the UML Editor region. 1. Save Saves your changed. 2. Add Class Adds a new class to you current view, this class is also added to the domain model. 3. Add Attribute Add an attribute to a class. 4. Add Operation Add an operation to a class. 5. Add Association Add an association between the two classes you select. 6. Add Inheritance Add an inheritance relationship between the two classes you select. Uml Editor Model you domain or a sub view of it using UML. This supports standard UML functionality, this includes concept of stereotypes which allow you to annotated custom meta data to any aspect of the model. 1. Class A UML Class. 2. Stereotypes An example of a stereotype being applied to a class, note stereotypes can be applied to any aspect of the model attributes, properties, etc. 3. Attributes List of classes attributes. 4. Operations List of classes operations. 5. Association An association between classes. Tree Model This tree view contains the entire domain model, as opposed to the UML editor which showing you a specific view of the domain model. 1. Views These are the views of the domain model, or sub sections of the domain model. This tool allows for multiple views to be created on top of a single domain model. This allows for creating simplified views or perspective based views on top of the underlying domain model. 2. Domain Model Artifacts These artifacts would be the basic model i.e. the UML Classes and their properties, plus the associations between them. 3. Folders This tool supports a dynamic folder structure allowing you store your domain model artifacts in a structure which makes sense to you. 4. Supporting Model Artifacts These would be the extensions to the UML model, namely custom data types, enumerations and stereotype definitions. Note these can be manually created or imported by Modules. Property Window This shows, and allows for editing, the properties of the currently selected item. 1. Item Type Type indicator for the selected item. 2. Properties The properties of the selected item. 3. Stereotypes Stereotypes which are on the currently selected item."
  },
  "articles/UserManual/HomeScreen.html": {
    "href": "articles/UserManual/HomeScreen.html",
    "title": "Home Screen | Intent Architect",
    "keywords": "Home Screen The home screen is a general landing page, it allows you to create new solutions, provides short cuts to your recently accessed applications, and solutions, as well as keeping you updated with our news feed. 1. Create New Solution Allows you to create a new solution, as stated. Solutions are just a named grouping concept for one or more applications. 2. Open Existing Solution Find and open a previously created solution. These would be files with the '.isln' extension. 3. Recent Contains a list of recently accessed solution and applications. 4. Recently Accessed Solution Click me to open this recently accessed solution. 5. Recently Accessed Application Click me to open this recently accessed application. 6. Show All Shows all the applications within the recently access solution, not just the recently accessed applications. 7. News Feed Our new feed, hopefully containing links and information you find useful."
  },
  "articles/UserManual/RepositoryConfiguration.html": {
    "href": "articles/UserManual/RepositoryConfiguration.html",
    "title": "Repository Configuration | Intent Architect",
    "keywords": "Repository Configuration This screen allows you to configure the Repositories for your application. These repositories are the sources of Application Templates and Modules. Repositories can be represented by a service or a physical folder on your hard drive. 1. Current Repository This control allows you to change / choose your default repository 2. Add New Allows you to add new repositories, i.e. new sources of Applications Templates and Modules. 3. Address This is Uri for the repository, it can either be in the form of a URL to a service or a folder location on your hard drive. 4. Ordering These arrows allow you to order the list of repositories in order of preference, with the top most repository being the most prefered. Whenever cascading actions / searches must be performed across the repositories they will be performed in the order you have specified here. 5. Edit Modify the details of the repository. 6. Delete Remove the repository."
  },
  "articles/UserManual/Shell.html": {
    "href": "articles/UserManual/Shell.html",
    "title": "The Shell | Intent Architect",
    "keywords": "The Shell This is the basic shell of Intent Architect which is typically always visible no matter where you are in the application. 1. Home Screen Area There is no place like home. 2. Solution drop down This list contains a complete list of all you Intent Architect solutions. This drop down can be used to switch between solutions. 3. Debug button This button is equivalent to clicking the Play button, the difference being this button will also attach the Visual Studio debugger to the execution, allowing you to debug your modules. Don't forget to include the PDB files into your module if you want to debug them. 4. Play button This almighty button runs the software factory for the application you currently have open. This will typically result in Intent Architect generating source code into your solution. 5. User context Show the currently logged in user and provides access to all user related functionality. 6. Context specific menu This area typically contains a menu of actions applicable to your current context. 7. Content Region The region contains the content you are currently passionately engaged with."
  },
  "articles/UserManual/SolutionScreen.html": {
    "href": "articles/UserManual/SolutionScreen.html",
    "title": "Solution Screen | Intent Architect",
    "keywords": "Solution Screen Ths screen allows for the creation / maintenance a solution. A solution simply represents a named logical grouping of applications. 1. Edit Solution Details Enough said. 2. Add New Application Adds a new application to this solution. 3. Edit Application Edit the application 4. Delete Application Delete this application"
  },
  "articles/UserManual/ApplicationModules.html": {
    "href": "articles/UserManual/ApplicationModules.html",
    "title": "Application Modules | Intent Architect",
    "keywords": "Application Modules This screen allows to manage which modules are installed for your application. These modules are typically your packaged patterns, i.e. templates generating your code , the way you want it, using your meta data. Modules typically should be a set of templates to achieve a pattern or set of related patterns. Modules often encapsulate a technology, and more specifically your usage patterns of the specific technology. Modules are discovered through repositories which can be either service based or folder based. It is important to note that modules can contain more than just patternized code generation, some other types of modules might include IDE Integration, Code Weavers or Meta Data providers. Modules can include any of the following plugins:- Plugin Type Description Template Registrations Standard code generation plugins namely templates and decorators. Application Processor Allow for the execution of custom code within the execution process at predefined execution steps. Meta Data Provider Load your own Meta Data to further enrich the code generation process. Output Transformer Intercept and optionally manipulate the generated code during the execution process. 1. Repository Configuration This allows you to configure your repositories, i.e. where Intent Architect is discovering your modules. 2. Module Filter This controls what modules you are seeing in the modules list. Browse - All modules available from you currently selected repository. Installed - All modules installed for current application. Update - All modules installed for current application which have updates available. 3. Search Finds what you looking for. 4. Module List Displays a list of modules based on your current repository, filters and search input. 5. Module List Item This gives an overview of a specific Module. This would include a name, the author, brief description and version information. Currently installed Modules are denoted by an icon, the colour of the icon provides additional information. Colour Description Green You have the latest version of the module installed. Blue There is a newer version of the module available. Red This module is installed but Intent Architect is unable to locate module in the configured repositories. 6. Module Details This section contains detailed information about the module. It also allows you to install, update, uninstall the module, as well as the ability to configure the module. 7. Module Commands This panel is dynamic and changes based on whether or not the Module is installed. It allows for installing the module, uninstalling the module and changing the version of a currently installed module. 8. Module Meta Data Provides meta data about the module including authoring information, modules dependencies, etc. 9. Module Configuration This section provides technical details about the various plugins present in the modules, typically this would be the list of templates the modules contains but it can also contain other plugin types. These plugins can be enabled or disabled using the check box. These plugins can be configured through the cog icon."
  },
  "articles/UserManual/ApplicationScreen.html": {
    "href": "articles/UserManual/ApplicationScreen.html",
    "title": "Application Screen | Intent Architect",
    "keywords": "Application Screen This screen is where you configure / describe your application and generate code for your application. On this screen you can configure you application, select patterns (modules) you would like to use and describe your high level architecture through our meta data generating DSLs. 1. Solution This is the solution the application belongs too. 2. Current Application This drop down indicates which application you are currently working with. You can swap between the various applications within the solution here. 3. Configuration This section allows you to configure how you would like your application's code to be structured. It allows you describe your code projects structures and map the code generation onto that project structure. 4. Modules This section allows you to manages your applications modules. These modules can be many things but typically represent the patterns you would like to see in your application code. 5. Domain This DSL allows you to describe your applications domain model using UML. 6. DTO This DSL allows you to describe your applications data contracts. This DSL also supports concepts like describing your contracts with reference to your domain allowing you to introduce compile time dependencies without introducing a runtime dependencies. 7. Services This DSL allows you to describe your applications services. 8. Events Not implemented yet. This DSL will allow for describing inbound and outbound application events. 9. Shell All the functions in this area are described in Shell ."
  },
  "articles/UserManual/Dto.html": {
    "href": "articles/UserManual/Dto.html",
    "title": "Data Contracts | Intent Architect",
    "keywords": "Data Contracts This screen allows to describe your data contracts or data transfer objects. As with all the meta data describing DSLs this data is technology agnostic and can be extending using your own custom meta data through the stereotype system. 1. Save 2. Folders This tool supports a dynamic folder structure allowing you store data contract meta data in a structure which makes sense to you. 3. Data Contract This ia an example of a data contract with it's members. The data contract can optionally be linked to a Domain Class, in this way you can capture you intent that your contracts are in fact based off of your domain model without introducing any run time dependencies. This allows you to better manage the relationship between domain model changes and data contracts. 4. Data Contract Member Data contract members are the properties of the data contract. Again these can optionally be defined with respect to the domain. 5. Supporting Model Artifacts These would be the extensions to the data contract model, namely custom data types, enumerations and stereotype definitions. Note these can be manually created or imported by Modules. 6. Property Window This shows, and allows for editing, the properties of the currently selected item."
  },
  "articles/UserManual/NewApplicationWizard.html": {
    "href": "articles/UserManual/NewApplicationWizard.html",
    "title": "New Application Wizard | Intent Architect",
    "keywords": "New Application Wizard This wizard creates new applications with in the current solution. This wizard will prompt you to select an Application Template to start with, based on you selection your application will be configured accordingly. 1. Repository Configuration This allows you to configure your repositories, i.e. where Intent Architect is discovering your application templates and Modules. 2. Application Templates This is a list of application templates you can base your application on. Application templates pre-configure your application according to the template. Application Template simply initialize you application to a pre-defined state, everything the Application Template does can be done manually through the UI. 3. Application Template description This section provides more detailed information about the Application Template and it's intentions, this information is supplied by the Application Template's creator. 4. Icon Selection Associate an Icon with you application. This icon is used purely for visual purposes within Intent Architect and is meant to make it easier to visually see which application you are working with, this is particularly useful for users who work with many applications. 5. Location This is the folder where you would like the application and it's associated data to be stored. By default the location will be a folder with the same name as the project within the Solutions directory. 6. Create Will create the application based on your selections."
  },
  "articles/UserManual/Services.html": {
    "href": "articles/UserManual/Services.html",
    "title": "Services | Intent Architect",
    "keywords": "Services This screen allows to describe your services. As with all the meta data describing DSLs this data is technology agnotic and can be extending using your own custom meta data through the stereotype system. 1. Save 2. Folders This tool supports a dynamic folder structure allowing you store data contract meta data in a structure which makes sense to you. 3. Service Definition This ia an example of a service definition. The basic service meta data is fairly simplistic but can be extended to describe any service related concepts you wish to model through the use of stereotypes. It's important to note that these are logical services and could be realized in any technology of your choice. 4. Stereotype Icon This is an example a stereotype on a service, the 'lock' icon is the visual showing the \"secured\" stereotype is applied to the service. The visualization of stereotype is customizable through the stereotype definitions. 5. Service Operation This the logical definition of a service operation, it defines the basic contract and can be enriched through the stereotype system. 6. Supporting Model Artifacts These would be the extensions to the service model, namely custom data types, enumerations and stereotype definitions. Note these can be manually created or imported by Modules. 7. Property Window This shows, and allows for editing, the properties of the currently selected item."
  },
  "articles/UserManual/SoftwareFactoryExecution.html": {
    "href": "articles/UserManual/SoftwareFactoryExecution.html",
    "title": "Software Factory Execution | Intent Architect",
    "keywords": "Software Factory Execution Clicking the Play button will kick off the execution of our software factory. This screen shows the execution details of the software factory, it provides detailed information about what is happening with in code generation process. This screen also shows the user what code changes will be made and allows for reviewing and/or rejecting these changes. Console tab 1. Console Tab This tab shows the details of the code generation execution process. 2. Search Filter Use this search to filter the console messages. 3. Category Filter These toggle-able buttons allow for filtering of console messages based on their category. 4. Console Messages These messages are the output from the code generation process. They can be useful for giving insight into the code generation process, should it be required. 5. Apply Changes Apply changes will commit the \"Checked\" changes / outputs of the code generation process, i.e. write the output to disk i.e. create, delete and overwrite code files on the hard drive. 6. Cancel This will cancel the process, no output will be written to disk, i.e. no changes will occur to your existing code base. Changes tab 1. Changes Tab This tab shows the details of the output from the code generation execution process. 2. Search Filter Use this search to filter the changes messages. 3. Category Filter These toggle-able buttons allow for filtering of changes messages based on their category. 4. Bulk output selector This allows for the bulk checking and un-checking of changes. 5. Change Messages This is a list of all file based changes which Intent Architect would like to make. 6. Individual Change Message Each line represents a file which will change. This line contains the following:- Check box - un-checking this box will prevent this change from occurring when clicking Apply Changes. Category Indicator (Created, Updated, Deleted) Compare Changes icon (magnifying glass) Name of the file which is changing. This file name is relatively pathed from the 'isln' file. 7. Apply Changes Apply changes will commit the \"Checked\" changes / outputs of the code generation process, i.e. write the output to disk, this will overwrite files if they exist on the hard drive. 8. Cancel This will cancel the process, no output will be written to disk, i.e. no changes will occur to your existing code base."
  },
  "modules/index.html": {
    "href": "modules/index.html",
    "title": "Modules | Intent Architect",
    "keywords": "Modules"
  },
  "modules/RoslynWeaver/Appendix.html": {
    "href": "modules/RoslynWeaver/Appendix.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Appendix List of Roslyn Weave Code Elements Classes Constructors Enums Fields Interfaces Methods Properties Roslyn Weave Modes Mode Description Fully The generated code element will be used. Ignore The non-generated element code will be used. Merge The code elements from both sources will be merged together. Code Element mode specifics Code Element Signature Body Class The class header i.e. every thing before the first {. The class body i.e. every thing after the first {. Constructor The signature of the constructor, i.e. every thing before the first {. The body of the constructor, i.e. every thing after the first { Enum The enum header i.e. every thing before the first {. The enum body i.e. every thing after the first {. Field The field declaration. N/A Interface The interface header i.e. every thing before the first {. The interface body i.e. every thing after the first {. Method The signature of the method, i.e. every thing before the first {. The body of the method, i.e. every thing after the first { Property The signature of the property, i.e. every thing before the first {. The body of the property, i.e. every thing after the first {"
  }
}