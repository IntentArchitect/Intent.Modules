{
  "modules/RoslynWeaver/Modes.html": {
    "href": "modules/RoslynWeaver/Modes.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Roslyn Weaver Modes The Roslyn Weaver goes through all the code elements in the existing solution file and merges in all code elements from the template output. The way in which the code elements are weaved is determined by the mode specified for the code element. The mode under which a code element is operating is controlled by using either the IntentManaged or DefaultIntentManaged attributes. A code element can be operating under one of three modes as detailed below. Mode Meaning Fully The code element from the Template Output will be used and the code element from the Solution Code File will be discarded. If the code element exists in the Solution Code File but not in the Template Output the code element will be removed. Ignore The code element from the Solution Code File will be used and the code element from the Template Output will be discarded. Merge The code element existing in both the Template Output and the Solution Code File the code elements will be merged to produce a new code element. How the merging occurs is code element specific and can be further controller by specifying a Signature and/or Body mode. If either side does not have a version of the code element it will be introduced, in this way merge mode is always addative code will typically not be removed by the weaver. If a code element is running under Merge mode you can further fine tune the weaving by specifying specific modes for the signature and body of the code element. By default the body and signature modes will be the same as the code element node i.e. Merge . Detailed description of what the signature and body of each code element ."
  },
  "modules/RoslynWeaver/HowToImplement.html": {
    "href": "modules/RoslynWeaver/HowToImplement.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver How to implement Roslyn Weaver in your templates Enabling you templates to work with the Rosyln Weaver module is as simple as implementing the IRoslynMerge interface. Alternativly you can inherit you template from the IntentRoslynProjectItemTemplateBase base class which implements this interface already, as well as several other quality of life features. using Intent.SoftwareFactory.Templates; //NOTE IRoslynMerge Interface public class MyTemplate : ITemplate, IRoslynMerge { ... public RoslynMergeConfig ConfigureRoslynMerger() { return new RoslynMergeConfig(new TemplateMetaData(Id, \"1.0\")); } ... } There are typically 3 types of templates, these can be categorized by the nature of their output Largely Generated content Largely Hand coded content Event split of generated and hand coded content To Do Use Partial Classes (With or without code behind), inheritance, composition Mention Code MIgrations InitialCodeGen"
  },
  "modules/index.html": {
    "href": "modules/index.html",
    "title": "Modules | Intent Architect",
    "keywords": "Modules"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to Intent Architect documentation. | Intent Architect",
    "keywords": "Welcome to Intent Architect documentation."
  },
  "modules/RoslynWeaver/Overview.html": {
    "href": "modules/RoslynWeaver/Overview.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Overview Roslyn Weaver allows developers to change or extend generated code files with their own custom code. Templates designed to work with this extension are far more powerful than traditional code generation, they allow hand written code to be introduced into the generated code. These template still maintaining the ability to continue changing and executing without losing the hand written code. In summary it allows generated code and custom written code to live symbiotically in a single file. The primary driver behind Roslyn Weaver is to overcome one of the biggest limitations of traditional code generation systems which is that they are typically ' all or nothing '. That is to to say you have to use the generated code as is for all scenarios and there is a very limit scope for extensibility. Any extensibility is typically done through inheritance or partial classes. While these traditional methods are available and may be great to use for some scenarios Roslyn Weaver introduces a wide new range of possibilities. Due to the Roslyn Weaver's ability to integate non-generated with generated code there are many new possibilities for extensibility beyond those of traditional code generation techniques. Some extensibilty techniques may include, (but not limited to) Creating custom code extention points in your templates Roslyn Weaver allows explicit deviation from the template, by the developer, for exceptional scenarios Template outputs are more open to change by the developer Some of the design goals behind Roslyn Weaver Feel and look like normal code, generated code is often easy to spot and terrible to read or maintain, Roslyn Weaver wants to be part of your dev team. Respect the developers code, try to maintain formatting and white space as much as possible. Try to be unintrusive, code should look and fell like code you would traditionally hand write. Terminology How Roslyn Weaver works Roslyn Weaver for Template Designers Roslyn Weaver for Template Consumers Roslyn Weaver Attributes Code Migrations Gotchas Appendix"
  },
  "modules/RoslynWeaver/Gotchas.html": {
    "href": "modules/RoslynWeaver/Gotchas.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Gotchas The process is bias favouring Output Trivia is only ever added when there is none Single namespace assumption Template Default Intent - Only introduced if not in Solution (Assrmbly level) using clauses and namespaces Code element equivelenacy Method matching"
  },
  "modules/RoslynWeaver/Attributes.html": {
    "href": "modules/RoslynWeaver/Attributes.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Roslyn Weaver Attributes Full list of Attributes IntentTemplate IntentManaged DefaultIntentManaged IntentInitialGen IntentTemplate Attribute Overview This attribute is added by the Roslyn Weaver automatically to all generated code, this attribute is used for. Determining which template, and version of the template, produced the solution code Code Migrations Usage This attribute is managed by the Roslyn Weaver which introduces it to the generated output based on the executing template. This attribute should not be used or introduced to a file directly by the developer, as it is managed by the Roslyn Weaver. This attribute is an assembly level attribute, as it applies to the file rather than any specific artifact within the file. Properties Name Description Id Corresponds to the Template Id of the template which produced this code file. Version Corresponds to the version of template which produced this code file. Example A generated file, using a template with Id : MyFirstTemplate would contain the following code. ... using Intent.CodeGen; [assembly: IntentTemplate(\"MyFirstTemplate\", Version = \"1.0\")] ... IntentManaged Attribute Overview This attribute can be added to a code element to control how the Roslyn Weaver merges the code. The merge behaviour is determined by the mode which is specified. Usage This attiribute can be introduced into generated code to alter the behaviour of the Roslyn Weaver. The typical scenario would be to allow you to introduce custom code into a generated code file. This attribute is typically used by developers to modify the template output, it typically should not be used in templates themselves, templates should typically using DefaultIntentManaged if they want to control the Roslyn Weavers behaviour. This attribute is will override DefaultIntentManaged if both are targeting the same code element. This attribute can be applied to any of the following. Class Constructor Enum Field Interface Method Property Properties Name Description ElementMode Specified the mode under which the code element should be merged Body Specified the mode under which the body of the code element should be merged. This is only required if the mode for the Body differs from the element mode. Signature Specified the mode under which the signature of the code element should be merged. This is only required if the mode for the Signature differs from the element mode Examples Using Ignore mode to change or add functionality In the code below a ToString could be newly introduced or changed from the version which was being generated. Either way the method is now in the developers control. Generated Code File ... [IntentManaged(Mode.Ignore)] public override string ToString() { return this.Id; } ... Fine tuning the mode The code example below is simlar to the one above, how ever in this example the method signature is running fully under code gen while the body of the method is under the developers control. Generated Code File ... [IntentManaged(Mode.Fully, Body = Mode.Ignore)] public override string ToString() { return this.Id; } ... DefaultIntentManaged Attribute Overview This attibute can be used to specify the default mode for 1 or more code elements. Usage The attribute is scoped based on were it is declared, i.e. if it is declared at an assembly level it's scope is the entire file, if it is declared on a class or interface it's scope is that class or interface. The code elements the attribute applies to work as follows. If Targets is specified the mode is applied to all code elements of the listed targets. e.g. Targets.Properties | Targets.Methods would apply the mode to all properties and methods within it's scope. If AccessModifiers is specified the mode is applied to all code elements with any of the listed access modifiers. e.g. AccessModifier.Public would apply the mode to all public code elements within it's scope. If both Targets and AccessModifiers are specified the mode will apply to any code elements which match any of the target AND any of the access modifiers. e.g. AccessModifier.Public and Targets.Properties | Targets.Methods would be all public methods and all public properties. If neither Targets or AccessModifiers is specified the mode will be applied to all code elements within the attributes scope. This attribute can be applied to any of the following. Assembly Class Interface Properties Name Description Element Mode Specified the mode under which the targeted code element should be merged Body Specified the mode under which the body of the targeted code element should be merged. This is only required if the mode for the body differs from the element mode. Signature Specified the mode under which the signature of the targeted code element should be merged. This is only required if the mode for the signature differs from the element mode. Targets Allows for targeting specifc code elements which the mode must apply to. Multiple targets can be specified using the | syntax. The valid targets are Classes, Constructors, Enums, Fields, Interfaces, Methods and Properties AccessModifiers This property can be used to target code elements based on access modifiers. Multiple access modifiers can be specified using the | syntax. The valid access modifiers are internal, private, protected and public. Examples Letting the code gen explictly control all public members of a class TODO Template Code File ... [DefaultIntentManaged(Mode.Fully, Body = Mode.Ignore, Targets = Targets.Methods | Targets.Properties, AccessModifiers = AccessModifiers.Public)] public MyClass() { ... } ... IntentInitialGen Attribute Overview This attribute can be used by developers creating templates to indicate code elements which are generated once off when the template is initally run. These code elements are typically stubs or default implementations for developers to complete or enrich. From the Roslyn Weavers perspective this code is seen as manual code, it just happens to get added in by the template as opposed to a developer. Usage This attribute should only be used in templates and does not make sense to exist in generated code. The Roslyn Weaver will remove these attributes from the generated code. Any templates using this attribute should be desined in such a way that the code targeted by these attributes is in a managed mode of Ignore or Merge . If the code element is under fully mode it will be removed on a subsequent execution of the template. This attribute can be applied to any of the following. Constructor Field Property Method Properties N/A Examples Adding an initial constructor The code below would add a default constructor to the class, with a compile time warning indicating that the constructor needs to be implemented. Template Code File ... [IntentInitialGen] public MyClass() { #warning please implement 1 or more meaningful non-anemic constructors } ... Generated Code File ... public MyClass() { #warning please implement 1 or more meaningful non-anemic constructors } ... Note the generated code is not seem as part of the template, hance if it is runnng under Fully managed mode, the code will be removed on a subsequent run."
  },
  "modules/RoslynWeaver/HowToWorkWith.html": {
    "href": "modules/RoslynWeaver/HowToWorkWith.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Working with Roslyn Weaver templates Roslyn Weaver provides several code based attributes ( Roslyn Weaver attributes ) which can used to control or change the code weaving process. As a developer working with the generated output, you will find that while the generated output is typically what you want ocassionally you may need to change or extend the output for exceptional circumstances. Note if you are doing this often you should consider upgrading or changing the templates themselves. Modifying the solution code file involves introducing, or changing exisitng, IntentManged attributes to fine tune the Roslyn Weavers behaviour to respect the non-generated code. Below are several examples of doing this. Turning off the code generation Assuming we have a generated solution code file, as per the code example below. ... using System; [assembly: IntentTemplate(\"MyFirstTemplate\", Version = \"1.0\")] public class MyGeneratedClass { ... } We could introduce the DefaultIntentManaged attribute to turn of the code generation for this specific file. ... using System; [assembly: DefaultIntentManaged(Mode.Ignore)] [assembly: IntentTemplate(\"MyFirstTemplate\", Version = \"1.0\")] public class MyGeneratedClass { ... } Note this does not techincally turn off the code generation is rather instructing the Roslyn Weaver to ignore all the code elements by default. Changing a classes signature Assuming we want to change a classes signature, e.g. Introduce a new attribute or an interface, given we have a generated output as below. ... using System; [assembly: DefaultIntentManaged(Mode.Fully)] [assembly: IntentTemplate(\"MyFirstTemplate\", Version = \"1.0\")] public class MyGeneratedClass { ... } There are several ways we could achieve this, adding any one of the IntentManaged attributes listed below to the class would allow you to modify the signature. ... using System; [assembly: DefaultIntentManaged(Mode.Fully)] [assembly: IntentTemplate(\"MyFirstTemplate\", Version = \"1.0\")] [IntentManaged(Mode.Merge, Signature=Mode.Ignore, Body=Mode.Fully)] // OR [IntentManaged(Mode.Merge, Signature=Mode.Merge, Body=Mode.Fully)] // OR [IntentManaged(Mode.Merge, Signature=Mode.Merge, Body=Mode.Merge)] // OR //This is equivelant to the line above [IntentManaged(Mode.Merge)] this is equivelant to the line above [MyManualAttribute] public class MyGeneratedClass : MyManualBaseClass, IMyManualInterface { ... } Changing a method implementation Assuming we want to change the implementation of a generated method, looking at the example below. ... public class MyGeneratedClass { public void MyMethod(string arg1) { } } We can modify the method using any of the IntentManaged attributes below. ... public class MyGeneratedClass { [IntentManaged(Mode.Ignore)] // OR [IntentManaged(Mode.Merge, Signature=Mode.Fully, Body=Mode.Ignore)] public void MyMethod(string arg1) { //My Implementation } }"
  },
  "modules/RoslynWeaver/CodeMigrations.html": {
    "href": "modules/RoslynWeaver/CodeMigrations.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Code Migrations"
  },
  "modules/RoslynWeaver/HowItWorks.html": {
    "href": "modules/RoslynWeaver/HowItWorks.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver How it works The Roslyn Weaver is an Intent Architect extension, more specifically an Output Transformer. The Roslyn Weaver works by modfiying the standard Intent Architect process. Simplyfied Intent Architect execution process Roslyn weavers intercepts the template output, finds the existing solution file ( if present) and weaves them together, typically preserving the non-generated code and merging in the generated template output. Roslyn Weaver's modified Intent Architect execution process As you can imagine the process of merging the code is complex, having said that developers do it all the time. Roslyn Weaver merges the code by allowing developers to annotate the code with attributes which dictate how the merging should be performed. These attributes are typically used in one of two ways:- By template designers to degin extend points in their templates, i.e. the \"put your code here\" scenario. Roslyn Weaver for Template Designers By developers consuming the templates to extend or deviate from the templatised pattern. Roslyn Weaver for Template Consumers"
  },
  "modules/RoslynWeaver/Appendix.html": {
    "href": "modules/RoslynWeaver/Appendix.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Appendix List of Roslyn Weave Code Elements Classes Constructors Enums Fields Interfaces Methods Properties Roslyn Weave Modes Mode Description Fully The generated code element will be used. Ignore The non-generated element code will be used. Merge The code elemeents from both sources will be merged together. Code Element mode specifics Code Element Signatue Body Class The class header i.e. every thing before the first {. The class body i.e. every thing after the first {. Constructor The signature of the constructor, i.e. every thing before the first {. The body of the constructor, i.e. every thing after the first { Enum The enum header i.e. every thing before the first {. The enum body i.e. every thing after the first {. Field The field declaration. N/A Interface The interface header i.e. every thing before the first {. The interface body i.e. every thing after the first {. Method The signature of the method, i.e. every thing before the first {. The body of the mthod, i.e. every thing after the first { Property The signature of the property, i.e. every thing before the first {. The body of the property, i.e. every thing after the first {"
  },
  "modules/RoslynWeaver/Terminology.html": {
    "href": "modules/RoslynWeaver/Terminology.html",
    "title": "Roslyn Weaver | Intent Architect",
    "keywords": "Roslyn Weaver Terminology Terms Term Description Roslyn Weaver Intent Architect plugin designed to merge existing code (Solution Code) with generated code (Tempate Output) to provide a more powerful and interactive code generation experience. Code Element The refers to a code fragment, e.g a method or property, within a code file which can be targeted for code weaving. List of Code Elements Mode This describes the strategy the Roslyn Weaver will use for weaving a specific code element when it is processing it. Output Transformer This is a plugin type supported by Intent Architect. This plugin type allows for the modification of the code being generated, it occurs after template execution but before peristence of the solution file. Roslyn Weaver is an example of such a plugin. Solution Code File Refers to a code file in a solution. These are the actual code files you would compile to produce your software product. The outputs from Intent Architect, i.e. the generated code, are typically solution code files. Within the context of the Roslyn Weaver it is important to note that these are also inputs, as the previous Intent Architects executions outputs become inputs to the following execution. Template Output Refers the generated code produced by Intent Architect. The Roslyn Weaver will weave this output with it's corresponding Solution Code Files to produce a new versions of the Solution Code Files. Weaving The process of taking a 2 pieces of code and merging them together to form a single piece of code."
  },
  "articles/UserManual/Shell.html": {
    "href": "articles/UserManual/Shell.html",
    "title": "User Manual | Intent Architect",
    "keywords": "User Manual The Shell Legend No Description 1 Home Screen Area 2 Solution drop down 3 Debug button 4 Play button 5 User context 6 Context specific menu 7 Content Region Home Screen Area Clicking here will take you back to the Home Screen . Solution drop down This list contains a complete list of all you Intent Architect solutions. This drop down can be used to switch between solutions. Debug button Play button User context Context specific menu Content Region"
  },
  "articles/Extensibility/CreateAModule.html": {
    "href": "articles/Extensibility/CreateAModule.html",
    "title": "Coming Soon | Intent Architect",
    "keywords": "Coming Soon"
  },
  "articles/GettingStarted/intro.html": {
    "href": "articles/GettingStarted/intro.html",
    "title": "Add your introductions here! | Intent Architect",
    "keywords": "Add your introductions here!"
  },
  "articles/UserManual/HomeScreen.html": {
    "href": "articles/UserManual/HomeScreen.html",
    "title": "User Manual | Intent Architect",
    "keywords": "User Manual Home Screen"
  }
}