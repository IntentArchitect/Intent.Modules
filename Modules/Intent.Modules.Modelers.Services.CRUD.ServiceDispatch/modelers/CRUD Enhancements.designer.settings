<?xml version="1.0" encoding="utf-8"?>
<settings version="3.1.1">
  <id>78de7c54-66ee-41af-a93a-007da1576209</id>
  <name>CRUD Enhancements</name>
  <designerReferences />
  <packageSettings />
  <packageExtensions>
    <packageExtension type="Services Package" typeId="df45eaf6-9202-4c25-8dd5-677e9ba1e906">
      <requiredPackages />
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Create CRUD Operations</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="FontAwesome" source="code" />
          <script>// This script is generalized such that you only need to copy and paste its contents to the
// following Modules' Create CRUD Operation scripts and adjust only the `currentCrudModule` variable accordingly:
// - `Intent.AzureFunctions`
// - `Modelers.Services.CRUD.ServiceDispatch`
const CrudModuleStandard = "Standard";
const CrudModuleAzureFunction = "Azure Function";
const currentCrudModule = CrudModuleStandard;
initGlobals();
// Detect if we're running from the "Execution Script dialogue", in which case we want to manually
// set the element to something:
let defaultDomainClassName = null;
if (element?.id == null) {
    // For testing as if a package was right clicked, substitute with package id:
    // element = { id: "7339add6-c32e-4d95-8e1b-1bbe86ca7f1c" }; // Azure
    // element = { id: "ef5c352b-fc74-4f13-b61b-a970f8360b08" }; // NestJS
    //element = { id: "a7ab362f-e8a8-4490-90d5-484b0371d949" };
    // For element, substitute with service's element id:
    // element = lookup("677c6801-e654-45c5-924e-886713db1f5e");
    // When set, the dialog asking to select the class from the domain is skipped:
    //defaultDomainClassName = "NewClass";
}
let entity = await preselectOrPromptEntity(defaultDomainClassName);
if (!entity) {
    return;
}
let service = getServiceFromCurrentContext(entity, element);
let entityFolder = getEntityFolder(service, entity);
let resultStdTypeDto = createStandardResultTypeDTO(entity, entityFolder);
createStandardCreateOperation(service, entity, entityFolder, currentCrudModule);
createStandardFindByIdOperation(service, entity, entityFolder, currentCrudModule, resultStdTypeDto);
createStandardFindAllOperation(service, entity, entityFolder, currentCrudModule, resultStdTypeDto);
createStandardUpdateOperation(service, entity, entityFolder, currentCrudModule);
createStandardDeleteOperation(service, entity, entityFolder, currentCrudModule);
/*
========================
    HOOK-IN FUNCTIONS
========================
Easier to alter the behavior of certain key operations.
Could make certain things configurable in the future.
*/
function getParameterFormat(str) {
    return toCamelCase(str);
}
function getRoutingFormat(str) {
    return str;
}
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
    }
    return str;
}
function getFolderName(nestedCompOwner, entity) {
    return nestedCompOwner ? pluralize(nestedCompOwner.name) : pluralize(entity.name);
}
function getBaseNameForElement(nestedCompOwner, entity, entityIsMany) {
    let entityName = entityIsMany ? toPascalCase(pluralize(entity.name)) : toPascalCase(entity.name);
    return nestedCompOwner ? `${toPascalCase(nestedCompOwner.name)}${entityName}` : entityName;
}
function getServiceName(nestedCompOwner, entity) {
    return nestedCompOwner
        ? `${toPascalCase(nestedCompOwner.name)}Service`
        : `${toPascalCase(entity.name)}Service`;
}
function getOperationFormat(baseName, nestedCompOwner, entity, entityIsMany = false) {
    let entityName = entityIsMany ? pluralize(entity.name) : entity.name;
    return `${baseName}${nestedCompOwner ? entityName : ""}`;
}
/*
========================
    CREATION FUNCTIONS
========================
*/
function createStandardResultTypeDTO(entity, entityFolder) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedDtoName = `${baseName}DTO`;
    if (hasElementInFolder(entityFolder, expectedDtoName)) {
        return entityFolder.getChildren().filter(x =&gt; x.name == expectedDtoName)[0];
    }
    let dto = createElement("DTO", expectedDtoName, entityFolder.id);
    dto.setMapping(entity.id);
    dto.setMetadata("baseName", baseName);
    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);
        if (!nestedCompOwnerFkDescr || nestedCompOwnerFkDescr.specialization == globals.FKSpecialization.Implicit) {
            let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), dto.id);
            nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        }
    }
    if (entityPkDescr.specialization == globals.PKSpecialization.Implicit) {
        let idField = createElement("DTO-Field", getFieldFormat(entityPkDescr.name), dto.id);
        idField.typeReference.setType(entityPkDescr.typeId);
    }
    let attributesWithMapPaths = getAttributesWithMapPath(entity);
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        let field = createElement("DTO-Field", getFieldFormat(entry.name), dto.id);
        field.typeReference.setType(entry.typeId);
        field.setMapping(entry.mapPath);
    }
    dto.collapse();
    return dto;
}
function createStandardCreateOperation(service, entity, entityFolder, currentCrudModule) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedCreateDtoName = `${baseName}CreateDTO`;
    if (hasElementInFolder(entityFolder, expectedCreateDtoName)) {
        let command = entityFolder.getChildren().filter(x =&gt; x.name == expectedCreateDtoName)[0];
        let entityPkDescr = getPrimaryKeyDescriptor(entity);
        command.typeReference.setType(entityPkDescr.typeId);
        return;
    }
    let createDto = createElement("DTO", expectedCreateDtoName, entityFolder.id);
    createDto.setMapping(entity.id, globals.projectMappingSettingId);
    createDto.setMetadata("baseName", baseName);
    createDto.setMetadata("originalVerb", "Create");
    let operation = createElement("Operation", getOperationFormat("Create", nestedCompOwner, entity), service.id);
    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";
    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);
        let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), createDto.id);
        nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        if (nestedCompOwnerFkDescr.specialization == globals.FKSpecialization.Explicit) {
            nestedCompOwnerIdDtoField.setMapping(nestedCompOwnerFkDescr.id);
        }
        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, null);
    }
    if (currentCrudModule === CrudModuleStandard) {
        setHttpStereotype(operation, "Http Settings", { "Verb": "POST", "Route": routePath });
    }
    else if (currentCrudModule === CrudModuleAzureFunction) {
        setHttpStereotype(operation, "Azure Function", { "Type": "Http Trigger", "Method": "POST", "Route": `${entity.getName().toLowerCase()}/${routePath}` });
    }
    let operationParamCreateDto = createElement("Parameter", getParameterFormat("dto"), operation.id);
    operationParamCreateDto.typeReference.setType(createDto.id);
    if (entityPkDescr.typeId) {
        operation.typeReference.setType(entityPkDescr.typeId);
        getReturnTypeMediatypeProperty(operation).setValue("application/json");
    }
    let attributesWithMapPaths = getAttributesWithMapPath(entity);
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        let field = createElement("DTO-Field", getFieldFormat(entry.name), createDto.id);
        field.typeReference.setType(entry.typeId);
        field.setMapping(entry.mapPath);
    }
    createDto.collapse();
    operation.collapse();
}
function createStandardFindByIdOperation(service, entity, entityFolder, currentCrudModule, resultTypeDto) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let operation = createElement("Operation", getOperationFormat("FindById", nestedCompOwner, entity), service.id);
    operation.typeReference.setType(resultTypeDto.id);
    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";
    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);
        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr);
    }
    else {
        routePath = getRoutePath(null, null, entityPkDescr);
    }
    if (currentCrudModule === CrudModuleStandard) {
        setHttpStereotype(operation, "Http Settings", { "Verb": "GET", "Route": routePath });
    }
    else if (currentCrudModule === CrudModuleAzureFunction) {
        setHttpStereotype(operation, "Azure Function", { "Type": "Http Trigger", "Method": "GET", "Route": `${entity.getName().toLowerCase()}/${routePath}` });
    }
    addPrimaryKeys(null, operation, entityPkDescr);
    operation.collapse();
}
function createStandardFindAllOperation(service, entity, entityFolder, currentCrudModule, resultTypeDto) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let operation = createElement("Operation", getOperationFormat("FindAll", nestedCompOwner, entity, true), service.id);
    operation.typeReference.setIsCollection(true);
    operation.typeReference.setType(resultTypeDto.id);
    let routePath = "";
    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);
        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, null);
    }
    if (currentCrudModule === CrudModuleStandard) {
        setHttpStereotype(operation, "Http Settings", { "Verb": "GET", "Route": routePath });
    }
    else if (currentCrudModule === CrudModuleAzureFunction) {
        setHttpStereotype(operation, "Azure Function", { "Type": "Http Trigger", "Method": "GET", "Route": `${entity.getName().toLowerCase()}/${routePath}` });
    }
    operation.collapse();
}
function createStandardUpdateOperation(service, entity, entityFolder, currentCrudModule) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedUpdateDtoName = `${baseName}UpdateDTO`;
    if (hasElementInFolder(entityFolder, expectedUpdateDtoName)) {
        return;
    }
    let updateDto = createElement("DTO", expectedUpdateDtoName, entityFolder.id);
    updateDto.setMapping(entity.id, globals.projectMappingSettingId);
    updateDto.setMetadata("baseName", baseName);
    updateDto.setMetadata("originalVerb", "Update");
    let operation = createElement("Operation", getOperationFormat("Put", nestedCompOwner, entity), service.id);
    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";
    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);
        let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), updateDto.id);
        nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        if (nestedCompOwnerFkDescr.specialization == globals.FKSpecialization.Explicit) {
            nestedCompOwnerIdDtoField.setMapping(nestedCompOwnerFkDescr.id);
        }
        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr);
    }
    else {
        routePath = getRoutePath(null, null, entityPkDescr);
    }
    if (currentCrudModule === CrudModuleStandard) {
        setHttpStereotype(operation, "Http Settings", { "Verb": "PUT", "Route": routePath });
    }
    else if (currentCrudModule === CrudModuleAzureFunction) {
        setHttpStereotype(operation, "Azure Function", { "Type": "Http Trigger", "Method": "PUT", "Route": `${entity.getName().toLowerCase()}/${routePath}` });
    }
    addPrimaryKeys(updateDto, operation, entityPkDescr);
    let dtoParam = createElement("Parameter", getParameterFormat("dto"), operation.id);
    dtoParam.typeReference.setType(updateDto.id);
    let attributesWithMapPaths = getAttributesWithMapPath(entity);
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        let field = createElement("DTO-Field", getFieldFormat(entry.name), updateDto.id);
        field.typeReference.setType(entry.typeId);
        field.setMapping(entry.mapPath);
    }
    updateDto.collapse();
    operation.collapse();
    function hasAttributeInCommand(command, attribute) {
        return command.getChildren("DTO-Field").some(x =&gt; x.name == attribute.name);
    }
}
function createStandardDeleteOperation(service, entity, entityFolder, currentCrudModule) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let operation = createElement("Operation", getOperationFormat("Delete", nestedCompOwner, entity), service.id);
    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";
    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);
        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr);
    }
    else {
        routePath = getRoutePath(null, null, entityPkDescr);
    }
    if (currentCrudModule === CrudModuleStandard) {
        setHttpStereotype(operation, "Http Settings", { "Verb": "DELETE", "Route": routePath });
    }
    else if (currentCrudModule === CrudModuleAzureFunction) {
        setHttpStereotype(operation, "Azure Function", { "Type": "Http Trigger", "Method": "DELETE", "Route": `${entity.getName().toLowerCase()}/${routePath}` });
    }
    addPrimaryKeys(null, operation, entityPkDescr);
    operation.collapse();
}
/*
========================
    UTILITY FUNCTIONS
========================
*/
var globals;
function initGlobals() {
    globals = {
        aggregateRootCache: Object.create(null),
        nestedCompositionalOwnerCache: Object.create(null),
        projectMappingSettingId: "01d74d4f-e478-4fde-a2f0-9ea92255f3c5",
        PKSpecialization: {
            Implicit: "implicit",
            Explicit: "explicit",
            ExplicitComposite: "explicit_composite",
            Unknown: "unknown"
        },
        FKSpecialization: {
            Implicit: "implicit",
            Explicit: "explicit",
        }
    };
}
async function showObject(object) {
    await dialogService.info(JSON.stringify(object, null, "  "));
}
async function preselectOrPromptEntity(preselectedDomainClassName) {
    let classes = lookupTypesOf("Class").filter(x =&gt; isAggregateRoot(x) || x.hasStereotype("Repository") || ownerIsAggregateRoot(x));
    if (classes.length == 0) {
        await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
        return;
    }
    let classId = preselectedDomainClassName != null
        ? classes.find(x =&gt; x.getName() === preselectedDomainClassName)?.id
        : await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: getFriendlyDisplayNameForClassSelection(x)
        })));
    if (classId == null) {
        await dialogService.error(`No class found with id "${classId}".`);
        return null;
    }
    let foundEntity = lookup(classId);
    return foundEntity;
}
function getFriendlyDisplayNameForClassSelection(element) {
    let found = element.getAssociations("Association").filter(x =&gt; x.isSourceEnd() &amp;&amp;
        !x.typeReference.isNullable &amp;&amp;
        !x.typeReference.isCollection &amp;&amp;
        isAggregateRoot(x.typeReference.getType()))[0]?.typeReference?.getType();
    return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
}
function getServiceFromCurrentContext(entity, packageOrServiceElement) {
    // Auto detect if we're running in the context of a service or package.
    if (packageOrServiceElement.specialization === "Service") {
        return packageOrServiceElement;
    }
    // Must be a package. See if we can find an existing service with the name we expect.
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let expectedServiceName = getServiceName(nestedCompOwner, entity);
    let services = packageOrServiceElement.getChildren("Service").filter(x =&gt; x.name === expectedServiceName);
    if (services.length &gt; 0) {
        return services[0];
    }
    return createElement("Service", expectedServiceName, packageOrServiceElement.id);
}
function getReturnTypeMediatypeProperty(element) {
    return element.getStereotype("Http Settings").getProperty("Return Type Mediatype");
}
function isAggregateRoot(element) {
    if (globals.aggregateRootCache[element.id]) {
        return globals.aggregateRootCache[element.id];
    }
    let result = !element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
    globals.aggregateRootCache[element.id] = result;
    return result;
}
function getNestedCompositionalOwner(entity) {
    if (globals.nestedCompositionalOwnerCache[entity.id]) {
        return globals.nestedCompositionalOwnerCache[entity.id];
    }
    let result = entity.getAssociations("Association")
        .filter(x =&gt; isAggregateRoot(x.typeReference.getType()) &amp;&amp;
        isOwnedBy(x) &amp;&amp;
        // Let's only target collections for now as part of the nested compositional crud support
        // as one-to-one relationships are more expensive to address and possibly not going to
        // be needed.
        x.getOtherEnd().typeReference.isCollection)[0];
    if (result) {
        globals.nestedCompositionalOwnerCache[entity.id] = result.typeReference.getType();
    }
    return result;
    function isOwnedBy(association) {
        return association.isSourceEnd() &amp;&amp;
            !association.typeReference.isNullable &amp;&amp;
            !association.typeReference.isCollection;
    }
}
function ownerIsAggregateRoot(entity) {
    // Let's not introduce this yet
    return false;
    //let result = getNestedCompositionalOwner(entity);
    //return result ? true : false;
}
function getEntityFolder(service, entity) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let expectedFolderName = getFolderName(nestedCompOwner, entity);
    var existing = service.getParent().getChildren().find(x =&gt; x.name == expectedFolderName);
    var folder = existing || createElement("Folder", expectedFolderName, service.getParent().id);
    return folder;
}
function hasElementInFolder(entityFolder, expectedElementName) {
    return entityFolder.getChildren().some(x =&gt; x.name == expectedElementName);
}
function setHttpStereotype(element, stereotypeName, props) {
    let stereotype = element.getStereotype(stereotypeName);
    for (let key of Object.keys(props)) {
        stereotype.getProperty(key).setValue(props[key]);
    }
}
function getSurrogateKeyType() {
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", "6b649125-18ea-48fd-a6ba-0bfff0d8f488");
    typeNameToIdMap.set("int", "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74");
    typeNameToIdMap.set("long", "33013006-E404-48C2-AC46-24EF5A5774FD");
    let typeName = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")?.getField("Key Type")?.value ?? "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
// Returns a dictionary instead of element to help deal with explicit vs implicit keys
function getPrimaryKeyDescriptor(entity) {
    if (!entity) {
        throw new Error("entity not specified");
    }
    let primaryKeys = getPrimaryKeysWithMapPath(entity);
    let keyLen = Object.keys(primaryKeys).length;
    switch (true) {
        case keyLen == 0:
            return {
                id: null,
                name: getDomainAttributeNameFormat("Id"),
                typeId: getSurrogateKeyType(),
                specialization: globals.PKSpecialization.Implicit,
                compositeKeys: null,
                mapPath: null
            };
        case keyLen == 1:
            let pkAttr = primaryKeys[Object.keys(primaryKeys)[0]];
            return {
                id: pkAttr.id,
                name: getDomainAttributeNameFormat(pkAttr.name),
                typeId: pkAttr.typeId,
                specialization: globals.PKSpecialization.Explicit,
                compositeKeys: null,
                mapPath: pkAttr.mapPath
            };
        case keyLen &gt; 1:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: globals.PKSpecialization.ExplicitComposite,
                compositeKeys: Object.values(primaryKeys).map((v) =&gt; {
                    return {
                        id: v.id,
                        name: getDomainAttributeNameFormat(v.name),
                        typeId: v.typeId,
                        mapPath: v.mapPath
                    };
                }),
                mapPath: null
            };
        default:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: globals.PKSpecialization.Unknown,
                compositeKeys: null,
                mapPath: null
            };
    }
}
;
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return keydict;
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
// Returns a dictionary instead of element to help deal with explicit vs implicit keys
function getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner) {
    if (!entity) {
        throw new Error("entity not specified");
    }
    if (!nestedCompOwner) {
        throw new Error("nestedCompOwner not specified");
    }
    let explicitFkAttr = entity.getChildren("Attribute")
        .filter(x =&gt; x.name.toLowerCase().indexOf(nestedCompOwner.name.toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
    if (explicitFkAttr) {
        return {
            name: getDomainAttributeNameFormat(explicitFkAttr.name),
            typeId: explicitFkAttr.typeReference.typeId,
            id: explicitFkAttr.id,
            specialization: globals.FKSpecialization.Explicit
        };
    }
    return {
        name: getDomainAttributeNameFormat(`${nestedCompOwner.name}Id`),
        typeId: getSurrogateKeyType(),
        id: null,
        specialization: globals.FKSpecialization.Implicit
    };
}
function addPrimaryKeys(dto, operation, entityPkDescr) {
    switch (entityPkDescr.specialization) {
        case globals.PKSpecialization.Implicit:
        case globals.PKSpecialization.Explicit:
            {
                if (dto) {
                    let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(entityPkDescr.name), dto.id);
                    primaryKeyDtoField.typeReference.setType(entityPkDescr.typeId);
                    if (entityPkDescr.specialization == globals.PKSpecialization.Explicit) {
                        primaryKeyDtoField.setMapping(entityPkDescr.mapPath);
                    }
                }
                let operationParamId = createElement("Parameter", getParameterFormat(entityPkDescr.name), operation.id);
                operationParamId.typeReference.setType(entityPkDescr.typeId);
            }
            break;
        case globals.PKSpecialization.ExplicitComposite:
            for (let key of entityPkDescr.compositeKeys) {
                if (dto) {
                    let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(key.name), dto.id);
                    primaryKeyDtoField.typeReference.setType(key.typeId);
                    primaryKeyDtoField.setMapping(key.id);
                }
                let operationParamId = createElement("Parameter", getParameterFormat(key.name), operation.id);
                operationParamId.typeReference.setType(entityPkDescr.typeId);
            }
            break;
    }
}
function getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr) {
    let list = [];
    if (nestedCompOwnerFkDescr) {
        list.push(`{${getParameterFormat(nestedCompOwnerFkDescr.name)}}`);
    }
    if (entity) {
        list.push(`${getRoutingFormat(entity.name)}`);
    }
    if (entityPkDescr) {
        switch (entityPkDescr.specialization) {
            case globals.PKSpecialization.Implicit:
            case globals.PKSpecialization.Explicit:
                list.push(`{${getParameterFormat(entityPkDescr.name)}}`);
                break;
            case globals.PKSpecialization.ExplicitComposite:
                list.push(entityPkDescr.compositeKeys.map(x =&gt; `{${getParameterFormat(x.name)}}`));
                break;
        }
    }
    if (list.length == 0) {
        return "";
    }
    return list.join("/");
}
function getDomainAttributeNamingConvention() {
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return application.getSettings(domainSettingsId)
        ?.getField("Attribute Naming Convention")?.value ?? "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.name === "PartitionKey";
}</script>
        </option>
      </scriptOptions>
      <typeOrder />
    </packageExtension>
  </packageExtensions>
  <elementSettings />
  <elementExtensions>
    <elementExtension type="DTO" typeId="fee0edca-4aa0-4f77-a524-6bbd84e78734">
      <mappingSettings>
        <mappingSetting id="01d74d4f-e478-4fde-a2f0-9ea92255f3c5">
          <name>Project to Domain</name>
          <shortcut>ctrl + shift + p</shortcut>
          <defaultModeler>6ab29b31-27af-4f56-a67c-986d82097d63</defaultModeler>
          <optionsSource>elements-of-type</optionsSource>
          <autoSyncTypeReferences>true</autoSyncTypeReferences>
          <symbol>fa-long-arrow-right</symbol>
          <targetTypeOptions>
            <option specializationType="04e12b51-ed12-42a3-9667-a6aa81bb6d10" displayText="Class" />
          </targetTypeOptions>
          <mapFrom>root</mapFrom>
          <mappings>
            <mapping id="91f640f0-6976-4ac0-b3f0-90cf2d9785e6">
              <criteria specializationType="Class">
                <hasTypeReference p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
                <isCollection p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
                <hasChildren p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
              </criteria>
              <mapTo specializationType="DTO" childMappingMode="map-to-child" />
              <behaviour autoSelectChildren="true" />
              <childMappings>
                <mapping id="53858b49-3863-4597-85a0-6d95b3fe6a04">
                  <criteria specializationType="Attribute">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                    <hasChildren>false</hasChildren>
                  </criteria>
                  <mapTo specializationType="DTO-Field" childMappingMode="map-to-child" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
                <mapping id="f9e4e028-cf9d-4dcf-8ab6-b56c5db25666">
                  <criteria specializationType="Association Target End">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                    <hasChildren p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                  </criteria>
                  <mapTo specializationType="DTO-Field" childMappingMode="map-to-child" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
                <mapping id="c2bfd200-aef9-468e-800f-56264c2c5b01">
                  <criteria specializationType="Association Source End">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                    <hasChildren p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                  </criteria>
                  <mapTo specializationType="DTO-Field" childMappingMode="map-to-child" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
                <mapping id="00eac74a-c9eb-4cb7-94a1-905c2bde1625">
                  <criteria specializationType="Generalization Target End">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection>false</isCollection>
                    <hasChildren p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                  </criteria>
                  <mapTo childMappingMode="traverse" useMappingSettings="91f640f0-6976-4ac0-b3f0-90cf2d9785e6" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
              </childMappings>
            </mapping>
          </mappings>
        </mappingSetting>
      </mappingSettings>
      <macros>
        <macro trigger="on-mapped">
          <script>//let element = lookup("29a81107-c71c-45b4-ba7b-982be63277a1")
const projectMappingSettingId = "01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
const originalDtoMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
initGlobals();
let fields = element.getChildren("DTO-Field")
    .filter(x =&gt; x.typeReference.getType() == null &amp;&amp; x.getMapping().getElement().specialization === "Association");
fields.forEach(f =&gt; {
    let mappedElement = f.getMapping().getElement();
    let originalVerb = "";
    if (element.hasMetadata("originalVerb")) {
        originalVerb = element.getMetadata("originalVerb");
        // In the event that the prefix is no longer the same as the
        // originally called verb, then don't propagate this any further
        // as end users might get confused.
        if (element.getName().indexOf(originalVerb) &lt; 0) {
            originalVerb = "";
        }
    }
    let targetMappingSettingId = (!originalVerb || originalVerb === "")
        ? originalDtoMappingSettingId
        : projectMappingSettingId;
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : domainName;
    let dtoName = `${originalVerb}${baseName}`;
    let dto = getOrCreateDTO(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), targetMappingSettingId);
    if (originalVerb !== "") {
        dto.setMetadata("originalVerb", originalVerb);
    }
    dto.setMetadata("baseName", baseName);
    ensureDtoFields(mappedElement, dto);
    f.typeReference.setType(dto.id);
});
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
    }
    return str;
}
var globals;
function initGlobals() {
    globals = {
        PKSpecialization: {
            Implicit: "implicit",
            Explicit: "explicit",
            ExplicitComposite: "explicit_composite",
            Unknown: "unknown"
        },
        FKSpecialization: {
            Implicit: "implicit",
            Explicit: "explicit",
        }
    };
}
function getOrCreateDTO(elementName, parentElement) {
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.name === `${elementName}DTO`)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", `${elementName}DTO`, parentElement.id);
    return dto;
}
function ensureDtoFields(mappedElement, dto) {
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let isCreateMode = dto.getMetadata("originalVerb")?.toLowerCase()?.startsWith("create") == true;
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; entry.name?.toLowerCase() === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        let field = createElement("DTO-Field", entry.name, dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (!isCreateMode) {
        let entityPkDescr = getPrimaryKeyDescriptor(domainElement);
        addPrimaryKeys(dto, entityPkDescr);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function addPrimaryKeys(dto, entityPkDescr) {
    switch (entityPkDescr.specialization) {
        case globals.PKSpecialization.Implicit:
        case globals.PKSpecialization.Explicit:
            {
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(entityPkDescr.name), dto.id);
                primaryKeyDtoField.typeReference.setType(entityPkDescr.typeId);
                if (entityPkDescr.specialization == globals.PKSpecialization.Explicit) {
                    primaryKeyDtoField.setMapping(entityPkDescr.mapPath);
                }
            }
            break;
        case globals.PKSpecialization.ExplicitComposite:
            for (let key of entityPkDescr.compositeKeys) {
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(key.name), dto.id);
                primaryKeyDtoField.typeReference.setType(key.typeId);
                primaryKeyDtoField.setMapping(key.id);
            }
            break;
    }
}
function getSurrogateKeyType() {
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", "6b649125-18ea-48fd-a6ba-0bfff0d8f488");
    typeNameToIdMap.set("int", "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74");
    typeNameToIdMap.set("long", "33013006-E404-48C2-AC46-24EF5A5774FD");
    let typeName = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")?.getField("Key Type")?.value ?? "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.name.toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
// Returns a dictionary instead of element to help deal with explicit vs implicit keys
function getPrimaryKeyDescriptor(entity) {
    if (!entity) {
        throw new Error("entity not specified");
    }
    let primaryKeys = getPrimaryKeysWithMapPath(entity);
    let keyLen = Object.keys(primaryKeys).length;
    switch (true) {
        case keyLen == 0:
            return {
                id: null,
                name: getDomainAttributeNameFormat("Id"),
                typeId: getSurrogateKeyType(),
                specialization: globals.PKSpecialization.Implicit,
                compositeKeys: null,
                mapPath: null
            };
        case keyLen == 1:
            let pkAttr = primaryKeys[Object.keys(primaryKeys)[0]];
            return {
                id: pkAttr.id,
                name: getDomainAttributeNameFormat(pkAttr.name),
                typeId: pkAttr.typeId,
                specialization: globals.PKSpecialization.Explicit,
                compositeKeys: null,
                mapPath: pkAttr.mapPath
            };
        case keyLen &gt; 1:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: globals.PKSpecialization.ExplicitComposite,
                compositeKeys: Object.values(primaryKeys).map((v) =&gt; {
                    return {
                        id: v.id,
                        name: getDomainAttributeNameFormat(v.name),
                        typeId: v.typeId,
                        mapPath: v.mapPath
                    };
                }),
                mapPath: null
            };
        default:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: globals.PKSpecialization.Unknown,
                compositeKeys: null,
                mapPath: null
            };
    }
}
;
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return keydict;
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return application.getSettings(domainSettingsId)
        ?.getField("Attribute Naming Convention")?.value ?? "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.name === "PartitionKey";
}</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="Service" typeId="b16578a5-27b1-4047-a8df-f0b783d706bd">
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Create CRUD Operations</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="FontAwesome" source="code" />
          <script>// This script is generalized such that you only need to copy and paste its contents to the
// following Modules' Create CRUD Operation scripts and adjust only the `currentCrudModule` variable accordingly:
// - `Intent.AzureFunctions`
// - `Modelers.Services.CRUD.ServiceDispatch`
const CrudModuleStandard = "Standard";
const CrudModuleAzureFunction = "Azure Function";
const currentCrudModule = CrudModuleStandard;
initGlobals();
// Detect if we're running from the "Execution Script dialogue", in which case we want to manually
// set the element to something:
let defaultDomainClassName = null;
if (element?.id == null) {
    // For testing as if a package was right clicked, substitute with package id:
    // element = { id: "7339add6-c32e-4d95-8e1b-1bbe86ca7f1c" }; // Azure
    // element = { id: "ef5c352b-fc74-4f13-b61b-a970f8360b08" }; // NestJS
    //element = { id: "a7ab362f-e8a8-4490-90d5-484b0371d949" };
    // For element, substitute with service's element id:
    // element = lookup("677c6801-e654-45c5-924e-886713db1f5e");
    // When set, the dialog asking to select the class from the domain is skipped:
    //defaultDomainClassName = "NewClass";
}
let entity = await preselectOrPromptEntity(defaultDomainClassName);
if (!entity) {
    return;
}
let service = getServiceFromCurrentContext(entity, element);
let entityFolder = getEntityFolder(service, entity);
let resultStdTypeDto = createStandardResultTypeDTO(entity, entityFolder);
createStandardCreateOperation(service, entity, entityFolder, currentCrudModule);
createStandardFindByIdOperation(service, entity, entityFolder, currentCrudModule, resultStdTypeDto);
createStandardFindAllOperation(service, entity, entityFolder, currentCrudModule, resultStdTypeDto);
createStandardUpdateOperation(service, entity, entityFolder, currentCrudModule);
createStandardDeleteOperation(service, entity, entityFolder, currentCrudModule);
/*
========================
    HOOK-IN FUNCTIONS
========================
Easier to alter the behavior of certain key operations.
Could make certain things configurable in the future.
*/
function getParameterFormat(str) {
    return toCamelCase(str);
}
function getRoutingFormat(str) {
    return str;
}
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
    }
    return str;
}
function getFolderName(nestedCompOwner, entity) {
    return nestedCompOwner ? pluralize(nestedCompOwner.name) : pluralize(entity.name);
}
function getBaseNameForElement(nestedCompOwner, entity, entityIsMany) {
    let entityName = entityIsMany ? toPascalCase(pluralize(entity.name)) : toPascalCase(entity.name);
    return nestedCompOwner ? `${toPascalCase(nestedCompOwner.name)}${entityName}` : entityName;
}
function getServiceName(nestedCompOwner, entity) {
    return nestedCompOwner
        ? `${toPascalCase(nestedCompOwner.name)}Service`
        : `${toPascalCase(entity.name)}Service`;
}
function getOperationFormat(baseName, nestedCompOwner, entity, entityIsMany = false) {
    let entityName = entityIsMany ? pluralize(entity.name) : entity.name;
    return `${baseName}${nestedCompOwner ? entityName : ""}`;
}
/*
========================
    CREATION FUNCTIONS
========================
*/
function createStandardResultTypeDTO(entity, entityFolder) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedDtoName = `${baseName}DTO`;
    if (hasElementInFolder(entityFolder, expectedDtoName)) {
        return entityFolder.getChildren().filter(x =&gt; x.name == expectedDtoName)[0];
    }
    let dto = createElement("DTO", expectedDtoName, entityFolder.id);
    dto.setMapping(entity.id);
    dto.setMetadata("baseName", baseName);
    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);
        if (!nestedCompOwnerFkDescr || nestedCompOwnerFkDescr.specialization == globals.FKSpecialization.Implicit) {
            let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), dto.id);
            nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        }
    }
    if (entityPkDescr.specialization == globals.PKSpecialization.Implicit) {
        let idField = createElement("DTO-Field", getFieldFormat(entityPkDescr.name), dto.id);
        idField.typeReference.setType(entityPkDescr.typeId);
    }
    let attributesWithMapPaths = getAttributesWithMapPath(entity);
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        let field = createElement("DTO-Field", getFieldFormat(entry.name), dto.id);
        field.typeReference.setType(entry.typeId);
        field.setMapping(entry.mapPath);
    }
    dto.collapse();
    return dto;
}
function createStandardCreateOperation(service, entity, entityFolder, currentCrudModule) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedCreateDtoName = `${baseName}CreateDTO`;
    if (hasElementInFolder(entityFolder, expectedCreateDtoName)) {
        let command = entityFolder.getChildren().filter(x =&gt; x.name == expectedCreateDtoName)[0];
        let entityPkDescr = getPrimaryKeyDescriptor(entity);
        command.typeReference.setType(entityPkDescr.typeId);
        return;
    }
    let createDto = createElement("DTO", expectedCreateDtoName, entityFolder.id);
    createDto.setMapping(entity.id, globals.projectMappingSettingId);
    createDto.setMetadata("baseName", baseName);
    createDto.setMetadata("originalVerb", "Create");
    let operation = createElement("Operation", getOperationFormat("Create", nestedCompOwner, entity), service.id);
    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";
    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);
        let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), createDto.id);
        nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        if (nestedCompOwnerFkDescr.specialization == globals.FKSpecialization.Explicit) {
            nestedCompOwnerIdDtoField.setMapping(nestedCompOwnerFkDescr.id);
        }
        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, null);
    }
    if (currentCrudModule === CrudModuleStandard) {
        setHttpStereotype(operation, "Http Settings", { "Verb": "POST", "Route": routePath });
    }
    else if (currentCrudModule === CrudModuleAzureFunction) {
        setHttpStereotype(operation, "Azure Function", { "Type": "Http Trigger", "Method": "POST", "Route": `${entity.getName().toLowerCase()}/${routePath}` });
    }
    let operationParamCreateDto = createElement("Parameter", getParameterFormat("dto"), operation.id);
    operationParamCreateDto.typeReference.setType(createDto.id);
    if (entityPkDescr.typeId) {
        operation.typeReference.setType(entityPkDescr.typeId);
        getReturnTypeMediatypeProperty(operation).setValue("application/json");
    }
    let attributesWithMapPaths = getAttributesWithMapPath(entity);
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        let field = createElement("DTO-Field", getFieldFormat(entry.name), createDto.id);
        field.typeReference.setType(entry.typeId);
        field.setMapping(entry.mapPath);
    }
    createDto.collapse();
    operation.collapse();
}
function createStandardFindByIdOperation(service, entity, entityFolder, currentCrudModule, resultTypeDto) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let operation = createElement("Operation", getOperationFormat("FindById", nestedCompOwner, entity), service.id);
    operation.typeReference.setType(resultTypeDto.id);
    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";
    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);
        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr);
    }
    else {
        routePath = getRoutePath(null, null, entityPkDescr);
    }
    if (currentCrudModule === CrudModuleStandard) {
        setHttpStereotype(operation, "Http Settings", { "Verb": "GET", "Route": routePath });
    }
    else if (currentCrudModule === CrudModuleAzureFunction) {
        setHttpStereotype(operation, "Azure Function", { "Type": "Http Trigger", "Method": "GET", "Route": `${entity.getName().toLowerCase()}/${routePath}` });
    }
    addPrimaryKeys(null, operation, entityPkDescr);
    operation.collapse();
}
function createStandardFindAllOperation(service, entity, entityFolder, currentCrudModule, resultTypeDto) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let operation = createElement("Operation", getOperationFormat("FindAll", nestedCompOwner, entity, true), service.id);
    operation.typeReference.setIsCollection(true);
    operation.typeReference.setType(resultTypeDto.id);
    let routePath = "";
    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);
        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, null);
    }
    if (currentCrudModule === CrudModuleStandard) {
        setHttpStereotype(operation, "Http Settings", { "Verb": "GET", "Route": routePath });
    }
    else if (currentCrudModule === CrudModuleAzureFunction) {
        setHttpStereotype(operation, "Azure Function", { "Type": "Http Trigger", "Method": "GET", "Route": `${entity.getName().toLowerCase()}/${routePath}` });
    }
    operation.collapse();
}
function createStandardUpdateOperation(service, entity, entityFolder, currentCrudModule) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedUpdateDtoName = `${baseName}UpdateDTO`;
    if (hasElementInFolder(entityFolder, expectedUpdateDtoName)) {
        return;
    }
    let updateDto = createElement("DTO", expectedUpdateDtoName, entityFolder.id);
    updateDto.setMapping(entity.id, globals.projectMappingSettingId);
    updateDto.setMetadata("baseName", baseName);
    updateDto.setMetadata("originalVerb", "Update");
    let operation = createElement("Operation", getOperationFormat("Put", nestedCompOwner, entity), service.id);
    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";
    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);
        let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), updateDto.id);
        nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        if (nestedCompOwnerFkDescr.specialization == globals.FKSpecialization.Explicit) {
            nestedCompOwnerIdDtoField.setMapping(nestedCompOwnerFkDescr.id);
        }
        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr);
    }
    else {
        routePath = getRoutePath(null, null, entityPkDescr);
    }
    if (currentCrudModule === CrudModuleStandard) {
        setHttpStereotype(operation, "Http Settings", { "Verb": "PUT", "Route": routePath });
    }
    else if (currentCrudModule === CrudModuleAzureFunction) {
        setHttpStereotype(operation, "Azure Function", { "Type": "Http Trigger", "Method": "PUT", "Route": `${entity.getName().toLowerCase()}/${routePath}` });
    }
    addPrimaryKeys(updateDto, operation, entityPkDescr);
    let dtoParam = createElement("Parameter", getParameterFormat("dto"), operation.id);
    dtoParam.typeReference.setType(updateDto.id);
    let attributesWithMapPaths = getAttributesWithMapPath(entity);
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        let field = createElement("DTO-Field", getFieldFormat(entry.name), updateDto.id);
        field.typeReference.setType(entry.typeId);
        field.setMapping(entry.mapPath);
    }
    updateDto.collapse();
    operation.collapse();
    function hasAttributeInCommand(command, attribute) {
        return command.getChildren("DTO-Field").some(x =&gt; x.name == attribute.name);
    }
}
function createStandardDeleteOperation(service, entity, entityFolder, currentCrudModule) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let operation = createElement("Operation", getOperationFormat("Delete", nestedCompOwner, entity), service.id);
    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";
    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);
        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr);
    }
    else {
        routePath = getRoutePath(null, null, entityPkDescr);
    }
    if (currentCrudModule === CrudModuleStandard) {
        setHttpStereotype(operation, "Http Settings", { "Verb": "DELETE", "Route": routePath });
    }
    else if (currentCrudModule === CrudModuleAzureFunction) {
        setHttpStereotype(operation, "Azure Function", { "Type": "Http Trigger", "Method": "DELETE", "Route": `${entity.getName().toLowerCase()}/${routePath}` });
    }
    addPrimaryKeys(null, operation, entityPkDescr);
    operation.collapse();
}
/*
========================
    UTILITY FUNCTIONS
========================
*/
var globals;
function initGlobals() {
    globals = {
        aggregateRootCache: Object.create(null),
        nestedCompositionalOwnerCache: Object.create(null),
        projectMappingSettingId: "01d74d4f-e478-4fde-a2f0-9ea92255f3c5",
        PKSpecialization: {
            Implicit: "implicit",
            Explicit: "explicit",
            ExplicitComposite: "explicit_composite",
            Unknown: "unknown"
        },
        FKSpecialization: {
            Implicit: "implicit",
            Explicit: "explicit",
        }
    };
}
async function showObject(object) {
    await dialogService.info(JSON.stringify(object, null, "  "));
}
async function preselectOrPromptEntity(preselectedDomainClassName) {
    let classes = lookupTypesOf("Class").filter(x =&gt; isAggregateRoot(x) || x.hasStereotype("Repository") || ownerIsAggregateRoot(x));
    if (classes.length == 0) {
        await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
        return;
    }
    let classId = preselectedDomainClassName != null
        ? classes.find(x =&gt; x.getName() === preselectedDomainClassName)?.id
        : await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: getFriendlyDisplayNameForClassSelection(x)
        })));
    if (classId == null) {
        await dialogService.error(`No class found with id "${classId}".`);
        return null;
    }
    let foundEntity = lookup(classId);
    return foundEntity;
}
function getFriendlyDisplayNameForClassSelection(element) {
    let found = element.getAssociations("Association").filter(x =&gt; x.isSourceEnd() &amp;&amp;
        !x.typeReference.isNullable &amp;&amp;
        !x.typeReference.isCollection &amp;&amp;
        isAggregateRoot(x.typeReference.getType()))[0]?.typeReference?.getType();
    return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
}
function getServiceFromCurrentContext(entity, packageOrServiceElement) {
    // Auto detect if we're running in the context of a service or package.
    if (packageOrServiceElement.specialization === "Service") {
        return packageOrServiceElement;
    }
    // Must be a package. See if we can find an existing service with the name we expect.
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let expectedServiceName = getServiceName(nestedCompOwner, entity);
    let services = packageOrServiceElement.getChildren("Service").filter(x =&gt; x.name === expectedServiceName);
    if (services.length &gt; 0) {
        return services[0];
    }
    return createElement("Service", expectedServiceName, packageOrServiceElement.id);
}
function getReturnTypeMediatypeProperty(element) {
    return element.getStereotype("Http Settings").getProperty("Return Type Mediatype");
}
function isAggregateRoot(element) {
    if (globals.aggregateRootCache[element.id]) {
        return globals.aggregateRootCache[element.id];
    }
    let result = !element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
    globals.aggregateRootCache[element.id] = result;
    return result;
}
function getNestedCompositionalOwner(entity) {
    if (globals.nestedCompositionalOwnerCache[entity.id]) {
        return globals.nestedCompositionalOwnerCache[entity.id];
    }
    let result = entity.getAssociations("Association")
        .filter(x =&gt; isAggregateRoot(x.typeReference.getType()) &amp;&amp;
        isOwnedBy(x) &amp;&amp;
        // Let's only target collections for now as part of the nested compositional crud support
        // as one-to-one relationships are more expensive to address and possibly not going to
        // be needed.
        x.getOtherEnd().typeReference.isCollection)[0];
    if (result) {
        globals.nestedCompositionalOwnerCache[entity.id] = result.typeReference.getType();
    }
    return result;
    function isOwnedBy(association) {
        return association.isSourceEnd() &amp;&amp;
            !association.typeReference.isNullable &amp;&amp;
            !association.typeReference.isCollection;
    }
}
function ownerIsAggregateRoot(entity) {
    // Let's not introduce this yet
    return false;
    //let result = getNestedCompositionalOwner(entity);
    //return result ? true : false;
}
function getEntityFolder(service, entity) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let expectedFolderName = getFolderName(nestedCompOwner, entity);
    var existing = service.getParent().getChildren().find(x =&gt; x.name == expectedFolderName);
    var folder = existing || createElement("Folder", expectedFolderName, service.getParent().id);
    return folder;
}
function hasElementInFolder(entityFolder, expectedElementName) {
    return entityFolder.getChildren().some(x =&gt; x.name == expectedElementName);
}
function setHttpStereotype(element, stereotypeName, props) {
    let stereotype = element.getStereotype(stereotypeName);
    for (let key of Object.keys(props)) {
        stereotype.getProperty(key).setValue(props[key]);
    }
}
function getSurrogateKeyType() {
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", "6b649125-18ea-48fd-a6ba-0bfff0d8f488");
    typeNameToIdMap.set("int", "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74");
    typeNameToIdMap.set("long", "33013006-E404-48C2-AC46-24EF5A5774FD");
    let typeName = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")?.getField("Key Type")?.value ?? "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
// Returns a dictionary instead of element to help deal with explicit vs implicit keys
function getPrimaryKeyDescriptor(entity) {
    if (!entity) {
        throw new Error("entity not specified");
    }
    let primaryKeys = getPrimaryKeysWithMapPath(entity);
    let keyLen = Object.keys(primaryKeys).length;
    switch (true) {
        case keyLen == 0:
            return {
                id: null,
                name: getDomainAttributeNameFormat("Id"),
                typeId: getSurrogateKeyType(),
                specialization: globals.PKSpecialization.Implicit,
                compositeKeys: null,
                mapPath: null
            };
        case keyLen == 1:
            let pkAttr = primaryKeys[Object.keys(primaryKeys)[0]];
            return {
                id: pkAttr.id,
                name: getDomainAttributeNameFormat(pkAttr.name),
                typeId: pkAttr.typeId,
                specialization: globals.PKSpecialization.Explicit,
                compositeKeys: null,
                mapPath: pkAttr.mapPath
            };
        case keyLen &gt; 1:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: globals.PKSpecialization.ExplicitComposite,
                compositeKeys: Object.values(primaryKeys).map((v) =&gt; {
                    return {
                        id: v.id,
                        name: getDomainAttributeNameFormat(v.name),
                        typeId: v.typeId,
                        mapPath: v.mapPath
                    };
                }),
                mapPath: null
            };
        default:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: globals.PKSpecialization.Unknown,
                compositeKeys: null,
                mapPath: null
            };
    }
}
;
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return keydict;
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
// Returns a dictionary instead of element to help deal with explicit vs implicit keys
function getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner) {
    if (!entity) {
        throw new Error("entity not specified");
    }
    if (!nestedCompOwner) {
        throw new Error("nestedCompOwner not specified");
    }
    let explicitFkAttr = entity.getChildren("Attribute")
        .filter(x =&gt; x.name.toLowerCase().indexOf(nestedCompOwner.name.toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
    if (explicitFkAttr) {
        return {
            name: getDomainAttributeNameFormat(explicitFkAttr.name),
            typeId: explicitFkAttr.typeReference.typeId,
            id: explicitFkAttr.id,
            specialization: globals.FKSpecialization.Explicit
        };
    }
    return {
        name: getDomainAttributeNameFormat(`${nestedCompOwner.name}Id`),
        typeId: getSurrogateKeyType(),
        id: null,
        specialization: globals.FKSpecialization.Implicit
    };
}
function addPrimaryKeys(dto, operation, entityPkDescr) {
    switch (entityPkDescr.specialization) {
        case globals.PKSpecialization.Implicit:
        case globals.PKSpecialization.Explicit:
            {
                if (dto) {
                    let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(entityPkDescr.name), dto.id);
                    primaryKeyDtoField.typeReference.setType(entityPkDescr.typeId);
                    if (entityPkDescr.specialization == globals.PKSpecialization.Explicit) {
                        primaryKeyDtoField.setMapping(entityPkDescr.mapPath);
                    }
                }
                let operationParamId = createElement("Parameter", getParameterFormat(entityPkDescr.name), operation.id);
                operationParamId.typeReference.setType(entityPkDescr.typeId);
            }
            break;
        case globals.PKSpecialization.ExplicitComposite:
            for (let key of entityPkDescr.compositeKeys) {
                if (dto) {
                    let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(key.name), dto.id);
                    primaryKeyDtoField.typeReference.setType(key.typeId);
                    primaryKeyDtoField.setMapping(key.id);
                }
                let operationParamId = createElement("Parameter", getParameterFormat(key.name), operation.id);
                operationParamId.typeReference.setType(entityPkDescr.typeId);
            }
            break;
    }
}
function getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr) {
    let list = [];
    if (nestedCompOwnerFkDescr) {
        list.push(`{${getParameterFormat(nestedCompOwnerFkDescr.name)}}`);
    }
    if (entity) {
        list.push(`${getRoutingFormat(entity.name)}`);
    }
    if (entityPkDescr) {
        switch (entityPkDescr.specialization) {
            case globals.PKSpecialization.Implicit:
            case globals.PKSpecialization.Explicit:
                list.push(`{${getParameterFormat(entityPkDescr.name)}}`);
                break;
            case globals.PKSpecialization.ExplicitComposite:
                list.push(entityPkDescr.compositeKeys.map(x =&gt; `{${getParameterFormat(x.name)}}`));
                break;
        }
    }
    if (list.length == 0) {
        return "";
    }
    return list.join("/");
}
function getDomainAttributeNamingConvention() {
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return application.getSettings(domainSettingsId)
        ?.getField("Attribute Naming Convention")?.value ?? "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.name === "PartitionKey";
}</script>
        </option>
      </scriptOptions>
      <typeOrder />
      <mappingSettings />
    </elementExtension>
  </elementExtensions>
  <associationSettings />
  <associationExtensions />
</settings>