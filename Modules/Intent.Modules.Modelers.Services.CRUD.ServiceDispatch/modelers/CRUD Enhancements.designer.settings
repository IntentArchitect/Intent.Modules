<?xml version="1.0" encoding="utf-8"?>
<settings version="3.1.1">
  <id>78de7c54-66ee-41af-a93a-007da1576209</id>
  <name>CRUD Enhancements</name>
  <designerReferences />
  <packageSettings />
  <packageExtensions>
    <packageExtension type="Services Package" typeId="df45eaf6-9202-4c25-8dd5-677e9ba1e906">
      <requiredPackages />
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Create CRUD Operations</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="FontAwesome" source="code" />
          <script>// This script in generalized so that it can be used as is for all the following contexts:
// - From a package (in which case it creates a service)
// - From a service (in which case it uses that service)
// - When the `Intent.Metadata.WebApi` designer extensions are installed (detected by the presence of the `Http Settings` stereotype on services)
// - When the `Intent.AzureFunctions` designer extensions are installed (detected by the presence of the `Azure Function` stereotype on services)

// Detect if we're running from the "Execution Script dialogue", in which case we want to manually
// set the element to something:
let defaultDomainClassName = null;
if (element?.id == null) {
    // For testing as if a package was right clicked, substitute with package id:
    // element = { id: "7339add6-c32e-4d95-8e1b-1bbe86ca7f1c" }; // Azure
    element = { id: "ef5c352b-fc74-4f13-b61b-a970f8360b08" }; // NestJS

    // For element, substitute with service's element id:
    // element = lookup("677c6801-e654-45c5-924e-886713db1f5e");

    // When set, the dialog asking to select the class from the domain is skipped:
    defaultDomainClassName = "NewClass";
}

async function showObject(object) {
    await dialogService.info(JSON.stringify(object, null, "  "));
}

const typeNameToIdMap = new Map();
typeNameToIdMap.set("guid", "6b649125-18ea-48fd-a6ba-0bfff0d8f488");
typeNameToIdMap.set("int", "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74");
typeNameToIdMap.set("long", "33013006-E404-48C2-AC46-24EF5A5774FD");
function getSurrogateKeyType() {
    let typeName = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")?.getField("Key Type")?.value ?? "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }

    return typeNameToIdMap.get("guid");
}

function isAggregateRoot(element) {
    return !element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
}

const userImmutableFieldNames = new Set(["created", "createdBy", "id", "updated", "updatedBy"]);
function isUserMutable(attributeName) {
    return !userImmutableFieldNames.has(attributeName.toLowerCase());
}

const stereotypeValues = [
    {
        stereotypeName: "Http Settings",
        propertiesByOperationName: {
            "Create": [
                { name: "Verb", resolveValue: () =&gt; "POST" },
                { name: "Route", resolveValue: () =&gt; "" }
            ],
            "FindById": [
                { name: "Verb", resolveValue: () =&gt; "GET" },
                { name: "Route", resolveValue: () =&gt; "{id}" }
            ],
            "FindAll": [
                { name: "Verb", resolveValue: () =&gt; "GET" },
                { name: "Route", resolveValue: () =&gt; "" }
            ],
            "Update": [
                { name: "Verb", resolveValue: () =&gt; "PUT" },
                { name: "Route", resolveValue: () =&gt; "{id}" }
            ],
            "Delete": [
                { name: "Verb", resolveValue: () =&gt; "DELETE" },
                { name: "Route", resolveValue: () =&gt; "{id}" }
            ]
        },
    },
    {
        stereotypeName: "Azure Function",
        propertiesByOperationName: {
            "Create": [
                { name: "Type", resolveValue: () =&gt; "Http Trigger" },
                { name: "Method", resolveValue: () =&gt; "POST" },
                { name: "Route", resolveValue: (entity) =&gt; `${entity.getName().toLowerCase()}` }
            ],
            "FindById": [
                { name: "Type", resolveValue: () =&gt; "Http Trigger" },
                { name: "Method", resolveValue: () =&gt; "GET" },
                { name: "Route", resolveValue: (entity) =&gt; `${entity.getName().toLowerCase()}/{id}` }
            ],
            "FindAll": [
                { name: "Type", resolveValue: () =&gt; "Http Trigger" },
                { name: "Method", resolveValue: () =&gt; "GET" },
                { name: "Route", resolveValue: (entity) =&gt; `${entity.getName().toLowerCase()}` }
            ],
            "Update": [
                { name: "Type", resolveValue: () =&gt; "Http Trigger" },
                { name: "Method", resolveValue: () =&gt; "PUT" },
                { name: "Route", resolveValue: (entity) =&gt; `${entity.getName().toLowerCase()}/{id}` }
            ],
            "Delete": [
                { name: "Type", resolveValue: () =&gt; "Http Trigger" },
                { name: "Method", resolveValue: () =&gt; "DELETE" },
                { name: "Route", resolveValue: (entity) =&gt; `${entity.getName().toLowerCase()}/{id}` }
            ]
        },
    }];
async function setOperationStereotype(operation, entity) {
    for (const stereotype of operation.getStereotypes()) {
        const values = stereotypeValues.find(x =&gt; x.stereotypeName === stereotype.name);
        if (values == null) {
            continue;
        }

        var properties = values.propertiesByOperationName[operation.getName()];
        if (properties == null) {
            continue;
        }

        for (const property of properties) {
            stereotype.getProperty(property.name).setValue(property.resolveValue(entity));
        }

        return;
    }

    await dialogService.error(`Could not determine Stereotype to update for operation "${operation.getName()}", please contact Intent Architect Support.`);
}

let classes = lookupTypesOf("Class").filter(x =&gt; isAggregateRoot(x) || x.hasStereotype("Repository"));
if (classes.length == 0) {
    await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
    return;
}

let classId = defaultDomainClassName != null
    ? classes.find(x =&gt; x.getName() === defaultDomainClassName)?.id
    : await dialogService.lookupFromOptions(classes);
if (classId == null) {
    await dialogService.error(`No class found with id "${classId}".`);
    return;
}

let entity = lookup(classId);

// Auto detect if we're running in the context of a service or package:
const service = element.specialization === "Service"
    ? element
    : createElement("Service", `${pluralize(toPascalCase(entity.name))}Service`, element.id);

// Get or create folder in which to place DTOs:
let folder = service.getParent().getChildren("Folder").find(x =&gt; x.name == pluralize(entity.name));
if (folder == null) {
    folder = createElement("Folder", pluralize(entity.name), service.getParent().id);
}

// Result DTO (used by "FindById" and "FindAll"):
const resultDto = createElement("DTO", `${entity.name}DTO`, folder.id);
resultDto.setMapping(entity.id);

// "Create" operation:
{
    const dto = createElement("DTO", `${entity.name}CreateDTO`, folder.id);
    for (let attribute of entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key"))) {
        let field = createElement("DTO-Field", attribute.name, dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
    }

    const operation = createElement("Operation", "Create", service.id);
    const operationParameter = createElement("Parameter", "dto", operation.id);
    operationParameter.typeReference.setType(dto.id);

    await setOperationStereotype(operation, entity);

    let pks = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    let pkTypeId;
    switch (true) {
        case pks.length == 0:
            pkTypeId = getSurrogateKeyType();
            operation.getStereotype("Http Settings").getProperty("Return Type Mediatype").setValue("application/json");
            break;
        case pks.length == 1:
            pkTypeId = pks[0].typeReference?.typeId ?? getSurrogateKeyType();
            operation.getStereotype("Http Settings").getProperty("Return Type Mediatype").setValue("application/json");
            break;
        case pks.length &gt; 1:
            pkTypeId = null;
            break;
    }
    operation.typeReference.setType(pkTypeId);

    operation.collapse();
}

// "FindById" operation:
{
    const operation = createElement("Operation", "FindById", service.id);

    operation.typeReference.setType(resultDto.id);
    if (entity.getChildren("Attribute").every(x =&gt; !x.hasStereotype("Primary Key"))) {
        const idField = createElement("DTO-Field", "Id", resultDto.id);
        idField.typeReference.setType(getSurrogateKeyType())

        const idParam = createElement("Parameter", "id", operation.id);
        idParam.typeReference.setType(getSurrogateKeyType());
    } else {
        for (let attribute of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))) {
            const field = createElement("DTO-Field", attribute.getName(), resultDto.id);
            field.typeReference.setType(attribute.typeReference.typeId)
            field.setMapping(attribute.id);

            const param = createElement("Parameter", toCamelCase(field.getName()), operation.id);
            param.typeReference.setType(attribute.typeReference.typeId);
        }
    }

    for (let attribute of entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key"))) {
        const field = createElement("DTO-Field", attribute.getName(), resultDto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
    }

    await setOperationStereotype(operation, entity);

    operation.collapse();
}

// "FindAll" operation:
{
    const operation = createElement("Operation", "FindAll", service.id);
    operation.typeReference.setType(resultDto.id);
    operation.typeReference.setIsCollection(true);

    await setOperationStereotype(operation, entity);

    operation.collapse();
}

// "Update" operation:
{
    const operation = createElement("Operation", "Update", service.id);
    const updateDTO = createElement("DTO", `${entity.name}UpdateDTO`, folder.id);

    if (entity.getChildren("Attribute").every(x =&gt; !x.hasStereotype("Primary Key"))) {
        let idParam = createElement("Parameter", "id", operation.id);
        idParam.typeReference.setType(getSurrogateKeyType());
    } else {
        for (let attribute of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))) {
            let field = createElement("DTO-Field", attribute.getName(), updateDTO.id);
            field.typeReference.setType(attribute.typeReference.typeId)

            let param = createElement("Parameter", toCamelCase(field.getName()), operation.id);
            param.typeReference.setType(attribute.typeReference.typeId);
        }
    }

    const updateOperationDtoParam = createElement("Parameter", "dto", operation.id);
    updateOperationDtoParam.typeReference.setType(updateDTO.id);

    for (let attribute of entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key"))) {
        const field = createElement("DTO-Field", attribute.getName(), updateDTO.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
    }

    await setOperationStereotype(operation, entity);

    operation.collapse();
}

// "Delete" operation:
{
    const operation = createElement("Operation", "Delete", service.id);

    if (entity.getChildren("Attribute").every(x =&gt; !x.hasStereotype("Primary Key"))) {
        const idParam = createElement("Parameter", "id", operation.id);
        idParam.typeReference.setType(getSurrogateKeyType());
    } else {
        for (let attribute of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))) {
            const param = createElement("Parameter", toCamelCase(attribute.getName()), operation.id);
            param.typeReference.setType(attribute.typeReference.typeId);
        }
    }

    await setOperationStereotype(operation, entity);

    operation.collapse();
}
</script>
        </option>
      </scriptOptions>
      <typeOrder />
    </packageExtension>
  </packageExtensions>
  <elementSettings />
  <elementExtensions>
    <elementExtension type="Service" typeId="b16578a5-27b1-4047-a8df-f0b783d706bd">
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Create CRUD Operations</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="FontAwesome" source="code" />
          <script>// This script in generalized so that it can be used as is for all the following contexts:
// - From a package (in which case it creates a service)
// - From a service (in which case it uses that service)
// - When the `Intent.Metadata.WebApi` designer extensions are installed (detected by the presence of the `Http Settings` stereotype on services)
// - When the `Intent.AzureFunctions` designer extensions are installed (detected by the presence of the `Azure Function` stereotype on services)

// Detect if we're running from the "Execution Script dialogue", in which case we want to manually
// set the element to something:
let defaultDomainClassName = null;
if (element?.id == null) {
    // For testing as if a package was right clicked, substitute with package id:
    // element = { id: "7339add6-c32e-4d95-8e1b-1bbe86ca7f1c" }; // Azure
    element = { id: "ef5c352b-fc74-4f13-b61b-a970f8360b08" }; // NestJS

    // For element, substitute with service's element id:
    // element = lookup("677c6801-e654-45c5-924e-886713db1f5e");

    // When set, the dialog asking to select the class from the domain is skipped:
    defaultDomainClassName = "NewClass";
}

async function showObject(object) {
    await dialogService.info(JSON.stringify(object, null, "  "));
}

const typeNameToIdMap = new Map();
typeNameToIdMap.set("guid", "6b649125-18ea-48fd-a6ba-0bfff0d8f488");
typeNameToIdMap.set("int", "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74");
typeNameToIdMap.set("long", "33013006-E404-48C2-AC46-24EF5A5774FD");
function getSurrogateKeyType() {
    let typeName = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")?.getField("Key Type")?.value ?? "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }

    return typeNameToIdMap.get("guid");
}

function isAggregateRoot(element) {
    return !element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
}

const userImmutableFieldNames = new Set(["created", "createdBy", "id", "updated", "updatedBy"]);
function isUserMutable(attributeName) {
    return !userImmutableFieldNames.has(attributeName.toLowerCase());
}

const stereotypeValues = [
    {
        stereotypeName: "Http Settings",
        propertiesByOperationName: {
            "Create": [
                { name: "Verb", resolveValue: () =&gt; "POST" },
                { name: "Route", resolveValue: () =&gt; "" }
            ],
            "FindById": [
                { name: "Verb", resolveValue: () =&gt; "GET" },
                { name: "Route", resolveValue: () =&gt; "{id}" }
            ],
            "FindAll": [
                { name: "Verb", resolveValue: () =&gt; "GET" },
                { name: "Route", resolveValue: () =&gt; "" }
            ],
            "Update": [
                { name: "Verb", resolveValue: () =&gt; "PUT" },
                { name: "Route", resolveValue: () =&gt; "{id}" }
            ],
            "Delete": [
                { name: "Verb", resolveValue: () =&gt; "DELETE" },
                { name: "Route", resolveValue: () =&gt; "{id}" }
            ]
        },
    },
    {
        stereotypeName: "Azure Function",
        propertiesByOperationName: {
            "Create": [
                { name: "Type", resolveValue: () =&gt; "Http Trigger" },
                { name: "Method", resolveValue: () =&gt; "POST" },
                { name: "Route", resolveValue: (entity) =&gt; `${entity.getName().toLowerCase()}` }
            ],
            "FindById": [
                { name: "Type", resolveValue: () =&gt; "Http Trigger" },
                { name: "Method", resolveValue: () =&gt; "GET" },
                { name: "Route", resolveValue: (entity) =&gt; `${entity.getName().toLowerCase()}/{id}` }
            ],
            "FindAll": [
                { name: "Type", resolveValue: () =&gt; "Http Trigger" },
                { name: "Method", resolveValue: () =&gt; "GET" },
                { name: "Route", resolveValue: (entity) =&gt; `${entity.getName().toLowerCase()}` }
            ],
            "Update": [
                { name: "Type", resolveValue: () =&gt; "Http Trigger" },
                { name: "Method", resolveValue: () =&gt; "PUT" },
                { name: "Route", resolveValue: (entity) =&gt; `${entity.getName().toLowerCase()}/{id}` }
            ],
            "Delete": [
                { name: "Type", resolveValue: () =&gt; "Http Trigger" },
                { name: "Method", resolveValue: () =&gt; "DELETE" },
                { name: "Route", resolveValue: (entity) =&gt; `${entity.getName().toLowerCase()}/{id}` }
            ]
        },
    }];
async function setOperationStereotype(operation, entity) {
    for (const stereotype of operation.getStereotypes()) {
        const values = stereotypeValues.find(x =&gt; x.stereotypeName === stereotype.name);
        if (values == null) {
            continue;
        }

        var properties = values.propertiesByOperationName[operation.getName()];
        if (properties == null) {
            continue;
        }

        for (const property of properties) {
            stereotype.getProperty(property.name).setValue(property.resolveValue(entity));
        }

        return;
    }

    await dialogService.error(`Could not determine Stereotype to update for operation "${operation.getName()}", please contact Intent Architect Support.`);
}

let classes = lookupTypesOf("Class").filter(x =&gt; isAggregateRoot(x) || x.hasStereotype("Repository"));
if (classes.length == 0) {
    await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
    return;
}

let classId = defaultDomainClassName != null
    ? classes.find(x =&gt; x.getName() === defaultDomainClassName)?.id
    : await dialogService.lookupFromOptions(classes);
if (classId == null) {
    await dialogService.error(`No class found with id "${classId}".`);
    return;
}

let entity = lookup(classId);

// Auto detect if we're running in the context of a service or package:
const service = element.specialization === "Service"
    ? element
    : createElement("Service", `${pluralize(toPascalCase(entity.name))}Service`, element.id);

// Get or create folder in which to place DTOs:
let folder = service.getParent().getChildren("Folder").find(x =&gt; x.name == pluralize(entity.name));
if (folder == null) {
    folder = createElement("Folder", pluralize(entity.name), service.getParent().id);
}

// Result DTO (used by "FindById" and "FindAll"):
const resultDto = createElement("DTO", `${entity.name}DTO`, folder.id);
resultDto.setMapping(entity.id);

// "Create" operation:
{
    const dto = createElement("DTO", `${entity.name}CreateDTO`, folder.id);
    for (let attribute of entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key"))) {
        let field = createElement("DTO-Field", attribute.name, dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
    }

    const operation = createElement("Operation", "Create", service.id);
    const operationParameter = createElement("Parameter", "dto", operation.id);
    operationParameter.typeReference.setType(dto.id);

    await setOperationStereotype(operation, entity);

    let pks = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    let pkTypeId;
    switch (true) {
        case pks.length == 0:
            pkTypeId = getSurrogateKeyType();
            operation.getStereotype("Http Settings").getProperty("Return Type Mediatype").setValue("application/json");
            break;
        case pks.length == 1:
            pkTypeId = pks[0].typeReference?.typeId ?? getSurrogateKeyType();
            operation.getStereotype("Http Settings").getProperty("Return Type Mediatype").setValue("application/json");
            break;
        case pks.length &gt; 1:
            pkTypeId = null;
            break;
    }
    operation.typeReference.setType(pkTypeId);

    operation.collapse();
}

// "FindById" operation:
{
    const operation = createElement("Operation", "FindById", service.id);

    operation.typeReference.setType(resultDto.id);
    if (entity.getChildren("Attribute").every(x =&gt; !x.hasStereotype("Primary Key"))) {
        const idField = createElement("DTO-Field", "Id", resultDto.id);
        idField.typeReference.setType(getSurrogateKeyType())

        const idParam = createElement("Parameter", "id", operation.id);
        idParam.typeReference.setType(getSurrogateKeyType());
    } else {
        for (let attribute of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))) {
            const field = createElement("DTO-Field", attribute.getName(), resultDto.id);
            field.typeReference.setType(attribute.typeReference.typeId)
            field.setMapping(attribute.id);

            const param = createElement("Parameter", toCamelCase(field.getName()), operation.id);
            param.typeReference.setType(attribute.typeReference.typeId);
        }
    }

    for (let attribute of entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key"))) {
        const field = createElement("DTO-Field", attribute.getName(), resultDto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
    }

    await setOperationStereotype(operation, entity);

    operation.collapse();
}

// "FindAll" operation:
{
    const operation = createElement("Operation", "FindAll", service.id);
    operation.typeReference.setType(resultDto.id);
    operation.typeReference.setIsCollection(true);

    await setOperationStereotype(operation, entity);

    operation.collapse();
}

// "Update" operation:
{
    const operation = createElement("Operation", "Update", service.id);
    const updateDTO = createElement("DTO", `${entity.name}UpdateDTO`, folder.id);

    if (entity.getChildren("Attribute").every(x =&gt; !x.hasStereotype("Primary Key"))) {
        let idParam = createElement("Parameter", "id", operation.id);
        idParam.typeReference.setType(getSurrogateKeyType());
    } else {
        for (let attribute of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))) {
            let field = createElement("DTO-Field", attribute.getName(), updateDTO.id);
            field.typeReference.setType(attribute.typeReference.typeId)

            let param = createElement("Parameter", toCamelCase(field.getName()), operation.id);
            param.typeReference.setType(attribute.typeReference.typeId);
        }
    }

    const updateOperationDtoParam = createElement("Parameter", "dto", operation.id);
    updateOperationDtoParam.typeReference.setType(updateDTO.id);

    for (let attribute of entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key"))) {
        const field = createElement("DTO-Field", attribute.getName(), updateDTO.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
    }

    await setOperationStereotype(operation, entity);

    operation.collapse();
}

// "Delete" operation:
{
    const operation = createElement("Operation", "Delete", service.id);

    if (entity.getChildren("Attribute").every(x =&gt; !x.hasStereotype("Primary Key"))) {
        const idParam = createElement("Parameter", "id", operation.id);
        idParam.typeReference.setType(getSurrogateKeyType());
    } else {
        for (let attribute of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))) {
            const param = createElement("Parameter", toCamelCase(attribute.getName()), operation.id);
            param.typeReference.setType(attribute.typeReference.typeId);
        }
    }

    await setOperationStereotype(operation, entity);

    operation.collapse();
}
</script>
        </option>
      </scriptOptions>
      <typeOrder />
      <mappingSettings />
    </elementExtension>
  </elementExtensions>
  <associationSettings />
  <associationExtensions />
</settings>