<#@ template  debug="true"  inherits="CSharpTemplateBase<ServiceModel>" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ import namespace="Intent.Modules.Common.Templates" #>
<#@ import namespace="Intent.Modules.Common.CSharp.Templates" #>
<#@ import namespace="Intent.Modelers.Services.Api" #>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Unity;
<#=DependencyUsings#>

[assembly: DefaultIntentManaged(Mode.Fully)]

namespace <#= Namespace #>
{
    public class <#= ClassName #> : IInvokable
    {
        private readonly I<#=Model.Name#> _appService;
        private readonly JsonSerializerSettings _jsonSerializerSettings;

        public <#= ClassName #>()
        {
            _appService = UnityConfig.GetConfiguredContainer().Resolve<I<#=Model.Name#>>();
            _jsonSerializerSettings = new JsonSerializerSettings
            {
                ContractResolver = new CamelCasePropertyNamesContractResolver()
            };
        }

        public async Task<object> Invoke(dynamic input)
        {
            return await Task.Factory.StartNew<object>(() =>
            {
                try
                {
                    var methodName = (string)input.methodName;
                    var methodParameters = ((object[]) input.methodParameters).Select(x => (string) x).ToArray();
                    AsyncAwaitOperationContext.SetHeaders(((IEnumerable<dynamic>)input.headers).ToDictionary(x => (string)x.name, x => (string)x.value));

                    switch (methodName)
                    {
<#
                        // An exception gets thrown if "null" is returned, so we always wrap everthing up in an object and 
                        // then on the receiving side we always read the "response" property as necessary. 
                        foreach(var operation in Model.Operations)
                        {
#>
                        case nameof(<#= operation.Name #>):
                            return JsonConvert.SerializeObject(new
                            {
                                Response = <#= operation.Name #>(methodParameters)
                            }, _jsonSerializerSettings);
<#
                        } // foreach(var operation in Model.Operations)
#>
                        default:
                            throw new Exception($"Unknown method: {methodName}");
                    }
                }
                catch (Exception e)
                {<# 
                    // Sometimes there is a StackOverflow exception when we try to send 
                    // some exceptions back to the client, so we just wrap all exceptions
                    // just in case.

                    // For example, new System.IO.FileSystemWatcher("invalid path", filterCriteria);
                #>
                    throw new SerializableException(e);
                }
            }, TaskCreationOptions.LongRunning);
        }
<#
        foreach(var operation in Model.Operations)
        {
#>

        private object <#= operation.Name #>(string[] methodParameters)
        {
<#
            if (operation.ReturnType != null)
            {
#>
            return _appService.<#= operation.Name#>(<#= GetOperationCallParameters(operation) #>);
<#
            }
            else
            {
#>
            _appService.<#= operation.Name#>(<#= GetOperationCallParameters(operation) #>);
            return null;
<#
            }
#>
        }
<#
        }
#>

        private T Deserialize<T>(string serializedString)
        {
            return serializedString != null
                ? JsonConvert.DeserializeObject<T>(serializedString)
                : default(T);
        }
    }
}