<#@ template  debug="true"  inherits="CSharpTemplateBase<ServiceModel>" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ Assembly Name="Intent.SoftwareFactory" #>
<#@ import namespace="Intent.Modules.Common.Templates" #>
<#@ import namespace="Intent.Modules.Common.CSharp.Templates" #>
<#@ import namespace="Intent.Modules.Application.Contracts" #> 
<#@ import namespace="Intent.Modelers.Services.Api" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using System.Transactions;
using Intent.RoslynWeaver.Attributes;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
<#=DependencyUsings#>

[assembly: DefaultIntentManaged(Mode.Fully)]

namespace <#=Namespace#>
{
    [Route("<#= GetRoute() #>")]
    public class <#= ClassName #> : Controller
    {
        private readonly <#= GetServiceInterfaceName() #> _appService;<#= DeclarePrivateVariables() #>

        public <#= ClassName #> (<#= GetServiceInterfaceName() #> appService<#= ConstructorParams() #>
            )
        {
             _appService = appService ?? throw new ArgumentNullException(nameof(appService));<#= ConstructorInit() #>
        } 
    
<#  foreach (var operation in Model.Operations)
    {#>
        [Http<#= GetHttpVerb(operation).ToString().ToLower().ToPascalCase() #>("<#= GetPath(operation) #>")]
        <#= GetSecurityAttribute(operation) #>
        [ProducesResponseType(<#= operation.ReturnType != null ? string.Format("typeof({0}), ", GetOperationReturnType(operation)) : "" #>(int)HttpStatusCode.OK)]
        public <#= operation.IsAsync() ? "async Task<IActionResult>" : "IActionResult" #> <#= operation.Name #>(<#= GetOperationParameters(operation) #>)
        {<#= BeginOperation(operation) #>
<#      if (operation.ReturnType != null)
        {
#>            <#= GetOperationReturnType(operation) #> result = default(<#= GetOperationReturnType(operation) #>);
<#      }#>
            var tso = new TransactionOptions { IsolationLevel = IsolationLevel.ReadCommitted };

            try
            {<#= BeforeTransaction(operation) #>
                using (TransactionScope ts = new TransactionScope(TransactionScopeOption.Required, tso<#= operation.IsAsync() ? ", TransactionScopeAsyncFlowOption.Enabled" : "" #>))
                {<#= BeforeCallToAppLayer(operation) #>
<#      if (operation.ReturnType != null) {#>
                    var appServiceResult = <#= operation.IsAsync() ? "await " : "" #>_appService.<#= operation.Name#>(<#= GetOperationCallParameters(operation) #>);
                    result = appServiceResult;
<#      } else { #>
                    <#= operation.IsAsync() ? "await " : "" #>_appService.<#= operation.Name#>(<#= GetOperationCallParameters(operation) #>);
<#      } #><#= AfterCallToAppLayer(operation) #>
                    ts.Complete();
                }<#= AfterTransaction(operation) #>
            }
            catch (Exception e)
            {<#= OnExceptionCaught(operation) #>
            }

<#      if (operation.ReturnType != null)
        {#>
            return Ok(result);
<#      } else {#>
            return Ok();
<#      }#>

        }

<#    }

        // Source code of base class: http://aspnetwebstack.codeplex.com/SourceControl/latest#src/System.Web.Http/ApiController.cs
        // As dispose is not virtual, looking at the source code, this looks like a better hook in point
#>
        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            //dispose all resources
            _appService.Dispose();<#=OnDispose()#>
        }
<#=ClassMethods()#>
    }
}