<?xml version="1.0" encoding="utf-8"?>
<settings version="3.1.1">
  <id>03bfccb7-d845-411f-ba08-4fddb01bbbda</id>
  <name>WebApi CQRS Extensions</name>
  <designerReferences />
  <packageSettings />
  <packageExtensions />
  <elementSettings />
  <elementExtensions>
    <elementExtension type="Command" typeId="ccf14eb6-3a55-4d81-b5b9-d27311c70cb9">
      <validateFunctionOverride>/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function validateRestRoutes(element) {
    let routeToValidate = RestRoute.create(element);
    if (!routeToValidate) {
        return "";
    }
    let routesToCompareAgainst = lookupTypesOf("Command", false)
        .concat(lookupTypesOf("Query", false))
        .concat(lookupTypesOf("Operation", false))
        .map(x =&gt; RestRoute.create(x))
        .filter(x =&gt; x != null);
    let message = __findOneDuplicate(routeToValidate, routesToCompareAgainst);
    if (message &amp;&amp; message != "") {
        return message;
    }
    message = __findMissingParameters(routeToValidate);
    if (message &amp;&amp; message != "") {
        return message;
    }
    return "";
}
function __findOneDuplicate(routeToValidate, routesToCompareAgainst) {
    for (let possibleDuplicate of routesToCompareAgainst) {
        // Make sure we're not checking the same route with itself.
        if (routeToValidate.underlyingElement.id == possibleDuplicate.underlyingElement.id) {
            continue;
        }
        if (possibleDuplicate.isDuplicate(routeToValidate)) {
            return `Duplicate rest route ${routeToValidate.underlyingElement.getName()}(${routeToValidate.underlyingElement.specialization}) with ${possibleDuplicate.underlyingElement.getName()}(${possibleDuplicate.underlyingElement.specialization}) - ${possibleDuplicate.originalRoute}`;
        }
    }
    return "";
}
function __findMissingParameters(routeToValidate) {
    let element = routeToValidate.underlyingElement;
    let elementType = element.specialization;
    let elementChildren;
    if (elementType === "Command" || elementType === "Query") {
        elementChildren = element.getChildren("DTO-Field");
    }
    else if (elementType === "Operation") {
        elementChildren = element.getChildren("Parameter");
    }
    else {
        return "";
    }
    let missingParameters = [];
    for (let routeParam of routeToValidate.routeParams) {
        let routeParamName = routeParam.toLowerCase();
        if (!elementChildren.some(e =&gt; e.getName().toLowerCase() === routeParamName)) {
            missingParameters.push(routeParam);
        }
    }
    if (missingParameters.length === 0) {
        return "";
    }
    return `Route mismatch: some route parameters do not match element's properties/parameters. Unmatched parameters: ${missingParameters.join(", ")}`;
}
class RestVersionSet {
    constructor(isVersioned, versionIds) {
        this.isVersioned = isVersioned;
        this.versionHashTable = {};
        for (let v of versionIds) {
            this.versionHashTable[v] = v;
        }
    }
    matches(versionSet) {
        // Only engage with versioning checks if both REST routes are versioned
        return !this.isVersioned || !versionSet.isVersioned || this.intersects(versionSet);
    }
    intersects(versionSet) {
        for (let v in this.versionHashTable) {
            if (versionSet.versionHashTable[v]) {
                return true;
            }
        }
        return false;
    }
    static create(element) {
        const apiVersionSettingId = "20855f03-c663-4ec6-b106-de06be98f1fe";
        let versionSetting = element.getStereotype(apiVersionSettingId);
        if (!versionSetting) {
            return new RestVersionSet(false, []);
        }
        let versionIds = JSON.parse(versionSetting.getProperty("Applicable Versions").value);
        return new RestVersionSet(true, versionIds !== null &amp;&amp; versionIds !== void 0 ? versionIds : []);
    }
}
class RestRoute {
    constructor(verb, originalRoute, underlyingElement) {
        this.verb = verb;
        this.originalRoute = originalRoute;
        this.underlyingElement = underlyingElement;
        this.routeParams = [];
        this.versionSet = RestVersionSet.create(underlyingElement);
        let counter = 0;
        let localRouteParams = this.routeParams;
        let actionName = underlyingElement.getName();
        this.hashedRoute = originalRoute
            .replace(/\{([^}]*)\}/g, function (match, g1) {
            if (g1 !== "version") {
                localRouteParams.push(g1);
            }
            return (counter++).toString();
        })
            .replace(/(\[action\])/g, actionName);
    }
    isDuplicate(possibleDuplicateRoute) {
        return this.hashedRoute === possibleDuplicateRoute.hashedRoute &amp;&amp;
            this.verb === possibleDuplicateRoute.verb &amp;&amp;
            this.versionSet.matches(possibleDuplicateRoute.versionSet);
    }
    static create(element) {
        if (!element) {
            return null;
        }
        const httpSettingsId = "b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6";
        let httpSettings = element.getStereotype(httpSettingsId);
        if (!httpSettings) {
            return null;
        }
        let absoluteRouteToCheck = getAbsoluteRoute(element, httpSettings);
        if (!absoluteRouteToCheck) {
            return null;
        }
        let verbToCheck = httpSettings.getProperty("Verb").value;
        return new RestRoute(verbToCheck, absoluteRouteToCheck, element);
        function getAbsoluteRoute(element, httpSettings) {
            var _a;
            if (element.specialization == "Operation") {
                const serviceHttpServiceSettingsId = "c29224ec-d473-4b95-ad4a-ec55c676c4fd";
                let serviceElement = element.getParent();
                if (!serviceElement) {
                    return null;
                }
                let operationPath = httpSettings.getProperty("Route").value;
                let servicePath = (_a = serviceElement.getStereotype(serviceHttpServiceSettingsId)) === null || _a === void 0 ? void 0 : _a.getProperty("Route").value;
                if (servicePath &amp;&amp; servicePath != "") {
                    if (servicePath.toLocaleLowerCase().includes('[controller]')) {
                        servicePath = servicePath.replace(/\[controller\]/gi, `[${serviceElement.getName()}]`);
                    }
                    return `${servicePath}/${operationPath}`;
                }
                //We don't know how the service name will be transformed so we add [{ServiceName}] to represent the transform
                return `[${serviceElement.getName()}]/${operationPath}`;
            }
            return httpSettings.getProperty("Route").value;
        }
    }
}
/// &lt;reference path="../_common/common-rest-route-validation.ts" /&gt;
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.WebApi
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/services-rest-route-validation/command/command-rest-route-validation.ts
 */
//Comment / UnComment below when you publish
return validateRestRoutes(lookup(id));
</validateFunctionOverride>
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Expose as Http Endpoint</text>
          <shortcut>ctrl + shift + e</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
;
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
/// &lt;reference path="domainHelper.ts" /&gt;
class EntityDomainElementDetails {
    constructor(entity) {
        this.entity = entity;
        this.owningEntity = DomainHelper.getOwningAggregate(entity);
    }
    getOwningOrTargetEntityName() {
        var _a;
        return ((_a = this.owningEntity) !== null &amp;&amp; _a !== void 0 ? _a : this.entity).getName();
    }
    hasOwningEntity() {
        return this.owningEntity != null;
    }
}
class MappedDomainElement {
    constructor(originalElement) {
        this.originalElement = originalElement;
        this.entityDomainElementDetails = this.isEntityDomainElement() ? new EntityDomainElementDetails(originalElement) : null;
    }
    isEntityDomainElement() {
        return this.originalElement.specialization == "Class";
    }
    getId() {
        return this.originalElement.id;
    }
    getName() {
        return this.originalElement.getName();
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/mappedDomainElement.ts" /&gt;
function getFolderParts(request, domainElement) {
    var _a;
    let depth = 0;
    let currentElement = request.getParent();
    let folderParts = [];
    while (currentElement.specialization === "Folder") {
        let folderName = currentElement.getName();
        if (depth === 0 &amp;&amp; domainElement != null) {
            const singularizedFolderName = singularize(folderName);
            const singularizedAggregateRootName = singularize((_a = domainElement.entityDomainElementDetails) === null || _a === void 0 ? void 0 : _a.getOwningOrTargetEntityName());
            if (singularizedFolderName.toLowerCase() === singularizedAggregateRootName.toLowerCase()) {
                folderName = pluralize(singularizedFolderName);
            }
        }
        folderParts.unshift(toKebabCase(folderName));
        currentElement = currentElement.getParent();
        depth++;
    }
    return folderParts;
}
/// &lt;reference path="attributeWithMapPath.ts" /&gt;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
ServicesConstants.dtoToDomainOperation = "8d1f6a8a-77c8-43a2-8e60-421559725419";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
/**
 * Workaround for element's from referenced packages not having getParent()
 * @param element The element whose parent should be searched for
 * @param parentSpecializationType The specialization type of the parent
 */
function getParent(element, parentSpecializationType) {
    const elements = lookupTypesOf(parentSpecializationType);
    const parent = elements
        .find(x =&gt; x.getChildren(element.specialization)
        .some(child =&gt; child.id === element.id));
    if (parent == null) {
        throw new Error("Could not find parent");
    }
    return parent;
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
/// &lt;reference path="../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/getParent.ts" /&gt;
/**
 * Gets select details of a mapped Command/Query. Intended for centralized logic of working out
 * things like keys for both the entity and owning entity if applicable.
 *
 * If the Command is for entity creation (either due to being mapped to a constructor or being
 * prefixed with "Create"), then primary keys for the entity are not populated.
 * @param request The Command or Query that has been mapped
 */
function getMappedRequestDetails(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    // Advanced mapping:
    if (mappedElement == null) {
        const advancedMappings = request.getAssociations()
            .filter(x =&gt; x.hasMappings(queryEntityMappingTypeId) ||
            x.hasMappings(createEntityMappingTypeId))
            .map(x =&gt; x.getMapping(queryEntityMappingTypeId) ||
            x.getMapping(createEntityMappingTypeId));
        if (advancedMappings.length === 1) {
            mappedElement = advancedMappings[0].getTargetElement();
        }
    }
    if (mappedElement == null) {
        return null;
    }
    let entity = mappedElement;
    if (entity.specialization !== "Class") {
        entity = getParent(entity, "Class");
    }
    const result = {
        entity: entity,
        mappingTargetType: mappedElement.specialization,
        entityKeyFields: [],
        ownerKeyFields: []
    };
    result.owningEntity = DomainHelper.getOwningAggregate(entity);
    // As long as it's not for creation, populate the PKs of the entity:
    if (result.mappingTargetType !== "Class Constructor" &amp;&amp;
        !request.getName().toLowerCase().startsWith("Create")) {
        result.entityKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity)
            : getKeysForOperationMapping(request, entity);
    }
    // If the entity is owned, populate its fields:
    if (result.owningEntity != null) {
        result.ownerKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity, result.owningEntity)
            : getKeysForOperationMapping(request, entity, result.owningEntity);
    }
    return result;
    /**
     * Return field details for primary keys. As requests mapped to operations and constructors can
     * never possibly map the attributes, these fields can only ever be matched by name.
     * @param request The CQRS Command or Query entity
     * @param owningEntity The Owning Aggregate Class
     */
    function getKeysForOperationMapping(request, entity, owningEntity) {
        const pks = DomainHelper.getPrimaryKeys(owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity);
        return pks.map(pk =&gt; {
            let fieldName = toPascalCase(pk.name);
            if (owningEntity != null) {
                fieldName = removePrefix(fieldName, toPascalCase(owningEntity.getName()));
                fieldName = `${owningEntity.getName()}${toCamelCase(fieldName)}`;
            }
            fieldName = ServicesHelper.getFieldFormat(fieldName);
            const existingField = request.getChildren("DTO-Field").find(field =&gt; field.getName().toLowerCase() == fieldName.toLowerCase());
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: [],
                name: fieldName,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
    function getKeysForClassMapping(request, entity, owningEntity) {
        const keys = owningEntity != null
            ? DomainHelper.getForeignKeys(entity, owningEntity)
            : DomainHelper.getPrimaryKeys(entity);
        return keys.map(pk =&gt; {
            const existingField = request.getChildren("DTO-Field").find(field =&gt; {
                if (field.getMapping() != null) {
                    return field.getMapping().getPath().some(x =&gt; x.id == pk.id);
                }
                return (pk.name.toLowerCase() === field.getName().toLowerCase());
            });
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: pk.mapPath,
                name: pk.name,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
function getRouteParts(request, domainElement) {
    if (domainElement == null) {
        throw new Error("entity is required");
    }
    let routeParts;
    routeParts = updateRoutePathsFromBasicMapping(request, domainElement);
    if (routeParts.length &gt; 0) {
        return routeParts;
    }
    routeParts = updateRoutePathsFromAdvancedMapping(request, domainElement);
    if (routeParts.length &gt; 0) {
        return routeParts;
    }
    return [];
}
function updateRoutePathsFromBasicMapping(request, domainElement) {
    var _a, _b;
    let routeParts = [];
    const mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    if (mappedElement != null) {
        const mappedDetails = getMappedRequestDetails(request);
        // Add the owning entity's ids as parts surrounded with curly braces
        if (((_b = domainElement.entityDomainElementDetails) === null || _b === void 0 ? void 0 : _b.hasOwningEntity()) == true) {
            routeParts.push(...mappedDetails.ownerKeyFields
                .filter(x =&gt; x.existingId != null)
                .map(x =&gt; {
                const field = request
                    .getChildren("DTO-Field")
                    .find(field =&gt; field.id === x.existingId);
                return `{${toCamelCase(field.getName())}}`;
            }));
            // Add a part for name of the owned entity
            routeParts.push(toKebabCase(singularize(domainElement.getName())));
        }
        // Add the entity's ids as parts surrounded with curly braces
        routeParts.push(...mappedDetails.entityKeyFields
            .filter(x =&gt; x.existingId != null)
            .map(x =&gt; {
            const field = request
                .getChildren("DTO-Field")
                .find(field =&gt; field.id === x.existingId);
            return `{${toCamelCase(field.getName())}}`;
        }));
        // Add the operation's name:
        if (mappedDetails.mappingTargetType === "Operation") {
            const entityName = domainElement.getName();
            let routePart = removePrefix(mappedElement.getName(), "Create", "Update", "Delete", "Add", "Remove");
            routePart = removeSuffix(routePart, "Request", "Query", "Command");
            routeParts.push(removePrefix(toKebabCase(routePart), toKebabCase(singularize(entityName)), toKebabCase(entityName), "-"));
        }
    }
    return routeParts;
}
function updateRoutePathsFromAdvancedMapping(request, domainElement) {
    var _a, _b, _c;
    let routeParts = [];
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    const updateEntityMappingTypeId = "01721b1a-a85d-4320-a5cd-8bd39247196a";
    const mappingTypeIds = [queryEntityMappingTypeId, createEntityMappingTypeId, updateEntityMappingTypeId];
    const associationWithMapping = request
        .getAssociations()
        .find(association =&gt; association.hasMappings() &amp;&amp; association
        .getMappings()
        .every(mapping =&gt; {
        if (!mappingTypeIds.includes(mapping.mappingTypeId)) {
            return false;
        }
        let element = mapping.getTargetElement();
        while (element != null) {
            if (element.specialization === "Class") {
                break;
            }
            element = getParent(element, "Class");
        }
        if (element == null) {
            return false;
        }
        return element.id === domainElement.getId();
    }));
    if (associationWithMapping != null) {
        const mappings = associationWithMapping.getMappings();
        const queryMapping = mappings.find(x =&gt; x.mappingTypeId === queryEntityMappingTypeId);
        const createMapping = mappings.find(x =&gt; x.mappingTypeId === createEntityMappingTypeId);
        const updateMapping = mappings.find(x =&gt; x.mappingTypeId === updateEntityMappingTypeId);
        // Add the owning entity's ids as parts surrounded with curly braces
        if (((_a = domainElement.entityDomainElementDetails) === null || _a === void 0 ? void 0 : _a.hasOwningEntity()) == true) {
            if (queryMapping != null) {
                let applicableClassIds = getEntityInheritanceHierarchyIds((_b = domainElement === null || domainElement === void 0 ? void 0 : domainElement.entityDomainElementDetails) === null || _b === void 0 ? void 0 : _b.owningEntity);
                routeParts.push(...queryMapping.getMappedEnds()
                    .filter(end =&gt; applicableClassIds.some(x =&gt; x === getParent(end.getTargetElement(), "Class").id))
                    .map(x =&gt; `{${toCamelCase(x.getSourceElement().getName())}}`));
            }
            // Add a part for name of the owned entity
            routeParts.push(toKebabCase(singularize(domainElement.getName())));
        }
        // Add the entity's ids as parts surrounded with curly braces
        if (queryMapping != null) {
            let applicableClassIds = getEntityInheritanceHierarchyIds((_c = domainElement === null || domainElement === void 0 ? void 0 : domainElement.entityDomainElementDetails) === null || _c === void 0 ? void 0 : _c.entity);
            routeParts.push(...queryMapping.getMappedEnds()
                .filter(end =&gt; applicableClassIds.some(x =&gt; x === getParent(end.getTargetElement(), "Class").id))
                .map(x =&gt; `{${toCamelCase(x.getSourceElement().getName())}}`));
        }
        // Add the operation's name:
        const mapping = createMapping !== null &amp;&amp; createMapping !== void 0 ? createMapping : updateMapping;
        if (mapping == null) {
            return routeParts;
        }
        var mappingEnd = mapping.getMappedEnds().find(x =&gt; x.getSourceElement().id === request.id);
        if (mappingEnd == null) {
            return routeParts;
        }
        const mappedElement = mappingEnd.getTargetElement();
        if ((mappedElement === null || mappedElement === void 0 ? void 0 : mappedElement.specialization) === "Operation") {
            const entityName = domainElement.getName();
            let routePart = removePrefix(mappedElement.getName(), "Create", "Update", "Delete", "Add", "Remove");
            routePart = removeSuffix(routePart, "Request", "Query", "Command");
            routeParts.push(removePrefix(toKebabCase(routePart), toKebabCase(singularize(entityName)), toKebabCase(entityName), "-"));
        }
        return routeParts;
    }
    return routeParts;
}
function getEntityInheritanceHierarchyIds(curEntity) {
    let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
    if (generalizations.length == 0) {
        return [curEntity.id];
    }
    let other = getEntityInheritanceHierarchyIds(generalizations[0].typeReference.getType());
    return other.concat(curEntity.id);
}
function getDefaultRoutePrefix(includeLastPathSeparator) {
    const defaultApiRoutePrefix = "api";
    const apiSettingsId = "4bd0b4e9-7b53-42a9-bb4a-277abb92a0eb";
    let settingsGroup = application.getSettings(apiSettingsId);
    let route = settingsGroup ? settingsGroup.getField("Default API Route Prefix").value : null;
    if (!route) {
        route = defaultApiRoutePrefix;
    }
    if (includeLastPathSeparator &amp;&amp; !route.endsWith("/")) {
        route += "/";
    }
    else if (!includeLastPathSeparator &amp;&amp; route.endsWith("/")) {
        route = removeSuffix(route, "/");
    }
    return route;
}
/// &lt;reference path="mappedDomainElement.ts" /&gt;
/**
 * Gets the ultimate target entity and it's owning entity (if it has one) of a mapped Command/Query.
 * @param request The Command or Query that has been mapped
 */
function getMappedDomainElement(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    const mappingTypeIds = [queryEntityMappingTypeId, createEntityMappingTypeId];
    const mappableElements = ["Class", "Repository"];
    const isMappableElement = function (element) {
        return mappableElements.some(x =&gt; (element === null || element === void 0 ? void 0 : element.specialization) === x);
    };
    let entity = null;
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    if (mappedElement != null) {
        let element = mappedElement;
        while (element != null) {
            if (isMappableElement(element)) {
                entity = element;
                break;
            }
            element = element.getParent();
        }
    }
    // Advanced mappings:
    if (mappedElement == null) {
        const targetEntities = request.getAssociations()
            .flatMap(association =&gt; association.getMappings()
            .filter(mapping =&gt; mappingTypeIds.some(y =&gt; mapping.mappingTypeId == y))
            .map(mapping =&gt; {
            let element = mapping.getTargetElement();
            while (element != null) {
                if (isMappableElement(element)) {
                    return element;
                }
                element = element.getParent();
            }
            return null;
        })
            .filter(entity =&gt; entity != null));
        // Only if all the targetClasses are the same:
        if (targetEntities.length &gt; 0 &amp;&amp; targetEntities.every(x =&gt; x.id === targetEntities[0].id)) {
            entity = targetEntities[0];
        }
    }
    if (entity == null) {
        return null;
    }
    return new MappedDomainElement(entity);
}
/// &lt;reference path="../_common/getFolderParts.ts" /&gt;
/// &lt;reference path="../_common/getRouteParts.ts" /&gt;
/// &lt;reference path="../_common/getDefaultRoutePrefix.ts" /&gt;
/// &lt;reference path="../../common/getMappedDomainElement.ts" /&gt;
function exposeAsHttpEndPoint(command) {
    var _a, _b;
    const domainElement = getMappedDomainElement(command);
    // Add the folder parts
    const routeParts = [];
    const defaultRoutePrefixParts = getDefaultRoutePrefix(false).split("/");
    routeParts.push(...defaultRoutePrefixParts);
    routeParts.push(...getFolderParts(command, domainElement));
    if (domainElement != null) {
        routeParts.push(...getRouteParts(command, domainElement));
    }
    else if (!["Create", "Update", "Delete"].some(x =&gt; command.getName().startsWith(x))) {
        routeParts.push(toKebabCase(removeSuffix(command.getName(), "Request", "Command")));
    }
    let endpointInputIdElement = command.getChildren().filter(x =&gt; x.hasMetadata("endpoint-input-id"))[0];
    if (endpointInputIdElement) {
        routeParts.push(`{${toCamelCase(endpointInputIdElement.getName())}}`);
    }
    const httpSettingsId = "b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6";
    const httpSettingsMediatypeId = "4490e212-1e99-43ce-b3dd-048ed2a6bae8";
    const httpSettings = (_a = command.getStereotype(httpSettingsId)) !== null &amp;&amp; _a !== void 0 ? _a : command.addStereotype(httpSettingsId);
    httpSettings.getProperty("Route").setValue(routeParts.join("/"));
    if (["Create", "Add"].some(x =&gt; command.getName().startsWith(x))) {
        httpSettings.getProperty("Verb").setValue("POST");
    }
    else if (["Delete", "Remove"].some(x =&gt; command.getName().startsWith(x))) {
        httpSettings.getProperty("Verb").setValue("DELETE");
    }
    else {
        httpSettings.getProperty("Verb").setValue("PUT");
    }
    if (((_b = command.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "Type-Definition") {
        httpSettings.getProperty(httpSettingsMediatypeId).setValue("application/json");
    }
}
/// &lt;reference path="shared.ts" /&gt;
/**
 * Used by Intent.Modules\Modules\Intent.Metadata.WebApi
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/services-expose-as-http-endpoint/command/expose-as-http-endpoint.ts
 */
exposeAsHttpEndPoint(element);
</script>
        </option>
        <option>
          <text>Expose as Http File Download</text>
          <icon type="FontAwesome" source="file-download" />
          <script>/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function makeReturnTypeFileDownloadDto(element) {
    var _a;
    const commonTypes = {
        string: "d384db9c-a279-45e1-801e-e4e8099625f2",
        stream: "fd4ead8e-92e9-47c2-97a6-81d898525ea0"
    };
    let returnResultType = lookupTypesOf("DTO").find(x =&gt; x.getName() == "FileDownloadDto");
    if (!returnResultType) {
        let folderName = "Common";
        const folder = (_a = element.getPackage().getChildren("Folder").find(x =&gt; x.getName() == folderName)) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Folder", folderName, element.getPackage().id);
        returnResultType = createElement("DTO", "FileDownloadDto", folder.id);
        returnResultType.id;
        let stream = createElement("DTO-Field", "Content", returnResultType.id);
        stream.typeReference.setType(commonTypes.stream);
        let filename = createElement("DTO-Field", "Filename", returnResultType.id);
        filename.typeReference.setType(commonTypes.string);
        filename.typeReference.setIsNullable(true);
        let contentType = createElement("DTO-Field", "ContentType", returnResultType.id);
        contentType.typeReference.setType(commonTypes.string);
        contentType.typeReference.setIsNullable(true);
    }
    element.typeReference.setType(returnResultType.id);
    element.typeReference.setIsCollection(false);
    element.typeReference.setIsNullable(false);
}
function applyFileTransferStereoType(element) {
    var _a;
    const fileTransferId = "d30e48e8-389e-4b70-84fd-e3bac44cfe19";
    (_a = element.getStereotype(fileTransferId)) !== null &amp;&amp; _a !== void 0 ? _a : element.addStereotype(fileTransferId);
}
function addUploadFields(element, childType) {
    const commonTypes = {
        string: "d384db9c-a279-45e1-801e-e4e8099625f2",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        stream: "fd4ead8e-92e9-47c2-97a6-81d898525ea0"
    };
    const parameterSettingId = "d01df110-1208-4af8-a913-92a49d219552";
    var existing = element.getChildren().find(x =&gt; x.getName() == "Content");
    if (!existing) {
        let stream = createElement(childType, "Content", element.id);
        stream.typeReference.setType(commonTypes.stream);
    }
    var existing = element.getChildren().find(x =&gt; x.getName() == "Filename");
    if (!existing) {
        let filename = createElement(childType, "Filename", element.id);
        filename.typeReference.setType(commonTypes.string);
        filename.typeReference.setIsNullable(true);
        let parameterSetting = filename.addStereotype(parameterSettingId);
    }
    var existing = element.getChildren().find(x =&gt; x.getName() == "ContentType");
    if (!existing) {
        let contentType = createElement(childType, "ContentType", element.id);
        contentType.typeReference.setType(commonTypes.string);
        contentType.typeReference.setIsNullable(true);
        let parameterSetting = contentType.addStereotype(parameterSettingId);
        parameterSetting.getProperty("Source").setValue("From Header");
        parameterSetting.getProperty("Header Name").setValue("Content-Type");
    }
    var existing = element.getChildren().find(x =&gt; x.getName() == "ContentLength");
    if (!existing) {
        let contentType = createElement(childType, "ContentLength", element.id);
        contentType.typeReference.setType(commonTypes.long);
        contentType.typeReference.setIsNullable(true);
        let parameterSetting = contentType.addStereotype(parameterSettingId);
        parameterSetting.getProperty("Source").setValue("From Header");
        parameterSetting.getProperty("Header Name").setValue("Content-Length");
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function getFolderParts(request, entity, owningEntity) {
    let depth = 0;
    let currentElement = request.getParent();
    let folderParts = [];
    while (currentElement.specialization === "Folder") {
        let folderName = currentElement.getName();
        if (depth === 0 &amp;&amp; entity != null) {
            const singularizedFolderName = singularize(folderName);
            const singularizedAggregateRootName = singularize((owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity).getName());
            if (singularizedFolderName.toLowerCase() === singularizedAggregateRootName.toLowerCase()) {
                folderName = singularizedFolderName;
            }
        }
        folderParts.unshift(toKebabCase(folderName));
        currentElement = currentElement.getParent();
        depth++;
    }
    return folderParts;
}
/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        if (Object.keys(primaryKeys).length == 0) {
            return [
                {
                    id: null,
                    name: DomainHelper.getAttributeNameFormat("Id"),
                    typeId: DomainHelper.getSurrogateKeyType(),
                    mapPath: null,
                    isNullable: false,
                    isCollection: false
                }
            ];
        }
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        if (foreignKeys.length &gt; 0) {
            return foreignKeys.map(x =&gt; ({
                name: DomainHelper.getAttributeNameFormat(x.getName()),
                typeId: x.typeReference.typeId,
                id: x.id,
                mapPath: [x.id],
                isCollection: x.typeReference.isCollection,
                isNullable: x.typeReference.isNullable,
                element: x
            }));
        }
        // Implicit FKs:
        return [{
                name: DomainHelper.getAttributeNameFormat(`${owningAggregate.getName()}Id`),
                typeId: DomainHelper.getPrimaryKeys(owningAggregate)[0].typeId,
                id: null,
                mapPath: null,
                isCollection: false,
                isNullable: false
            }];
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(command, settings) {
        var _a;
        this.command = command;
        this.settings = settings;
        this.mappedElement = (_a = command.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.command.id; }
    ;
    setReturnType(typeId, isCollection) {
        this.command.typeReference.setType(typeId);
        if (isCollection != null) {
            this.command.typeReference.setIsCollection(isCollection);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.command.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.command.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.command;
    }
    collapse() {
        this.command.collapse();
    }
}
/**
 * Workaround for element's from referenced packages not having getParent()
 * @param element The element whose parent should be searched for
 * @param parentSpecializationType The specialization type of the parent
 */
function getParent(element, parentSpecializationType) {
    const elements = lookupTypesOf(parentSpecializationType);
    const parent = elements
        .find(x =&gt; x.getChildren(element.specialization)
        .some(child =&gt; child.id === element.id));
    if (parent == null) {
        throw new Error("Could not find parent");
    }
    return parent;
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
/// &lt;reference path="../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/getParent.ts" /&gt;
/**
 * Gets select details of a mapped Command/Query. Intended for centralized logic of working out
 * things like keys (including implicit ones) for both the entity and owning entity if applicable.
 *
 * If the Command is for entity creation (either due to being mapped to a constructor or being
 * prefixed with "Create"), then primary keys for the entity are not populated.
 * @param request The Command or Query that has been mapped
 */
function getMappedRequestDetails(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    // Advanced mapping:
    if (mappedElement == null) {
        const advancedMappings = request.getAssociations()
            .filter(x =&gt; x.hasMappings(queryEntityMappingTypeId) ||
            x.hasMappings(createEntityMappingTypeId))
            .map(x =&gt; x.getMapping(queryEntityMappingTypeId) ||
            x.getMapping(createEntityMappingTypeId));
        if (advancedMappings.length === 1) {
            mappedElement = advancedMappings[0].getTargetElement();
        }
    }
    if (mappedElement == null) {
        return null;
    }
    let entity = mappedElement;
    if (entity.specialization !== "Class") {
        entity = getParent(entity, "Class");
    }
    const result = {
        entity: entity,
        mappingTargetType: mappedElement.specialization,
        entityKeyFields: [],
        ownerKeyFields: []
    };
    result.owningEntity = DomainHelper.getOwningAggregate(entity);
    // As long as it's not for creation, populate the PKs of the entity:
    if (result.mappingTargetType !== "Class Constructor" &amp;&amp;
        !request.getName().toLowerCase().startsWith("Create")) {
        result.entityKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity)
            : getKeysForOperationMapping(request, entity);
    }
    // If the entity is owned, populate its fields:
    if (result.owningEntity != null) {
        result.ownerKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity, result.owningEntity)
            : getKeysForOperationMapping(request, entity, result.owningEntity);
    }
    return result;
    /**
     * Return field details for primary keys. As requests mapped to operations and constructors can
     * never possibly map the attributes, these fields can only ever be matched by name.
     * @param request The CQRS Command or Query entity
     * @param owningEntity The Owning Aggregate Class
     */
    function getKeysForOperationMapping(request, entity, owningEntity) {
        const pks = DomainHelper.getPrimaryKeys(owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity);
        return pks.map(pk =&gt; {
            let fieldName = toPascalCase(pk.name);
            if (owningEntity != null) {
                fieldName = removePrefix(fieldName, toPascalCase(owningEntity.getName()));
                fieldName = `${owningEntity.getName()}${toCamelCase(fieldName)}`;
            }
            fieldName = ServicesHelper.getFieldFormat(fieldName);
            const existingField = request.getChildren("DTO-Field").find(field =&gt; field.getName().toLowerCase() == fieldName.toLowerCase());
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: [],
                name: fieldName,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
    function getKeysForClassMapping(request, entity, owningEntity) {
        const keys = owningEntity != null
            ? DomainHelper.getForeignKeys(entity, owningEntity)
            : DomainHelper.getPrimaryKeys(entity);
        return keys.map(pk =&gt; {
            const existingField = request.getChildren("DTO-Field").find(field =&gt; {
                if (field.getMapping() != null) {
                    return field.getMapping().getPath().some(x =&gt; x.id == pk.id);
                }
                return (pk.name.toLowerCase() === field.getName().toLowerCase());
            });
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: pk.mapPath,
                name: pk.name,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
function getRouteParts(request, entity, owningEntity) {
    var _a;
    if (entity == null) {
        throw new Error("entity is required");
    }
    const routeParts = [];
    // Basic mapping:
    const mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    if (mappedElement != null) {
        const mappedDetails = getMappedRequestDetails(request);
        // Add the owning entity's ids as parts surrounded with curly braces
        if (owningEntity != null) {
            routeParts.push(...mappedDetails.ownerKeyFields
                .filter(x =&gt; x.existingId != null)
                .map(x =&gt; {
                const field = request
                    .getChildren("DTO-Field")
                    .find(field =&gt; field.id === x.existingId);
                return `{${toCamelCase(field.getName())}}`;
            }));
            // Add a part for name of the owned entity
            routeParts.push(toKebabCase(singularize(entity.getName())));
        }
        // Add the entity's ids as parts surrounded with curly braces
        routeParts.push(...mappedDetails.entityKeyFields
            .filter(x =&gt; x.existingId != null)
            .map(x =&gt; {
            const field = request
                .getChildren("DTO-Field")
                .find(field =&gt; field.id === x.existingId);
            return `{${toCamelCase(field.getName())}}`;
        }));
        // Add the operation's name:
        if (mappedDetails.mappingTargetType === "Operation") {
            const entityName = entity.getName();
            let routePart = removePrefix(mappedElement.getName(), "Create", "Update", "Delete", "Add", "Remove");
            routePart = removeSuffix(routePart, "Request", "Query", "Command");
            routeParts.push(removePrefix(toKebabCase(routePart), toKebabCase(singularize(entityName)), toKebabCase(entityName), "-"));
        }
        return routeParts;
    }
    // Advanced mapping:
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    const updateEntityMappingTypeId = "01721b1a-a85d-4320-a5cd-8bd39247196a";
    const mappingTypeIds = [queryEntityMappingTypeId, createEntityMappingTypeId, updateEntityMappingTypeId];
    const associationWithMapping = request
        .getAssociations()
        .find(association =&gt; association.hasMappings() &amp;&amp; association
        .getMappings()
        .every(mapping =&gt; {
        if (!mappingTypeIds.includes(mapping.mappingTypeId)) {
            return false;
        }
        let element = mapping.getTargetElement();
        while (element != null) {
            if (element.specialization === "Class") {
                break;
            }
            element = getParent(element, "Class");
        }
        if (element == null) {
            return false;
        }
        return element.id === entity.id;
    }));
    if (associationWithMapping != null) {
        const mappings = associationWithMapping.getMappings();
        const queryMapping = mappings.find(x =&gt; x.mappingTypeId === queryEntityMappingTypeId);
        const createMapping = mappings.find(x =&gt; x.mappingTypeId === createEntityMappingTypeId);
        const updateMapping = mappings.find(x =&gt; x.mappingTypeId === updateEntityMappingTypeId);
        // Add the owning entity's ids as parts surrounded with curly braces
        if (owningEntity != null) {
            if (queryMapping != null) {
                let applicableClassIds = getEntityInheritanceHierarchyIds(owningEntity);
                routeParts.push(...queryMapping.getMappedEnds()
                    .filter(end =&gt; applicableClassIds.some(x =&gt; x === getParent(end.getTargetElement(), "Class").id))
                    .map(x =&gt; `{${toCamelCase(x.getSourceElement().getName())}}`));
            }
            // Add a part for name of the owned entity
            routeParts.push(toKebabCase(singularize(entity.getName())));
        }
        // Add the entity's ids as parts surrounded with curly braces
        if (queryMapping != null) {
            let applicableClassIds = getEntityInheritanceHierarchyIds(entity);
            routeParts.push(...queryMapping.getMappedEnds()
                .filter(end =&gt; applicableClassIds.some(x =&gt; x === getParent(end.getTargetElement(), "Class").id))
                .map(x =&gt; `{${toCamelCase(x.getSourceElement().getName())}}`));
        }
        // Add the operation's name:
        const mapping = createMapping !== null &amp;&amp; createMapping !== void 0 ? createMapping : updateMapping;
        if (mapping == null) {
            return routeParts;
        }
        var mappingEnd = mapping.getMappedEnds().find(x =&gt; x.getSourceElement().id === request.id);
        if (mappingEnd == null) {
            return routeParts;
        }
        const mappedElement = mappingEnd.getTargetElement();
        if ((mappedElement === null || mappedElement === void 0 ? void 0 : mappedElement.specialization) === "Operation") {
            const entityName = entity.getName();
            let routePart = removePrefix(mappedElement.getName(), "Create", "Update", "Delete", "Add", "Remove");
            routePart = removeSuffix(routePart, "Request", "Query", "Command");
            routeParts.push(removePrefix(toKebabCase(routePart), toKebabCase(singularize(entityName)), toKebabCase(entityName), "-"));
        }
        return routeParts;
    }
    return routeParts;
    function getEntityInheritanceHierarchyIds(curEntity) {
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return [curEntity.id];
        }
        let other = getEntityInheritanceHierarchyIds(generalizations[0].typeReference.getType());
        return other.concat(curEntity.id);
    }
}
function getDefaultRoutePrefix(includeLastPathSeparator) {
    var _a;
    const defaultApiRoutePrefix = "api/";
    const apiSettingsId = "4bd0b4e9-7b53-42a9-bb4a-277abb92a0eb";
    let settingsGroup = application.getSettings(apiSettingsId);
    if (!settingsGroup) {
        return defaultApiRoutePrefix;
    }
    let field = settingsGroup.getField("Default API Route Prefix");
    if (!field) {
        return defaultApiRoutePrefix;
    }
    let route = (_a = field.value) !== null &amp;&amp; _a !== void 0 ? _a : "";
    if (includeLastPathSeparator &amp;&amp; !route.endsWith("/")) {
        route += "/";
    }
    else if (!includeLastPathSeparator &amp;&amp; route.endsWith("/")) {
        route = removeSuffix(route, "/");
    }
    return route;
}
/// &lt;reference path="domainHelper.ts" /&gt;
/// &lt;reference path="getParent.ts" /&gt;
/**
 * Gets the ultimate target entity and it's owning entity (if it has one) of a mapped Command/Query.
 * @param request The Command or Query that has been mapped
 */
function getMappedEntity(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    const mappingTypeIds = [queryEntityMappingTypeId, createEntityMappingTypeId];
    let entity = null;
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    if (mappedElement != null) {
        let element = mappedElement;
        while (element != null) {
            if ((element === null || element === void 0 ? void 0 : element.specialization) === "Class") {
                entity = element;
                break;
            }
            element = getParent(element, "Class");
        }
    }
    // Advanced mappings:
    if (mappedElement == null) {
        const targetEntities = request.getAssociations()
            .flatMap(association =&gt; association.getMappings()
            .filter(mapping =&gt; mappingTypeIds.some(y =&gt; mapping.mappingTypeId == y))
            .map(mapping =&gt; {
            let element = mapping.getTargetElement();
            while (element != null) {
                if (element.specialization === "Class") {
                    return element;
                }
                element = getParent(element, "Class");
            }
            return null;
        })
            .filter(entity =&gt; entity != null));
        // Only if all the targetClasses are the same:
        if (targetEntities.length &gt; 0 &amp;&amp; targetEntities.every(x =&gt; x.id === targetEntities[0].id)) {
            entity = targetEntities[0];
        }
    }
    if (entity == null) {
        return {};
    }
    return {
        entity: entity,
        owningEntity: DomainHelper.getOwningAggregate(entity)
    };
}
/// &lt;reference path="../_common/getFolderParts.ts" /&gt;
/// &lt;reference path="../_common/getRouteParts.ts" /&gt;
/// &lt;reference path="../_common/getDefaultRoutePrefix.ts" /&gt;
/// &lt;reference path="../../common/getMappedEntity.ts" /&gt;
function exposeAsHttpEndPoint(command) {
    var _a, _b;
    const { entity, owningEntity } = getMappedEntity(command);
    // Add the folder parts
    const routeParts = [];
    const defaultRoutePrefixParts = getDefaultRoutePrefix(false).split("/");
    routeParts.push(...defaultRoutePrefixParts);
    routeParts.push(...getFolderParts(command, entity, owningEntity));
    if (entity != null) {
        routeParts.push(...getRouteParts(command, entity, owningEntity));
    }
    else if (!["Create", "Update", "Delete"].some(x =&gt; command.getName().startsWith(x))) {
        routeParts.push(toKebabCase(removeSuffix(command.getName(), "Request", "Command")));
    }
    const httpSettingsId = "b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6";
    const httpSettingsMediatypeId = "4490e212-1e99-43ce-b3dd-048ed2a6bae8";
    const httpSettings = (_a = command.getStereotype(httpSettingsId)) !== null &amp;&amp; _a !== void 0 ? _a : command.addStereotype(httpSettingsId);
    httpSettings.getProperty("Route").setValue(routeParts.join("/"));
    if (["Create", "Add"].some(x =&gt; command.getName().startsWith(x))) {
        httpSettings.getProperty("Verb").setValue("POST");
    }
    else if (["Delete", "Remove"].some(x =&gt; command.getName().startsWith(x))) {
        httpSettings.getProperty("Verb").setValue("DELETE");
    }
    else {
        httpSettings.getProperty("Verb").setValue("PUT");
    }
    if (((_b = command.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "Type-Definition") {
        httpSettings.getProperty(httpSettingsMediatypeId).setValue("application/json");
    }
}
/// &lt;reference path="../common/common-file-transfer.ts" /&gt;
/// &lt;reference path="../../services-expose-as-http-endpoint/command/shared.ts" /&gt;
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.WebApi
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/expose-as-file-download-command/expose-as-file-download-command.ts
 */
function configureDownload(element) {
    applyFileTransferStereoType(element);
    makeReturnTypeFileDownloadDto(element);
    exposeAsHttpEndPoint(element);
}
configureDownload(element);
</script>
        </option>
        <option>
          <text>Expose as Http File Upload</text>
          <icon type="FontAwesome" source="file-upload" />
          <script>/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function makeReturnTypeFileDownloadDto(element) {
    var _a;
    const commonTypes = {
        string: "d384db9c-a279-45e1-801e-e4e8099625f2",
        stream: "fd4ead8e-92e9-47c2-97a6-81d898525ea0"
    };
    let returnResultType = lookupTypesOf("DTO").find(x =&gt; x.getName() == "FileDownloadDto");
    if (!returnResultType) {
        let folderName = "Common";
        const folder = (_a = element.getPackage().getChildren("Folder").find(x =&gt; x.getName() == folderName)) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Folder", folderName, element.getPackage().id);
        returnResultType = createElement("DTO", "FileDownloadDto", folder.id);
        returnResultType.id;
        let stream = createElement("DTO-Field", "Content", returnResultType.id);
        stream.typeReference.setType(commonTypes.stream);
        let filename = createElement("DTO-Field", "Filename", returnResultType.id);
        filename.typeReference.setType(commonTypes.string);
        filename.typeReference.setIsNullable(true);
        let contentType = createElement("DTO-Field", "ContentType", returnResultType.id);
        contentType.typeReference.setType(commonTypes.string);
        contentType.typeReference.setIsNullable(true);
    }
    element.typeReference.setType(returnResultType.id);
    element.typeReference.setIsCollection(false);
    element.typeReference.setIsNullable(false);
}
function applyFileTransferStereoType(element) {
    var _a;
    const fileTransferId = "d30e48e8-389e-4b70-84fd-e3bac44cfe19";
    (_a = element.getStereotype(fileTransferId)) !== null &amp;&amp; _a !== void 0 ? _a : element.addStereotype(fileTransferId);
}
function makePost(element) {
    var _a;
    const httpSettingsId = "b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6";
    const httpSettings = (_a = element.getStereotype(httpSettingsId)) !== null &amp;&amp; _a !== void 0 ? _a : element.addStereotype(httpSettingsId);
    httpSettings.getProperty("Verb").setValue("POST");
}
function addUploadFields(element, childType) {
    const commonTypes = {
        string: "d384db9c-a279-45e1-801e-e4e8099625f2",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        stream: "fd4ead8e-92e9-47c2-97a6-81d898525ea0"
    };
    const parameterSettingId = "d01df110-1208-4af8-a913-92a49d219552";
    var existing = element.getChildren().find(x =&gt; x.getName() == "Content");
    if (!existing) {
        let stream = createElement(childType, "Content", element.id);
        stream.typeReference.setType(commonTypes.stream);
    }
    var existing = element.getChildren().find(x =&gt; x.getName() == "Filename");
    if (!existing) {
        let filename = createElement(childType, "Filename", element.id);
        filename.typeReference.setType(commonTypes.string);
        filename.typeReference.setIsNullable(true);
    }
    var existing = element.getChildren().find(x =&gt; x.getName() == "ContentType");
    if (!existing) {
        let contentType = createElement(childType, "ContentType", element.id);
        contentType.typeReference.setType(commonTypes.string);
        contentType.typeReference.setIsNullable(true);
        let parameterSetting = contentType.addStereotype(parameterSettingId);
        parameterSetting.getProperty("Source").setValue("From Header");
        parameterSetting.getProperty("Header Name").setValue("Content-Type");
    }
    var existing = element.getChildren().find(x =&gt; x.getName() == "ContentLength");
    if (!existing) {
        let contentType = createElement(childType, "ContentLength", element.id);
        contentType.typeReference.setType(commonTypes.long);
        contentType.typeReference.setIsNullable(true);
        let parameterSetting = contentType.addStereotype(parameterSettingId);
        parameterSetting.getProperty("Source").setValue("From Header");
        parameterSetting.getProperty("Header Name").setValue("Content-Length");
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function getFolderParts(request, entity, owningEntity) {
    let depth = 0;
    let currentElement = request.getParent();
    let folderParts = [];
    while (currentElement.specialization === "Folder") {
        let folderName = currentElement.getName();
        if (depth === 0 &amp;&amp; entity != null) {
            const singularizedFolderName = singularize(folderName);
            const singularizedAggregateRootName = singularize((owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity).getName());
            if (singularizedFolderName.toLowerCase() === singularizedAggregateRootName.toLowerCase()) {
                folderName = singularizedFolderName;
            }
        }
        folderParts.unshift(toKebabCase(folderName));
        currentElement = currentElement.getParent();
        depth++;
    }
    return folderParts;
}
/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        if (Object.keys(primaryKeys).length == 0) {
            return [
                {
                    id: null,
                    name: DomainHelper.getAttributeNameFormat("Id"),
                    typeId: DomainHelper.getSurrogateKeyType(),
                    mapPath: null,
                    isNullable: false,
                    isCollection: false
                }
            ];
        }
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        if (foreignKeys.length &gt; 0) {
            return foreignKeys.map(x =&gt; ({
                name: DomainHelper.getAttributeNameFormat(x.getName()),
                typeId: x.typeReference.typeId,
                id: x.id,
                mapPath: [x.id],
                isCollection: x.typeReference.isCollection,
                isNullable: x.typeReference.isNullable,
                element: x
            }));
        }
        // Implicit FKs:
        return [{
                name: DomainHelper.getAttributeNameFormat(`${owningAggregate.getName()}Id`),
                typeId: DomainHelper.getPrimaryKeys(owningAggregate)[0].typeId,
                id: null,
                mapPath: null,
                isCollection: false,
                isNullable: false
            }];
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(command, settings) {
        var _a;
        this.command = command;
        this.settings = settings;
        this.mappedElement = (_a = command.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.command.id; }
    ;
    setReturnType(typeId, isCollection) {
        this.command.typeReference.setType(typeId);
        if (isCollection != null) {
            this.command.typeReference.setIsCollection(isCollection);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.command.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.command.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.command;
    }
    collapse() {
        this.command.collapse();
    }
}
/**
 * Workaround for element's from referenced packages not having getParent()
 * @param element The element whose parent should be searched for
 * @param parentSpecializationType The specialization type of the parent
 */
function getParent(element, parentSpecializationType) {
    const elements = lookupTypesOf(parentSpecializationType);
    const parent = elements
        .find(x =&gt; x.getChildren(element.specialization)
        .some(child =&gt; child.id === element.id));
    if (parent == null) {
        throw new Error("Could not find parent");
    }
    return parent;
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
/// &lt;reference path="../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/getParent.ts" /&gt;
/**
 * Gets select details of a mapped Command/Query. Intended for centralized logic of working out
 * things like keys (including implicit ones) for both the entity and owning entity if applicable.
 *
 * If the Command is for entity creation (either due to being mapped to a constructor or being
 * prefixed with "Create"), then primary keys for the entity are not populated.
 * @param request The Command or Query that has been mapped
 */
function getMappedRequestDetails(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    // Advanced mapping:
    if (mappedElement == null) {
        const advancedMappings = request.getAssociations()
            .filter(x =&gt; x.hasMappings(queryEntityMappingTypeId) ||
            x.hasMappings(createEntityMappingTypeId))
            .map(x =&gt; x.getMapping(queryEntityMappingTypeId) ||
            x.getMapping(createEntityMappingTypeId));
        if (advancedMappings.length === 1) {
            mappedElement = advancedMappings[0].getTargetElement();
        }
    }
    if (mappedElement == null) {
        return null;
    }
    let entity = mappedElement;
    if (entity.specialization !== "Class") {
        entity = getParent(entity, "Class");
    }
    const result = {
        entity: entity,
        mappingTargetType: mappedElement.specialization,
        entityKeyFields: [],
        ownerKeyFields: []
    };
    result.owningEntity = DomainHelper.getOwningAggregate(entity);
    // As long as it's not for creation, populate the PKs of the entity:
    if (result.mappingTargetType !== "Class Constructor" &amp;&amp;
        !request.getName().toLowerCase().startsWith("Create")) {
        result.entityKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity)
            : getKeysForOperationMapping(request, entity);
    }
    // If the entity is owned, populate its fields:
    if (result.owningEntity != null) {
        result.ownerKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity, result.owningEntity)
            : getKeysForOperationMapping(request, entity, result.owningEntity);
    }
    return result;
    /**
     * Return field details for primary keys. As requests mapped to operations and constructors can
     * never possibly map the attributes, these fields can only ever be matched by name.
     * @param request The CQRS Command or Query entity
     * @param owningEntity The Owning Aggregate Class
     */
    function getKeysForOperationMapping(request, entity, owningEntity) {
        const pks = DomainHelper.getPrimaryKeys(owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity);
        return pks.map(pk =&gt; {
            let fieldName = toPascalCase(pk.name);
            if (owningEntity != null) {
                fieldName = removePrefix(fieldName, toPascalCase(owningEntity.getName()));
                fieldName = `${owningEntity.getName()}${toCamelCase(fieldName)}`;
            }
            fieldName = ServicesHelper.getFieldFormat(fieldName);
            const existingField = request.getChildren("DTO-Field").find(field =&gt; field.getName().toLowerCase() == fieldName.toLowerCase());
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: [],
                name: fieldName,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
    function getKeysForClassMapping(request, entity, owningEntity) {
        const keys = owningEntity != null
            ? DomainHelper.getForeignKeys(entity, owningEntity)
            : DomainHelper.getPrimaryKeys(entity);
        return keys.map(pk =&gt; {
            const existingField = request.getChildren("DTO-Field").find(field =&gt; {
                if (field.getMapping() != null) {
                    return field.getMapping().getPath().some(x =&gt; x.id == pk.id);
                }
                return (pk.name.toLowerCase() === field.getName().toLowerCase());
            });
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: pk.mapPath,
                name: pk.name,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
function getRouteParts(request, entity, owningEntity) {
    var _a;
    if (entity == null) {
        throw new Error("entity is required");
    }
    const routeParts = [];
    // Basic mapping:
    const mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    if (mappedElement != null) {
        const mappedDetails = getMappedRequestDetails(request);
        // Add the owning entity's ids as parts surrounded with curly braces
        if (owningEntity != null) {
            routeParts.push(...mappedDetails.ownerKeyFields
                .filter(x =&gt; x.existingId != null)
                .map(x =&gt; {
                const field = request
                    .getChildren("DTO-Field")
                    .find(field =&gt; field.id === x.existingId);
                return `{${toCamelCase(field.getName())}}`;
            }));
            // Add a part for name of the owned entity
            routeParts.push(toKebabCase(singularize(entity.getName())));
        }
        // Add the entity's ids as parts surrounded with curly braces
        routeParts.push(...mappedDetails.entityKeyFields
            .filter(x =&gt; x.existingId != null)
            .map(x =&gt; {
            const field = request
                .getChildren("DTO-Field")
                .find(field =&gt; field.id === x.existingId);
            return `{${toCamelCase(field.getName())}}`;
        }));
        // Add the operation's name:
        if (mappedDetails.mappingTargetType === "Operation") {
            const entityName = entity.getName();
            let routePart = removePrefix(mappedElement.getName(), "Create", "Update", "Delete", "Add", "Remove");
            routePart = removeSuffix(routePart, "Request", "Query", "Command");
            routeParts.push(removePrefix(toKebabCase(routePart), toKebabCase(singularize(entityName)), toKebabCase(entityName), "-"));
        }
        return routeParts;
    }
    // Advanced mapping:
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    const updateEntityMappingTypeId = "01721b1a-a85d-4320-a5cd-8bd39247196a";
    const mappingTypeIds = [queryEntityMappingTypeId, createEntityMappingTypeId, updateEntityMappingTypeId];
    const associationWithMapping = request
        .getAssociations()
        .find(association =&gt; association.hasMappings() &amp;&amp; association
        .getMappings()
        .every(mapping =&gt; {
        if (!mappingTypeIds.includes(mapping.mappingTypeId)) {
            return false;
        }
        let element = mapping.getTargetElement();
        while (element != null) {
            if (element.specialization === "Class") {
                break;
            }
            element = getParent(element, "Class");
        }
        if (element == null) {
            return false;
        }
        return element.id === entity.id;
    }));
    if (associationWithMapping != null) {
        const mappings = associationWithMapping.getMappings();
        const queryMapping = mappings.find(x =&gt; x.mappingTypeId === queryEntityMappingTypeId);
        const createMapping = mappings.find(x =&gt; x.mappingTypeId === createEntityMappingTypeId);
        const updateMapping = mappings.find(x =&gt; x.mappingTypeId === updateEntityMappingTypeId);
        // Add the owning entity's ids as parts surrounded with curly braces
        if (owningEntity != null) {
            if (queryMapping != null) {
                let applicableClassIds = getEntityInheritanceHierarchyIds(owningEntity);
                routeParts.push(...queryMapping.getMappedEnds()
                    .filter(end =&gt; applicableClassIds.some(x =&gt; x === getParent(end.getTargetElement(), "Class").id))
                    .map(x =&gt; `{${toCamelCase(x.getSourceElement().getName())}}`));
            }
            // Add a part for name of the owned entity
            routeParts.push(toKebabCase(singularize(entity.getName())));
        }
        // Add the entity's ids as parts surrounded with curly braces
        if (queryMapping != null) {
            let applicableClassIds = getEntityInheritanceHierarchyIds(entity);
            routeParts.push(...queryMapping.getMappedEnds()
                .filter(end =&gt; applicableClassIds.some(x =&gt; x === getParent(end.getTargetElement(), "Class").id))
                .map(x =&gt; `{${toCamelCase(x.getSourceElement().getName())}}`));
        }
        // Add the operation's name:
        const mapping = createMapping !== null &amp;&amp; createMapping !== void 0 ? createMapping : updateMapping;
        if (mapping == null) {
            return routeParts;
        }
        var mappingEnd = mapping.getMappedEnds().find(x =&gt; x.getSourceElement().id === request.id);
        if (mappingEnd == null) {
            return routeParts;
        }
        const mappedElement = mappingEnd.getTargetElement();
        if ((mappedElement === null || mappedElement === void 0 ? void 0 : mappedElement.specialization) === "Operation") {
            const entityName = entity.getName();
            let routePart = removePrefix(mappedElement.getName(), "Create", "Update", "Delete", "Add", "Remove");
            routePart = removeSuffix(routePart, "Request", "Query", "Command");
            routeParts.push(removePrefix(toKebabCase(routePart), toKebabCase(singularize(entityName)), toKebabCase(entityName), "-"));
        }
        return routeParts;
    }
    return routeParts;
    function getEntityInheritanceHierarchyIds(curEntity) {
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return [curEntity.id];
        }
        let other = getEntityInheritanceHierarchyIds(generalizations[0].typeReference.getType());
        return other.concat(curEntity.id);
    }
}
function getDefaultRoutePrefix(includeLastPathSeparator) {
    var _a;
    const defaultApiRoutePrefix = "api/";
    const apiSettingsId = "4bd0b4e9-7b53-42a9-bb4a-277abb92a0eb";
    let settingsGroup = application.getSettings(apiSettingsId);
    if (!settingsGroup) {
        return defaultApiRoutePrefix;
    }
    let field = settingsGroup.getField("Default API Route Prefix");
    if (!field) {
        return defaultApiRoutePrefix;
    }
    let route = (_a = field.value) !== null &amp;&amp; _a !== void 0 ? _a : "";
    if (includeLastPathSeparator &amp;&amp; !route.endsWith("/")) {
        route += "/";
    }
    else if (!includeLastPathSeparator &amp;&amp; route.endsWith("/")) {
        route = removeSuffix(route, "/");
    }
    return route;
}
/// &lt;reference path="domainHelper.ts" /&gt;
/// &lt;reference path="getParent.ts" /&gt;
/**
 * Gets the ultimate target entity and it's owning entity (if it has one) of a mapped Command/Query.
 * @param request The Command or Query that has been mapped
 */
function getMappedEntity(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    const mappingTypeIds = [queryEntityMappingTypeId, createEntityMappingTypeId];
    let entity = null;
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    if (mappedElement != null) {
        let element = mappedElement;
        while (element != null) {
            if ((element === null || element === void 0 ? void 0 : element.specialization) === "Class") {
                entity = element;
                break;
            }
            element = getParent(element, "Class");
        }
    }
    // Advanced mappings:
    if (mappedElement == null) {
        const targetEntities = request.getAssociations()
            .flatMap(association =&gt; association.getMappings()
            .filter(mapping =&gt; mappingTypeIds.some(y =&gt; mapping.mappingTypeId == y))
            .map(mapping =&gt; {
            let element = mapping.getTargetElement();
            while (element != null) {
                if (element.specialization === "Class") {
                    return element;
                }
                element = getParent(element, "Class");
            }
            return null;
        })
            .filter(entity =&gt; entity != null));
        // Only if all the targetClasses are the same:
        if (targetEntities.length &gt; 0 &amp;&amp; targetEntities.every(x =&gt; x.id === targetEntities[0].id)) {
            entity = targetEntities[0];
        }
    }
    if (entity == null) {
        return {};
    }
    return {
        entity: entity,
        owningEntity: DomainHelper.getOwningAggregate(entity)
    };
}
/// &lt;reference path="../_common/getFolderParts.ts" /&gt;
/// &lt;reference path="../_common/getRouteParts.ts" /&gt;
/// &lt;reference path="../_common/getDefaultRoutePrefix.ts" /&gt;
/// &lt;reference path="../../common/getMappedEntity.ts" /&gt;
function exposeAsHttpEndPoint(command) {
    var _a, _b;
    const { entity, owningEntity } = getMappedEntity(command);
    // Add the folder parts
    const routeParts = [];
    const defaultRoutePrefixParts = getDefaultRoutePrefix(false).split("/");
    routeParts.push(...defaultRoutePrefixParts);
    routeParts.push(...getFolderParts(command, entity, owningEntity));
    if (entity != null) {
        routeParts.push(...getRouteParts(command, entity, owningEntity));
    }
    else if (!["Create", "Update", "Delete"].some(x =&gt; command.getName().startsWith(x))) {
        routeParts.push(toKebabCase(removeSuffix(command.getName(), "Request", "Command")));
    }
    const httpSettingsId = "b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6";
    const httpSettingsMediatypeId = "4490e212-1e99-43ce-b3dd-048ed2a6bae8";
    const httpSettings = (_a = command.getStereotype(httpSettingsId)) !== null &amp;&amp; _a !== void 0 ? _a : command.addStereotype(httpSettingsId);
    httpSettings.getProperty("Route").setValue(routeParts.join("/"));
    if (["Create", "Add"].some(x =&gt; command.getName().startsWith(x))) {
        httpSettings.getProperty("Verb").setValue("POST");
    }
    else if (["Delete", "Remove"].some(x =&gt; command.getName().startsWith(x))) {
        httpSettings.getProperty("Verb").setValue("DELETE");
    }
    else {
        httpSettings.getProperty("Verb").setValue("PUT");
    }
    if (((_b = command.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "Type-Definition") {
        httpSettings.getProperty(httpSettingsMediatypeId).setValue("application/json");
    }
}
/// &lt;reference path="../common/common-file-transfer.ts" /&gt;
/// &lt;reference path="../../services-expose-as-http-endpoint/command/shared.ts" /&gt;
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.WebApi
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/expose-as-file-upload-command/expose-as-file-upload-command.ts
 */
function configureUpload(element) {
    applyFileTransferStereoType(element);
    addUploadFields(element, "DTO-Field");
    exposeAsHttpEndPoint(element);
    makePost(element);
}
configureUpload(element);
</script>
        </option>
      </scriptOptions>
      <mappingOptions />
      <typeOrder />
      <mappingSettings />
      <macros>
        <macro trigger="on-changed">
          <script>function execute() {
    const apiVersionStereotypeId = "20855f03-c663-4ec6-b106-de06be98f1fe";
    const httpSettingsStereotypeId = "b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6";

    let route = element.getStereotype(httpSettingsStereotypeId)?.getProperty("Route")?.getValue();

    if (!element.hasStereotype(apiVersionStereotypeId) &amp;&amp; route?.indexOf("{version}") &gt;= 0) {
        // Api version Stereotype removed
        route = route.replace("{version}/", "");
        element.getStereotype(httpSettingsStereotypeId).getProperty("Route").setValue(route);
        return;
    }

    if (element.hasStereotype(apiVersionStereotypeId) &amp;&amp; route?.indexOf("{version}") &lt; 0) {
        // Api version Stereotype added
        let defaultRoutePrefix = getDefaultRoutePrefix(false);
        let startIndex = route.indexOf(defaultRoutePrefix);
        if (startIndex == 0) {
            route = `${defaultRoutePrefix}/{version}/${(route.substring(defaultRoutePrefix.length+1))}`;
        } else {
            route = `{version}/${(route)}`;
        }
        element.getStereotype(httpSettingsStereotypeId).getProperty("Route").setValue(route);
        return;
    }
}

function getDefaultRoutePrefix(includeLastPathSeparator) {
    const defaultApiRoutePrefix = "api/";
    const apiSettingsId = "4bd0b4e9-7b53-42a9-bb4a-277abb92a0eb";

    let settingsGroup = application.getSettings(apiSettingsId);
    if (!settingsGroup) { return defaultApiRoutePrefix; }
    
    let field = settingsGroup.getField("Default API Route Prefix");
    if (!field) { return defaultApiRoutePrefix; }
    
    let route = field.value ?? "";

    if (includeLastPathSeparator &amp;&amp; !route.endsWith("/")) {
        route += "/";
    } else if (!includeLastPathSeparator &amp;&amp; route.endsWith("/")) {
        route = removeSuffix(route, "/");
    }

    return route;
}

execute();</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="Query" typeId="e71b0662-e29d-4db2-868b-8a12464b25d0">
      <validateFunctionOverride>/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function validateRestRoutes(element) {
    let routeToValidate = RestRoute.create(element);
    if (!routeToValidate) {
        return "";
    }
    let routesToCompareAgainst = lookupTypesOf("Command", false)
        .concat(lookupTypesOf("Query", false))
        .concat(lookupTypesOf("Operation", false))
        .map(x =&gt; RestRoute.create(x))
        .filter(x =&gt; x != null);
    let message = __findOneDuplicate(routeToValidate, routesToCompareAgainst);
    if (message &amp;&amp; message != "") {
        return message;
    }
    message = __findMissingParameters(routeToValidate);
    if (message &amp;&amp; message != "") {
        return message;
    }
    return "";
}
function __findOneDuplicate(routeToValidate, routesToCompareAgainst) {
    for (let possibleDuplicate of routesToCompareAgainst) {
        // Make sure we're not checking the same route with itself.
        if (routeToValidate.underlyingElement.id == possibleDuplicate.underlyingElement.id) {
            continue;
        }
        if (possibleDuplicate.isDuplicate(routeToValidate)) {
            return `Duplicate rest route ${routeToValidate.underlyingElement.getName()}(${routeToValidate.underlyingElement.specialization}) with ${possibleDuplicate.underlyingElement.getName()}(${possibleDuplicate.underlyingElement.specialization}) - ${possibleDuplicate.originalRoute}`;
        }
    }
    return "";
}
function __findMissingParameters(routeToValidate) {
    let element = routeToValidate.underlyingElement;
    let elementType = element.specialization;
    let elementChildren;
    if (elementType === "Command" || elementType === "Query") {
        elementChildren = element.getChildren("DTO-Field");
    }
    else if (elementType === "Operation") {
        elementChildren = element.getChildren("Parameter");
    }
    else {
        return "";
    }
    let missingParameters = [];
    for (let routeParam of routeToValidate.routeParams) {
        let routeParamName = routeParam.toLowerCase();
        if (!elementChildren.some(e =&gt; e.getName().toLowerCase() === routeParamName)) {
            missingParameters.push(routeParam);
        }
    }
    if (missingParameters.length === 0) {
        return "";
    }
    return `Route mismatch: some route parameters do not match element's properties/parameters. Unmatched parameters: ${missingParameters.join(", ")}`;
}
class RestVersionSet {
    constructor(isVersioned, versionIds) {
        this.isVersioned = isVersioned;
        this.versionHashTable = {};
        for (let v of versionIds) {
            this.versionHashTable[v] = v;
        }
    }
    matches(versionSet) {
        // Only engage with versioning checks if both REST routes are versioned
        return !this.isVersioned || !versionSet.isVersioned || this.intersects(versionSet);
    }
    intersects(versionSet) {
        for (let v in this.versionHashTable) {
            if (versionSet.versionHashTable[v]) {
                return true;
            }
        }
        return false;
    }
    static create(element) {
        const apiVersionSettingId = "20855f03-c663-4ec6-b106-de06be98f1fe";
        let versionSetting = element.getStereotype(apiVersionSettingId);
        if (!versionSetting) {
            return new RestVersionSet(false, []);
        }
        let versionIds = JSON.parse(versionSetting.getProperty("Applicable Versions").value);
        return new RestVersionSet(true, versionIds !== null &amp;&amp; versionIds !== void 0 ? versionIds : []);
    }
}
class RestRoute {
    constructor(verb, originalRoute, underlyingElement) {
        this.verb = verb;
        this.originalRoute = originalRoute;
        this.underlyingElement = underlyingElement;
        this.routeParams = [];
        this.versionSet = RestVersionSet.create(underlyingElement);
        let counter = 0;
        let localRouteParams = this.routeParams;
        let actionName = underlyingElement.getName();
        this.hashedRoute = originalRoute
            .replace(/\{([^}]*)\}/g, function (match, g1) {
            if (g1 !== "version") {
                localRouteParams.push(g1);
            }
            return (counter++).toString();
        })
            .replace(/(\[action\])/g, actionName);
    }
    isDuplicate(possibleDuplicateRoute) {
        return this.hashedRoute === possibleDuplicateRoute.hashedRoute &amp;&amp;
            this.verb === possibleDuplicateRoute.verb &amp;&amp;
            this.versionSet.matches(possibleDuplicateRoute.versionSet);
    }
    static create(element) {
        if (!element) {
            return null;
        }
        const httpSettingsId = "b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6";
        let httpSettings = element.getStereotype(httpSettingsId);
        if (!httpSettings) {
            return null;
        }
        let absoluteRouteToCheck = getAbsoluteRoute(element, httpSettings);
        if (!absoluteRouteToCheck) {
            return null;
        }
        let verbToCheck = httpSettings.getProperty("Verb").value;
        return new RestRoute(verbToCheck, absoluteRouteToCheck, element);
        function getAbsoluteRoute(element, httpSettings) {
            var _a;
            if (element.specialization == "Operation") {
                const serviceHttpServiceSettingsId = "c29224ec-d473-4b95-ad4a-ec55c676c4fd";
                let serviceElement = element.getParent();
                if (!serviceElement) {
                    return null;
                }
                let operationPath = httpSettings.getProperty("Route").value;
                let servicePath = (_a = serviceElement.getStereotype(serviceHttpServiceSettingsId)) === null || _a === void 0 ? void 0 : _a.getProperty("Route").value;
                if (servicePath &amp;&amp; servicePath != "") {
                    if (servicePath.toLocaleLowerCase().includes('[controller]')) {
                        servicePath = servicePath.replace(/\[controller\]/gi, `[${serviceElement.getName()}]`);
                    }
                    return `${servicePath}/${operationPath}`;
                }
                //We don't know how the service name will be transformed so we add [{ServiceName}] to represent the transform
                return `[${serviceElement.getName()}]/${operationPath}`;
            }
            return httpSettings.getProperty("Route").value;
        }
    }
}
/// &lt;reference path="../_common/common-rest-route-validation.ts" /&gt;
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.WebApi
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/services-rest-route-validation/command/query-rest-route-validation.ts
 */
//Comment / UnComment below when you publish
return validateRestRoutes(lookup(id));
</validateFunctionOverride>
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Expose as Http Endpoint</text>
          <shortcut>ctrl + shift + e</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
;
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
/// &lt;reference path="domainHelper.ts" /&gt;
class EntityDomainElementDetails {
    constructor(entity) {
        this.entity = entity;
        this.owningEntity = DomainHelper.getOwningAggregate(entity);
    }
    getOwningOrTargetEntityName() {
        var _a;
        return ((_a = this.owningEntity) !== null &amp;&amp; _a !== void 0 ? _a : this.entity).getName();
    }
    hasOwningEntity() {
        return this.owningEntity != null;
    }
}
class MappedDomainElement {
    constructor(originalElement) {
        this.originalElement = originalElement;
        this.entityDomainElementDetails = this.isEntityDomainElement() ? new EntityDomainElementDetails(originalElement) : null;
    }
    isEntityDomainElement() {
        return this.originalElement.specialization == "Class";
    }
    getId() {
        return this.originalElement.id;
    }
    getName() {
        return this.originalElement.getName();
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/mappedDomainElement.ts" /&gt;
function getFolderParts(request, domainElement) {
    var _a;
    let depth = 0;
    let currentElement = request.getParent();
    let folderParts = [];
    while (currentElement.specialization === "Folder") {
        let folderName = currentElement.getName();
        if (depth === 0 &amp;&amp; domainElement != null) {
            const singularizedFolderName = singularize(folderName);
            const singularizedAggregateRootName = singularize((_a = domainElement.entityDomainElementDetails) === null || _a === void 0 ? void 0 : _a.getOwningOrTargetEntityName());
            if (singularizedFolderName.toLowerCase() === singularizedAggregateRootName.toLowerCase()) {
                folderName = pluralize(singularizedFolderName);
            }
        }
        folderParts.unshift(toKebabCase(folderName));
        currentElement = currentElement.getParent();
        depth++;
    }
    return folderParts;
}
/// &lt;reference path="attributeWithMapPath.ts" /&gt;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
ServicesConstants.dtoToDomainOperation = "8d1f6a8a-77c8-43a2-8e60-421559725419";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
/**
 * Workaround for element's from referenced packages not having getParent()
 * @param element The element whose parent should be searched for
 * @param parentSpecializationType The specialization type of the parent
 */
function getParent(element, parentSpecializationType) {
    const elements = lookupTypesOf(parentSpecializationType);
    const parent = elements
        .find(x =&gt; x.getChildren(element.specialization)
        .some(child =&gt; child.id === element.id));
    if (parent == null) {
        throw new Error("Could not find parent");
    }
    return parent;
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
/// &lt;reference path="../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/getParent.ts" /&gt;
/**
 * Gets select details of a mapped Command/Query. Intended for centralized logic of working out
 * things like keys for both the entity and owning entity if applicable.
 *
 * If the Command is for entity creation (either due to being mapped to a constructor or being
 * prefixed with "Create"), then primary keys for the entity are not populated.
 * @param request The Command or Query that has been mapped
 */
function getMappedRequestDetails(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    // Advanced mapping:
    if (mappedElement == null) {
        const advancedMappings = request.getAssociations()
            .filter(x =&gt; x.hasMappings(queryEntityMappingTypeId) ||
            x.hasMappings(createEntityMappingTypeId))
            .map(x =&gt; x.getMapping(queryEntityMappingTypeId) ||
            x.getMapping(createEntityMappingTypeId));
        if (advancedMappings.length === 1) {
            mappedElement = advancedMappings[0].getTargetElement();
        }
    }
    if (mappedElement == null) {
        return null;
    }
    let entity = mappedElement;
    if (entity.specialization !== "Class") {
        entity = getParent(entity, "Class");
    }
    const result = {
        entity: entity,
        mappingTargetType: mappedElement.specialization,
        entityKeyFields: [],
        ownerKeyFields: []
    };
    result.owningEntity = DomainHelper.getOwningAggregate(entity);
    // As long as it's not for creation, populate the PKs of the entity:
    if (result.mappingTargetType !== "Class Constructor" &amp;&amp;
        !request.getName().toLowerCase().startsWith("Create")) {
        result.entityKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity)
            : getKeysForOperationMapping(request, entity);
    }
    // If the entity is owned, populate its fields:
    if (result.owningEntity != null) {
        result.ownerKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity, result.owningEntity)
            : getKeysForOperationMapping(request, entity, result.owningEntity);
    }
    return result;
    /**
     * Return field details for primary keys. As requests mapped to operations and constructors can
     * never possibly map the attributes, these fields can only ever be matched by name.
     * @param request The CQRS Command or Query entity
     * @param owningEntity The Owning Aggregate Class
     */
    function getKeysForOperationMapping(request, entity, owningEntity) {
        const pks = DomainHelper.getPrimaryKeys(owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity);
        return pks.map(pk =&gt; {
            let fieldName = toPascalCase(pk.name);
            if (owningEntity != null) {
                fieldName = removePrefix(fieldName, toPascalCase(owningEntity.getName()));
                fieldName = `${owningEntity.getName()}${toCamelCase(fieldName)}`;
            }
            fieldName = ServicesHelper.getFieldFormat(fieldName);
            const existingField = request.getChildren("DTO-Field").find(field =&gt; field.getName().toLowerCase() == fieldName.toLowerCase());
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: [],
                name: fieldName,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
    function getKeysForClassMapping(request, entity, owningEntity) {
        const keys = owningEntity != null
            ? DomainHelper.getForeignKeys(entity, owningEntity)
            : DomainHelper.getPrimaryKeys(entity);
        return keys.map(pk =&gt; {
            const existingField = request.getChildren("DTO-Field").find(field =&gt; {
                if (field.getMapping() != null) {
                    return field.getMapping().getPath().some(x =&gt; x.id == pk.id);
                }
                return (pk.name.toLowerCase() === field.getName().toLowerCase());
            });
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: pk.mapPath,
                name: pk.name,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
function getRouteParts(request, domainElement) {
    if (domainElement == null) {
        throw new Error("entity is required");
    }
    let routeParts;
    routeParts = updateRoutePathsFromBasicMapping(request, domainElement);
    if (routeParts.length &gt; 0) {
        return routeParts;
    }
    routeParts = updateRoutePathsFromAdvancedMapping(request, domainElement);
    if (routeParts.length &gt; 0) {
        return routeParts;
    }
    return [];
}
function updateRoutePathsFromBasicMapping(request, domainElement) {
    var _a, _b;
    let routeParts = [];
    const mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    if (mappedElement != null) {
        const mappedDetails = getMappedRequestDetails(request);
        // Add the owning entity's ids as parts surrounded with curly braces
        if (((_b = domainElement.entityDomainElementDetails) === null || _b === void 0 ? void 0 : _b.hasOwningEntity()) == true) {
            routeParts.push(...mappedDetails.ownerKeyFields
                .filter(x =&gt; x.existingId != null)
                .map(x =&gt; {
                const field = request
                    .getChildren("DTO-Field")
                    .find(field =&gt; field.id === x.existingId);
                return `{${toCamelCase(field.getName())}}`;
            }));
            // Add a part for name of the owned entity
            routeParts.push(toKebabCase(singularize(domainElement.getName())));
        }
        // Add the entity's ids as parts surrounded with curly braces
        routeParts.push(...mappedDetails.entityKeyFields
            .filter(x =&gt; x.existingId != null)
            .map(x =&gt; {
            const field = request
                .getChildren("DTO-Field")
                .find(field =&gt; field.id === x.existingId);
            return `{${toCamelCase(field.getName())}}`;
        }));
        // Add the operation's name:
        if (mappedDetails.mappingTargetType === "Operation") {
            const entityName = domainElement.getName();
            let routePart = removePrefix(mappedElement.getName(), "Create", "Update", "Delete", "Add", "Remove");
            routePart = removeSuffix(routePart, "Request", "Query", "Command");
            routeParts.push(removePrefix(toKebabCase(routePart), toKebabCase(singularize(entityName)), toKebabCase(entityName), "-"));
        }
    }
    return routeParts;
}
function updateRoutePathsFromAdvancedMapping(request, domainElement) {
    var _a, _b, _c;
    let routeParts = [];
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    const updateEntityMappingTypeId = "01721b1a-a85d-4320-a5cd-8bd39247196a";
    const mappingTypeIds = [queryEntityMappingTypeId, createEntityMappingTypeId, updateEntityMappingTypeId];
    const associationWithMapping = request
        .getAssociations()
        .find(association =&gt; association.hasMappings() &amp;&amp; association
        .getMappings()
        .every(mapping =&gt; {
        if (!mappingTypeIds.includes(mapping.mappingTypeId)) {
            return false;
        }
        let element = mapping.getTargetElement();
        while (element != null) {
            if (element.specialization === "Class") {
                break;
            }
            element = getParent(element, "Class");
        }
        if (element == null) {
            return false;
        }
        return element.id === domainElement.getId();
    }));
    if (associationWithMapping != null) {
        const mappings = associationWithMapping.getMappings();
        const queryMapping = mappings.find(x =&gt; x.mappingTypeId === queryEntityMappingTypeId);
        const createMapping = mappings.find(x =&gt; x.mappingTypeId === createEntityMappingTypeId);
        const updateMapping = mappings.find(x =&gt; x.mappingTypeId === updateEntityMappingTypeId);
        // Add the owning entity's ids as parts surrounded with curly braces
        if (((_a = domainElement.entityDomainElementDetails) === null || _a === void 0 ? void 0 : _a.hasOwningEntity()) == true) {
            if (queryMapping != null) {
                let applicableClassIds = getEntityInheritanceHierarchyIds((_b = domainElement === null || domainElement === void 0 ? void 0 : domainElement.entityDomainElementDetails) === null || _b === void 0 ? void 0 : _b.owningEntity);
                routeParts.push(...queryMapping.getMappedEnds()
                    .filter(end =&gt; applicableClassIds.some(x =&gt; x === getParent(end.getTargetElement(), "Class").id))
                    .map(x =&gt; `{${toCamelCase(x.getSourceElement().getName())}}`));
            }
            // Add a part for name of the owned entity
            routeParts.push(toKebabCase(singularize(domainElement.getName())));
        }
        // Add the entity's ids as parts surrounded with curly braces
        if (queryMapping != null) {
            let applicableClassIds = getEntityInheritanceHierarchyIds((_c = domainElement === null || domainElement === void 0 ? void 0 : domainElement.entityDomainElementDetails) === null || _c === void 0 ? void 0 : _c.entity);
            routeParts.push(...queryMapping.getMappedEnds()
                .filter(end =&gt; applicableClassIds.some(x =&gt; x === getParent(end.getTargetElement(), "Class").id))
                .map(x =&gt; `{${toCamelCase(x.getSourceElement().getName())}}`));
        }
        // Add the operation's name:
        const mapping = createMapping !== null &amp;&amp; createMapping !== void 0 ? createMapping : updateMapping;
        if (mapping == null) {
            return routeParts;
        }
        var mappingEnd = mapping.getMappedEnds().find(x =&gt; x.getSourceElement().id === request.id);
        if (mappingEnd == null) {
            return routeParts;
        }
        const mappedElement = mappingEnd.getTargetElement();
        if ((mappedElement === null || mappedElement === void 0 ? void 0 : mappedElement.specialization) === "Operation") {
            const entityName = domainElement.getName();
            let routePart = removePrefix(mappedElement.getName(), "Create", "Update", "Delete", "Add", "Remove");
            routePart = removeSuffix(routePart, "Request", "Query", "Command");
            routeParts.push(removePrefix(toKebabCase(routePart), toKebabCase(singularize(entityName)), toKebabCase(entityName), "-"));
        }
        return routeParts;
    }
    return routeParts;
}
function getEntityInheritanceHierarchyIds(curEntity) {
    let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
    if (generalizations.length == 0) {
        return [curEntity.id];
    }
    let other = getEntityInheritanceHierarchyIds(generalizations[0].typeReference.getType());
    return other.concat(curEntity.id);
}
function getDefaultRoutePrefix(includeLastPathSeparator) {
    const defaultApiRoutePrefix = "api";
    const apiSettingsId = "4bd0b4e9-7b53-42a9-bb4a-277abb92a0eb";
    let settingsGroup = application.getSettings(apiSettingsId);
    let route = settingsGroup ? settingsGroup.getField("Default API Route Prefix").value : null;
    if (!route) {
        route = defaultApiRoutePrefix;
    }
    if (includeLastPathSeparator &amp;&amp; !route.endsWith("/")) {
        route += "/";
    }
    else if (!includeLastPathSeparator &amp;&amp; route.endsWith("/")) {
        route = removeSuffix(route, "/");
    }
    return route;
}
/// &lt;reference path="mappedDomainElement.ts" /&gt;
/**
 * Gets the ultimate target entity and it's owning entity (if it has one) of a mapped Command/Query.
 * @param request The Command or Query that has been mapped
 */
function getMappedDomainElement(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    const mappingTypeIds = [queryEntityMappingTypeId, createEntityMappingTypeId];
    const mappableElements = ["Class", "Repository"];
    const isMappableElement = function (element) {
        return mappableElements.some(x =&gt; (element === null || element === void 0 ? void 0 : element.specialization) === x);
    };
    let entity = null;
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    if (mappedElement != null) {
        let element = mappedElement;
        while (element != null) {
            if (isMappableElement(element)) {
                entity = element;
                break;
            }
            element = element.getParent();
        }
    }
    // Advanced mappings:
    if (mappedElement == null) {
        const targetEntities = request.getAssociations()
            .flatMap(association =&gt; association.getMappings()
            .filter(mapping =&gt; mappingTypeIds.some(y =&gt; mapping.mappingTypeId == y))
            .map(mapping =&gt; {
            let element = mapping.getTargetElement();
            while (element != null) {
                if (isMappableElement(element)) {
                    return element;
                }
                element = element.getParent();
            }
            return null;
        })
            .filter(entity =&gt; entity != null));
        // Only if all the targetClasses are the same:
        if (targetEntities.length &gt; 0 &amp;&amp; targetEntities.every(x =&gt; x.id === targetEntities[0].id)) {
            entity = targetEntities[0];
        }
    }
    if (entity == null) {
        return null;
    }
    return new MappedDomainElement(entity);
}
/// &lt;reference path="../_common/getFolderParts.ts" /&gt;
/// &lt;reference path="../_common/getRouteParts.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/// &lt;reference path="../_common/getDefaultRoutePrefix.ts" /&gt;
/// &lt;reference path="../../common/getMappedDomainElement.ts" /&gt;
function exposeAsHttpEndPoint(request) {
    var _a, _b;
    const domainElement = getMappedDomainElement(request);
    // Add the folder parts
    const routeParts = [];
    const defaultRoutePrefixParts = getDefaultRoutePrefix(false).split("/");
    routeParts.push(...defaultRoutePrefixParts);
    routeParts.push(...getFolderParts(request, domainElement));
    if (domainElement != null) {
        routeParts.push(...getRouteParts(request, domainElement));
    }
    else if (!["Get", "Find", "Lookup"].some(x =&gt; request.getName().startsWith(x))) {
        routeParts.push(toKebabCase(removeSuffix(request.getName(), "Request", "Query")));
    }
    let endpointInputIdElement = request.getChildren().filter(x =&gt; x.hasMetadata("endpoint-input-id"))[0];
    if (endpointInputIdElement) {
        routeParts.push(`{${toCamelCase(endpointInputIdElement.getName())}}`);
    }
    const httpSettingsId = "b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6";
    const httpSettings = (_a = request.getStereotype(httpSettingsId)) !== null &amp;&amp; _a !== void 0 ? _a : request.addStereotype(httpSettingsId);
    httpSettings.getProperty("Verb").setValue("GET");
    httpSettings.getProperty("Route").setValue(routeParts.join("/"));
    const httpSettingsMediatypeId = "4490e212-1e99-43ce-b3dd-048ed2a6bae8";
    if (((_b = request.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "Type-Definition") {
        httpSettings.getProperty(httpSettingsMediatypeId).setValue("application/json");
    }
}
/// &lt;reference path="shared.ts" /&gt;
/**
 * Used by Intent.Modules\Modules\Intent.Metadata.WebApi
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/services-expose-as-http-endpoint/query/expose-as-http-endpoint.ts
 */
exposeAsHttpEndPoint(element);
</script>
        </option>
        <option>
          <text>Expose as Http File Download</text>
          <icon type="FontAwesome" source="file-download" />
          <script>/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function makeReturnTypeFileDownloadDto(element) {
    var _a;
    const commonTypes = {
        string: "d384db9c-a279-45e1-801e-e4e8099625f2",
        stream: "fd4ead8e-92e9-47c2-97a6-81d898525ea0"
    };
    let returnResultType = lookupTypesOf("DTO").find(x =&gt; x.getName() == "FileDownloadDto");
    if (!returnResultType) {
        let folderName = "Common";
        const folder = (_a = element.getPackage().getChildren("Folder").find(x =&gt; x.getName() == folderName)) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Folder", folderName, element.getPackage().id);
        returnResultType = createElement("DTO", "FileDownloadDto", folder.id);
        returnResultType.id;
        let stream = createElement("DTO-Field", "Content", returnResultType.id);
        stream.typeReference.setType(commonTypes.stream);
        let filename = createElement("DTO-Field", "Filename", returnResultType.id);
        filename.typeReference.setType(commonTypes.string);
        filename.typeReference.setIsNullable(true);
        let contentType = createElement("DTO-Field", "ContentType", returnResultType.id);
        contentType.typeReference.setType(commonTypes.string);
        contentType.typeReference.setIsNullable(true);
    }
    element.typeReference.setType(returnResultType.id);
    element.typeReference.setIsCollection(false);
    element.typeReference.setIsNullable(false);
}
function applyFileTransferStereoType(element) {
    var _a;
    const fileTransferId = "d30e48e8-389e-4b70-84fd-e3bac44cfe19";
    (_a = element.getStereotype(fileTransferId)) !== null &amp;&amp; _a !== void 0 ? _a : element.addStereotype(fileTransferId);
}
function addUploadFields(element, childType) {
    const commonTypes = {
        string: "d384db9c-a279-45e1-801e-e4e8099625f2",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        stream: "fd4ead8e-92e9-47c2-97a6-81d898525ea0"
    };
    const parameterSettingId = "d01df110-1208-4af8-a913-92a49d219552";
    var existing = element.getChildren().find(x =&gt; x.getName() == "Content");
    if (!existing) {
        let stream = createElement(childType, "Content", element.id);
        stream.typeReference.setType(commonTypes.stream);
    }
    var existing = element.getChildren().find(x =&gt; x.getName() == "Filename");
    if (!existing) {
        let filename = createElement(childType, "Filename", element.id);
        filename.typeReference.setType(commonTypes.string);
        filename.typeReference.setIsNullable(true);
        let parameterSetting = filename.addStereotype(parameterSettingId);
    }
    var existing = element.getChildren().find(x =&gt; x.getName() == "ContentType");
    if (!existing) {
        let contentType = createElement(childType, "ContentType", element.id);
        contentType.typeReference.setType(commonTypes.string);
        contentType.typeReference.setIsNullable(true);
        let parameterSetting = contentType.addStereotype(parameterSettingId);
        parameterSetting.getProperty("Source").setValue("From Header");
        parameterSetting.getProperty("Header Name").setValue("Content-Type");
    }
    var existing = element.getChildren().find(x =&gt; x.getName() == "ContentLength");
    if (!existing) {
        let contentType = createElement(childType, "ContentLength", element.id);
        contentType.typeReference.setType(commonTypes.long);
        contentType.typeReference.setIsNullable(true);
        let parameterSetting = contentType.addStereotype(parameterSettingId);
        parameterSetting.getProperty("Source").setValue("From Header");
        parameterSetting.getProperty("Header Name").setValue("Content-Length");
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function getFolderParts(request, entity, owningEntity) {
    let depth = 0;
    let currentElement = request.getParent();
    let folderParts = [];
    while (currentElement.specialization === "Folder") {
        let folderName = currentElement.getName();
        if (depth === 0 &amp;&amp; entity != null) {
            const singularizedFolderName = singularize(folderName);
            const singularizedAggregateRootName = singularize((owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity).getName());
            if (singularizedFolderName.toLowerCase() === singularizedAggregateRootName.toLowerCase()) {
                folderName = singularizedFolderName;
            }
        }
        folderParts.unshift(toKebabCase(folderName));
        currentElement = currentElement.getParent();
        depth++;
    }
    return folderParts;
}
/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        if (Object.keys(primaryKeys).length == 0) {
            return [
                {
                    id: null,
                    name: DomainHelper.getAttributeNameFormat("Id"),
                    typeId: DomainHelper.getSurrogateKeyType(),
                    mapPath: null,
                    isNullable: false,
                    isCollection: false
                }
            ];
        }
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        if (foreignKeys.length &gt; 0) {
            return foreignKeys.map(x =&gt; ({
                name: DomainHelper.getAttributeNameFormat(x.getName()),
                typeId: x.typeReference.typeId,
                id: x.id,
                mapPath: [x.id],
                isCollection: x.typeReference.isCollection,
                isNullable: x.typeReference.isNullable,
                element: x
            }));
        }
        // Implicit FKs:
        return [{
                name: DomainHelper.getAttributeNameFormat(`${owningAggregate.getName()}Id`),
                typeId: DomainHelper.getPrimaryKeys(owningAggregate)[0].typeId,
                id: null,
                mapPath: null,
                isCollection: false,
                isNullable: false
            }];
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(command, settings) {
        var _a;
        this.command = command;
        this.settings = settings;
        this.mappedElement = (_a = command.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.command.id; }
    ;
    setReturnType(typeId, isCollection) {
        this.command.typeReference.setType(typeId);
        if (isCollection != null) {
            this.command.typeReference.setIsCollection(isCollection);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.command.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.command.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.command;
    }
    collapse() {
        this.command.collapse();
    }
}
/**
 * Workaround for element's from referenced packages not having getParent()
 * @param element The element whose parent should be searched for
 * @param parentSpecializationType The specialization type of the parent
 */
function getParent(element, parentSpecializationType) {
    const elements = lookupTypesOf(parentSpecializationType);
    const parent = elements
        .find(x =&gt; x.getChildren(element.specialization)
        .some(child =&gt; child.id === element.id));
    if (parent == null) {
        throw new Error("Could not find parent");
    }
    return parent;
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
/// &lt;reference path="../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/getParent.ts" /&gt;
/**
 * Gets select details of a mapped Command/Query. Intended for centralized logic of working out
 * things like keys (including implicit ones) for both the entity and owning entity if applicable.
 *
 * If the Command is for entity creation (either due to being mapped to a constructor or being
 * prefixed with "Create"), then primary keys for the entity are not populated.
 * @param request The Command or Query that has been mapped
 */
function getMappedRequestDetails(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    // Advanced mapping:
    if (mappedElement == null) {
        const advancedMappings = request.getAssociations()
            .filter(x =&gt; x.hasMappings(queryEntityMappingTypeId) ||
            x.hasMappings(createEntityMappingTypeId))
            .map(x =&gt; x.getMapping(queryEntityMappingTypeId) ||
            x.getMapping(createEntityMappingTypeId));
        if (advancedMappings.length === 1) {
            mappedElement = advancedMappings[0].getTargetElement();
        }
    }
    if (mappedElement == null) {
        return null;
    }
    let entity = mappedElement;
    if (entity.specialization !== "Class") {
        entity = getParent(entity, "Class");
    }
    const result = {
        entity: entity,
        mappingTargetType: mappedElement.specialization,
        entityKeyFields: [],
        ownerKeyFields: []
    };
    result.owningEntity = DomainHelper.getOwningAggregate(entity);
    // As long as it's not for creation, populate the PKs of the entity:
    if (result.mappingTargetType !== "Class Constructor" &amp;&amp;
        !request.getName().toLowerCase().startsWith("Create")) {
        result.entityKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity)
            : getKeysForOperationMapping(request, entity);
    }
    // If the entity is owned, populate its fields:
    if (result.owningEntity != null) {
        result.ownerKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity, result.owningEntity)
            : getKeysForOperationMapping(request, entity, result.owningEntity);
    }
    return result;
    /**
     * Return field details for primary keys. As requests mapped to operations and constructors can
     * never possibly map the attributes, these fields can only ever be matched by name.
     * @param request The CQRS Command or Query entity
     * @param owningEntity The Owning Aggregate Class
     */
    function getKeysForOperationMapping(request, entity, owningEntity) {
        const pks = DomainHelper.getPrimaryKeys(owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity);
        return pks.map(pk =&gt; {
            let fieldName = toPascalCase(pk.name);
            if (owningEntity != null) {
                fieldName = removePrefix(fieldName, toPascalCase(owningEntity.getName()));
                fieldName = `${owningEntity.getName()}${toCamelCase(fieldName)}`;
            }
            fieldName = ServicesHelper.getFieldFormat(fieldName);
            const existingField = request.getChildren("DTO-Field").find(field =&gt; field.getName().toLowerCase() == fieldName.toLowerCase());
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: [],
                name: fieldName,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
    function getKeysForClassMapping(request, entity, owningEntity) {
        const keys = owningEntity != null
            ? DomainHelper.getForeignKeys(entity, owningEntity)
            : DomainHelper.getPrimaryKeys(entity);
        return keys.map(pk =&gt; {
            const existingField = request.getChildren("DTO-Field").find(field =&gt; {
                if (field.getMapping() != null) {
                    return field.getMapping().getPath().some(x =&gt; x.id == pk.id);
                }
                return (pk.name.toLowerCase() === field.getName().toLowerCase());
            });
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: pk.mapPath,
                name: pk.name,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
function getRouteParts(request, entity, owningEntity) {
    var _a;
    if (entity == null) {
        throw new Error("entity is required");
    }
    const routeParts = [];
    // Basic mapping:
    const mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    if (mappedElement != null) {
        const mappedDetails = getMappedRequestDetails(request);
        // Add the owning entity's ids as parts surrounded with curly braces
        if (owningEntity != null) {
            routeParts.push(...mappedDetails.ownerKeyFields
                .filter(x =&gt; x.existingId != null)
                .map(x =&gt; {
                const field = request
                    .getChildren("DTO-Field")
                    .find(field =&gt; field.id === x.existingId);
                return `{${toCamelCase(field.getName())}}`;
            }));
            // Add a part for name of the owned entity
            routeParts.push(toKebabCase(singularize(entity.getName())));
        }
        // Add the entity's ids as parts surrounded with curly braces
        routeParts.push(...mappedDetails.entityKeyFields
            .filter(x =&gt; x.existingId != null)
            .map(x =&gt; {
            const field = request
                .getChildren("DTO-Field")
                .find(field =&gt; field.id === x.existingId);
            return `{${toCamelCase(field.getName())}}`;
        }));
        // Add the operation's name:
        if (mappedDetails.mappingTargetType === "Operation") {
            const entityName = entity.getName();
            let routePart = removePrefix(mappedElement.getName(), "Create", "Update", "Delete", "Add", "Remove");
            routePart = removeSuffix(routePart, "Request", "Query", "Command");
            routeParts.push(removePrefix(toKebabCase(routePart), toKebabCase(singularize(entityName)), toKebabCase(entityName), "-"));
        }
        return routeParts;
    }
    // Advanced mapping:
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    const updateEntityMappingTypeId = "01721b1a-a85d-4320-a5cd-8bd39247196a";
    const mappingTypeIds = [queryEntityMappingTypeId, createEntityMappingTypeId, updateEntityMappingTypeId];
    const associationWithMapping = request
        .getAssociations()
        .find(association =&gt; association.hasMappings() &amp;&amp; association
        .getMappings()
        .every(mapping =&gt; {
        if (!mappingTypeIds.includes(mapping.mappingTypeId)) {
            return false;
        }
        let element = mapping.getTargetElement();
        while (element != null) {
            if (element.specialization === "Class") {
                break;
            }
            element = getParent(element, "Class");
        }
        if (element == null) {
            return false;
        }
        return element.id === entity.id;
    }));
    if (associationWithMapping != null) {
        const mappings = associationWithMapping.getMappings();
        const queryMapping = mappings.find(x =&gt; x.mappingTypeId === queryEntityMappingTypeId);
        const createMapping = mappings.find(x =&gt; x.mappingTypeId === createEntityMappingTypeId);
        const updateMapping = mappings.find(x =&gt; x.mappingTypeId === updateEntityMappingTypeId);
        // Add the owning entity's ids as parts surrounded with curly braces
        if (owningEntity != null) {
            if (queryMapping != null) {
                let applicableClassIds = getEntityInheritanceHierarchyIds(owningEntity);
                routeParts.push(...queryMapping.getMappedEnds()
                    .filter(end =&gt; applicableClassIds.some(x =&gt; x === getParent(end.getTargetElement(), "Class").id))
                    .map(x =&gt; `{${toCamelCase(x.getSourceElement().getName())}}`));
            }
            // Add a part for name of the owned entity
            routeParts.push(toKebabCase(singularize(entity.getName())));
        }
        // Add the entity's ids as parts surrounded with curly braces
        if (queryMapping != null) {
            let applicableClassIds = getEntityInheritanceHierarchyIds(entity);
            routeParts.push(...queryMapping.getMappedEnds()
                .filter(end =&gt; applicableClassIds.some(x =&gt; x === getParent(end.getTargetElement(), "Class").id))
                .map(x =&gt; `{${toCamelCase(x.getSourceElement().getName())}}`));
        }
        // Add the operation's name:
        const mapping = createMapping !== null &amp;&amp; createMapping !== void 0 ? createMapping : updateMapping;
        if (mapping == null) {
            return routeParts;
        }
        var mappingEnd = mapping.getMappedEnds().find(x =&gt; x.getSourceElement().id === request.id);
        if (mappingEnd == null) {
            return routeParts;
        }
        const mappedElement = mappingEnd.getTargetElement();
        if ((mappedElement === null || mappedElement === void 0 ? void 0 : mappedElement.specialization) === "Operation") {
            const entityName = entity.getName();
            let routePart = removePrefix(mappedElement.getName(), "Create", "Update", "Delete", "Add", "Remove");
            routePart = removeSuffix(routePart, "Request", "Query", "Command");
            routeParts.push(removePrefix(toKebabCase(routePart), toKebabCase(singularize(entityName)), toKebabCase(entityName), "-"));
        }
        return routeParts;
    }
    return routeParts;
    function getEntityInheritanceHierarchyIds(curEntity) {
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return [curEntity.id];
        }
        let other = getEntityInheritanceHierarchyIds(generalizations[0].typeReference.getType());
        return other.concat(curEntity.id);
    }
}
function getDefaultRoutePrefix(includeLastPathSeparator) {
    var _a;
    const defaultApiRoutePrefix = "api/";
    const apiSettingsId = "4bd0b4e9-7b53-42a9-bb4a-277abb92a0eb";
    let settingsGroup = application.getSettings(apiSettingsId);
    if (!settingsGroup) {
        return defaultApiRoutePrefix;
    }
    let field = settingsGroup.getField("Default API Route Prefix");
    if (!field) {
        return defaultApiRoutePrefix;
    }
    let route = (_a = field.value) !== null &amp;&amp; _a !== void 0 ? _a : "";
    if (includeLastPathSeparator &amp;&amp; !route.endsWith("/")) {
        route += "/";
    }
    else if (!includeLastPathSeparator &amp;&amp; route.endsWith("/")) {
        route = removeSuffix(route, "/");
    }
    return route;
}
/// &lt;reference path="domainHelper.ts" /&gt;
/// &lt;reference path="getParent.ts" /&gt;
/**
 * Gets the ultimate target entity and it's owning entity (if it has one) of a mapped Command/Query.
 * @param request The Command or Query that has been mapped
 */
function getMappedEntity(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    const mappingTypeIds = [queryEntityMappingTypeId, createEntityMappingTypeId];
    let entity = null;
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    if (mappedElement != null) {
        let element = mappedElement;
        while (element != null) {
            if ((element === null || element === void 0 ? void 0 : element.specialization) === "Class") {
                entity = element;
                break;
            }
            element = getParent(element, "Class");
        }
    }
    // Advanced mappings:
    if (mappedElement == null) {
        const targetEntities = request.getAssociations()
            .flatMap(association =&gt; association.getMappings()
            .filter(mapping =&gt; mappingTypeIds.some(y =&gt; mapping.mappingTypeId == y))
            .map(mapping =&gt; {
            let element = mapping.getTargetElement();
            while (element != null) {
                if (element.specialization === "Class") {
                    return element;
                }
                element = getParent(element, "Class");
            }
            return null;
        })
            .filter(entity =&gt; entity != null));
        // Only if all the targetClasses are the same:
        if (targetEntities.length &gt; 0 &amp;&amp; targetEntities.every(x =&gt; x.id === targetEntities[0].id)) {
            entity = targetEntities[0];
        }
    }
    if (entity == null) {
        return {};
    }
    return {
        entity: entity,
        owningEntity: DomainHelper.getOwningAggregate(entity)
    };
}
/// &lt;reference path="../_common/getFolderParts.ts" /&gt;
/// &lt;reference path="../_common/getRouteParts.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/// &lt;reference path="../_common/getDefaultRoutePrefix.ts" /&gt;
/// &lt;reference path="../../common/getMappedEntity.ts" /&gt;
function exposeAsHttpEndPoint(request) {
    var _a;
    const { entity, owningEntity } = getMappedEntity(request);
    // Add the folder parts
    const routeParts = [];
    const defaultRoutePrefixParts = getDefaultRoutePrefix(false).split("/");
    routeParts.push(...defaultRoutePrefixParts);
    routeParts.push(...getFolderParts(request, entity, owningEntity));
    if (entity != null) {
        routeParts.push(...getRouteParts(request, entity, owningEntity));
    }
    else if (!["Get", "Find", "Lookup"].some(x =&gt; request.getName().startsWith(x))) {
        routeParts.push(toKebabCase(removeSuffix(request.getName(), "Request", "Query")));
    }
    const httpSettingsId = "b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6";
    const httpSettings = (_a = request.getStereotype(httpSettingsId)) !== null &amp;&amp; _a !== void 0 ? _a : request.addStereotype(httpSettingsId);
    httpSettings.getProperty("Verb").setValue("GET");
    httpSettings.getProperty("Route").setValue(routeParts.join("/"));
}
/// &lt;reference path="../common/common-file-transfer.ts" /&gt;
/// &lt;reference path="../../services-expose-as-http-endpoint/query/shared.ts" /&gt;
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.WebApi
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/expose-as-file-download-query/expose-as-file-download-query.ts
 */
function configureDownload(element) {
    applyFileTransferStereoType(element);
    makeReturnTypeFileDownloadDto(element);
    exposeAsHttpEndPoint(element);
}
configureDownload(element);
</script>
        </option>
      </scriptOptions>
      <mappingOptions />
      <typeOrder />
      <mappingSettings />
      <macros>
        <macro trigger="on-changed">
          <script>function execute() {
    const apiVersionStereotypeId = "20855f03-c663-4ec6-b106-de06be98f1fe";
    const httpSettingsStereotypeId = "b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6";

    let route = element.getStereotype(httpSettingsStereotypeId)?.getProperty("Route")?.getValue();

    if (!element.hasStereotype(apiVersionStereotypeId) &amp;&amp; route?.indexOf("{version}") &gt;= 0) {
        // Api version Stereotype removed
        route = route.replace("{version}/", "");
        element.getStereotype(httpSettingsStereotypeId).getProperty("Route").setValue(route);
        return;
    }

    if (element.hasStereotype(apiVersionStereotypeId) &amp;&amp; route?.indexOf("{version}") &lt; 0) {
        // Api version Stereotype added
        let defaultRoutePrefix = getDefaultRoutePrefix(false);
        let startIndex = route.indexOf(defaultRoutePrefix);
        if (startIndex == 0) {
            route = `${defaultRoutePrefix}/{version}/${(route.substring(defaultRoutePrefix.length+1))}`;
        } else {
            route = `{version}/${(route)}`;
        }
        element.getStereotype(httpSettingsStereotypeId).getProperty("Route").setValue(route);
        return;
    }
}

function getDefaultRoutePrefix(includeLastPathSeparator) {
    const defaultApiRoutePrefix = "api/";
    const apiSettingsId = "4bd0b4e9-7b53-42a9-bb4a-277abb92a0eb";

    let settingsGroup = application.getSettings(apiSettingsId);
    if (!settingsGroup) { return defaultApiRoutePrefix; }
    
    let field = settingsGroup.getField("Default API Route Prefix");
    if (!field) { return defaultApiRoutePrefix; }
    
    let route = field.value ?? "";

    if (includeLastPathSeparator &amp;&amp; !route.endsWith("/")) {
        route += "/";
    } else if (!includeLastPathSeparator &amp;&amp; route.endsWith("/")) {
        route = removeSuffix(route, "/");
    }

    return route;
}

execute();</script>
        </macro>
      </macros>
    </elementExtension>
  </elementExtensions>
  <associationSettings />
  <associationExtensions />
  <mappingSettings />
  <mappableElementPackages />
  <mappableElementPackageExtensions />
  <scripts />
</settings>