<?xml version="1.0" encoding="utf-8"?>
<class id="ff90bc13-1a5c-4317-aa43-5ac02720f17c" type="Element Extension" typeId="e3c7b1ca-f080-45c1-b56f-8d44226c8e20">
  <name>Service Proxy Operation Extension</name>
  <display>Service Proxy Operation Extension: Operation</display>
  <isAbstract>false</isAbstract>
  <sort-children>by-type-then-manually</sort-children>
  <genericTypes />
  <typeReference id="c6fa9506-3d13-4c63-bf69-dcf4b34ac109">
    <typeId>aee6811e-b2f6-4562-a8eb-502029f63bc8</typeId>
    <isNavigable>true</isNavigable>
    <isNullable>false</isNullable>
    <isCollection>false</isCollection>
    <isRequired>true</isRequired>
    <typePackageName>Intent.Modelers.Types.ServiceProxies</typePackageName>
    <typePackageId>b58a9e76-55b8-45ec-a22b-bcdfcb6fd833</typePackageId>
    <stereotypes />
    <genericTypeParameters />
  </typeReference>
  <isMapped>false</isMapped>
  <parentFolderId>c42185b8-f247-42a6-9006-a968ffcf0c12</parentFolderId>
  <packageId>53353621-7752-4a01-90f3-cd2e83ec19a4</packageId>
  <packageName>Intent.Modelers.Services.ProxyInteractions</packageName>
  <stereotypes>
    <stereotype stereotypeDefinitionId="159cbc8e-a910-40f7-8e45-3edadbb863c2" name="Type Reference Extension Settings">
      <addedByDefault>true</addedByDefault>
      <definitionPackageName>Intent.ModuleBuilder</definitionPackageName>
      <definitionPackageId>9972b2a9-b749-4bba-b5c8-824bf694c6ef</definitionPackageId>
      <properties>
        <property name="35226a83-3965-4224-8aef-20c68a0c5180" display="Mode" value="Inherit" isActive="true" />
        <property name="7d3859d4-084d-4ff0-8b31-850b4a8f8cd0" display="Display Name" isActive="false" />
        <property name="17223dbd-8df0-4700-8b81-02274ca3ed7f" display="Hint" isActive="false" />
        <property name="b2cef034-5706-45d2-8554-f4dc582a18ff" display="Target Types" value="null" isActive="false" />
        <property name="08ec0581-c90a-489b-858f-ee265327c948" display="Target Traits" isActive="true" />
        <property name="93e4efa9-186d-4e88-ae0a-491bcd6e6f5e" display="Default Type Id" isActive="false" />
        <property name="7a0c4185-1c08-4d3e-9185-14683d7a3bd0" display="Allow Collection" value="Inherit" isActive="false" />
        <property name="e3dc90ec-4f5f-4f20-b271-e28a5094dc91" display="Allow Nullable" value="Inherit" isActive="false" />
      </properties>
    </stereotype>
    <stereotype stereotypeDefinitionId="312eab00-f6db-492e-bbb4-e41383c8d3d8" name="Extension Settings">
      <addedByDefault>true</addedByDefault>
      <definitionPackageName>Intent.ModuleBuilder</definitionPackageName>
      <definitionPackageId>9972b2a9-b749-4bba-b5c8-824bf694c6ef</definitionPackageId>
      <properties>
        <property name="8c964307-9d03-4a14-9fd3-40ea2607955a" display="Display Text Function" value="" isActive="true" />
        <property name="996ed45f-2318-4587-9618-73db3d7cfed0" display="Validate Function" value="" isActive="true" />
      </properties>
    </stereotype>
  </stereotypes>
  <metadata />
  <childElements>
    <childElement id="3fd774ec-4792-4640-830a-6d67de20bf81" type="Context Menu" typeId="d45e383d-90ba-4b64-aca7-34ca100cea21">
      <name>[context menu]</name>
      <display>[context menu]</display>
      <isAbstract>false</isAbstract>
      <sort-children>manually</sort-children>
      <genericTypes />
      <isMapped>false</isMapped>
      <parentFolderId>ff90bc13-1a5c-4317-aa43-5ac02720f17c</parentFolderId>
      <packageId>53353621-7752-4a01-90f3-cd2e83ec19a4</packageId>
      <packageName>Intent.Modelers.Services.ProxyInteractions</packageName>
      <stereotypes />
      <metadata />
      <childElements>
        <childElement id="600bb8e7-23db-4daf-ac67-9c30100a509d" type="Run Script Option" typeId="345d46fb-c500-409a-88c7-26720572c9af">
          <name>Create CQRS Operation</name>
          <display>Create CQRS Operation: Inline Script</display>
          <isAbstract>false</isAbstract>
          <genericTypes />
          <typeReference id="42cfb19e-6244-42a1-8328-0ea1fae57cc5">
            <typeId>043eee26-1591-42ac-9f2c-fc911b070eb1</typeId>
            <isNavigable>true</isNavigable>
            <isNullable>false</isNullable>
            <isCollection>false</isCollection>
            <isRequired>true</isRequired>
            <typePackageName>Intent.ModuleBuilder</typePackageName>
            <typePackageId>9972b2a9-b749-4bba-b5c8-824bf694c6ef</typePackageId>
            <stereotypes />
            <genericTypeParameters />
          </typeReference>
          <isMapped>false</isMapped>
          <parentFolderId>3fd774ec-4792-4640-830a-6d67de20bf81</parentFolderId>
          <packageId>53353621-7752-4a01-90f3-cd2e83ec19a4</packageId>
          <packageName>Intent.Modelers.Services.ProxyInteractions</packageName>
          <stereotypes>
            <stereotype stereotypeDefinitionId="56bc0465-c1fe-4bca-9493-2a3ce88a4047" name="Script Settings">
              <addedByDefault>true</addedByDefault>
              <definitionPackageName>Intent.ModuleBuilder</definitionPackageName>
              <definitionPackageId>9972b2a9-b749-4bba-b5c8-824bf694c6ef</definitionPackageId>
              <properties>
                <property name="73a4088f-626e-4d31-b0b2-113167f015b2" display="Script" value="/// &lt;reference path=&quot;../../typings/elementmacro.context.api.d.ts&quot; /&gt;&#xD;&#xA;function getPackageSelectItemOptions(packages, packageTypeName) {&#xD;&#xA;    return {&#xD;&#xA;        items: packages,&#xD;&#xA;        getId(item) {&#xD;&#xA;            return item.id;&#xD;&#xA;        },&#xD;&#xA;        getDisplayName(item) {&#xD;&#xA;            return item.getName();&#xD;&#xA;        },&#xD;&#xA;        getItemNotFoundMessage(itemId) {&#xD;&#xA;            return `No ${packageTypeName} found with id &quot;${itemId}&quot;.`;&#xD;&#xA;        },&#xD;&#xA;        getNoItemsFoundMessage() {&#xD;&#xA;            return `No packages of type ${packageTypeName} could be found.`;&#xD;&#xA;        },&#xD;&#xA;    };&#xD;&#xA;}&#xD;&#xA;function getElementSelectItemOptions(elements, elementTypeName, relevantPackageTypeName) {&#xD;&#xA;    return {&#xD;&#xA;        items: elements,&#xD;&#xA;        getId(item) {&#xD;&#xA;            return item.id;&#xD;&#xA;        },&#xD;&#xA;        getDisplayName(item) {&#xD;&#xA;            return item.getName();&#xD;&#xA;        },&#xD;&#xA;        getItemNotFoundMessage(itemId) {&#xD;&#xA;            return `No &quot;${elementTypeName}&quot; found with id &quot;${itemId}&quot;.`;&#xD;&#xA;        },&#xD;&#xA;        getNoItemsFoundMessage() {&#xD;&#xA;            return `No Elements of type &quot;${elementTypeName}&quot; could be found. Please ensure that you have a reference to the ${relevantPackageTypeName} package and that at least one ${elementTypeName} exists in it.`;&#xD;&#xA;        },&#xD;&#xA;    };&#xD;&#xA;}&#xD;&#xA;/**&#xD;&#xA; * Dialog selection.&#xD;&#xA; * @param options For simplicity, use getPackageSelectItemOptions() or getElementSelectItemOptions()&#xD;&#xA; * @returns Selected item.&#xD;&#xA; */&#xD;&#xA;async function openSelectItemDialog(options) {&#xD;&#xA;    if (!options) {&#xD;&#xA;        throw new Error(&quot;Options are required for 'openSelectItemDialog'.&quot;);&#xD;&#xA;    }&#xD;&#xA;    let items = options.items;&#xD;&#xA;    if (items.length == 0) {&#xD;&#xA;        await dialogService.info(options.getNoItemsFoundMessage());&#xD;&#xA;        return null;&#xD;&#xA;    }&#xD;&#xA;    let itemId = await dialogService.lookupFromOptions(items.map(item =&gt; ({&#xD;&#xA;        id: options.getId(item),&#xD;&#xA;        name: options.getDisplayName(item)&#xD;&#xA;    })));&#xD;&#xA;    if (itemId == null) {&#xD;&#xA;        await dialogService.error(options.getItemNotFoundMessage(itemId));&#xD;&#xA;        return null;&#xD;&#xA;    }&#xD;&#xA;    let foundItem = items.filter(item =&gt; options.getId(item) === itemId)[0];&#xD;&#xA;    return foundItem;&#xD;&#xA;}&#xD;&#xA;;&#xD;&#xA;/// &lt;reference path=&quot;attributeWithMapPath.ts&quot; /&gt;&#xD;&#xA;class ServicesConstants {&#xD;&#xA;}&#xD;&#xA;ServicesConstants.dtoToEntityMappingId = &quot;942eae46-49f1-450e-9274-a92d40ac35fa&quot;; //&quot;01d74d4f-e478-4fde-a2f0-9ea92255f3c5&quot;;&#xD;&#xA;ServicesConstants.dtoFromEntityMappingId = &quot;1f747d14-681c-4a20-8c68-34223f41b825&quot;;&#xD;&#xA;ServicesConstants.dtoToDomainOperation = &quot;8d1f6a8a-77c8-43a2-8e60-421559725419&quot;;&#xD;&#xA;class ServicesHelper {&#xD;&#xA;    static addDtoFieldsFromDomain(dto, attributes) {&#xD;&#xA;        for (let key of attributes) {&#xD;&#xA;            if (dto &amp;&amp; !dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {&#xD;&#xA;                let field = createElement(&quot;DTO-Field&quot;, ServicesHelper.getFieldFormat(key.name), dto.id);&#xD;&#xA;                field.typeReference.setType(key.typeId);&#xD;&#xA;                if ((key.mapPath ?? []).length &gt; 0) {&#xD;&#xA;                    field.setMapping(key.mapPath);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getParameterFormat(str) {&#xD;&#xA;        return toCamelCase(str);&#xD;&#xA;    }&#xD;&#xA;    static getRoutingFormat(str) {&#xD;&#xA;        return pluralize(str);&#xD;&#xA;    }&#xD;&#xA;    static getFieldFormat(str) {&#xD;&#xA;        return toPascalCase(str);&#xD;&#xA;    }&#xD;&#xA;    static formatName(str, type) {&#xD;&#xA;        switch (type) {&#xD;&#xA;            case &quot;property&quot;:&#xD;&#xA;            case &quot;class&quot;:&#xD;&#xA;                return toPascalCase(str);&#xD;&#xA;            case &quot;parameter&quot;:&#xD;&#xA;                return toCamelCase(str);&#xD;&#xA;            default:&#xD;&#xA;                return str;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/**&#xD;&#xA; * Helper class to build up source and target mapping paths for&#xD;&#xA; * advanced mapping scenarios.&#xD;&#xA; *&#xD;&#xA; * @remarks&#xD;&#xA; *&#xD;&#xA; * Source Path and Target Path is maintained separately since not all mapping scenarios are&#xD;&#xA; * straightforward.&#xD;&#xA; *&#xD;&#xA; * @example&#xD;&#xA; *&#xD;&#xA; * When to Push/Pop the Paths&#xD;&#xA; *&#xD;&#xA;    let leftField = createField(...);&#xD;&#xA;&#xD;&#xA;    mappingStore.pushSourcePath(leftField.id);&#xD;&#xA;    mappingStore.pushTargetPath(rightField.id);&#xD;&#xA;&#xD;&#xA;    let leftFieldDto = replicateDto(rightField.typeReference.getType(), folder, mappingStore);&#xD;&#xA;&#xD;&#xA;    mappingStore.popSourcePath();&#xD;&#xA;    mappingStore.popTargetPath();&#xD;&#xA;&#xD;&#xA;    leftField.typeReference.setType(leftFieldDto.id);&#xD;&#xA; *&#xD;&#xA; * Adding mappings&#xD;&#xA; *&#xD;&#xA;    function replicateDto(existingDto: MacroApi.Context.IElementApi, ...) {&#xD;&#xA;        let newDto = createElement(&quot;DTO&quot;, existingDto.getName(), folder.id);&#xD;&#xA;        existingDto.getChildren(&quot;DTO-Field&quot;).forEach(existingField =&gt; {&#xD;&#xA;            let newField = createElement(&quot;DTO-Field&quot;, existingField.getName(), newDto.id);&#xD;&#xA;            // ...&#xD;&#xA;            mappingStore.addMapping(newField.id, existingField.id);&#xD;&#xA;            // ...&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA; */&#xD;&#xA;class MappingStore {&#xD;&#xA;    constructor() {&#xD;&#xA;        this.mappings = [];&#xD;&#xA;        this.sourcePath = [];&#xD;&#xA;        this.targetPath = [];&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Get all the recorded mapping entries&#xD;&#xA;     */&#xD;&#xA;    getMappings() {&#xD;&#xA;        return this.mappings;&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Keep track of this element id on the source end&#xD;&#xA;     * when navigating inside it's type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    pushSourcePath(id) {&#xD;&#xA;        this.sourcePath.push(id);&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Remove the last tracked element on the source path stack&#xD;&#xA;     * when done navigating down its type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    popSourcePath() {&#xD;&#xA;        this.sourcePath.pop();&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Keep track of this element id on the target end&#xD;&#xA;     * when navigating inside it's type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    pushTargetPath(id) {&#xD;&#xA;        this.targetPath.push(id);&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Remove the last tracked element on the target path stack&#xD;&#xA;     * when done navigating down its type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    popTargetPath() {&#xD;&#xA;        this.targetPath.pop();&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Record a mapping between a source element id and target element id.&#xD;&#xA;     * Target and Source path stack will be used to build up the whole path.&#xD;&#xA;     */&#xD;&#xA;    addMapping(sourceId, targetId) {&#xD;&#xA;        this.mappings.push({&#xD;&#xA;            sourcePath: this.sourcePath.concat([sourceId]),&#xD;&#xA;            targetPath: this.targetPath.concat([targetId])&#xD;&#xA;        });&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;class ElementManager {&#xD;&#xA;    constructor(innerElement, settings) {&#xD;&#xA;        this.innerElement = innerElement;&#xD;&#xA;        this.settings = settings;&#xD;&#xA;        this.mappedElement = innerElement.getMapping()?.getElement();&#xD;&#xA;    }&#xD;&#xA;    get id() { return this.innerElement.id; }&#xD;&#xA;    ;&#xD;&#xA;    setReturnType(typeId, isCollection, isNullable) {&#xD;&#xA;        this.innerElement.typeReference.setType(typeId);&#xD;&#xA;        if (isCollection != null) {&#xD;&#xA;            this.innerElement.typeReference.setIsCollection(isCollection);&#xD;&#xA;        }&#xD;&#xA;        if (isNullable != null) {&#xD;&#xA;            this.innerElement.typeReference.setIsNullable(isNullable);&#xD;&#xA;        }&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;    addChild(name, type) {&#xD;&#xA;        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, this.settings.childType ?? &quot;property&quot;), this.innerElement.id);&#xD;&#xA;        const typeReferenceDetails = type == null&#xD;&#xA;            ? null&#xD;&#xA;            : typeof (type) === &quot;string&quot;&#xD;&#xA;                ? { id: type, isNullable: false, isCollection: false }&#xD;&#xA;                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };&#xD;&#xA;        if (typeReferenceDetails != null) {&#xD;&#xA;            field.typeReference.setType(typeReferenceDetails.id);&#xD;&#xA;            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);&#xD;&#xA;            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);&#xD;&#xA;        }&#xD;&#xA;        return field;&#xD;&#xA;    }&#xD;&#xA;    addChildrenFrom(elements, options) {&#xD;&#xA;        let order = 0;&#xD;&#xA;        elements.forEach(e =&gt; {&#xD;&#xA;            if (e.mapPath != null) {&#xD;&#xA;                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let field = this.addChild(e.name, e.typeId);&#xD;&#xA;            field.typeReference.setIsCollection(e.isCollection);&#xD;&#xA;            field.typeReference.setIsNullable(e.isNullable);&#xD;&#xA;            if (options?.addToTop) {&#xD;&#xA;                field.setOrder(order++);&#xD;&#xA;            }&#xD;&#xA;            if (this.mappedElement != null &amp;&amp; e.mapPath) {&#xD;&#xA;                field.setMapping(e.mapPath);&#xD;&#xA;            }&#xD;&#xA;        });&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;    mapToElement(param1, mappingSettingsId) {&#xD;&#xA;        let elementIds;&#xD;&#xA;        let element;&#xD;&#xA;        if (Array.isArray(param1)) {&#xD;&#xA;            elementIds = param1;&#xD;&#xA;            element = lookup(elementIds[elementIds.length - 1]);&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            elementIds = [param1.id];&#xD;&#xA;            element = param1;&#xD;&#xA;        }&#xD;&#xA;        this.mappedElement = element;&#xD;&#xA;        this.innerElement.setMapping(elementIds, mappingSettingsId);&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;    getElement() {&#xD;&#xA;        return this.innerElement;&#xD;&#xA;    }&#xD;&#xA;    collapse() {&#xD;&#xA;        this.innerElement.collapse();&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;servicesHelper.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;mappingStore.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;elementManager.ts&quot; /&gt;&#xD;&#xA;var CrudType;&#xD;&#xA;(function (CrudType) {&#xD;&#xA;    CrudType[CrudType[&quot;Create&quot;] = 0] = &quot;Create&quot;;&#xD;&#xA;    CrudType[CrudType[&quot;Read&quot;] = 1] = &quot;Read&quot;;&#xD;&#xA;    CrudType[CrudType[&quot;Update&quot;] = 2] = &quot;Update&quot;;&#xD;&#xA;    CrudType[CrudType[&quot;Delete&quot;] = 3] = &quot;Delete&quot;;&#xD;&#xA;})(CrudType || (CrudType = {}));&#xD;&#xA;class ProxyServiceHelper {&#xD;&#xA;    static _createService(proxy, folder) {&#xD;&#xA;        let serviceName = proxy.getName();&#xD;&#xA;        serviceName = ProxyServiceHelper.sanitizeServiceName(serviceName);&#xD;&#xA;        const existing = folder.getPackage().getChildren(&quot;Service&quot;).find(x =&gt; x.getName() == serviceName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        let serviceElement = createElement(&quot;Service&quot;, serviceName, folder.getPackage().id);&#xD;&#xA;        //const httpServiceSettingsStereotypeId = &quot;c29224ec-d473-4b95-ad4a-ec55c676c4fd&quot;;&#xD;&#xA;        // let httpServiceSettings = serviceElement.getStereotype(httpServiceSettingsStereotypeId) ?? serviceElement.addStereotype(httpServiceSettingsStereotypeId);&#xD;&#xA;        // httpServiceSettings.getProperty(&quot;Route&quot;).setValue(`api/${toKebabCase(serviceName)}`);&#xD;&#xA;        return serviceElement;&#xD;&#xA;    }&#xD;&#xA;    static sanitizeServiceName(name) {&#xD;&#xA;        name = removeSuffix(name, &quot;Proxy&quot;, &quot;Client&quot;, &quot;Service&quot;);&#xD;&#xA;        name = removeSuffix(name, &quot;Proxy&quot;, &quot;Client&quot;, &quot;Service&quot;);&#xD;&#xA;        name += &quot;Service&quot;;&#xD;&#xA;        name = toPascalCase(name);&#xD;&#xA;        return name;&#xD;&#xA;    }&#xD;&#xA;    static createAppServices(proxy, folder) {&#xD;&#xA;        let serviceElement = ProxyServiceHelper._createService(proxy, folder);&#xD;&#xA;        for (let operation of proxy.getChildren(&quot;Operation&quot;)) {&#xD;&#xA;            ProxyServiceHelper.createAppServiceOperationAction(operation, folder, serviceElement);&#xD;&#xA;        }&#xD;&#xA;        return serviceElement;&#xD;&#xA;    }&#xD;&#xA;    static createAppServiceOperationAction(operation, folder, service) {&#xD;&#xA;        let operationName = operation.getName();&#xD;&#xA;        operationName = removeSuffix(operationName, &quot;Async&quot;);&#xD;&#xA;        operationName = toPascalCase(operationName);&#xD;&#xA;        let metadata = ProxyServiceHelper.getProxyOperationMetadata(operation);&#xD;&#xA;        if (!service) {&#xD;&#xA;            service = ProxyServiceHelper._createService(operation.getParent(), folder);&#xD;&#xA;        }&#xD;&#xA;        let operationElement = createElement(&quot;Operation&quot;, operationName, service.id);&#xD;&#xA;        let verb = metadata.httpVerb ? metadata.httpVerb : &quot;POST&quot;;&#xD;&#xA;        let route = metadata.httpRoute ? metadata.httpRoute : `${toKebabCase(operationName)}`;&#xD;&#xA;        // const httpSettingsStereotypeId = &quot;b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6&quot;;&#xD;&#xA;        // let httpSettings = operationElement.getStereotype(httpSettingsStereotypeId) ?? operationElement.addStereotype(httpSettingsStereotypeId);&#xD;&#xA;        // httpSettings.getProperty(&quot;Verb&quot;).setValue(verb);&#xD;&#xA;        // httpSettings.getProperty(&quot;Route&quot;).setValue(route);&#xD;&#xA;        let mappingStore = new MappingStore();&#xD;&#xA;        ProxyServiceHelper.recreateAction(operation.getChildren(&quot;Parameter&quot;), operationElement, false, folder, mappingStore);&#xD;&#xA;        let callOp = createAssociation(&quot;Call Service Operation&quot;, operationElement.id, operation.id);&#xD;&#xA;        let mapping = callOp.createMapping(operationElement.id, operation.id);&#xD;&#xA;        mapping.addMappedEnd(&quot;Invocation Mapping&quot;, [operationElement.id], [operation.id]);&#xD;&#xA;        for (let entry of mappingStore.getMappings()) {&#xD;&#xA;            mapping.addMappedEnd(&quot;Data Mapping&quot;, entry.sourcePath, entry.targetPath);&#xD;&#xA;        }&#xD;&#xA;        if (operation.typeReference?.getTypeId()) {&#xD;&#xA;            operationElement.typeReference.setType(operation.typeReference.getTypeId());&#xD;&#xA;            operationElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());&#xD;&#xA;            operationElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());&#xD;&#xA;        }&#xD;&#xA;        return operationElement;&#xD;&#xA;    }&#xD;&#xA;    static createCqrsAction(operation, folder) {&#xD;&#xA;        let operationName = operation.getName();&#xD;&#xA;        operationName = removeSuffix(operationName, &quot;Async&quot;, &quot;Command&quot;, &quot;Query&quot;);&#xD;&#xA;        operationName = toPascalCase(operationName);&#xD;&#xA;        let metadata = ProxyServiceHelper.getProxyOperationMetadata(operation);&#xD;&#xA;        let actionTypeName;&#xD;&#xA;        switch (metadata.crudType) {&#xD;&#xA;            default:&#xD;&#xA;                actionTypeName = &quot;Command&quot;;&#xD;&#xA;                break;&#xD;&#xA;            case CrudType.Read:&#xD;&#xA;                actionTypeName = &quot;Query&quot;;&#xD;&#xA;                break;&#xD;&#xA;        }&#xD;&#xA;        const actionName = `${operationName}${actionTypeName}`;&#xD;&#xA;        const existing = folder.getChildren().find(x =&gt; x.getName() == actionName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        const actionElement = createElement(actionTypeName, actionName, folder.id);&#xD;&#xA;        let verb = metadata.httpVerb ? metadata.httpVerb : &quot;POST&quot;;&#xD;&#xA;        let route = metadata.httpRoute ? metadata.httpRoute : `api/${toKebabCase(folder.getName())}/${toKebabCase(actionName)}`;&#xD;&#xA;        // const httpSettingsStereotypeId = &quot;b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6&quot;;&#xD;&#xA;        // let httpSettings = actionElement.getStereotype(httpSettingsStereotypeId) ?? actionElement.addStereotype(httpSettingsStereotypeId);&#xD;&#xA;        // httpSettings.getProperty(&quot;Verb&quot;).setValue(verb);&#xD;&#xA;        // httpSettings.getProperty(&quot;Route&quot;).setValue(route);&#xD;&#xA;        let mappingStore = new MappingStore();&#xD;&#xA;        ProxyServiceHelper.recreateAction(operation.getChildren(&quot;Parameter&quot;), actionElement, true, folder, mappingStore);&#xD;&#xA;        let callOp = createAssociation(&quot;Call Service Operation&quot;, actionElement.id, operation.id);&#xD;&#xA;        let mapping = callOp.createMapping(actionElement.id, operation.id);&#xD;&#xA;        mapping.addMappedEnd(&quot;Invocation Mapping&quot;, [actionElement.id], [operation.id]);&#xD;&#xA;        for (let entry of mappingStore.getMappings()) {&#xD;&#xA;            mapping.addMappedEnd(&quot;Data Mapping&quot;, entry.sourcePath, entry.targetPath);&#xD;&#xA;        }&#xD;&#xA;        if (operation.typeReference?.getTypeId()) {&#xD;&#xA;            actionElement.typeReference.setType(operation.typeReference.getTypeId());&#xD;&#xA;            actionElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());&#xD;&#xA;            actionElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());&#xD;&#xA;        }&#xD;&#xA;        return actionElement;&#xD;&#xA;    }&#xD;&#xA;    static getProxyOperationMetadata(operation) {&#xD;&#xA;        let mappedElement = operation.getMapping()?.getElement();&#xD;&#xA;        let crudType;&#xD;&#xA;        let httpSettings = mappedElement?.getStereotype(&quot;Http Settings&quot;);&#xD;&#xA;        let httpVerb = httpSettings?.getProperty(&quot;Verb&quot;)?.getValue();&#xD;&#xA;        let httpRoute = httpSettings?.getProperty(&quot;Route&quot;)?.getValue();&#xD;&#xA;        const routeParamRegex = /\{([a-zA-Z0-9_\-]+)\}/g;&#xD;&#xA;        let httpRouteParams = httpRoute ? [...httpRoute.matchAll(routeParamRegex)].map(match =&gt; match[1]) : [];&#xD;&#xA;        if (httpVerb) {&#xD;&#xA;            switch (httpVerb.toUpperCase()) {&#xD;&#xA;                case &quot;POST&quot;:&#xD;&#xA;                    crudType = CrudType.Create;&#xD;&#xA;                    break;&#xD;&#xA;                case &quot;PUT&quot;:&#xD;&#xA;                    crudType = CrudType.Update;&#xD;&#xA;                    break;&#xD;&#xA;                case &quot;DELETE&quot;:&#xD;&#xA;                    crudType = CrudType.Delete;&#xD;&#xA;                    break;&#xD;&#xA;                case &quot;GET&quot;:&#xD;&#xA;                    crudType = CrudType.Read;&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        else if (mappedElement &amp;&amp; (mappedElement.specialization === &quot;Command&quot; ||&#xD;&#xA;            mappedElement.specialization === &quot;Query&quot; ||&#xD;&#xA;            mappedElement.specialization === &quot;Operation&quot;)) {&#xD;&#xA;            for (let association of mappedElement.getAssociations()) {&#xD;&#xA;                switch (association.specialization) {&#xD;&#xA;                    case &quot;Create Entity Action&quot;:&#xD;&#xA;                        crudType = CrudType.Create;&#xD;&#xA;                        break;&#xD;&#xA;                    case &quot;Update Entity Action&quot;:&#xD;&#xA;                        crudType = CrudType.Update;&#xD;&#xA;                        break;&#xD;&#xA;                    case &quot;Delete Entity Action&quot;:&#xD;&#xA;                        crudType = CrudType.Delete;&#xD;&#xA;                        break;&#xD;&#xA;                    case &quot;Query Entity Action&quot;:&#xD;&#xA;                        crudType = CrudType.Read;&#xD;&#xA;                        break;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        else if (!crudType) {&#xD;&#xA;            let mappedElementNameLower = (mappedElement ? mappedElement.getName() : operation.getName()).toLocaleLowerCase();&#xD;&#xA;            if (mappedElementNameLower.indexOf(&quot;create&quot;) &gt; -1) {&#xD;&#xA;                crudType = CrudType.Create;&#xD;&#xA;            }&#xD;&#xA;            else if (mappedElementNameLower.indexOf(&quot;update&quot;) &gt; -1) {&#xD;&#xA;                crudType = CrudType.Update;&#xD;&#xA;            }&#xD;&#xA;            else if (mappedElementNameLower.indexOf(&quot;delete&quot;) &gt; -1) {&#xD;&#xA;                crudType = CrudType.Delete;&#xD;&#xA;            }&#xD;&#xA;            else if (mappedElementNameLower.indexOf(&quot;get&quot;) &gt; -1 || mappedElementNameLower.indexOf(&quot;find&quot;) &gt; -1) {&#xD;&#xA;                crudType = CrudType.Read;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return {&#xD;&#xA;            crudType: crudType,&#xD;&#xA;            httpVerb: httpVerb,&#xD;&#xA;            httpRoute: httpRoute,&#xD;&#xA;            httpRouteParams: httpRouteParams&#xD;&#xA;        };&#xD;&#xA;    }&#xD;&#xA;    static recreateAction(proxyFields, actionElement, flattenFieldsFromComplexTypes, folder, mappingStore) {&#xD;&#xA;        const childSpecialization = flattenFieldsFromComplexTypes&#xD;&#xA;            ? &quot;DTO-Field&quot;&#xD;&#xA;            : proxyFields.length &gt; 0&#xD;&#xA;                ? proxyFields[0].specialization&#xD;&#xA;                : &quot;DTO-Field&quot;;&#xD;&#xA;        let elementManager = new ElementManager(actionElement, { childSpecialization: childSpecialization });&#xD;&#xA;        for (let proxyField of proxyFields) {&#xD;&#xA;            let paramRefType = proxyField.typeReference?.getType()?.specialization;&#xD;&#xA;            switch (paramRefType) {&#xD;&#xA;                case &quot;Command&quot;:&#xD;&#xA;                case &quot;Query&quot;:&#xD;&#xA;                case &quot;DTO&quot;:&#xD;&#xA;                    // Complex type&#xD;&#xA;                    let proxyRefType = proxyField.typeReference.getType();&#xD;&#xA;                    if (flattenFieldsFromComplexTypes) {&#xD;&#xA;                        mappingStore.pushTargetPath(proxyField.id);&#xD;&#xA;                        ProxyServiceHelper.recreateAction(proxyRefType.getChildren(&quot;DTO-Field&quot;), elementManager.getElement(), false, folder, mappingStore);&#xD;&#xA;                        mappingStore.popTargetPath();&#xD;&#xA;                    }&#xD;&#xA;                    else {&#xD;&#xA;                        let actionField = elementManager.addChild(proxyField.getName(), null);&#xD;&#xA;                        mappingStore.pushSourcePath(actionField.id);&#xD;&#xA;                        mappingStore.pushTargetPath(proxyField.id);&#xD;&#xA;                        let actionDto = ProxyServiceHelper.replicateDto(proxyRefType, folder, mappingStore);&#xD;&#xA;                        mappingStore.popSourcePath();&#xD;&#xA;                        mappingStore.popTargetPath();&#xD;&#xA;                        actionField.typeReference.setType(actionDto.id);&#xD;&#xA;                        actionField.typeReference.setIsCollection(proxyField.typeReference.isCollection);&#xD;&#xA;                        actionField.typeReference.setIsNullable(proxyField.typeReference.isNullable);&#xD;&#xA;                        if (proxyField.hasMetadata(&quot;endpoint-input-id&quot;)) {&#xD;&#xA;                            actionField.addMetadata(&quot;endpoint-input-id&quot;, proxyField.getMetadata(&quot;endpoint-input-id&quot;));&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;                default:&#xD;&#xA;                    // Non-Complex type&#xD;&#xA;                    let fieldName = proxyField.getName();&#xD;&#xA;                    if (elementManager.getElement().getChildren().some(x =&gt; x.getName() === fieldName)) {&#xD;&#xA;                        let parentName = proxyField.getParent().getName();&#xD;&#xA;                        fieldName = parentName + fieldName;&#xD;&#xA;                    }&#xD;&#xA;                    let actionField = elementManager.addChild(fieldName, proxyField.typeReference);&#xD;&#xA;                    mappingStore.addMapping(actionField.id, proxyField.id);&#xD;&#xA;                    if (proxyField.hasMetadata(&quot;endpoint-input-id&quot;)) {&#xD;&#xA;                        actionField.addMetadata(&quot;endpoint-input-id&quot;, proxyField.getMetadata(&quot;endpoint-input-id&quot;));&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        elementManager.collapse();&#xD;&#xA;    }&#xD;&#xA;    static replicateDto(proxyDto, folder, mappingStore) {&#xD;&#xA;        let newDto = createElement(&quot;DTO&quot;, proxyDto.getName(), folder.id);&#xD;&#xA;        proxyDto.getChildren(&quot;DTO-Field&quot;).forEach(proxyField =&gt; {&#xD;&#xA;            let actionField = createElement(&quot;DTO-Field&quot;, proxyField.getName(), newDto.id);&#xD;&#xA;            let fieldRefType = proxyField.typeReference?.getType()?.specialization;&#xD;&#xA;            switch (fieldRefType) {&#xD;&#xA;                case &quot;Command&quot;:&#xD;&#xA;                case &quot;Query&quot;:&#xD;&#xA;                case &quot;DTO&quot;:&#xD;&#xA;                    // Complex type&#xD;&#xA;                    mappingStore.pushSourcePath(actionField.id);&#xD;&#xA;                    mappingStore.pushTargetPath(proxyField.id);&#xD;&#xA;                    let nestedDto = ProxyServiceHelper.replicateDto(proxyField.typeReference.getType(), folder, mappingStore);&#xD;&#xA;                    mappingStore.popSourcePath();&#xD;&#xA;                    mappingStore.popTargetPath();&#xD;&#xA;                    actionField.typeReference.setType(nestedDto.id);&#xD;&#xA;                    break;&#xD;&#xA;                default:&#xD;&#xA;                    // Non-Complex type&#xD;&#xA;                    actionField.typeReference.setType(proxyField.typeReference.getTypeId());&#xD;&#xA;                    mappingStore.addMapping(actionField.id, proxyField.id);&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;            actionField.typeReference.setIsCollection(proxyField.typeReference.isCollection);&#xD;&#xA;            actionField.typeReference.setIsNullable(proxyField.typeReference.isNullable);&#xD;&#xA;        });&#xD;&#xA;        return newDto;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;../../common/openSelectItemDialog.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/proxyServiceHelper.ts&quot; /&gt;&#xD;&#xA;async function execute(proxyOperation) {&#xD;&#xA;    let servicePackages = getPackages().filter(pkg =&gt; pkg.specialization === &quot;Services Package&quot;);&#xD;&#xA;    let selectedPackage;&#xD;&#xA;    if (servicePackages.length == 1) {&#xD;&#xA;        selectedPackage = servicePackages[0];&#xD;&#xA;    }&#xD;&#xA;    else {&#xD;&#xA;        selectedPackage = await openSelectItemDialog(getPackageSelectItemOptions(servicePackages, &quot;Service Package&quot;));&#xD;&#xA;    }&#xD;&#xA;    const proxy = proxyOperation.getParent();&#xD;&#xA;    const folderName = pluralize(proxy.getName());&#xD;&#xA;    const folder = selectedPackage.getChildren(&quot;Folder&quot;).find(x =&gt; x.getName() == pluralize(folderName)) ?? createElement(&quot;Folder&quot;, pluralize(folderName), selectedPackage.id);&#xD;&#xA;    ProxyServiceHelper.createCqrsAction(proxyOperation, folder);&#xD;&#xA;    const diagramElement = folder.getChildren(&quot;Diagram&quot;).find(x =&gt; x.getName() == folderName) ?? createElement(&quot;Diagram&quot;, folderName, folder.id);&#xD;&#xA;    diagramElement.loadDiagram();&#xD;&#xA;    const diagram = getCurrentDiagram();&#xD;&#xA;    //Since we're adding a single new element on the diagram, it may not be positioned below the last created one.&#xD;&#xA;    let lastActionVisual = null;&#xD;&#xA;    for (let action of folder.getChildren(&quot;Command&quot;).concat(folder.getChildren(&quot;Query&quot;))) {&#xD;&#xA;        if (diagram.isVisual(action.id)) {&#xD;&#xA;            lastActionVisual = diagram.getVisual(action.id);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    let newPosition = null;&#xD;&#xA;    // This is an attempt to reposition the newly created elements due to the lack of&#xD;&#xA;    // directly manipulating the visuals on the diagram but it ends up skewing diagonally.&#xD;&#xA;    if (lastActionVisual) {&#xD;&#xA;        newPosition = {&#xD;&#xA;            x: lastActionVisual.getPosition().x,&#xD;&#xA;            y: lastActionVisual.getPosition().y - lastActionVisual.getSize().height&#xD;&#xA;        };&#xD;&#xA;    }&#xD;&#xA;    diagram.layoutVisuals(folder, newPosition, true);&#xD;&#xA;}&#xD;&#xA;/**&#xD;&#xA; * Used by Intent.Modelers.Services.ProxyInteractions&#xD;&#xA; *&#xD;&#xA; * Source code here:&#xD;&#xA; * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/create-proxy-operation-cqrs-macro-advanced-mapping/create-proxy-operation-cqrs-macro-advanced-mapping.ts&#xD;&#xA; */&#xD;&#xA;await execute(element);&#xD;&#xA;" isActive="true" />
                <property name="7df9c3b9-91a0-4cb7-bc3a-15d72f160054" display="Dependencies" isActive="true" />
              </properties>
            </stereotype>
            <stereotype stereotypeDefinitionId="cbe77364-d1d0-400b-a8c4-646a4c869612" name="Option Settings">
              <comment />
              <addedByDefault>true</addedByDefault>
              <definitionPackageName>Intent.ModuleBuilder</definitionPackageName>
              <definitionPackageId>9972b2a9-b749-4bba-b5c8-824bf694c6ef</definitionPackageId>
              <properties>
                <property name="b2c3a117-23d3-47e5-8b83-5b902c55a226" display="Icon" value="{&quot;source&quot;:&quot;data:image/png;base64,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&quot;,&quot;type&quot;:0,&quot;absolutePathRelativeTo&quot;:null}" isActive="true" />
                <property name="0abff08a-3986-40b1-a28f-4cc03c4fc1ec" display="Shortcut" isActive="true" />
                <property name="79f6973f-5e3a-4618-9d4c-d7cc604bffe0" display="Shortcut (macOS)" isActive="true" />
                <property name="6087e660-9599-47fb-9ff4-1ad901ce2a00" display="Trigger On Double-Click" value="false" isActive="true" />
                <property name="c03841e5-a1e9-4e95-b699-5a466dde7d7d" display="Is Option Visible Function" value="return application.isModuleInstalled(&quot;Intent.Modelers.Services.CQRS&quot;) &amp;&amp; application.isModuleInstalled(&quot;Intent.Modelers.Services.DomainInteractions&quot;);" isActive="true" />
                <property name="e034a0ca-0101-4594-8384-43048b714578" display="Order" isActive="true" />
                <property name="3e93529e-2110-414e-aec1-2656e1a99b22" display="Top Divider" value="false" isActive="true" />
                <property name="d2572c08-f02e-40b2-8a06-4d5251bb3352" display="Bottom Divider" value="false" isActive="true" />
              </properties>
            </stereotype>
          </stereotypes>
          <metadata />
          <childElements />
        </childElement>
        <childElement id="f623b1a9-12af-4260-afb7-d6acfe5da9df" type="Run Script Option" typeId="345d46fb-c500-409a-88c7-26720572c9af">
          <name>Create Service Operation</name>
          <display>Create Service Operation: Inline Script</display>
          <isAbstract>false</isAbstract>
          <genericTypes />
          <typeReference id="9615c483-ce62-445e-8b81-cf4289245eab">
            <typeId>043eee26-1591-42ac-9f2c-fc911b070eb1</typeId>
            <isNavigable>true</isNavigable>
            <isNullable>false</isNullable>
            <isCollection>false</isCollection>
            <isRequired>true</isRequired>
            <typePackageName>Intent.ModuleBuilder</typePackageName>
            <typePackageId>9972b2a9-b749-4bba-b5c8-824bf694c6ef</typePackageId>
            <stereotypes />
            <genericTypeParameters />
          </typeReference>
          <isMapped>false</isMapped>
          <parentFolderId>3fd774ec-4792-4640-830a-6d67de20bf81</parentFolderId>
          <packageId>53353621-7752-4a01-90f3-cd2e83ec19a4</packageId>
          <packageName>Intent.Modelers.Services.ProxyInteractions</packageName>
          <stereotypes>
            <stereotype stereotypeDefinitionId="56bc0465-c1fe-4bca-9493-2a3ce88a4047" name="Script Settings">
              <addedByDefault>true</addedByDefault>
              <definitionPackageName>Intent.ModuleBuilder</definitionPackageName>
              <definitionPackageId>9972b2a9-b749-4bba-b5c8-824bf694c6ef</definitionPackageId>
              <properties>
                <property name="73a4088f-626e-4d31-b0b2-113167f015b2" display="Script" value="/// &lt;reference path=&quot;../../typings/elementmacro.context.api.d.ts&quot; /&gt;&#xD;&#xA;function getPackageSelectItemOptions(packages, packageTypeName) {&#xD;&#xA;    return {&#xD;&#xA;        items: packages,&#xD;&#xA;        getId(item) {&#xD;&#xA;            return item.id;&#xD;&#xA;        },&#xD;&#xA;        getDisplayName(item) {&#xD;&#xA;            return item.getName();&#xD;&#xA;        },&#xD;&#xA;        getItemNotFoundMessage(itemId) {&#xD;&#xA;            return `No ${packageTypeName} found with id &quot;${itemId}&quot;.`;&#xD;&#xA;        },&#xD;&#xA;        getNoItemsFoundMessage() {&#xD;&#xA;            return `No packages of type ${packageTypeName} could be found.`;&#xD;&#xA;        },&#xD;&#xA;    };&#xD;&#xA;}&#xD;&#xA;function getElementSelectItemOptions(elements, elementTypeName, relevantPackageTypeName) {&#xD;&#xA;    return {&#xD;&#xA;        items: elements,&#xD;&#xA;        getId(item) {&#xD;&#xA;            return item.id;&#xD;&#xA;        },&#xD;&#xA;        getDisplayName(item) {&#xD;&#xA;            return item.getName();&#xD;&#xA;        },&#xD;&#xA;        getItemNotFoundMessage(itemId) {&#xD;&#xA;            return `No &quot;${elementTypeName}&quot; found with id &quot;${itemId}&quot;.`;&#xD;&#xA;        },&#xD;&#xA;        getNoItemsFoundMessage() {&#xD;&#xA;            return `No Elements of type &quot;${elementTypeName}&quot; could be found. Please ensure that you have a reference to the ${relevantPackageTypeName} package and that at least one ${elementTypeName} exists in it.`;&#xD;&#xA;        },&#xD;&#xA;    };&#xD;&#xA;}&#xD;&#xA;/**&#xD;&#xA; * Dialog selection.&#xD;&#xA; * @param options For simplicity, use getPackageSelectItemOptions() or getElementSelectItemOptions()&#xD;&#xA; * @returns Selected item.&#xD;&#xA; */&#xD;&#xA;async function openSelectItemDialog(options) {&#xD;&#xA;    if (!options) {&#xD;&#xA;        throw new Error(&quot;Options are required for 'openSelectItemDialog'.&quot;);&#xD;&#xA;    }&#xD;&#xA;    let items = options.items;&#xD;&#xA;    if (items.length == 0) {&#xD;&#xA;        await dialogService.info(options.getNoItemsFoundMessage());&#xD;&#xA;        return null;&#xD;&#xA;    }&#xD;&#xA;    let itemId = await dialogService.lookupFromOptions(items.map(item =&gt; ({&#xD;&#xA;        id: options.getId(item),&#xD;&#xA;        name: options.getDisplayName(item)&#xD;&#xA;    })));&#xD;&#xA;    if (itemId == null) {&#xD;&#xA;        await dialogService.error(options.getItemNotFoundMessage(itemId));&#xD;&#xA;        return null;&#xD;&#xA;    }&#xD;&#xA;    let foundItem = items.filter(item =&gt; options.getId(item) === itemId)[0];&#xD;&#xA;    return foundItem;&#xD;&#xA;}&#xD;&#xA;;&#xD;&#xA;/// &lt;reference path=&quot;attributeWithMapPath.ts&quot; /&gt;&#xD;&#xA;class ServicesConstants {&#xD;&#xA;}&#xD;&#xA;ServicesConstants.dtoToEntityMappingId = &quot;942eae46-49f1-450e-9274-a92d40ac35fa&quot;; //&quot;01d74d4f-e478-4fde-a2f0-9ea92255f3c5&quot;;&#xD;&#xA;ServicesConstants.dtoFromEntityMappingId = &quot;1f747d14-681c-4a20-8c68-34223f41b825&quot;;&#xD;&#xA;ServicesConstants.dtoToDomainOperation = &quot;8d1f6a8a-77c8-43a2-8e60-421559725419&quot;;&#xD;&#xA;class ServicesHelper {&#xD;&#xA;    static addDtoFieldsFromDomain(dto, attributes) {&#xD;&#xA;        for (let key of attributes) {&#xD;&#xA;            if (dto &amp;&amp; !dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {&#xD;&#xA;                let field = createElement(&quot;DTO-Field&quot;, ServicesHelper.getFieldFormat(key.name), dto.id);&#xD;&#xA;                field.typeReference.setType(key.typeId);&#xD;&#xA;                if ((key.mapPath ?? []).length &gt; 0) {&#xD;&#xA;                    field.setMapping(key.mapPath);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getParameterFormat(str) {&#xD;&#xA;        return toCamelCase(str);&#xD;&#xA;    }&#xD;&#xA;    static getRoutingFormat(str) {&#xD;&#xA;        return pluralize(str);&#xD;&#xA;    }&#xD;&#xA;    static getFieldFormat(str) {&#xD;&#xA;        return toPascalCase(str);&#xD;&#xA;    }&#xD;&#xA;    static formatName(str, type) {&#xD;&#xA;        switch (type) {&#xD;&#xA;            case &quot;property&quot;:&#xD;&#xA;            case &quot;class&quot;:&#xD;&#xA;                return toPascalCase(str);&#xD;&#xA;            case &quot;parameter&quot;:&#xD;&#xA;                return toCamelCase(str);&#xD;&#xA;            default:&#xD;&#xA;                return str;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/**&#xD;&#xA; * Helper class to build up source and target mapping paths for&#xD;&#xA; * advanced mapping scenarios.&#xD;&#xA; *&#xD;&#xA; * @remarks&#xD;&#xA; *&#xD;&#xA; * Source Path and Target Path is maintained separately since not all mapping scenarios are&#xD;&#xA; * straightforward.&#xD;&#xA; *&#xD;&#xA; * @example&#xD;&#xA; *&#xD;&#xA; * When to Push/Pop the Paths&#xD;&#xA; *&#xD;&#xA;    let leftField = createField(...);&#xD;&#xA;&#xD;&#xA;    mappingStore.pushSourcePath(leftField.id);&#xD;&#xA;    mappingStore.pushTargetPath(rightField.id);&#xD;&#xA;&#xD;&#xA;    let leftFieldDto = replicateDto(rightField.typeReference.getType(), folder, mappingStore);&#xD;&#xA;&#xD;&#xA;    mappingStore.popSourcePath();&#xD;&#xA;    mappingStore.popTargetPath();&#xD;&#xA;&#xD;&#xA;    leftField.typeReference.setType(leftFieldDto.id);&#xD;&#xA; *&#xD;&#xA; * Adding mappings&#xD;&#xA; *&#xD;&#xA;    function replicateDto(existingDto: MacroApi.Context.IElementApi, ...) {&#xD;&#xA;        let newDto = createElement(&quot;DTO&quot;, existingDto.getName(), folder.id);&#xD;&#xA;        existingDto.getChildren(&quot;DTO-Field&quot;).forEach(existingField =&gt; {&#xD;&#xA;            let newField = createElement(&quot;DTO-Field&quot;, existingField.getName(), newDto.id);&#xD;&#xA;            // ...&#xD;&#xA;            mappingStore.addMapping(newField.id, existingField.id);&#xD;&#xA;            // ...&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA; */&#xD;&#xA;class MappingStore {&#xD;&#xA;    constructor() {&#xD;&#xA;        this.mappings = [];&#xD;&#xA;        this.sourcePath = [];&#xD;&#xA;        this.targetPath = [];&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Get all the recorded mapping entries&#xD;&#xA;     */&#xD;&#xA;    getMappings() {&#xD;&#xA;        return this.mappings;&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Keep track of this element id on the source end&#xD;&#xA;     * when navigating inside it's type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    pushSourcePath(id) {&#xD;&#xA;        this.sourcePath.push(id);&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Remove the last tracked element on the source path stack&#xD;&#xA;     * when done navigating down its type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    popSourcePath() {&#xD;&#xA;        this.sourcePath.pop();&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Keep track of this element id on the target end&#xD;&#xA;     * when navigating inside it's type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    pushTargetPath(id) {&#xD;&#xA;        this.targetPath.push(id);&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Remove the last tracked element on the target path stack&#xD;&#xA;     * when done navigating down its type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    popTargetPath() {&#xD;&#xA;        this.targetPath.pop();&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Record a mapping between a source element id and target element id.&#xD;&#xA;     * Target and Source path stack will be used to build up the whole path.&#xD;&#xA;     */&#xD;&#xA;    addMapping(sourceId, targetId) {&#xD;&#xA;        this.mappings.push({&#xD;&#xA;            sourcePath: this.sourcePath.concat([sourceId]),&#xD;&#xA;            targetPath: this.targetPath.concat([targetId])&#xD;&#xA;        });&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;class ElementManager {&#xD;&#xA;    constructor(innerElement, settings) {&#xD;&#xA;        this.innerElement = innerElement;&#xD;&#xA;        this.settings = settings;&#xD;&#xA;        this.mappedElement = innerElement.getMapping()?.getElement();&#xD;&#xA;    }&#xD;&#xA;    get id() { return this.innerElement.id; }&#xD;&#xA;    ;&#xD;&#xA;    setReturnType(typeId, isCollection, isNullable) {&#xD;&#xA;        this.innerElement.typeReference.setType(typeId);&#xD;&#xA;        if (isCollection != null) {&#xD;&#xA;            this.innerElement.typeReference.setIsCollection(isCollection);&#xD;&#xA;        }&#xD;&#xA;        if (isNullable != null) {&#xD;&#xA;            this.innerElement.typeReference.setIsNullable(isNullable);&#xD;&#xA;        }&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;    addChild(name, type) {&#xD;&#xA;        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, this.settings.childType ?? &quot;property&quot;), this.innerElement.id);&#xD;&#xA;        const typeReferenceDetails = type == null&#xD;&#xA;            ? null&#xD;&#xA;            : typeof (type) === &quot;string&quot;&#xD;&#xA;                ? { id: type, isNullable: false, isCollection: false }&#xD;&#xA;                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };&#xD;&#xA;        if (typeReferenceDetails != null) {&#xD;&#xA;            field.typeReference.setType(typeReferenceDetails.id);&#xD;&#xA;            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);&#xD;&#xA;            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);&#xD;&#xA;        }&#xD;&#xA;        return field;&#xD;&#xA;    }&#xD;&#xA;    addChildrenFrom(elements, options) {&#xD;&#xA;        let order = 0;&#xD;&#xA;        elements.forEach(e =&gt; {&#xD;&#xA;            if (e.mapPath != null) {&#xD;&#xA;                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let field = this.addChild(e.name, e.typeId);&#xD;&#xA;            field.typeReference.setIsCollection(e.isCollection);&#xD;&#xA;            field.typeReference.setIsNullable(e.isNullable);&#xD;&#xA;            if (options?.addToTop) {&#xD;&#xA;                field.setOrder(order++);&#xD;&#xA;            }&#xD;&#xA;            if (this.mappedElement != null &amp;&amp; e.mapPath) {&#xD;&#xA;                field.setMapping(e.mapPath);&#xD;&#xA;            }&#xD;&#xA;        });&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;    mapToElement(param1, mappingSettingsId) {&#xD;&#xA;        let elementIds;&#xD;&#xA;        let element;&#xD;&#xA;        if (Array.isArray(param1)) {&#xD;&#xA;            elementIds = param1;&#xD;&#xA;            element = lookup(elementIds[elementIds.length - 1]);&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            elementIds = [param1.id];&#xD;&#xA;            element = param1;&#xD;&#xA;        }&#xD;&#xA;        this.mappedElement = element;&#xD;&#xA;        this.innerElement.setMapping(elementIds, mappingSettingsId);&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;    getElement() {&#xD;&#xA;        return this.innerElement;&#xD;&#xA;    }&#xD;&#xA;    collapse() {&#xD;&#xA;        this.innerElement.collapse();&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;servicesHelper.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;mappingStore.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;elementManager.ts&quot; /&gt;&#xD;&#xA;var CrudType;&#xD;&#xA;(function (CrudType) {&#xD;&#xA;    CrudType[CrudType[&quot;Create&quot;] = 0] = &quot;Create&quot;;&#xD;&#xA;    CrudType[CrudType[&quot;Read&quot;] = 1] = &quot;Read&quot;;&#xD;&#xA;    CrudType[CrudType[&quot;Update&quot;] = 2] = &quot;Update&quot;;&#xD;&#xA;    CrudType[CrudType[&quot;Delete&quot;] = 3] = &quot;Delete&quot;;&#xD;&#xA;})(CrudType || (CrudType = {}));&#xD;&#xA;class ProxyServiceHelper {&#xD;&#xA;    static _createService(proxy, folder) {&#xD;&#xA;        let serviceName = proxy.getName();&#xD;&#xA;        serviceName = ProxyServiceHelper.sanitizeServiceName(serviceName);&#xD;&#xA;        const existing = folder.getPackage().getChildren(&quot;Service&quot;).find(x =&gt; x.getName() == serviceName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        let serviceElement = createElement(&quot;Service&quot;, serviceName, folder.getPackage().id);&#xD;&#xA;        //const httpServiceSettingsStereotypeId = &quot;c29224ec-d473-4b95-ad4a-ec55c676c4fd&quot;;&#xD;&#xA;        // let httpServiceSettings = serviceElement.getStereotype(httpServiceSettingsStereotypeId) ?? serviceElement.addStereotype(httpServiceSettingsStereotypeId);&#xD;&#xA;        // httpServiceSettings.getProperty(&quot;Route&quot;).setValue(`api/${toKebabCase(serviceName)}`);&#xD;&#xA;        return serviceElement;&#xD;&#xA;    }&#xD;&#xA;    static sanitizeServiceName(name) {&#xD;&#xA;        name = removeSuffix(name, &quot;Proxy&quot;, &quot;Client&quot;, &quot;Service&quot;);&#xD;&#xA;        name = removeSuffix(name, &quot;Proxy&quot;, &quot;Client&quot;, &quot;Service&quot;);&#xD;&#xA;        name += &quot;Service&quot;;&#xD;&#xA;        name = toPascalCase(name);&#xD;&#xA;        return name;&#xD;&#xA;    }&#xD;&#xA;    static createAppServices(proxy, folder) {&#xD;&#xA;        let serviceElement = ProxyServiceHelper._createService(proxy, folder);&#xD;&#xA;        for (let operation of proxy.getChildren(&quot;Operation&quot;)) {&#xD;&#xA;            ProxyServiceHelper.createAppServiceOperationAction(operation, folder, serviceElement);&#xD;&#xA;        }&#xD;&#xA;        return serviceElement;&#xD;&#xA;    }&#xD;&#xA;    static createAppServiceOperationAction(operation, folder, service) {&#xD;&#xA;        let operationName = operation.getName();&#xD;&#xA;        operationName = removeSuffix(operationName, &quot;Async&quot;);&#xD;&#xA;        operationName = toPascalCase(operationName);&#xD;&#xA;        let metadata = ProxyServiceHelper.getProxyOperationMetadata(operation);&#xD;&#xA;        if (!service) {&#xD;&#xA;            service = ProxyServiceHelper._createService(operation.getParent(), folder);&#xD;&#xA;        }&#xD;&#xA;        let operationElement = createElement(&quot;Operation&quot;, operationName, service.id);&#xD;&#xA;        let verb = metadata.httpVerb ? metadata.httpVerb : &quot;POST&quot;;&#xD;&#xA;        let route = metadata.httpRoute ? metadata.httpRoute : `${toKebabCase(operationName)}`;&#xD;&#xA;        // const httpSettingsStereotypeId = &quot;b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6&quot;;&#xD;&#xA;        // let httpSettings = operationElement.getStereotype(httpSettingsStereotypeId) ?? operationElement.addStereotype(httpSettingsStereotypeId);&#xD;&#xA;        // httpSettings.getProperty(&quot;Verb&quot;).setValue(verb);&#xD;&#xA;        // httpSettings.getProperty(&quot;Route&quot;).setValue(route);&#xD;&#xA;        let mappingStore = new MappingStore();&#xD;&#xA;        ProxyServiceHelper.recreateAction(operation.getChildren(&quot;Parameter&quot;), operationElement, false, folder, mappingStore);&#xD;&#xA;        let callOp = createAssociation(&quot;Call Service Operation&quot;, operationElement.id, operation.id);&#xD;&#xA;        let mapping = callOp.createMapping(operationElement.id, operation.id);&#xD;&#xA;        mapping.addMappedEnd(&quot;Invocation Mapping&quot;, [operationElement.id], [operation.id]);&#xD;&#xA;        for (let entry of mappingStore.getMappings()) {&#xD;&#xA;            mapping.addMappedEnd(&quot;Data Mapping&quot;, entry.sourcePath, entry.targetPath);&#xD;&#xA;        }&#xD;&#xA;        if (operation.typeReference?.getTypeId()) {&#xD;&#xA;            operationElement.typeReference.setType(operation.typeReference.getTypeId());&#xD;&#xA;            operationElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());&#xD;&#xA;            operationElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());&#xD;&#xA;        }&#xD;&#xA;        return operationElement;&#xD;&#xA;    }&#xD;&#xA;    static createCqrsAction(operation, folder) {&#xD;&#xA;        let operationName = operation.getName();&#xD;&#xA;        operationName = removeSuffix(operationName, &quot;Async&quot;, &quot;Command&quot;, &quot;Query&quot;);&#xD;&#xA;        operationName = toPascalCase(operationName);&#xD;&#xA;        let metadata = ProxyServiceHelper.getProxyOperationMetadata(operation);&#xD;&#xA;        let actionTypeName;&#xD;&#xA;        switch (metadata.crudType) {&#xD;&#xA;            default:&#xD;&#xA;                actionTypeName = &quot;Command&quot;;&#xD;&#xA;                break;&#xD;&#xA;            case CrudType.Read:&#xD;&#xA;                actionTypeName = &quot;Query&quot;;&#xD;&#xA;                break;&#xD;&#xA;        }&#xD;&#xA;        const actionName = `${operationName}${actionTypeName}`;&#xD;&#xA;        const existing = folder.getChildren().find(x =&gt; x.getName() == actionName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        const actionElement = createElement(actionTypeName, actionName, folder.id);&#xD;&#xA;        let verb = metadata.httpVerb ? metadata.httpVerb : &quot;POST&quot;;&#xD;&#xA;        let route = metadata.httpRoute ? metadata.httpRoute : `api/${toKebabCase(folder.getName())}/${toKebabCase(actionName)}`;&#xD;&#xA;        // const httpSettingsStereotypeId = &quot;b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6&quot;;&#xD;&#xA;        // let httpSettings = actionElement.getStereotype(httpSettingsStereotypeId) ?? actionElement.addStereotype(httpSettingsStereotypeId);&#xD;&#xA;        // httpSettings.getProperty(&quot;Verb&quot;).setValue(verb);&#xD;&#xA;        // httpSettings.getProperty(&quot;Route&quot;).setValue(route);&#xD;&#xA;        let mappingStore = new MappingStore();&#xD;&#xA;        ProxyServiceHelper.recreateAction(operation.getChildren(&quot;Parameter&quot;), actionElement, true, folder, mappingStore);&#xD;&#xA;        let callOp = createAssociation(&quot;Call Service Operation&quot;, actionElement.id, operation.id);&#xD;&#xA;        let mapping = callOp.createMapping(actionElement.id, operation.id);&#xD;&#xA;        mapping.addMappedEnd(&quot;Invocation Mapping&quot;, [actionElement.id], [operation.id]);&#xD;&#xA;        for (let entry of mappingStore.getMappings()) {&#xD;&#xA;            mapping.addMappedEnd(&quot;Data Mapping&quot;, entry.sourcePath, entry.targetPath);&#xD;&#xA;        }&#xD;&#xA;        if (operation.typeReference?.getTypeId()) {&#xD;&#xA;            actionElement.typeReference.setType(operation.typeReference.getTypeId());&#xD;&#xA;            actionElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());&#xD;&#xA;            actionElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());&#xD;&#xA;        }&#xD;&#xA;        return actionElement;&#xD;&#xA;    }&#xD;&#xA;    static getProxyOperationMetadata(operation) {&#xD;&#xA;        let mappedElement = operation.getMapping()?.getElement();&#xD;&#xA;        let crudType;&#xD;&#xA;        let httpSettings = mappedElement?.getStereotype(&quot;Http Settings&quot;);&#xD;&#xA;        let httpVerb = httpSettings?.getProperty(&quot;Verb&quot;)?.getValue();&#xD;&#xA;        let httpRoute = httpSettings?.getProperty(&quot;Route&quot;)?.getValue();&#xD;&#xA;        const routeParamRegex = /\{([a-zA-Z0-9_\-]+)\}/g;&#xD;&#xA;        let httpRouteParams = httpRoute ? [...httpRoute.matchAll(routeParamRegex)].map(match =&gt; match[1]) : [];&#xD;&#xA;        if (httpVerb) {&#xD;&#xA;            switch (httpVerb.toUpperCase()) {&#xD;&#xA;                case &quot;POST&quot;:&#xD;&#xA;                    crudType = CrudType.Create;&#xD;&#xA;                    break;&#xD;&#xA;                case &quot;PUT&quot;:&#xD;&#xA;                    crudType = CrudType.Update;&#xD;&#xA;                    break;&#xD;&#xA;                case &quot;DELETE&quot;:&#xD;&#xA;                    crudType = CrudType.Delete;&#xD;&#xA;                    break;&#xD;&#xA;                case &quot;GET&quot;:&#xD;&#xA;                    crudType = CrudType.Read;&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        else if (mappedElement &amp;&amp; (mappedElement.specialization === &quot;Command&quot; ||&#xD;&#xA;            mappedElement.specialization === &quot;Query&quot; ||&#xD;&#xA;            mappedElement.specialization === &quot;Operation&quot;)) {&#xD;&#xA;            for (let association of mappedElement.getAssociations()) {&#xD;&#xA;                switch (association.specialization) {&#xD;&#xA;                    case &quot;Create Entity Action&quot;:&#xD;&#xA;                        crudType = CrudType.Create;&#xD;&#xA;                        break;&#xD;&#xA;                    case &quot;Update Entity Action&quot;:&#xD;&#xA;                        crudType = CrudType.Update;&#xD;&#xA;                        break;&#xD;&#xA;                    case &quot;Delete Entity Action&quot;:&#xD;&#xA;                        crudType = CrudType.Delete;&#xD;&#xA;                        break;&#xD;&#xA;                    case &quot;Query Entity Action&quot;:&#xD;&#xA;                        crudType = CrudType.Read;&#xD;&#xA;                        break;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        else if (!crudType) {&#xD;&#xA;            let mappedElementNameLower = (mappedElement ? mappedElement.getName() : operation.getName()).toLocaleLowerCase();&#xD;&#xA;            if (mappedElementNameLower.indexOf(&quot;create&quot;) &gt; -1) {&#xD;&#xA;                crudType = CrudType.Create;&#xD;&#xA;            }&#xD;&#xA;            else if (mappedElementNameLower.indexOf(&quot;update&quot;) &gt; -1) {&#xD;&#xA;                crudType = CrudType.Update;&#xD;&#xA;            }&#xD;&#xA;            else if (mappedElementNameLower.indexOf(&quot;delete&quot;) &gt; -1) {&#xD;&#xA;                crudType = CrudType.Delete;&#xD;&#xA;            }&#xD;&#xA;            else if (mappedElementNameLower.indexOf(&quot;get&quot;) &gt; -1 || mappedElementNameLower.indexOf(&quot;find&quot;) &gt; -1) {&#xD;&#xA;                crudType = CrudType.Read;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return {&#xD;&#xA;            crudType: crudType,&#xD;&#xA;            httpVerb: httpVerb,&#xD;&#xA;            httpRoute: httpRoute,&#xD;&#xA;            httpRouteParams: httpRouteParams&#xD;&#xA;        };&#xD;&#xA;    }&#xD;&#xA;    static recreateAction(proxyFields, actionElement, flattenFieldsFromComplexTypes, folder, mappingStore) {&#xD;&#xA;        const childSpecialization = flattenFieldsFromComplexTypes&#xD;&#xA;            ? &quot;DTO-Field&quot;&#xD;&#xA;            : proxyFields.length &gt; 0&#xD;&#xA;                ? proxyFields[0].specialization&#xD;&#xA;                : &quot;DTO-Field&quot;;&#xD;&#xA;        let elementManager = new ElementManager(actionElement, { childSpecialization: childSpecialization });&#xD;&#xA;        for (let proxyField of proxyFields) {&#xD;&#xA;            let paramRefType = proxyField.typeReference?.getType()?.specialization;&#xD;&#xA;            switch (paramRefType) {&#xD;&#xA;                case &quot;Command&quot;:&#xD;&#xA;                case &quot;Query&quot;:&#xD;&#xA;                case &quot;DTO&quot;:&#xD;&#xA;                    // Complex type&#xD;&#xA;                    let proxyRefType = proxyField.typeReference.getType();&#xD;&#xA;                    if (flattenFieldsFromComplexTypes) {&#xD;&#xA;                        mappingStore.pushTargetPath(proxyField.id);&#xD;&#xA;                        ProxyServiceHelper.recreateAction(proxyRefType.getChildren(&quot;DTO-Field&quot;), elementManager.getElement(), false, folder, mappingStore);&#xD;&#xA;                        mappingStore.popTargetPath();&#xD;&#xA;                    }&#xD;&#xA;                    else {&#xD;&#xA;                        let actionField = elementManager.addChild(proxyField.getName(), null);&#xD;&#xA;                        mappingStore.pushSourcePath(actionField.id);&#xD;&#xA;                        mappingStore.pushTargetPath(proxyField.id);&#xD;&#xA;                        let actionDto = ProxyServiceHelper.replicateDto(proxyRefType, folder, mappingStore);&#xD;&#xA;                        mappingStore.popSourcePath();&#xD;&#xA;                        mappingStore.popTargetPath();&#xD;&#xA;                        actionField.typeReference.setType(actionDto.id);&#xD;&#xA;                        actionField.typeReference.setIsCollection(proxyField.typeReference.isCollection);&#xD;&#xA;                        actionField.typeReference.setIsNullable(proxyField.typeReference.isNullable);&#xD;&#xA;                        if (proxyField.hasMetadata(&quot;endpoint-input-id&quot;)) {&#xD;&#xA;                            actionField.addMetadata(&quot;endpoint-input-id&quot;, proxyField.getMetadata(&quot;endpoint-input-id&quot;));&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;                default:&#xD;&#xA;                    // Non-Complex type&#xD;&#xA;                    let fieldName = proxyField.getName();&#xD;&#xA;                    if (elementManager.getElement().getChildren().some(x =&gt; x.getName() === fieldName)) {&#xD;&#xA;                        let parentName = proxyField.getParent().getName();&#xD;&#xA;                        fieldName = parentName + fieldName;&#xD;&#xA;                    }&#xD;&#xA;                    let actionField = elementManager.addChild(fieldName, proxyField.typeReference);&#xD;&#xA;                    mappingStore.addMapping(actionField.id, proxyField.id);&#xD;&#xA;                    if (proxyField.hasMetadata(&quot;endpoint-input-id&quot;)) {&#xD;&#xA;                        actionField.addMetadata(&quot;endpoint-input-id&quot;, proxyField.getMetadata(&quot;endpoint-input-id&quot;));&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        elementManager.collapse();&#xD;&#xA;    }&#xD;&#xA;    static replicateDto(proxyDto, folder, mappingStore) {&#xD;&#xA;        let newDto = createElement(&quot;DTO&quot;, proxyDto.getName(), folder.id);&#xD;&#xA;        proxyDto.getChildren(&quot;DTO-Field&quot;).forEach(proxyField =&gt; {&#xD;&#xA;            let actionField = createElement(&quot;DTO-Field&quot;, proxyField.getName(), newDto.id);&#xD;&#xA;            let fieldRefType = proxyField.typeReference?.getType()?.specialization;&#xD;&#xA;            switch (fieldRefType) {&#xD;&#xA;                case &quot;Command&quot;:&#xD;&#xA;                case &quot;Query&quot;:&#xD;&#xA;                case &quot;DTO&quot;:&#xD;&#xA;                    // Complex type&#xD;&#xA;                    mappingStore.pushSourcePath(actionField.id);&#xD;&#xA;                    mappingStore.pushTargetPath(proxyField.id);&#xD;&#xA;                    let nestedDto = ProxyServiceHelper.replicateDto(proxyField.typeReference.getType(), folder, mappingStore);&#xD;&#xA;                    mappingStore.popSourcePath();&#xD;&#xA;                    mappingStore.popTargetPath();&#xD;&#xA;                    actionField.typeReference.setType(nestedDto.id);&#xD;&#xA;                    break;&#xD;&#xA;                default:&#xD;&#xA;                    // Non-Complex type&#xD;&#xA;                    actionField.typeReference.setType(proxyField.typeReference.getTypeId());&#xD;&#xA;                    mappingStore.addMapping(actionField.id, proxyField.id);&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;            actionField.typeReference.setIsCollection(proxyField.typeReference.isCollection);&#xD;&#xA;            actionField.typeReference.setIsNullable(proxyField.typeReference.isNullable);&#xD;&#xA;        });&#xD;&#xA;        return newDto;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;../../common/openSelectItemDialog.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/proxyServiceHelper.ts&quot; /&gt;&#xD;&#xA;async function execute(operation) {&#xD;&#xA;    let servicePackages = getPackages().filter(pkg =&gt; pkg.specialization === &quot;Services Package&quot;);&#xD;&#xA;    let selectedPackage;&#xD;&#xA;    if (servicePackages.length == 1) {&#xD;&#xA;        selectedPackage = servicePackages[0];&#xD;&#xA;    }&#xD;&#xA;    else {&#xD;&#xA;        selectedPackage = await openSelectItemDialog(getPackageSelectItemOptions(servicePackages, &quot;Service Package&quot;));&#xD;&#xA;    }&#xD;&#xA;    const proxy = operation.getParent();&#xD;&#xA;    const folderName = pluralize(ProxyServiceHelper.sanitizeServiceName(proxy.getName()));&#xD;&#xA;    const folder = selectedPackage.getChildren(&quot;Folder&quot;).find(x =&gt; x.getName() == pluralize(folderName)) ?? createElement(&quot;Folder&quot;, pluralize(folderName), selectedPackage.id);&#xD;&#xA;    let newOperation = ProxyServiceHelper.createAppServiceOperationAction(operation, folder);&#xD;&#xA;    const diagramElement = folder.getChildren(&quot;Diagram&quot;).find(x =&gt; x.getName() == folderName) ?? createElement(&quot;Diagram&quot;, folderName, folder.id);&#xD;&#xA;    diagramElement.loadDiagram();&#xD;&#xA;    const diagram = getCurrentDiagram();&#xD;&#xA;    diagram.layoutVisuals([folder, newOperation.getParent()], null, true);&#xD;&#xA;}&#xD;&#xA;/**&#xD;&#xA; * Used by Intent.Modelers.Services.ProxyInteractions&#xD;&#xA; *&#xD;&#xA; * Source code here:&#xD;&#xA; * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/create-appservice-proxy-operation-macro-advanced-mapping/create-appservice-proxy-operation-macro-advanced-mapping.ts&#xD;&#xA; */&#xD;&#xA;await execute(element);&#xD;&#xA;" isActive="true" />
                <property name="7df9c3b9-91a0-4cb7-bc3a-15d72f160054" display="Dependencies" isActive="true" />
              </properties>
            </stereotype>
            <stereotype stereotypeDefinitionId="cbe77364-d1d0-400b-a8c4-646a4c869612" name="Option Settings">
              <comment />
              <addedByDefault>true</addedByDefault>
              <definitionPackageName>Intent.ModuleBuilder</definitionPackageName>
              <definitionPackageId>9972b2a9-b749-4bba-b5c8-824bf694c6ef</definitionPackageId>
              <properties>
                <property name="b2c3a117-23d3-47e5-8b83-5b902c55a226" display="Icon" value="{&quot;source&quot;:&quot;data:image/png;base64,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&quot;,&quot;type&quot;:0,&quot;absolutePathRelativeTo&quot;:null}" isActive="true" />
                <property name="0abff08a-3986-40b1-a28f-4cc03c4fc1ec" display="Shortcut" isActive="true" />
                <property name="79f6973f-5e3a-4618-9d4c-d7cc604bffe0" display="Shortcut (macOS)" isActive="true" />
                <property name="6087e660-9599-47fb-9ff4-1ad901ce2a00" display="Trigger On Double-Click" value="false" isActive="true" />
                <property name="c03841e5-a1e9-4e95-b699-5a466dde7d7d" display="Is Option Visible Function" value="return application.isModuleInstalled(&quot;Intent.Modelers.Services.DomainInteractions&quot;);" isActive="true" />
                <property name="e034a0ca-0101-4594-8384-43048b714578" display="Order" isActive="true" />
                <property name="3e93529e-2110-414e-aec1-2656e1a99b22" display="Top Divider" value="false" isActive="true" />
                <property name="d2572c08-f02e-40b2-8a06-4d5251bb3352" display="Bottom Divider" value="false" isActive="true" />
              </properties>
            </stereotype>
          </stereotypes>
          <metadata />
          <childElements />
        </childElement>
      </childElements>
    </childElement>
  </childElements>
</class>