<?xml version="1.0" encoding="utf-8"?>
<settings version="3.1.1">
  <id>4652d8dc-eea5-49cb-8c08-93ac1972962c</id>
  <name>Document Db Key Automation Extensions</name>
  <designerReferences />
  <packageSettings />
  <packageExtensions>
    <packageExtension type="Domain Package" typeId="1a824508-4623-45d9-accc-f572091ade5a">
      <requiredPackages />
      <macros>
        <macro trigger="on-changed">
          <script>/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function isAggregateRoot(element) {
    return !element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function getDefaultIdType() {
    var _a, _b;
    const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
    const guidTypeId = "6b649125-18ea-48fd-a6ba-0bfff0d8f488";
    const intTypeId = "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74";
    const longTypeId = "33013006-E404-48C2-AC46-24EF5A5774FD";
    const documentDbSettingsId = "d5581fe8-7385-4bb6-88dc-8940e20ec1d4";
    switch ((_b = (_a = application.getSettings(documentDbSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Id Type")) === null || _b === void 0 ? void 0 : _b.value) {
        default:
            return stringTypeId;
        case "guid":
            return guidTypeId;
        case "int":
            return intTypeId;
        case "long":
            return longTypeId;
    }
}
/// &lt;reference path="isAggregateRoot.ts" /&gt;
/// &lt;reference path="getDefaultIdType.ts" /&gt;
function updatePartitionKeyAsPrimary(element, packageLoad = false) {
    if (!isCosmosDb(element))
        return;
    console.warn(element.specialization);
    let allowedTypes = ["Class", "Folder", "Domain Package"];
    if (!allowedTypes.includes(element.specialization)) {
        return;
    }
    const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
    const containerStereotypeId = "ef9b1772-18e1-44ad-b606-66406221c805";
    const multiTenancyStereotypeId = "586eb05b-d647-4430-ac05-8d096fe3f79e";
    let partitionKey = getPartitionKey(element);
    if (!packageLoad &amp;&amp; ["Folder", "Domain Package"].includes(element.specialization)) {
        //prevent unnecessary package scans on every package change event.
        if (element.hasMetadata("currentPartitionKey") &amp;&amp; element.getMetadata("currentPartitionKey") === partitionKey) {
            return;
        }
        console.warn();
    }
    console.warn("Doing Check");
    if (element.specialization == "Class") {
        ensureCorrectPartitionKey(element, partitionKey, packageLoad);
    }
    else {
        updateDescendants(element, partitionKey, packageLoad);
    }
    element.setMetadata("currentPartitionKey", partitionKey);
    function getPartitionKey(element) {
        var _a, _b;
        let result = "";
        while (element) {
            if (element.hasStereotype(containerStereotypeId) &amp;&amp; ((_a = element.getStereotype(containerStereotypeId).getProperty("Partition Key")) === null || _a === void 0 ? void 0 : _a.value)) {
                let partitionKey = (_b = element.getStereotype(containerStereotypeId).getProperty("Partition Key")) === null || _b === void 0 ? void 0 : _b.value;
                if (!partitionKey)
                    partitionKey = "";
                return partitionKey;
            }
            element = element.getParent();
        }
        return result;
    }
    function updateDescendants(element, partitionKeyName, packageLoad) {
        console.warn("checking :" + element.getName());
        let children = element.getChildren().filter(c =&gt; allowedTypes.includes(c.specialization));
        children.forEach(child =&gt; {
            var _a;
            if (child.hasStereotype(containerStereotypeId)) {
                if (packageLoad) {
                    //On package load we check the entire tree not just the scope of the edited item
                    partitionKeyName = (_a = child.getStereotype(containerStereotypeId).getProperty("Partition Key")) === null || _a === void 0 ? void 0 : _a.value;
                }
                else {
                    return;
                }
            }
            if (child.specialization == "Class") {
                ensureCorrectPartitionKey(child, partitionKeyName, packageLoad);
            }
            else {
                updateDescendants(child, partitionKeyName, packageLoad);
            }
        });
    }
    function ensureCorrectPartitionKey(element, partitionKeyName, packageLoad) {
        var _a;
        console.warn("Updating class :" + element.getName());
        if (element.specialization !== "Class") {
            return;
        }
        if (!partitionKeyName) {
            let toRemove = element.getChildren("Attribute")
                .find(x =&gt; x.hasStereotype(primaryKeyStereotypeId) &amp;&amp; x.hasMetadata("partition-key"));
            if (toRemove != null) {
                toRemove.delete();
            }
        }
        else {
            let toFix = element.getChildren("Attribute")
                .find(x =&gt; x.hasStereotype(primaryKeyStereotypeId) &amp;&amp; x.hasMetadata("partition-key") &amp;&amp; x.getName().toLowerCase() != partitionKeyName.toLowerCase());
            if (toFix != null) {
                toFix.removeMetadata("partition-key");
                toFix.removeStereotype(primaryKeyStereotypeId);
            }
            let toAdjust = element.getChildren("Attribute")
                .find(x =&gt; x.getName().toLowerCase() == partitionKeyName.toLowerCase());
            if (toAdjust != null) {
                if (!toAdjust.hasStereotype(primaryKeyStereotypeId)) {
                    toAdjust.addStereotype(primaryKeyStereotypeId);
                }
                let partitionPkStereotype = toAdjust.getStereotype(primaryKeyStereotypeId);
                if (!element.hasStereotype(multiTenancyStereotypeId)) {
                    (_a = partitionPkStereotype.getProperty("Data source")) === null || _a === void 0 ? void 0 : _a.setValue("User supplied");
                }
                toAdjust.setMetadata("partition-key", "true");
            }
        }
    }
    function isCosmosDb(element) {
        var _a, _b, _c;
        const documentStoreId = "8b68020c-6652-484b-85e8-6c33e1d8031f";
        const cosmosDbProvider = "3e1a00f7-c6f1-4785-a544-bbcb17602b31";
        let docDbStereotype = element.getPackage().getStereotype(documentStoreId);
        let providers = lookupTypesOf("Document Db Provider").filter((elem, index) =&gt; lookupTypesOf("Document Db Provider").findIndex(obj =&gt; obj.id == elem.id) === index &amp;&amp; elem.getName() != "Custom");
        return ((!((_a = docDbStereotype.getProperty("Provider")) === null || _a === void 0 ? void 0 : _a.getValue()) &amp;&amp; providers.length == 1 &amp;&amp; providers[0].id == cosmosDbProvider) ||
            ((_c = (_b = docDbStereotype.getProperty("Provider")) === null || _b === void 0 ? void 0 : _b.getValue()) === null || _c === void 0 ? void 0 : _c.id) == cosmosDbProvider);
    }
}
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.DocumentDB
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/documentdb/package-on-change/package-on-change.ts
 */
/// &lt;reference path="../common/updatePartitionKeyAsPrimary.ts" /&gt;
const package = element.getPackage();
function execute() {
    const documentStoreId = "8b68020c-6652-484b-85e8-6c33e1d8031f";
    if (!package.hasStereotype(documentStoreId)) {
        return;
    }
    updatePartitionKeyAsPrimary(element);
}
execute();
</script>
        </macro>
        <macro trigger="on-loaded">
          <script>/**
 * Will run code against a package as needed based on the current (which is stored in metadata on the package) and a target version.
 *
 * If the package is already at the {@link targetVersion}, {@link action} is not executed. After execution of {@link targetVersion} is recorded
 * in metadata on the package under the {@link metadataKeyName} key.
 *
 * @param package The package to ensure is at the latest version and on which the version will be stored as metadata.
 * @param metadataKeyName The name of the metadata key in which to store the version.
 * @param targetVersion The version that should be saved in the metadata this method is complete.
 * @param action A delegate which is called if the current version in the metadata is unspecified or less than the {@link targetVersion}.
 * The delegate is passed the current version as specified in the metadata, or if there is no version yet it is passed -1.
 */
function ensureIsAtTargetVersion(package, metadataKeyName, targetVersion, action) {
    if (!Number.isInteger(targetVersion)) {
        throw new Error("targetVersion must be an integer");
    }
    var currentVersion = package.hasMetadata(metadataKeyName) &amp;&amp;
        Number.isInteger(Number.parseInt(package.getMetadata(metadataKeyName)))
        ? Number.parseInt(package.getMetadata(metadataKeyName))
        : -1;
    if (currentVersion &gt;= targetVersion) {
        return;
    }
    action(currentVersion);
    package.removeMetadata(metadataKeyName);
    package.addMetadata(metadataKeyName, targetVersion.toString());
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function isAggregateRoot(element) {
    return !element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function getDefaultIdType() {
    var _a, _b;
    const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
    const guidTypeId = "6b649125-18ea-48fd-a6ba-0bfff0d8f488";
    const intTypeId = "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74";
    const longTypeId = "33013006-E404-48C2-AC46-24EF5A5774FD";
    const documentDbSettingsId = "d5581fe8-7385-4bb6-88dc-8940e20ec1d4";
    switch ((_b = (_a = application.getSettings(documentDbSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Id Type")) === null || _b === void 0 ? void 0 : _b.value) {
        default:
            return stringTypeId;
        case "guid":
            return guidTypeId;
        case "int":
            return intTypeId;
        case "long":
            return longTypeId;
    }
}
/// &lt;reference path="isAggregateRoot.ts" /&gt;
/// &lt;reference path="getDefaultIdType.ts" /&gt;
function updatePrimaryKey(element) {
    if (element.specialization !== "Class") {
        return;
    }
    const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
    let idAttr = element.getChildren("Attribute")
        .find(x =&gt; x.hasStereotype(primaryKeyStereotypeId));
    const isToCompositionalOneRelationshipTarget = () =&gt; element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; !x.getOtherEnd().typeReference.isCollection);
    if ((!isAggregateRoot(element) &amp;&amp; isToCompositionalOneRelationshipTarget()) || derivedFromTypeHasPk(element)) {
        if (idAttr != null) {
            idAttr.delete();
        }
        updateDerivedTypePks(element);
        return;
    }
    if (isTableStorage(element)) {
        updateTableStoragePk(element);
    }
    else {
        if (idAttr == null) {
            const classNameWithId = `${element.getName()}Id`.toLowerCase();
            idAttr = element.getChildren("Attribute")
                .find(attribute =&gt; {
                const attributeName = attribute.getName().toLowerCase();
                return attributeName === "id" || attributeName === classNameWithId;
            });
        }
        if (idAttr == null) {
            idAttr = createElement("Attribute", "Id", element.id);
            idAttr.setOrder(0);
            if (idAttr.typeReference == null)
                throw new Error("typeReference is not defined");
            idAttr.typeReference.setType(getDefaultIdType());
        }
        if (!idAttr.hasStereotype(primaryKeyStereotypeId)) {
            idAttr.addStereotype(primaryKeyStereotypeId);
        }
    }
    updateDerivedTypePks(element);
    function derivedFromTypeHasPk(element) {
        const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
        return element.getAssociations("Generalization")
            .some(generalization =&gt; {
            if (!generalization.isTargetEnd()) {
                return false;
            }
            const baseType = generalization.typeReference.getType();
            if (baseType.getChildren("Attribute").some(attribute =&gt; attribute.hasStereotype(primaryKeyStereotypeId))) {
                return true;
            }
            return derivedFromTypeHasPk(baseType);
        });
    }
    function updateDerivedTypePks(element) {
        const derivedTypes = element.getAssociations("Generalization")
            .filter(generalization =&gt; generalization.isSourceEnd())
            .map(generalization =&gt; generalization.typeReference.getType());
        for (const derivedType of derivedTypes) {
            updatePrimaryKey(derivedType);
        }
    }
}
function isTableStorage(element) {
    var _a, _b, _c;
    const documentStoreId = "8b68020c-6652-484b-85e8-6c33e1d8031f";
    const tableStorageProvider = "1d05ee8e-747f-4120-9647-29ac784ef633";
    var docDbStereotype = element.getPackage().getStereotype(documentStoreId);
    let providers = lookupTypesOf("Document Db Provider").filter((elem, index) =&gt; lookupTypesOf("Document Db Provider").findIndex(obj =&gt; obj.id == elem.id) === index &amp;&amp; elem.getName() != "Custom");
    return ((!((_a = docDbStereotype.getProperty("Provider")) === null || _a === void 0 ? void 0 : _a.getValue()) &amp;&amp; providers.length == 1 &amp;&amp; providers[0].id == tableStorageProvider) ||
        ((_c = (_b = docDbStereotype.getProperty("Provider")) === null || _b === void 0 ? void 0 : _b.getValue()) === null || _c === void 0 ? void 0 : _c.id) == tableStorageProvider);
}
function updateTableStoragePk(element) {
    var _a, _b;
    const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
    const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
    let idAttrs = element.getChildren("Attribute").filter(x =&gt; x.hasStereotype(primaryKeyStereotypeId));
    if (!isAggregateRoot(element)) {
        if (idAttrs.length &gt; 0) {
            idAttrs.forEach(key =&gt; key.delete());
        }
    }
    else {
        //Keys are not right
        if (!(idAttrs.length == 2 &amp;&amp; idAttrs[0].getName() == "PartitionKey" &amp;&amp; idAttrs[1].getName() == "RowKey")) {
            if (idAttrs.length &gt; 0) {
                idAttrs.forEach(key =&gt; key.delete());
            }
            let rowKeyAttr = createElement("Attribute", "RowKey", element.id);
            rowKeyAttr.setOrder(0);
            rowKeyAttr.typeReference.setType(stringTypeId);
            let idPkSterotype = rowKeyAttr.addStereotype(primaryKeyStereotypeId);
            (_a = idPkSterotype.getProperty("Data source")) === null || _a === void 0 ? void 0 : _a.setValue("User supplied");
            let partitionKeyAttr = createElement("Attribute", "PartitionKey", element.id);
            partitionKeyAttr.setOrder(0);
            partitionKeyAttr.typeReference.setType(stringTypeId);
            let partitionPkStereotype = partitionKeyAttr.addStereotype(primaryKeyStereotypeId);
            (_b = partitionPkStereotype.getProperty("Data source")) === null || _b === void 0 ? void 0 : _b.setValue("User supplied");
        }
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function isAggregateRelationship(associationEnd) {
    let sourceAssociationEnd = associationEnd;
    if (associationEnd.isTargetEnd()) {
        sourceAssociationEnd = sourceAssociationEnd.getOtherEnd();
    }
    return sourceAssociationEnd.typeReference.isNullable || sourceAssociationEnd.typeReference.isCollection;
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../common/isAggregateRelationship.ts" /&gt;
function requiresForeignKey(associationEnd) {
    return associationEnd.typeReference.isNavigable &amp;&amp;
        isAggregateRelationship(associationEnd);
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
;
function getPrimaryKeysWithMapPath(entity) {
    let keyDict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
    // There is a problem with execution order where this script executes before
    // the generalization script had a chance to potentially remove a PK attribute
    // and so I have to perform an inheritance check and ignore any PKs on derived classes.
    if (generalizations.length == 0) {
        keys.forEach(key =&gt; {
            if (key.typeReference == null)
                throw new Error("typeReference is undefined");
            return keyDict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: [key.id],
                isNullable: false,
                isCollection: false
            };
        });
    }
    traverseInheritanceHierarchyForPrimaryKeys(keyDict, entity, []);
    return keyDict;
    function traverseInheritanceHierarchyForPrimaryKeys(keyDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            if (key.typeReference == null)
                throw new Error("typeReference is undefined");
            keyDict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keyDict, nextEntity, generalizationStack);
    }
}
/// &lt;reference path="../common/getPrimaryKeysWithMapPath.ts" /&gt;
function updateForeignKeyAttribute(startingEndType, destinationEndType, associationEnd, associationId) {
    const ForeignKeyStereotypeId = "ced3e970-e900-4f99-bd04-b993228fe17d";
    let primaryKeyDict = getPrimaryKeysWithMapPath(destinationEndType);
    let primaryKeyObjects = Object.values(primaryKeyDict);
    let primaryKeysLen = primaryKeyObjects.length;
    primaryKeyObjects.forEach((pk, index) =&gt; {
        var _a;
        let fk = (_a = startingEndType.getChildren()
            .filter(x =&gt; (x.getMetadata("association") == associationId) ||
            (x.hasStereotype(ForeignKeyStereotypeId) &amp;&amp; !x.hasMetadata("association")))[index]) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Attribute", "", startingEndType.id);
        // This check to avoid a loop where the Domain script is updating the conventions and this keeps renaming it back.
        let fkNameToUse = `${toCamelCase(associationEnd.getName())}${toPascalCase(pk.name)}`;
        if (associationEnd.typeReference.isCollection) {
            fkNameToUse = pluralize(fkNameToUse);
        }
        if (fk.getName().toLocaleLowerCase() !== fkNameToUse.toLocaleLowerCase()) {
            if (!fk.hasMetadata("fk-original-name") || (fk.getMetadata("fk-original-name") == fk.getName())) {
                if (fkNameToUse != fk.getName()) {
                    fk.setName(fkNameToUse);
                }
                fk.setMetadata("fk-original-name", fk.getName());
            }
        }
        fk.setMetadata("association", associationId);
        fk.setMetadata("is-managed-key", "true");
        let fkStereotype = fk.getStereotype(ForeignKeyStereotypeId);
        if (!fkStereotype) {
            fk.addStereotype(ForeignKeyStereotypeId);
            fkStereotype = fk.getStereotype(ForeignKeyStereotypeId);
        }
        if (fkStereotype.getProperty("Association").getValue() != associationId) {
            fkStereotype.getProperty("Association").setValue(associationId);
        }
        if (fk.typeReference == null)
            throw new Error("typeReference is undefined");
        if (fk.typeReference.typeId != pk.typeId) {
            fk.typeReference.setType(pk.typeId);
        }
        if (fk.typeReference.isNullable != associationEnd.typeReference.isNullable) {
            fk.typeReference.setIsNullable(associationEnd.typeReference.isNullable);
        }
        if (fk.typeReference.isCollection != associationEnd.typeReference.isCollection) {
            fk.typeReference.setIsCollection(associationEnd.typeReference.isCollection);
        }
    });
    startingEndType.getChildren().filter(x =&gt; x.getMetadata("association") == associationId).forEach((attr, index) =&gt; {
        if (index &gt;= primaryKeysLen) {
            attr.delete();
        }
    });
}
/// &lt;reference path="../common/requiresForeignKey.ts" /&gt;
/// &lt;reference path="../common/updateForeignKeyAttribute.ts" /&gt;
function updateForeignKeysForElement(element) {
    for (let association of element.getAssociations()) {
        if (!association.isTargetEnd()) {
            continue;
        }
        let sourceType = lookup(association.getOtherEnd().typeReference.typeId);
        let targetType = lookup(association.typeReference.typeId);
        if (!sourceType || !targetType) {
            continue;
        }
        if (requiresForeignKey(association)) {
            updateForeignKeyAttribute(sourceType, targetType, association, association.id);
        }
        if (requiresForeignKey(association.getOtherEnd())) {
            updateForeignKeyAttribute(targetType, sourceType, association.getOtherEnd(), association.id);
        }
    }
    removeOrphanedAssociations(element);
}
function removeOrphanedAssociations(element) {
    let existingAssociations = element.getAssociations();
    let existingAttributes = element.getChildren("Attribute");
    for (let attr of existingAttributes) {
        if (!attr.getMetadata("association")) {
            continue;
        }
        if (!existingAssociations.some(x =&gt; attr.getMetadata("association") == x.id)) {
            attr.delete();
        }
    }
}
/// &lt;reference path="isAggregateRoot.ts" /&gt;
/// &lt;reference path="getDefaultIdType.ts" /&gt;
function updatePartitionKeyAsPrimary(element, packageLoad = false) {
    if (!isCosmosDb(element))
        return;
    console.warn(element.specialization);
    let allowedTypes = ["Class", "Folder", "Domain Package"];
    if (!allowedTypes.includes(element.specialization)) {
        return;
    }
    const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
    const containerStereotypeId = "ef9b1772-18e1-44ad-b606-66406221c805";
    const multiTenancyStereotypeId = "586eb05b-d647-4430-ac05-8d096fe3f79e";
    let partitionKey = getPartitionKey(element);
    if (!packageLoad &amp;&amp; ["Folder", "Domain Package"].includes(element.specialization)) {
        //prevent unnecessary package scans on every package change event.
        if (element.hasMetadata("currentPartitionKey") &amp;&amp; element.getMetadata("currentPartitionKey") === partitionKey) {
            return;
        }
        console.warn();
    }
    console.warn("Doing Check");
    if (element.specialization == "Class") {
        ensureCorrectPartitionKey(element, partitionKey, packageLoad);
    }
    else {
        updateDescendants(element, partitionKey, packageLoad);
    }
    element.setMetadata("currentPartitionKey", partitionKey);
    function getPartitionKey(element) {
        var _a, _b;
        let result = "";
        while (element) {
            if (element.hasStereotype(containerStereotypeId) &amp;&amp; ((_a = element.getStereotype(containerStereotypeId).getProperty("Partition Key")) === null || _a === void 0 ? void 0 : _a.value)) {
                let partitionKey = (_b = element.getStereotype(containerStereotypeId).getProperty("Partition Key")) === null || _b === void 0 ? void 0 : _b.value;
                if (!partitionKey)
                    partitionKey = "";
                return partitionKey;
            }
            element = element.getParent();
        }
        return result;
    }
    function updateDescendants(element, partitionKeyName, packageLoad) {
        console.warn("checking :" + element.getName());
        let children = element.getChildren().filter(c =&gt; allowedTypes.includes(c.specialization));
        children.forEach(child =&gt; {
            var _a;
            if (child.hasStereotype(containerStereotypeId)) {
                if (packageLoad) {
                    //On package load we check the entire tree not just the scope of the edited item
                    partitionKeyName = (_a = child.getStereotype(containerStereotypeId).getProperty("Partition Key")) === null || _a === void 0 ? void 0 : _a.value;
                }
                else {
                    return;
                }
            }
            if (child.specialization == "Class") {
                ensureCorrectPartitionKey(child, partitionKeyName, packageLoad);
            }
            else {
                updateDescendants(child, partitionKeyName, packageLoad);
            }
        });
    }
    function ensureCorrectPartitionKey(element, partitionKeyName, packageLoad) {
        var _a;
        console.warn("Updating class :" + element.getName());
        if (element.specialization !== "Class") {
            return;
        }
        if (!partitionKeyName) {
            let toRemove = element.getChildren("Attribute")
                .find(x =&gt; x.hasStereotype(primaryKeyStereotypeId) &amp;&amp; x.hasMetadata("partition-key"));
            if (toRemove != null) {
                toRemove.delete();
            }
        }
        else {
            let toFix = element.getChildren("Attribute")
                .find(x =&gt; x.hasStereotype(primaryKeyStereotypeId) &amp;&amp; x.hasMetadata("partition-key") &amp;&amp; x.getName().toLowerCase() != partitionKeyName.toLowerCase());
            if (toFix != null) {
                toFix.removeMetadata("partition-key");
                toFix.removeStereotype(primaryKeyStereotypeId);
            }
            let toAdjust = element.getChildren("Attribute")
                .find(x =&gt; x.getName().toLowerCase() == partitionKeyName.toLowerCase());
            if (toAdjust != null) {
                if (!toAdjust.hasStereotype(primaryKeyStereotypeId)) {
                    toAdjust.addStereotype(primaryKeyStereotypeId);
                }
                let partitionPkStereotype = toAdjust.getStereotype(primaryKeyStereotypeId);
                if (!element.hasStereotype(multiTenancyStereotypeId)) {
                    (_a = partitionPkStereotype.getProperty("Data source")) === null || _a === void 0 ? void 0 : _a.setValue("User supplied");
                }
                toAdjust.setMetadata("partition-key", "true");
            }
        }
    }
    function isCosmosDb(element) {
        var _a, _b, _c;
        const documentStoreId = "8b68020c-6652-484b-85e8-6c33e1d8031f";
        const cosmosDbProvider = "3e1a00f7-c6f1-4785-a544-bbcb17602b31";
        let docDbStereotype = element.getPackage().getStereotype(documentStoreId);
        let providers = lookupTypesOf("Document Db Provider").filter((elem, index) =&gt; lookupTypesOf("Document Db Provider").findIndex(obj =&gt; obj.id == elem.id) === index &amp;&amp; elem.getName() != "Custom");
        return ((!((_a = docDbStereotype.getProperty("Provider")) === null || _a === void 0 ? void 0 : _a.getValue()) &amp;&amp; providers.length == 1 &amp;&amp; providers[0].id == cosmosDbProvider) ||
            ((_c = (_b = docDbStereotype.getProperty("Provider")) === null || _b === void 0 ? void 0 : _b.getValue()) === null || _c === void 0 ? void 0 : _c.id) == cosmosDbProvider);
    }
}
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.DocumentDB
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/documentdb/package-on-loaded/package-on-loaded.ts
 */
/// &lt;reference path="../../common/ensureIsAtTargetVersion.ts" /&gt;
/// &lt;reference path="../common/updatePrimaryKey.ts" /&gt;
/// &lt;reference path="../common/updateForeignKeysForElement.ts" /&gt;
/// &lt;reference path="../common/updatePartitionKeyAsPrimary.ts" /&gt;
const package = element.getPackage();
function execute() {
    const documentStoreId = "8b68020c-6652-484b-85e8-6c33e1d8031f";
    package.getStereotypes();
    if (!package.hasStereotype(documentStoreId) &amp;&amp;
        !package.hasMetadata("database-paradigm-selected") &amp;&amp;
        !package.hasStereotype("Relational Database")) {
        package.addStereotype(documentStoreId);
    }
    package.setMetadata("database-paradigm-selected", "true");
    if (!package.hasStereotype(documentStoreId)) {
        return;
    }
    let classes = lookupTypesOf("Class").filter(x =&gt; x.getPackage().id === package.id);
    for (let classElement of classes) {
        updatePrimaryKey(classElement);
        updateForeignKeysForElement(classElement);
    }
    updatePartitionKeyAsPrimary(element, true);
}
execute();
</script>
        </macro>
      </macros>
    </packageExtension>
  </packageExtensions>
  <elementSettings />
  <elementExtensions>
    <elementExtension type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10">
      <mappingSettings />
      <macros>
        <macro trigger="on-changed">
          <script>/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function isAggregateRoot(element) {
    return !element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function getDefaultIdType() {
    var _a, _b;
    const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
    const guidTypeId = "6b649125-18ea-48fd-a6ba-0bfff0d8f488";
    const intTypeId = "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74";
    const longTypeId = "33013006-E404-48C2-AC46-24EF5A5774FD";
    const documentDbSettingsId = "d5581fe8-7385-4bb6-88dc-8940e20ec1d4";
    switch ((_b = (_a = application.getSettings(documentDbSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Id Type")) === null || _b === void 0 ? void 0 : _b.value) {
        default:
            return stringTypeId;
        case "guid":
            return guidTypeId;
        case "int":
            return intTypeId;
        case "long":
            return longTypeId;
    }
}
/// &lt;reference path="isAggregateRoot.ts" /&gt;
/// &lt;reference path="getDefaultIdType.ts" /&gt;
function updatePrimaryKey(element) {
    if (element.specialization !== "Class") {
        return;
    }
    const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
    let idAttr = element.getChildren("Attribute")
        .find(x =&gt; x.hasStereotype(primaryKeyStereotypeId));
    const isToCompositionalOneRelationshipTarget = () =&gt; element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; !x.getOtherEnd().typeReference.isCollection);
    if ((!isAggregateRoot(element) &amp;&amp; isToCompositionalOneRelationshipTarget()) || derivedFromTypeHasPk(element)) {
        if (idAttr != null) {
            idAttr.delete();
        }
        updateDerivedTypePks(element);
        return;
    }
    if (isTableStorage(element)) {
        updateTableStoragePk(element);
    }
    else {
        if (idAttr == null) {
            const classNameWithId = `${element.getName()}Id`.toLowerCase();
            idAttr = element.getChildren("Attribute")
                .find(attribute =&gt; {
                const attributeName = attribute.getName().toLowerCase();
                return attributeName === "id" || attributeName === classNameWithId;
            });
        }
        if (idAttr == null) {
            idAttr = createElement("Attribute", "Id", element.id);
            idAttr.setOrder(0);
            if (idAttr.typeReference == null)
                throw new Error("typeReference is not defined");
            idAttr.typeReference.setType(getDefaultIdType());
        }
        if (!idAttr.hasStereotype(primaryKeyStereotypeId)) {
            idAttr.addStereotype(primaryKeyStereotypeId);
        }
    }
    updateDerivedTypePks(element);
    function derivedFromTypeHasPk(element) {
        const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
        return element.getAssociations("Generalization")
            .some(generalization =&gt; {
            if (!generalization.isTargetEnd()) {
                return false;
            }
            const baseType = generalization.typeReference.getType();
            if (baseType.getChildren("Attribute").some(attribute =&gt; attribute.hasStereotype(primaryKeyStereotypeId))) {
                return true;
            }
            return derivedFromTypeHasPk(baseType);
        });
    }
    function updateDerivedTypePks(element) {
        const derivedTypes = element.getAssociations("Generalization")
            .filter(generalization =&gt; generalization.isSourceEnd())
            .map(generalization =&gt; generalization.typeReference.getType());
        for (const derivedType of derivedTypes) {
            updatePrimaryKey(derivedType);
        }
    }
}
function isTableStorage(element) {
    var _a, _b, _c;
    const documentStoreId = "8b68020c-6652-484b-85e8-6c33e1d8031f";
    const tableStorageProvider = "1d05ee8e-747f-4120-9647-29ac784ef633";
    var docDbStereotype = element.getPackage().getStereotype(documentStoreId);
    let providers = lookupTypesOf("Document Db Provider").filter((elem, index) =&gt; lookupTypesOf("Document Db Provider").findIndex(obj =&gt; obj.id == elem.id) === index &amp;&amp; elem.getName() != "Custom");
    return ((!((_a = docDbStereotype.getProperty("Provider")) === null || _a === void 0 ? void 0 : _a.getValue()) &amp;&amp; providers.length == 1 &amp;&amp; providers[0].id == tableStorageProvider) ||
        ((_c = (_b = docDbStereotype.getProperty("Provider")) === null || _b === void 0 ? void 0 : _b.getValue()) === null || _c === void 0 ? void 0 : _c.id) == tableStorageProvider);
}
function updateTableStoragePk(element) {
    var _a, _b;
    const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
    const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
    let idAttrs = element.getChildren("Attribute").filter(x =&gt; x.hasStereotype(primaryKeyStereotypeId));
    if (!isAggregateRoot(element)) {
        if (idAttrs.length &gt; 0) {
            idAttrs.forEach(key =&gt; key.delete());
        }
    }
    else {
        //Keys are not right
        if (!(idAttrs.length == 2 &amp;&amp; idAttrs[0].getName() == "PartitionKey" &amp;&amp; idAttrs[1].getName() == "RowKey")) {
            if (idAttrs.length &gt; 0) {
                idAttrs.forEach(key =&gt; key.delete());
            }
            let rowKeyAttr = createElement("Attribute", "RowKey", element.id);
            rowKeyAttr.setOrder(0);
            rowKeyAttr.typeReference.setType(stringTypeId);
            let idPkSterotype = rowKeyAttr.addStereotype(primaryKeyStereotypeId);
            (_a = idPkSterotype.getProperty("Data source")) === null || _a === void 0 ? void 0 : _a.setValue("User supplied");
            let partitionKeyAttr = createElement("Attribute", "PartitionKey", element.id);
            partitionKeyAttr.setOrder(0);
            partitionKeyAttr.typeReference.setType(stringTypeId);
            let partitionPkStereotype = partitionKeyAttr.addStereotype(primaryKeyStereotypeId);
            (_b = partitionPkStereotype.getProperty("Data source")) === null || _b === void 0 ? void 0 : _b.setValue("User supplied");
        }
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function isAggregateRelationship(associationEnd) {
    let sourceAssociationEnd = associationEnd;
    if (associationEnd.isTargetEnd()) {
        sourceAssociationEnd = sourceAssociationEnd.getOtherEnd();
    }
    return sourceAssociationEnd.typeReference.isNullable || sourceAssociationEnd.typeReference.isCollection;
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../common/isAggregateRelationship.ts" /&gt;
function requiresForeignKey(associationEnd) {
    return associationEnd.typeReference.isNavigable &amp;&amp;
        isAggregateRelationship(associationEnd);
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
;
function getPrimaryKeysWithMapPath(entity) {
    let keyDict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
    // There is a problem with execution order where this script executes before
    // the generalization script had a chance to potentially remove a PK attribute
    // and so I have to perform an inheritance check and ignore any PKs on derived classes.
    if (generalizations.length == 0) {
        keys.forEach(key =&gt; {
            if (key.typeReference == null)
                throw new Error("typeReference is undefined");
            return keyDict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: [key.id],
                isNullable: false,
                isCollection: false
            };
        });
    }
    traverseInheritanceHierarchyForPrimaryKeys(keyDict, entity, []);
    return keyDict;
    function traverseInheritanceHierarchyForPrimaryKeys(keyDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            if (key.typeReference == null)
                throw new Error("typeReference is undefined");
            keyDict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keyDict, nextEntity, generalizationStack);
    }
}
/// &lt;reference path="../common/getPrimaryKeysWithMapPath.ts" /&gt;
function updateForeignKeyAttribute(startingEndType, destinationEndType, associationEnd, associationId) {
    const ForeignKeyStereotypeId = "ced3e970-e900-4f99-bd04-b993228fe17d";
    let primaryKeyDict = getPrimaryKeysWithMapPath(destinationEndType);
    let primaryKeyObjects = Object.values(primaryKeyDict);
    let primaryKeysLen = primaryKeyObjects.length;
    primaryKeyObjects.forEach((pk, index) =&gt; {
        var _a;
        let fk = (_a = startingEndType.getChildren()
            .filter(x =&gt; (x.getMetadata("association") == associationId) ||
            (x.hasStereotype(ForeignKeyStereotypeId) &amp;&amp; !x.hasMetadata("association")))[index]) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Attribute", "", startingEndType.id);
        // This check to avoid a loop where the Domain script is updating the conventions and this keeps renaming it back.
        let fkNameToUse = `${toCamelCase(associationEnd.getName())}${toPascalCase(pk.name)}`;
        if (associationEnd.typeReference.isCollection) {
            fkNameToUse = pluralize(fkNameToUse);
        }
        if (fk.getName().toLocaleLowerCase() !== fkNameToUse.toLocaleLowerCase()) {
            if (!fk.hasMetadata("fk-original-name") || (fk.getMetadata("fk-original-name") == fk.getName())) {
                if (fkNameToUse != fk.getName()) {
                    fk.setName(fkNameToUse);
                }
                fk.setMetadata("fk-original-name", fk.getName());
            }
        }
        fk.setMetadata("association", associationId);
        fk.setMetadata("is-managed-key", "true");
        let fkStereotype = fk.getStereotype(ForeignKeyStereotypeId);
        if (!fkStereotype) {
            fk.addStereotype(ForeignKeyStereotypeId);
            fkStereotype = fk.getStereotype(ForeignKeyStereotypeId);
        }
        if (fkStereotype.getProperty("Association").getValue() != associationId) {
            fkStereotype.getProperty("Association").setValue(associationId);
        }
        if (fk.typeReference == null)
            throw new Error("typeReference is undefined");
        if (fk.typeReference.typeId != pk.typeId) {
            fk.typeReference.setType(pk.typeId);
        }
        if (fk.typeReference.isNullable != associationEnd.typeReference.isNullable) {
            fk.typeReference.setIsNullable(associationEnd.typeReference.isNullable);
        }
        if (fk.typeReference.isCollection != associationEnd.typeReference.isCollection) {
            fk.typeReference.setIsCollection(associationEnd.typeReference.isCollection);
        }
    });
    startingEndType.getChildren().filter(x =&gt; x.getMetadata("association") == associationId).forEach((attr, index) =&gt; {
        if (index &gt;= primaryKeysLen) {
            attr.delete();
        }
    });
}
/// &lt;reference path="../common/requiresForeignKey.ts" /&gt;
/// &lt;reference path="../common/updateForeignKeyAttribute.ts" /&gt;
function updateForeignKeysForElement(element) {
    for (let association of element.getAssociations()) {
        if (!association.isTargetEnd()) {
            continue;
        }
        let sourceType = lookup(association.getOtherEnd().typeReference.typeId);
        let targetType = lookup(association.typeReference.typeId);
        if (!sourceType || !targetType) {
            continue;
        }
        if (requiresForeignKey(association)) {
            updateForeignKeyAttribute(sourceType, targetType, association, association.id);
        }
        if (requiresForeignKey(association.getOtherEnd())) {
            updateForeignKeyAttribute(targetType, sourceType, association.getOtherEnd(), association.id);
        }
    }
    removeOrphanedAssociations(element);
}
function removeOrphanedAssociations(element) {
    let existingAssociations = element.getAssociations();
    let existingAttributes = element.getChildren("Attribute");
    for (let attr of existingAttributes) {
        if (!attr.getMetadata("association")) {
            continue;
        }
        if (!existingAssociations.some(x =&gt; attr.getMetadata("association") == x.id)) {
            attr.delete();
        }
    }
}
/// &lt;reference path="isAggregateRoot.ts" /&gt;
/// &lt;reference path="getDefaultIdType.ts" /&gt;
function updatePartitionKeyAsPrimary(element, packageLoad = false) {
    if (!isCosmosDb(element))
        return;
    console.warn(element.specialization);
    let allowedTypes = ["Class", "Folder", "Domain Package"];
    if (!allowedTypes.includes(element.specialization)) {
        return;
    }
    const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
    const containerStereotypeId = "ef9b1772-18e1-44ad-b606-66406221c805";
    const multiTenancyStereotypeId = "586eb05b-d647-4430-ac05-8d096fe3f79e";
    let partitionKey = getPartitionKey(element);
    if (!packageLoad &amp;&amp; ["Folder", "Domain Package"].includes(element.specialization)) {
        //prevent unnecessary package scans on every package change event.
        if (element.hasMetadata("currentPartitionKey") &amp;&amp; element.getMetadata("currentPartitionKey") === partitionKey) {
            return;
        }
        console.warn();
    }
    console.warn("Doing Check");
    if (element.specialization == "Class") {
        ensureCorrectPartitionKey(element, partitionKey, packageLoad);
    }
    else {
        updateDescendants(element, partitionKey, packageLoad);
    }
    element.setMetadata("currentPartitionKey", partitionKey);
    function getPartitionKey(element) {
        var _a, _b;
        let result = "";
        while (element) {
            if (element.hasStereotype(containerStereotypeId) &amp;&amp; ((_a = element.getStereotype(containerStereotypeId).getProperty("Partition Key")) === null || _a === void 0 ? void 0 : _a.value)) {
                let partitionKey = (_b = element.getStereotype(containerStereotypeId).getProperty("Partition Key")) === null || _b === void 0 ? void 0 : _b.value;
                if (!partitionKey)
                    partitionKey = "";
                return partitionKey;
            }
            element = element.getParent();
        }
        return result;
    }
    function updateDescendants(element, partitionKeyName, packageLoad) {
        console.warn("checking :" + element.getName());
        let children = element.getChildren().filter(c =&gt; allowedTypes.includes(c.specialization));
        children.forEach(child =&gt; {
            var _a;
            if (child.hasStereotype(containerStereotypeId)) {
                if (packageLoad) {
                    //On package load we check the entire tree not just the scope of the edited item
                    partitionKeyName = (_a = child.getStereotype(containerStereotypeId).getProperty("Partition Key")) === null || _a === void 0 ? void 0 : _a.value;
                }
                else {
                    return;
                }
            }
            if (child.specialization == "Class") {
                ensureCorrectPartitionKey(child, partitionKeyName, packageLoad);
            }
            else {
                updateDescendants(child, partitionKeyName, packageLoad);
            }
        });
    }
    function ensureCorrectPartitionKey(element, partitionKeyName, packageLoad) {
        var _a;
        console.warn("Updating class :" + element.getName());
        if (element.specialization !== "Class") {
            return;
        }
        if (!partitionKeyName) {
            let toRemove = element.getChildren("Attribute")
                .find(x =&gt; x.hasStereotype(primaryKeyStereotypeId) &amp;&amp; x.hasMetadata("partition-key"));
            if (toRemove != null) {
                toRemove.delete();
            }
        }
        else {
            let toFix = element.getChildren("Attribute")
                .find(x =&gt; x.hasStereotype(primaryKeyStereotypeId) &amp;&amp; x.hasMetadata("partition-key") &amp;&amp; x.getName().toLowerCase() != partitionKeyName.toLowerCase());
            if (toFix != null) {
                toFix.removeMetadata("partition-key");
                toFix.removeStereotype(primaryKeyStereotypeId);
            }
            let toAdjust = element.getChildren("Attribute")
                .find(x =&gt; x.getName().toLowerCase() == partitionKeyName.toLowerCase());
            if (toAdjust != null) {
                if (!toAdjust.hasStereotype(primaryKeyStereotypeId)) {
                    toAdjust.addStereotype(primaryKeyStereotypeId);
                }
                let partitionPkStereotype = toAdjust.getStereotype(primaryKeyStereotypeId);
                if (!element.hasStereotype(multiTenancyStereotypeId)) {
                    (_a = partitionPkStereotype.getProperty("Data source")) === null || _a === void 0 ? void 0 : _a.setValue("User supplied");
                }
                toAdjust.setMetadata("partition-key", "true");
            }
        }
    }
    function isCosmosDb(element) {
        var _a, _b, _c;
        const documentStoreId = "8b68020c-6652-484b-85e8-6c33e1d8031f";
        const cosmosDbProvider = "3e1a00f7-c6f1-4785-a544-bbcb17602b31";
        let docDbStereotype = element.getPackage().getStereotype(documentStoreId);
        let providers = lookupTypesOf("Document Db Provider").filter((elem, index) =&gt; lookupTypesOf("Document Db Provider").findIndex(obj =&gt; obj.id == elem.id) === index &amp;&amp; elem.getName() != "Custom");
        return ((!((_a = docDbStereotype.getProperty("Provider")) === null || _a === void 0 ? void 0 : _a.getValue()) &amp;&amp; providers.length == 1 &amp;&amp; providers[0].id == cosmosDbProvider) ||
            ((_c = (_b = docDbStereotype.getProperty("Provider")) === null || _b === void 0 ? void 0 : _b.getValue()) === null || _c === void 0 ? void 0 : _c.id) == cosmosDbProvider);
    }
}
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.DocumentDB
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/documentdb/class-on-changed/class-on-changed.ts
 */
/// &lt;reference path="../common/updatePrimaryKey.ts" /&gt;
/// &lt;reference path="../common/updateForeignKeysForElement.ts" /&gt;
/// &lt;reference path="../common/updatePartitionKeyAsPrimary.ts" /&gt;
function execute() {
    const documentStoreId = "8b68020c-6652-484b-85e8-6c33e1d8031f";
    if (!element.getPackage().hasStereotype(documentStoreId)) {
        return;
    }
    updatePrimaryKey(element);
    updateForeignKeysForElement(element);
    updatePartitionKeyAsPrimary(element);
}
execute();
</script>
        </macro>
        <macro trigger="on-created">
          <script>/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function isAggregateRoot(element) {
    return !element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function getDefaultIdType() {
    var _a, _b;
    const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
    const guidTypeId = "6b649125-18ea-48fd-a6ba-0bfff0d8f488";
    const intTypeId = "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74";
    const longTypeId = "33013006-E404-48C2-AC46-24EF5A5774FD";
    const documentDbSettingsId = "d5581fe8-7385-4bb6-88dc-8940e20ec1d4";
    switch ((_b = (_a = application.getSettings(documentDbSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Id Type")) === null || _b === void 0 ? void 0 : _b.value) {
        default:
            return stringTypeId;
        case "guid":
            return guidTypeId;
        case "int":
            return intTypeId;
        case "long":
            return longTypeId;
    }
}
/// &lt;reference path="isAggregateRoot.ts" /&gt;
/// &lt;reference path="getDefaultIdType.ts" /&gt;
function updatePrimaryKey(element) {
    if (element.specialization !== "Class") {
        return;
    }
    const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
    let idAttr = element.getChildren("Attribute")
        .find(x =&gt; x.hasStereotype(primaryKeyStereotypeId));
    const isToCompositionalOneRelationshipTarget = () =&gt; element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; !x.getOtherEnd().typeReference.isCollection);
    if ((!isAggregateRoot(element) &amp;&amp; isToCompositionalOneRelationshipTarget()) || derivedFromTypeHasPk(element)) {
        if (idAttr != null) {
            idAttr.delete();
        }
        updateDerivedTypePks(element);
        return;
    }
    if (isTableStorage(element)) {
        updateTableStoragePk(element);
    }
    else {
        if (idAttr == null) {
            const classNameWithId = `${element.getName()}Id`.toLowerCase();
            idAttr = element.getChildren("Attribute")
                .find(attribute =&gt; {
                const attributeName = attribute.getName().toLowerCase();
                return attributeName === "id" || attributeName === classNameWithId;
            });
        }
        if (idAttr == null) {
            idAttr = createElement("Attribute", "Id", element.id);
            idAttr.setOrder(0);
            if (idAttr.typeReference == null)
                throw new Error("typeReference is not defined");
            idAttr.typeReference.setType(getDefaultIdType());
        }
        if (!idAttr.hasStereotype(primaryKeyStereotypeId)) {
            idAttr.addStereotype(primaryKeyStereotypeId);
        }
    }
    updateDerivedTypePks(element);
    function derivedFromTypeHasPk(element) {
        const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
        return element.getAssociations("Generalization")
            .some(generalization =&gt; {
            if (!generalization.isTargetEnd()) {
                return false;
            }
            const baseType = generalization.typeReference.getType();
            if (baseType.getChildren("Attribute").some(attribute =&gt; attribute.hasStereotype(primaryKeyStereotypeId))) {
                return true;
            }
            return derivedFromTypeHasPk(baseType);
        });
    }
    function updateDerivedTypePks(element) {
        const derivedTypes = element.getAssociations("Generalization")
            .filter(generalization =&gt; generalization.isSourceEnd())
            .map(generalization =&gt; generalization.typeReference.getType());
        for (const derivedType of derivedTypes) {
            updatePrimaryKey(derivedType);
        }
    }
}
function isTableStorage(element) {
    var _a, _b, _c;
    const documentStoreId = "8b68020c-6652-484b-85e8-6c33e1d8031f";
    const tableStorageProvider = "1d05ee8e-747f-4120-9647-29ac784ef633";
    var docDbStereotype = element.getPackage().getStereotype(documentStoreId);
    let providers = lookupTypesOf("Document Db Provider").filter((elem, index) =&gt; lookupTypesOf("Document Db Provider").findIndex(obj =&gt; obj.id == elem.id) === index &amp;&amp; elem.getName() != "Custom");
    return ((!((_a = docDbStereotype.getProperty("Provider")) === null || _a === void 0 ? void 0 : _a.getValue()) &amp;&amp; providers.length == 1 &amp;&amp; providers[0].id == tableStorageProvider) ||
        ((_c = (_b = docDbStereotype.getProperty("Provider")) === null || _b === void 0 ? void 0 : _b.getValue()) === null || _c === void 0 ? void 0 : _c.id) == tableStorageProvider);
}
function updateTableStoragePk(element) {
    var _a, _b;
    const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
    const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
    let idAttrs = element.getChildren("Attribute").filter(x =&gt; x.hasStereotype(primaryKeyStereotypeId));
    if (!isAggregateRoot(element)) {
        if (idAttrs.length &gt; 0) {
            idAttrs.forEach(key =&gt; key.delete());
        }
    }
    else {
        //Keys are not right
        if (!(idAttrs.length == 2 &amp;&amp; idAttrs[0].getName() == "PartitionKey" &amp;&amp; idAttrs[1].getName() == "RowKey")) {
            if (idAttrs.length &gt; 0) {
                idAttrs.forEach(key =&gt; key.delete());
            }
            let rowKeyAttr = createElement("Attribute", "RowKey", element.id);
            rowKeyAttr.setOrder(0);
            rowKeyAttr.typeReference.setType(stringTypeId);
            let idPkSterotype = rowKeyAttr.addStereotype(primaryKeyStereotypeId);
            (_a = idPkSterotype.getProperty("Data source")) === null || _a === void 0 ? void 0 : _a.setValue("User supplied");
            let partitionKeyAttr = createElement("Attribute", "PartitionKey", element.id);
            partitionKeyAttr.setOrder(0);
            partitionKeyAttr.typeReference.setType(stringTypeId);
            let partitionPkStereotype = partitionKeyAttr.addStereotype(primaryKeyStereotypeId);
            (_b = partitionPkStereotype.getProperty("Data source")) === null || _b === void 0 ? void 0 : _b.setValue("User supplied");
        }
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function isAggregateRelationship(associationEnd) {
    let sourceAssociationEnd = associationEnd;
    if (associationEnd.isTargetEnd()) {
        sourceAssociationEnd = sourceAssociationEnd.getOtherEnd();
    }
    return sourceAssociationEnd.typeReference.isNullable || sourceAssociationEnd.typeReference.isCollection;
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../common/isAggregateRelationship.ts" /&gt;
function requiresForeignKey(associationEnd) {
    return associationEnd.typeReference.isNavigable &amp;&amp;
        isAggregateRelationship(associationEnd);
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
;
function getPrimaryKeysWithMapPath(entity) {
    let keyDict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
    // There is a problem with execution order where this script executes before
    // the generalization script had a chance to potentially remove a PK attribute
    // and so I have to perform an inheritance check and ignore any PKs on derived classes.
    if (generalizations.length == 0) {
        keys.forEach(key =&gt; {
            if (key.typeReference == null)
                throw new Error("typeReference is undefined");
            return keyDict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: [key.id],
                isNullable: false,
                isCollection: false
            };
        });
    }
    traverseInheritanceHierarchyForPrimaryKeys(keyDict, entity, []);
    return keyDict;
    function traverseInheritanceHierarchyForPrimaryKeys(keyDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            if (key.typeReference == null)
                throw new Error("typeReference is undefined");
            keyDict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keyDict, nextEntity, generalizationStack);
    }
}
/// &lt;reference path="../common/getPrimaryKeysWithMapPath.ts" /&gt;
function updateForeignKeyAttribute(startingEndType, destinationEndType, associationEnd, associationId) {
    const ForeignKeyStereotypeId = "ced3e970-e900-4f99-bd04-b993228fe17d";
    let primaryKeyDict = getPrimaryKeysWithMapPath(destinationEndType);
    let primaryKeyObjects = Object.values(primaryKeyDict);
    let primaryKeysLen = primaryKeyObjects.length;
    primaryKeyObjects.forEach((pk, index) =&gt; {
        var _a;
        let fk = (_a = startingEndType.getChildren()
            .filter(x =&gt; (x.getMetadata("association") == associationId) ||
            (x.hasStereotype(ForeignKeyStereotypeId) &amp;&amp; !x.hasMetadata("association")))[index]) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Attribute", "", startingEndType.id);
        // This check to avoid a loop where the Domain script is updating the conventions and this keeps renaming it back.
        let fkNameToUse = `${toCamelCase(associationEnd.getName())}${toPascalCase(pk.name)}`;
        if (associationEnd.typeReference.isCollection) {
            fkNameToUse = pluralize(fkNameToUse);
        }
        if (fk.getName().toLocaleLowerCase() !== fkNameToUse.toLocaleLowerCase()) {
            if (!fk.hasMetadata("fk-original-name") || (fk.getMetadata("fk-original-name") == fk.getName())) {
                if (fkNameToUse != fk.getName()) {
                    fk.setName(fkNameToUse);
                }
                fk.setMetadata("fk-original-name", fk.getName());
            }
        }
        fk.setMetadata("association", associationId);
        fk.setMetadata("is-managed-key", "true");
        let fkStereotype = fk.getStereotype(ForeignKeyStereotypeId);
        if (!fkStereotype) {
            fk.addStereotype(ForeignKeyStereotypeId);
            fkStereotype = fk.getStereotype(ForeignKeyStereotypeId);
        }
        if (fkStereotype.getProperty("Association").getValue() != associationId) {
            fkStereotype.getProperty("Association").setValue(associationId);
        }
        if (fk.typeReference == null)
            throw new Error("typeReference is undefined");
        if (fk.typeReference.typeId != pk.typeId) {
            fk.typeReference.setType(pk.typeId);
        }
        if (fk.typeReference.isNullable != associationEnd.typeReference.isNullable) {
            fk.typeReference.setIsNullable(associationEnd.typeReference.isNullable);
        }
        if (fk.typeReference.isCollection != associationEnd.typeReference.isCollection) {
            fk.typeReference.setIsCollection(associationEnd.typeReference.isCollection);
        }
    });
    startingEndType.getChildren().filter(x =&gt; x.getMetadata("association") == associationId).forEach((attr, index) =&gt; {
        if (index &gt;= primaryKeysLen) {
            attr.delete();
        }
    });
}
/// &lt;reference path="../common/requiresForeignKey.ts" /&gt;
/// &lt;reference path="../common/updateForeignKeyAttribute.ts" /&gt;
function updateForeignKeysForElement(element) {
    for (let association of element.getAssociations()) {
        if (!association.isTargetEnd()) {
            continue;
        }
        let sourceType = lookup(association.getOtherEnd().typeReference.typeId);
        let targetType = lookup(association.typeReference.typeId);
        if (!sourceType || !targetType) {
            continue;
        }
        if (requiresForeignKey(association)) {
            updateForeignKeyAttribute(sourceType, targetType, association, association.id);
        }
        if (requiresForeignKey(association.getOtherEnd())) {
            updateForeignKeyAttribute(targetType, sourceType, association.getOtherEnd(), association.id);
        }
    }
    removeOrphanedAssociations(element);
}
function removeOrphanedAssociations(element) {
    let existingAssociations = element.getAssociations();
    let existingAttributes = element.getChildren("Attribute");
    for (let attr of existingAttributes) {
        if (!attr.getMetadata("association")) {
            continue;
        }
        if (!existingAssociations.some(x =&gt; attr.getMetadata("association") == x.id)) {
            attr.delete();
        }
    }
}
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.DocumentDB
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/documentdb/class-on-created/class-on-created.ts
 */
/// &lt;reference path="../common/updatePrimaryKey.ts" /&gt;
/// &lt;reference path="../common/updateForeignKeysForElement.ts" /&gt;
function execute() {
    const documentStoreId = "8b68020c-6652-484b-85e8-6c33e1d8031f";
    if (!element.getPackage().hasStereotype(documentStoreId)) {
        return;
    }
    updatePrimaryKey(element);
    updateForeignKeysForElement(element);
}
execute();
</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="Folder" typeId="4d95d53a-8855-4f35-aa82-e312643f5c5f">
      <mappingSettings />
      <macros>
        <macro trigger="on-changed">
          <script>/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function isAggregateRoot(element) {
    return !element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function getDefaultIdType() {
    var _a, _b;
    const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
    const guidTypeId = "6b649125-18ea-48fd-a6ba-0bfff0d8f488";
    const intTypeId = "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74";
    const longTypeId = "33013006-E404-48C2-AC46-24EF5A5774FD";
    const documentDbSettingsId = "d5581fe8-7385-4bb6-88dc-8940e20ec1d4";
    switch ((_b = (_a = application.getSettings(documentDbSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Id Type")) === null || _b === void 0 ? void 0 : _b.value) {
        default:
            return stringTypeId;
        case "guid":
            return guidTypeId;
        case "int":
            return intTypeId;
        case "long":
            return longTypeId;
    }
}
/// &lt;reference path="isAggregateRoot.ts" /&gt;
/// &lt;reference path="getDefaultIdType.ts" /&gt;
function updatePartitionKeyAsPrimary(element, packageLoad = false) {
    if (!isCosmosDb(element))
        return;
    console.warn(element.specialization);
    let allowedTypes = ["Class", "Folder", "Domain Package"];
    if (!allowedTypes.includes(element.specialization)) {
        return;
    }
    const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
    const containerStereotypeId = "ef9b1772-18e1-44ad-b606-66406221c805";
    const multiTenancyStereotypeId = "586eb05b-d647-4430-ac05-8d096fe3f79e";
    let partitionKey = getPartitionKey(element);
    if (!packageLoad &amp;&amp; ["Folder", "Domain Package"].includes(element.specialization)) {
        //prevent unnecessary package scans on every package change event.
        if (element.hasMetadata("currentPartitionKey") &amp;&amp; element.getMetadata("currentPartitionKey") === partitionKey) {
            return;
        }
        console.warn();
    }
    console.warn("Doing Check");
    if (element.specialization == "Class") {
        ensureCorrectPartitionKey(element, partitionKey, packageLoad);
    }
    else {
        updateDescendants(element, partitionKey, packageLoad);
    }
    element.setMetadata("currentPartitionKey", partitionKey);
    function getPartitionKey(element) {
        var _a, _b;
        let result = "";
        while (element) {
            if (element.hasStereotype(containerStereotypeId) &amp;&amp; ((_a = element.getStereotype(containerStereotypeId).getProperty("Partition Key")) === null || _a === void 0 ? void 0 : _a.value)) {
                let partitionKey = (_b = element.getStereotype(containerStereotypeId).getProperty("Partition Key")) === null || _b === void 0 ? void 0 : _b.value;
                if (!partitionKey)
                    partitionKey = "";
                return partitionKey;
            }
            element = element.getParent();
        }
        return result;
    }
    function updateDescendants(element, partitionKeyName, packageLoad) {
        console.warn("checking :" + element.getName());
        let children = element.getChildren().filter(c =&gt; allowedTypes.includes(c.specialization));
        children.forEach(child =&gt; {
            var _a;
            if (child.hasStereotype(containerStereotypeId)) {
                if (packageLoad) {
                    //On package load we check the entire tree not just the scope of the edited item
                    partitionKeyName = (_a = child.getStereotype(containerStereotypeId).getProperty("Partition Key")) === null || _a === void 0 ? void 0 : _a.value;
                }
                else {
                    return;
                }
            }
            if (child.specialization == "Class") {
                ensureCorrectPartitionKey(child, partitionKeyName, packageLoad);
            }
            else {
                updateDescendants(child, partitionKeyName, packageLoad);
            }
        });
    }
    function ensureCorrectPartitionKey(element, partitionKeyName, packageLoad) {
        var _a;
        console.warn("Updating class :" + element.getName());
        if (element.specialization !== "Class") {
            return;
        }
        if (!partitionKeyName) {
            let toRemove = element.getChildren("Attribute")
                .find(x =&gt; x.hasStereotype(primaryKeyStereotypeId) &amp;&amp; x.hasMetadata("partition-key"));
            if (toRemove != null) {
                toRemove.delete();
            }
        }
        else {
            let toFix = element.getChildren("Attribute")
                .find(x =&gt; x.hasStereotype(primaryKeyStereotypeId) &amp;&amp; x.hasMetadata("partition-key") &amp;&amp; x.getName().toLowerCase() != partitionKeyName.toLowerCase());
            if (toFix != null) {
                toFix.removeMetadata("partition-key");
                toFix.removeStereotype(primaryKeyStereotypeId);
            }
            let toAdjust = element.getChildren("Attribute")
                .find(x =&gt; x.getName().toLowerCase() == partitionKeyName.toLowerCase());
            if (toAdjust != null) {
                if (!toAdjust.hasStereotype(primaryKeyStereotypeId)) {
                    toAdjust.addStereotype(primaryKeyStereotypeId);
                }
                let partitionPkStereotype = toAdjust.getStereotype(primaryKeyStereotypeId);
                if (!element.hasStereotype(multiTenancyStereotypeId)) {
                    (_a = partitionPkStereotype.getProperty("Data source")) === null || _a === void 0 ? void 0 : _a.setValue("User supplied");
                }
                toAdjust.setMetadata("partition-key", "true");
            }
        }
    }
    function isCosmosDb(element) {
        var _a, _b, _c;
        const documentStoreId = "8b68020c-6652-484b-85e8-6c33e1d8031f";
        const cosmosDbProvider = "3e1a00f7-c6f1-4785-a544-bbcb17602b31";
        let docDbStereotype = element.getPackage().getStereotype(documentStoreId);
        let providers = lookupTypesOf("Document Db Provider").filter((elem, index) =&gt; lookupTypesOf("Document Db Provider").findIndex(obj =&gt; obj.id == elem.id) === index &amp;&amp; elem.getName() != "Custom");
        return ((!((_a = docDbStereotype.getProperty("Provider")) === null || _a === void 0 ? void 0 : _a.getValue()) &amp;&amp; providers.length == 1 &amp;&amp; providers[0].id == cosmosDbProvider) ||
            ((_c = (_b = docDbStereotype.getProperty("Provider")) === null || _b === void 0 ? void 0 : _b.getValue()) === null || _c === void 0 ? void 0 : _c.id) == cosmosDbProvider);
    }
}
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.DocumentDB
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/documentdb/folder-on-change/folder-on-change.ts
 */
/// &lt;reference path="../common/updatePartitionKeyAsPrimary.ts" /&gt;
const package = element.getPackage();
function execute() {
    const documentStoreId = "8b68020c-6652-484b-85e8-6c33e1d8031f";
    if (!package.hasStereotype(documentStoreId)) {
        return;
    }
    updatePartitionKeyAsPrimary(element);
}
execute();
</script>
        </macro>
      </macros>
    </elementExtension>
  </elementExtensions>
  <associationSettings />
  <associationExtensions>
    <associationExtension type="Association" typeId="eaf9ed4e-0b61-4ac1-ba88-09f912c12087">
      <sourceEndExtension>
        <typeReferenceExtension>
          <isRequired>true</isRequired>
          <targetTypes />
          <allowIsNavigable>inherit</allowIsNavigable>
          <allowIsNullable>inherit</allowIsNullable>
          <allowIsCollection>inherit</allowIsCollection>
        </typeReferenceExtension>
      </sourceEndExtension>
      <targetEndExtension>
        <typeReferenceExtension>
          <isRequired>true</isRequired>
          <targetTypes />
          <allowIsNavigable>inherit</allowIsNavigable>
          <allowIsNullable>inherit</allowIsNullable>
          <allowIsCollection>inherit</allowIsCollection>
        </typeReferenceExtension>
      </targetEndExtension>
      <macros>
        <macro trigger="on-changed">
          <script>/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function isAggregateRoot(element) {
    return !element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function getDefaultIdType() {
    var _a, _b;
    const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
    const guidTypeId = "6b649125-18ea-48fd-a6ba-0bfff0d8f488";
    const intTypeId = "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74";
    const longTypeId = "33013006-E404-48C2-AC46-24EF5A5774FD";
    const documentDbSettingsId = "d5581fe8-7385-4bb6-88dc-8940e20ec1d4";
    switch ((_b = (_a = application.getSettings(documentDbSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Id Type")) === null || _b === void 0 ? void 0 : _b.value) {
        default:
            return stringTypeId;
        case "guid":
            return guidTypeId;
        case "int":
            return intTypeId;
        case "long":
            return longTypeId;
    }
}
/// &lt;reference path="isAggregateRoot.ts" /&gt;
/// &lt;reference path="getDefaultIdType.ts" /&gt;
function updatePrimaryKey(element) {
    if (element.specialization !== "Class") {
        return;
    }
    const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
    let idAttr = element.getChildren("Attribute")
        .find(x =&gt; x.hasStereotype(primaryKeyStereotypeId));
    const isToCompositionalOneRelationshipTarget = () =&gt; element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; !x.getOtherEnd().typeReference.isCollection);
    if ((!isAggregateRoot(element) &amp;&amp; isToCompositionalOneRelationshipTarget()) || derivedFromTypeHasPk(element)) {
        if (idAttr != null) {
            idAttr.delete();
        }
        updateDerivedTypePks(element);
        return;
    }
    if (isTableStorage(element)) {
        updateTableStoragePk(element);
    }
    else {
        if (idAttr == null) {
            const classNameWithId = `${element.getName()}Id`.toLowerCase();
            idAttr = element.getChildren("Attribute")
                .find(attribute =&gt; {
                const attributeName = attribute.getName().toLowerCase();
                return attributeName === "id" || attributeName === classNameWithId;
            });
        }
        if (idAttr == null) {
            idAttr = createElement("Attribute", "Id", element.id);
            idAttr.setOrder(0);
            if (idAttr.typeReference == null)
                throw new Error("typeReference is not defined");
            idAttr.typeReference.setType(getDefaultIdType());
        }
        if (!idAttr.hasStereotype(primaryKeyStereotypeId)) {
            idAttr.addStereotype(primaryKeyStereotypeId);
        }
    }
    updateDerivedTypePks(element);
    function derivedFromTypeHasPk(element) {
        const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
        return element.getAssociations("Generalization")
            .some(generalization =&gt; {
            if (!generalization.isTargetEnd()) {
                return false;
            }
            const baseType = generalization.typeReference.getType();
            if (baseType.getChildren("Attribute").some(attribute =&gt; attribute.hasStereotype(primaryKeyStereotypeId))) {
                return true;
            }
            return derivedFromTypeHasPk(baseType);
        });
    }
    function updateDerivedTypePks(element) {
        const derivedTypes = element.getAssociations("Generalization")
            .filter(generalization =&gt; generalization.isSourceEnd())
            .map(generalization =&gt; generalization.typeReference.getType());
        for (const derivedType of derivedTypes) {
            updatePrimaryKey(derivedType);
        }
    }
}
function isTableStorage(element) {
    var _a, _b, _c;
    const documentStoreId = "8b68020c-6652-484b-85e8-6c33e1d8031f";
    const tableStorageProvider = "1d05ee8e-747f-4120-9647-29ac784ef633";
    var docDbStereotype = element.getPackage().getStereotype(documentStoreId);
    let providers = lookupTypesOf("Document Db Provider").filter((elem, index) =&gt; lookupTypesOf("Document Db Provider").findIndex(obj =&gt; obj.id == elem.id) === index &amp;&amp; elem.getName() != "Custom");
    return ((!((_a = docDbStereotype.getProperty("Provider")) === null || _a === void 0 ? void 0 : _a.getValue()) &amp;&amp; providers.length == 1 &amp;&amp; providers[0].id == tableStorageProvider) ||
        ((_c = (_b = docDbStereotype.getProperty("Provider")) === null || _b === void 0 ? void 0 : _b.getValue()) === null || _c === void 0 ? void 0 : _c.id) == tableStorageProvider);
}
function updateTableStoragePk(element) {
    var _a, _b;
    const primaryKeyStereotypeId = "64f6a994-4909-4a9d-a0a9-afc5adf2ef74";
    const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
    let idAttrs = element.getChildren("Attribute").filter(x =&gt; x.hasStereotype(primaryKeyStereotypeId));
    if (!isAggregateRoot(element)) {
        if (idAttrs.length &gt; 0) {
            idAttrs.forEach(key =&gt; key.delete());
        }
    }
    else {
        //Keys are not right
        if (!(idAttrs.length == 2 &amp;&amp; idAttrs[0].getName() == "PartitionKey" &amp;&amp; idAttrs[1].getName() == "RowKey")) {
            if (idAttrs.length &gt; 0) {
                idAttrs.forEach(key =&gt; key.delete());
            }
            let rowKeyAttr = createElement("Attribute", "RowKey", element.id);
            rowKeyAttr.setOrder(0);
            rowKeyAttr.typeReference.setType(stringTypeId);
            let idPkSterotype = rowKeyAttr.addStereotype(primaryKeyStereotypeId);
            (_a = idPkSterotype.getProperty("Data source")) === null || _a === void 0 ? void 0 : _a.setValue("User supplied");
            let partitionKeyAttr = createElement("Attribute", "PartitionKey", element.id);
            partitionKeyAttr.setOrder(0);
            partitionKeyAttr.typeReference.setType(stringTypeId);
            let partitionPkStereotype = partitionKeyAttr.addStereotype(primaryKeyStereotypeId);
            (_b = partitionPkStereotype.getProperty("Data source")) === null || _b === void 0 ? void 0 : _b.setValue("User supplied");
        }
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function isAggregateRelationship(associationEnd) {
    let sourceAssociationEnd = associationEnd;
    if (associationEnd.isTargetEnd()) {
        sourceAssociationEnd = sourceAssociationEnd.getOtherEnd();
    }
    return sourceAssociationEnd.typeReference.isNullable || sourceAssociationEnd.typeReference.isCollection;
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../common/isAggregateRelationship.ts" /&gt;
function requiresForeignKey(associationEnd) {
    return associationEnd.typeReference.isNavigable &amp;&amp;
        isAggregateRelationship(associationEnd);
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
;
function getPrimaryKeysWithMapPath(entity) {
    let keyDict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
    // There is a problem with execution order where this script executes before
    // the generalization script had a chance to potentially remove a PK attribute
    // and so I have to perform an inheritance check and ignore any PKs on derived classes.
    if (generalizations.length == 0) {
        keys.forEach(key =&gt; {
            if (key.typeReference == null)
                throw new Error("typeReference is undefined");
            return keyDict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: [key.id],
                isNullable: false,
                isCollection: false
            };
        });
    }
    traverseInheritanceHierarchyForPrimaryKeys(keyDict, entity, []);
    return keyDict;
    function traverseInheritanceHierarchyForPrimaryKeys(keyDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            if (key.typeReference == null)
                throw new Error("typeReference is undefined");
            keyDict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keyDict, nextEntity, generalizationStack);
    }
}
/// &lt;reference path="../common/getPrimaryKeysWithMapPath.ts" /&gt;
function updateForeignKeyAttribute(startingEndType, destinationEndType, associationEnd, associationId) {
    const ForeignKeyStereotypeId = "ced3e970-e900-4f99-bd04-b993228fe17d";
    let primaryKeyDict = getPrimaryKeysWithMapPath(destinationEndType);
    let primaryKeyObjects = Object.values(primaryKeyDict);
    let primaryKeysLen = primaryKeyObjects.length;
    primaryKeyObjects.forEach((pk, index) =&gt; {
        var _a;
        let fk = (_a = startingEndType.getChildren()
            .filter(x =&gt; (x.getMetadata("association") == associationId) ||
            (x.hasStereotype(ForeignKeyStereotypeId) &amp;&amp; !x.hasMetadata("association")))[index]) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Attribute", "", startingEndType.id);
        // This check to avoid a loop where the Domain script is updating the conventions and this keeps renaming it back.
        let fkNameToUse = `${toCamelCase(associationEnd.getName())}${toPascalCase(pk.name)}`;
        if (associationEnd.typeReference.isCollection) {
            fkNameToUse = pluralize(fkNameToUse);
        }
        if (fk.getName().toLocaleLowerCase() !== fkNameToUse.toLocaleLowerCase()) {
            if (!fk.hasMetadata("fk-original-name") || (fk.getMetadata("fk-original-name") == fk.getName())) {
                if (fkNameToUse != fk.getName()) {
                    fk.setName(fkNameToUse);
                }
                fk.setMetadata("fk-original-name", fk.getName());
            }
        }
        fk.setMetadata("association", associationId);
        fk.setMetadata("is-managed-key", "true");
        let fkStereotype = fk.getStereotype(ForeignKeyStereotypeId);
        if (!fkStereotype) {
            fk.addStereotype(ForeignKeyStereotypeId);
            fkStereotype = fk.getStereotype(ForeignKeyStereotypeId);
        }
        if (fkStereotype.getProperty("Association").getValue() != associationId) {
            fkStereotype.getProperty("Association").setValue(associationId);
        }
        if (fk.typeReference == null)
            throw new Error("typeReference is undefined");
        if (fk.typeReference.typeId != pk.typeId) {
            fk.typeReference.setType(pk.typeId);
        }
        if (fk.typeReference.isNullable != associationEnd.typeReference.isNullable) {
            fk.typeReference.setIsNullable(associationEnd.typeReference.isNullable);
        }
        if (fk.typeReference.isCollection != associationEnd.typeReference.isCollection) {
            fk.typeReference.setIsCollection(associationEnd.typeReference.isCollection);
        }
    });
    startingEndType.getChildren().filter(x =&gt; x.getMetadata("association") == associationId).forEach((attr, index) =&gt; {
        if (index &gt;= primaryKeysLen) {
            attr.delete();
        }
    });
}
/// &lt;reference path="requiresForeignKey.ts" /&gt;
/// &lt;reference path="updateForeignKeyAttribute.ts" /&gt;
function updateForeignKeysForAssociation(associationEnd) {
    let sourceType = lookup(associationEnd.getOtherEnd().typeReference.typeId);
    let targetType = lookup(associationEnd.typeReference.typeId);
    if (!sourceType || !targetType) {
        return;
    }
    if (requiresForeignKey(associationEnd)) {
        updateForeignKeyAttribute(sourceType, targetType, associationEnd, associationEnd.id);
    }
    else {
        sourceType.getChildren()
            .filter(x =&gt; x.getMetadata("association") == associationEnd.id)
            .forEach(x =&gt; x.delete());
    }
    if (requiresForeignKey(associationEnd.getOtherEnd())) {
        updateForeignKeyAttribute(targetType, sourceType, associationEnd.getOtherEnd(), associationEnd.id);
    }
    else {
        targetType.getChildren()
            .filter(x =&gt; x.getMetadata("association") == associationEnd.id)
            .forEach(x =&gt; x.delete());
    }
}
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.DocumentDB
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/documentdb/association-on-changed/association-on-changed.ts
 */
/// &lt;reference path="../common/updatePrimaryKey.ts" /&gt;
/// &lt;reference path="../common/updateForeignKeysForAssociation.ts" /&gt;
function execute() {
    //This happens while linking the association i.e. only 1 end attached.
    if (association.typeReference.getType() == null) {
        return;
    }
    let sourceTarget = association.getOtherEnd().typeReference.getType();
    const documentStoreId = "8b68020c-6652-484b-85e8-6c33e1d8031f";
    if (!sourceTarget.getPackage().hasStereotype(documentStoreId)) {
        return;
    }
    updatePrimaryKey(association.typeReference.getType());
    updateForeignKeysForAssociation(association);
}
execute();
</script>
        </macro>
        <macro trigger="on-created">
          <script>/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.DocumentDB
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/documentdb/association-on-created/association-on-created.ts
 */
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
function execute() {
    if (!association) {
        return;
    }
    let sourceEnd = association.getOtherEnd().typeReference;
    const documentStoreId = "8b68020c-6652-484b-85e8-6c33e1d8031f";
    if (!sourceEnd.getType().getPackage().hasStereotype(documentStoreId)) {
        return;
    }
    sourceEnd.setIsCollection(false);
    sourceEnd.setIsNullable(false);
}
execute();
</script>
        </macro>
      </macros>
    </associationExtension>
  </associationExtensions>
  <mappingSettings />
  <mappableElementPackages />
  <mappableElementPackageExtensions />
</settings>