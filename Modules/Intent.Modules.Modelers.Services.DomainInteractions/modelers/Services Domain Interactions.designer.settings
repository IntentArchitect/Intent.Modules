<?xml version="1.0" encoding="utf-8"?>
<settings version="3.1.1">
  <id>f36cb21a-faf9-46ff-85e7-41f38345253d</id>
  <name>Services Domain Interactions</name>
  <designerReferences />
  <packageSettings />
  <packageExtensions>
    <packageExtension type="Services Package" typeId="df45eaf6-9202-4c25-8dd5-677e9ba1e906">
      <requiredPackages />
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Create CRUD Service</text>
          <shortcut>alt + s</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "basic";</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(command, settings) {
        var _a;
        this.command = command;
        this.settings = settings;
        this.mappedElement = (_a = command.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.command.id; }
    ;
    setReturnType(typeId, isCollection) {
        this.command.typeReference.setType(typeId);
        if (isCollection != null) {
            this.command.typeReference.setIsCollection(isCollection);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.command.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.command.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.command;
    }
    collapse() {
        this.command.collapse();
    }
}
// services-crud script (see ~/DesignerMacros/src/services-crud folder in Intent.Modules)
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
var servicesCrud;
(function (servicesCrud) {
    async function execute() {
        const package = element.getPackage();
        const entity = await DomainHelper.openSelectEntityDialog({
            includeOwnedRelationships: false
        });
        if (!entity) {
            return;
        }
        const serviceName = `${toPascalCase(pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName()))}Service`;
        const existingService = element.specialization == "Service" ? element : package.getChildren("Service").find(x =&gt; x.getName() == pluralize(serviceName));
        const service = existingService || createElement("Service", serviceName, package.id);
        const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName());
        const existingFolder = package.getChildren("Folder").find(x =&gt; x.getName() == pluralize(folderName));
        const folder = existingFolder || createElement("Folder", pluralize(folderName), package.id);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const resultDto = createMappedResultDto(entity, folder);
        createStandardCreateOperation(service, entity, folder);
        if (primaryKeys.length &gt; 0) {
            createStandardFindByIdOperation(service, entity, resultDto);
        }
        createStandardFindAllOperation(service, entity, resultDto);
        if (primaryKeys.length &gt; 0) {
            createStandardUpdateOperation(service, entity, folder);
            createStandardDeleteOperation(service, entity);
        }
    }
    servicesCrud.execute = execute;
    ;
    function createMappedResultDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == dtoName);
        if (existing) {
            return existing;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoFromEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        dtoManager.collapse();
        return dtoManager.getElement();
    }
    servicesCrud.createMappedResultDto = createMappedResultDto;
    function createStandardCreateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}CreateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Create${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Create${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });
        let operationManager = new ElementManager(createElement("Operation", `Create${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        operationManager.addChild("dto", dtoManager.id);
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        if (primaryKeys.length == 1) {
            operationManager.setReturnType(primaryKeys[0].typeId);
        }
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardCreateOperation = createStandardCreateOperation;
    function createStandardFindByIdOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${entity.getName()}ById`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.addChildrenFrom(DomainHelper.getPrimaryKeys(entity));
        operationManager.collapse();
    }
    servicesCrud.createStandardFindByIdOperation = createStandardFindByIdOperation;
    function createStandardFindAllOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${pluralize(entity.getName())}`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id, true);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.collapse();
    }
    servicesCrud.createStandardFindAllOperation = createStandardFindAllOperation;
    function createStandardUpdateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}UpdateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Update${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Update${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
            childType: "property"
        });
        let operationManager = new ElementManager(createElement("Operation", `Update${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.addChild("dto", dtoManager.id);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardUpdateOperation = createStandardUpdateOperation;
    function createStandardDeleteOperation(service, entity) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        if (service.getChildren().some(x =&gt; x.getName() == `Delete${entity.getName()}`)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", `Delete${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.collapse();
    }
    servicesCrud.createStandardDeleteOperation = createStandardDeleteOperation;
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
})(servicesCrud || (servicesCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/create-crud/create-crud.ts
 */
await servicesCrud.execute();
</script>
        </option>
        <option>
          <text>Create CRUD Service</text>
          <shortcut>alt + s</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "advanced";</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        var _a, _b, _c, _d, _e, _f;
        if (element.specialization == "Service") {
            let entity = (_c = (_b = (_a = element.getChildren("Operation").find(x =&gt; x.getName().startsWith("Find"))) === null || _a === void 0 ? void 0 : _a.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.getMapping()) === null || _c === void 0 ? void 0 : _c.getElement();
            element.getChildren("Operation").forEach(operation =&gt; {
                convertOperation(operation, entity);
            });
        }
        else if (element.specialization == "Operation") {
            let dtoParam = element.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
            let dto = (_d = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType()) !== null &amp;&amp; _d !== void 0 ? _d : (_e = element.typeReference) === null || _e === void 0 ? void 0 : _e.getType();
            let entity = (_f = dto === null || dto === void 0 ? void 0 : dto.getMapping().getElement()) !== null &amp;&amp; _f !== void 0 ? _f : lookupTypesOf("Class").find(x =&gt; x.getName() == element.getName().replace("Delete", ""));
            if (entity) {
                convertOperation(element, entity);
            }
            else {
                console.warn("Cannot execute conversion script on Operation " + element.getName());
            }
        }
        else {
            console.error("Cannot qualify this script. Please contact Intent Architect support.");
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertOperation(operation, entity) {
        var _a, _b;
        let target = entity;
        let dtoParam = operation.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
        let dto = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType();
        // CREATE OPERATION:
        if (operation.getName().startsWith("Create") &amp;&amp; ((_a = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType().getMapping()) === null || _a === void 0 ? void 0 : _a.getElement().id) == entity.id) {
            let action = createAssociation("Create Entity Action", operation.id, target.id);
            let mapping = action.createMapping(operation.id, entity.id);
            mapping.addMappedEnd("Invocation Mapping", [operation.id], [target.id]);
            mapContract("Data Mapping", dto, [operation.id, dtoParam.id], [target.id], mapping);
            // DELETE OPERATION:
        }
        else if (operation.getName().startsWith("Delete") &amp;&amp; operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Delete Entity Action", operation.id, entity.id);
            let mapping = action.createMapping(operation.id, entity.id);
            addFilterMapping(mapping, operation, entity);
            // UPDATE OPERATION:
        }
        else if (operation.getName().startsWith("Update") &amp;&amp; ((_b = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType().getMapping()) === null || _b === void 0 ? void 0 : _b.getElement().id) == entity.id) {
            let action = createAssociation("Update Entity Action", operation.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(operation.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            mapContract("Data Mapping", dto, [operation.id, dtoParam.id], [target.id], updateMapping);
            // FIND BY ID OPERATION:
        }
        else if (operation.getName().startsWith("Find" + entity.getName()) &amp;&amp; operation.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // FIND ALL OPERATION:
        }
        else if (operation.getName().startsWith("Find" + pluralize(entity.getName()))) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            action.typeReference.setIsCollection(true);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
        }
        else {
            console.warn(`Could not convert operation: ${operation.getName()} (For entity ${entity.getName()}. Has parameters: (${operation.getChildren("Parameter").map(x =&gt; x.getName())}))`);
        }
    }
    convertToAdvancedMapping.convertOperation = convertOperation;
    function addFilterMapping(mapping, operation, entity) {
        var _a;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id");
            let pk = pkFields[0];
            if (idField &amp;&amp; pk) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a;
                let idField = operation.getChildren("Parameter").find(x =&gt; (x.getName().toLowerCase() == pk.name.toLowerCase()));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
                }
            });
        }
    }
    function mapContract(mappingType, dto, sourcePath, targetPathIds, mapping, isNested = false) {
        console.log("mapContract: " + dto.getName());
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; (isNested || !x.getMapping().getElement().hasStereotype("Primary Key"))).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping, true);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(command, settings) {
        var _a;
        this.command = command;
        this.settings = settings;
        this.mappedElement = (_a = command.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.command.id; }
    ;
    setReturnType(typeId, isCollection) {
        this.command.typeReference.setType(typeId);
        if (isCollection != null) {
            this.command.typeReference.setIsCollection(isCollection);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.command.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.command.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.command;
    }
    collapse() {
        this.command.collapse();
    }
}
// services-crud script (see ~/DesignerMacros/src/services-crud folder in Intent.Modules)
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
var servicesCrud;
(function (servicesCrud) {
    async function execute() {
        let package = element.getPackage();
        let entity = await DomainHelper.openSelectEntityDialog({
            includeOwnedRelationships: false
        });
        if (!entity) {
            return;
        }
        let serviceName = `${toPascalCase(pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName()))}Service`;
        var existingService = element.specialization == "Service" ? element : package.getChildren("Service").find(x =&gt; x.getName() == pluralize(serviceName));
        let service = existingService || createElement("Service", serviceName, package.id);
        let folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName());
        var existingFolder = package.getChildren("Folder").find(x =&gt; x.getName() == pluralize(folderName));
        var folder = existingFolder || createElement("Folder", pluralize(folderName), package.id);
        let resultDto = createMappedResultDto(entity, folder);
        createStandardCreateOperation(service, entity, folder);
        createStandardFindByIdOperation(service, entity, resultDto);
        createStandardFindAllOperation(service, entity, resultDto);
        createStandardUpdateOperation(service, entity, folder);
        createStandardDeleteOperation(service, entity);
    }
    servicesCrud.execute = execute;
    ;
    function createMappedResultDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == dtoName);
        if (existing) {
            return existing;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoFromEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        dtoManager.collapse();
        return dtoManager.getElement();
    }
    servicesCrud.createMappedResultDto = createMappedResultDto;
    function createStandardCreateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}CreateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Create${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Create${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });
        let operationManager = new ElementManager(createElement("Operation", `Create${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        operationManager.addChild("dto", dtoManager.id);
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        if (primaryKeys.length == 1) {
            operationManager.setReturnType(primaryKeys[0].typeId);
        }
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardCreateOperation = createStandardCreateOperation;
    function createStandardFindByIdOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${entity.getName()}ById`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.addChildrenFrom(DomainHelper.getPrimaryKeys(entity));
        operationManager.collapse();
    }
    servicesCrud.createStandardFindByIdOperation = createStandardFindByIdOperation;
    function createStandardFindAllOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${pluralize(entity.getName())}`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id, true);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.collapse();
    }
    servicesCrud.createStandardFindAllOperation = createStandardFindAllOperation;
    function createStandardUpdateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}UpdateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Update${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Update${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
            childType: "property"
        });
        let operationManager = new ElementManager(createElement("Operation", `Update${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.addChild("dto", dtoManager.id);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardUpdateOperation = createStandardUpdateOperation;
    function createStandardDeleteOperation(service, entity) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        if (service.getChildren().some(x =&gt; x.getName() == `Delete${entity.getName()}`)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", `Delete${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.collapse();
    }
    servicesCrud.createStandardDeleteOperation = createStandardDeleteOperation;
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
})(servicesCrud || (servicesCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/create-crud/create-crud.ts
 */
//await servicesCrud.execute();
/// &lt;reference path="../_common/convertToAdvancedMapping.ts"/&gt;
/// &lt;reference path="../create-crud/create-crud.ts"/&gt;
async function execute(element) {
    const package = element.getPackage();
    const entity = await DomainHelper.openSelectEntityDialog({
        includeOwnedRelationships: false
    });
    if (!entity) {
        return;
    }
    const serviceName = `${toPascalCase(pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName()))}Service`;
    const existingService = element.specialization == "Service" ? element : package.getChildren("Service").find(x =&gt; x.getName() == pluralize(serviceName));
    const service = existingService !== null &amp;&amp; existingService !== void 0 ? existingService : createElement("Service", serviceName, package.id);
    const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName());
    const existingFolder = package.getChildren("Folder").find(x =&gt; x.getName() == pluralize(folderName));
    const folder = existingFolder !== null &amp;&amp; existingFolder !== void 0 ? existingFolder : createElement("Folder", pluralize(folderName), package.id);
    const primaryKeys = DomainHelper.getPrimaryKeys(entity);
    const resultDto = servicesCrud.createMappedResultDto(entity, folder);
    servicesCrud.createStandardCreateOperation(service, entity, folder);
    if (primaryKeys.length &gt; 0) {
        servicesCrud.createStandardFindByIdOperation(service, entity, resultDto);
    }
    servicesCrud.createStandardFindAllOperation(service, entity, resultDto);
    if (primaryKeys.length &gt; 0) {
        servicesCrud.createStandardUpdateOperation(service, entity, folder);
        servicesCrud.createStandardDeleteOperation(service, entity);
    }
    service.getChildren("Operation").forEach(operation =&gt; {
        convertToAdvancedMapping.convertOperation(operation, entity);
    });
}
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/create-crud-advanced-mapping/create-crud-advanced-mapping.ts
 */
await execute(element);
</script>
        </option>
        <option>
          <text>Create CRUD CQRS Operations</text>
          <shortcut>alt + c</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>function folderHasCommandOrQueries(element) {
    return element.specialization === "Folder" &amp;&amp; (element.getChildren("Command").length &gt; 0 || element.getChildren("Query").length &gt; 0);
}

return application.isModuleInstalled("Intent.Modelers.Services.CQRS") &amp;&amp;
    application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "basic" &amp;&amp;
    !folderHasCommandOrQueries(element);</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(command, settings) {
        var _a;
        this.command = command;
        this.settings = settings;
        this.mappedElement = (_a = command.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.command.id; }
    ;
    setReturnType(typeId, isCollection) {
        this.command.typeReference.setType(typeId);
        if (isCollection != null) {
            this.command.typeReference.setIsCollection(isCollection);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.command.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.command.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.command;
    }
    collapse() {
        this.command.collapse();
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b, _c;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; ((_c = entry.name) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", entry.name, dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    if (primaryKeys.length == 0) {
        // Implicit key:
        primaryKeys.push({
            id: null,
            name: "Id",
            typeId: getSurrogateKeyType(),
            mapPath: null,
            isNullable: false,
            isCollection: false
        });
    }
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; {
        var _a;
        return !x.hasStereotype("Primary Key") &amp;&amp;
            !legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
    });
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/**
 * Workaround for element's from referenced packages not having getParent()
 * @param element The element whose parent should be searched for
 * @param parentSpecializationType The specialization type of the parent
 */
function getParent(element, parentSpecializationType) {
    const elements = lookupTypesOf(parentSpecializationType);
    const parent = elements
        .find(x =&gt; x.getChildren(element.specialization)
        .some(child =&gt; child.id === element.id));
    if (parent == null) {
        throw new Error("Could not find parent");
    }
    return parent;
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
/// &lt;reference path="../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/getParent.ts" /&gt;
/**
 * Gets select details of a mapped Command/Query. Intended for centralized logic of working out
 * things like keys for both the entity and owning entity if applicable.
 *
 * If the Command is for entity creation (either due to being mapped to a constructor or being
 * prefixed with "Create"), then primary keys for the entity are not populated.
 * @param request The Command or Query that has been mapped
 */
function getMappedRequestDetails(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    // Advanced mapping:
    if (mappedElement == null) {
        const advancedMappings = request.getAssociations()
            .filter(x =&gt; x.hasMappings(queryEntityMappingTypeId) ||
            x.hasMappings(createEntityMappingTypeId))
            .map(x =&gt; x.getMapping(queryEntityMappingTypeId) ||
            x.getMapping(createEntityMappingTypeId));
        if (advancedMappings.length === 1) {
            mappedElement = advancedMappings[0].getTargetElement();
        }
    }
    if (mappedElement == null) {
        return null;
    }
    let entity = mappedElement;
    if (entity.specialization !== "Class") {
        entity = getParent(entity, "Class");
    }
    const result = {
        entity: entity,
        mappingTargetType: mappedElement.specialization,
        entityKeyFields: [],
        ownerKeyFields: []
    };
    result.owningEntity = DomainHelper.getOwningAggregate(entity);
    // As long as it's not for creation, populate the PKs of the entity:
    if (result.mappingTargetType !== "Class Constructor" &amp;&amp;
        !request.getName().toLowerCase().startsWith("Create")) {
        result.entityKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity)
            : getKeysForOperationMapping(request, entity);
    }
    // If the entity is owned, populate its fields:
    if (result.owningEntity != null) {
        result.ownerKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity, result.owningEntity)
            : getKeysForOperationMapping(request, entity, result.owningEntity);
    }
    return result;
    /**
     * Return field details for primary keys. As requests mapped to operations and constructors can
     * never possibly map the attributes, these fields can only ever be matched by name.
     * @param request The CQRS Command or Query entity
     * @param owningEntity The Owning Aggregate Class
     */
    function getKeysForOperationMapping(request, entity, owningEntity) {
        const pks = DomainHelper.getPrimaryKeys(owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity);
        return pks.map(pk =&gt; {
            let fieldName = toPascalCase(pk.name);
            if (owningEntity != null) {
                fieldName = removePrefix(fieldName, toPascalCase(owningEntity.getName()));
                fieldName = `${owningEntity.getName()}${toCamelCase(fieldName)}`;
            }
            fieldName = ServicesHelper.getFieldFormat(fieldName);
            const existingField = request.getChildren("DTO-Field").find(field =&gt; field.getName().toLowerCase() == fieldName.toLowerCase());
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: [],
                name: fieldName,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
    function getKeysForClassMapping(request, entity, owningEntity) {
        const keys = owningEntity != null
            ? DomainHelper.getForeignKeys(entity, owningEntity)
            : DomainHelper.getPrimaryKeys(entity);
        return keys.map(pk =&gt; {
            const existingField = request.getChildren("DTO-Field").find(field =&gt; {
                if (field.getMapping() != null) {
                    return field.getMapping().getPath().some(x =&gt; x.id == pk.id);
                }
                return (pk.name.toLowerCase() === field.getName().toLowerCase());
            });
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: pk.mapPath,
                name: pk.name,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/**
 * Ensures that for the provided contract, it has the provided field creating it if necessary and
 * then ensure the field has the correct typeReference details and order.
 * The field's element is returned.
 */
function ensureHasField(options) {
    const { contract, fieldDetail, mappingSettingsId, order } = options;
    let field = fieldDetail.existingId != null
        ? contract.getChildren("DTO-Field").find(x =&gt; x.id === fieldDetail.existingId)
        : createElement("DTO-Field", fieldDetail.name, contract.id);
    field.typeReference.setType(fieldDetail.typeId);
    field.typeReference.setIsCollection(fieldDetail.isCollection);
    field.typeReference.setIsNullable(fieldDetail.isNullable);
    if (order != null) {
        field.setOrder(order);
    }
    if (mappingSettingsId != null) {
        field.setMapping(fieldDetail.mappingPath, mappingSettingsId);
    }
    return field;
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/// &lt;reference path="ensureHasField.ts" /&gt;
function onMapCommand(element, isForCrudScript, isForCreate = false) {
    var _a, _b, _c;
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    // const mapToDomainDataSettingsId = "735c87d0-06fc-4491-8b5f-5adc6f953c54";
    const mappingDetails = getMappedRequestDetails(element);
    if (mappingDetails == null) {
        return;
    }
    if (isForCrudScript ||
        mappingDetails.mappingTargetType !== "Class") {
        let order = 0;
        let keyFields = mappingDetails.ownerKeyFields;
        if (!isForCreate) {
            keyFields = keyFields.concat(mappingDetails.entityKeyFields);
        }
        for (const keyField of keyFields) {
            ensureHasField({
                contract: element,
                fieldDetail: keyField,
                order: order++
            });
        }
    }
    if (mappingDetails.mappingTargetType === "Operation" &amp;&amp;
        isComplexType((_c = (_b = (_a = element.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType())) {
        getOrCreateCommandCrudDto(element, element, false, mapFromDomainMappingSettingId);
    }
    const fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; ((_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement().specialization.startsWith("Association")); });
    fields.forEach(field =&gt; {
        getOrCreateCommandCrudDto(element, field, true, projectMappingSettingId);
    });
    const complexFields = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp;
            isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType());
    });
    complexFields.forEach(cf =&gt; {
        getOrCreateCommandCrudDto(element, cf, false, projectMappingSettingId);
    });
    function isComplexType(element) {
        if (element == null) {
            console.warn("isComplexType element parameter received null");
        }
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object";
    }
    function getOrCreateCommandCrudDto(command, dtoField, autoAddPrimaryKey, mappingTypeSettingId) {
        let mappedElement = dtoField.getMapping().getElement();
        if (mappedElement.typeReference == null)
            throw new Error("TypeReference is undefined");
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.typeReference.getType().getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        let dto = getOrCreateDto(dtoName, command.getParent());
        dto.setMetadata("originalVerb", originalVerb);
        dto.setMetadata("baseName", baseName);
        dto.setMapping(mappedElement.typeReference.getTypeId(), mappingTypeSettingId);
        ensureDtoFields(autoAddPrimaryKey, mappedElement, dto);
        dtoField.typeReference.setType(dto.id);
    }
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
function onMapDto(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b, _c; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; ((_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.specialization.startsWith("Association")); });
    fields.forEach(f =&gt; {
        getOrCreateDtoCrudDto(element, f, true);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d, _e;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (complexTypes.includes((_e = (_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()) === null || _e === void 0 ? void 0 : _e.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateDtoCrudDto(element, f, false);
    });
}
function getOrCreateDtoCrudDto(element, dtoField, autoAddPrimaryKey) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const originalDtoMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    let mappedElement = dtoField.getMapping().getElement();
    let originalVerb = "";
    if (element.hasMetadata("originalVerb")) {
        originalVerb = element.getMetadata("originalVerb");
        // In the event that the prefix is no longer the same as the
        // originally called verb, then don't propagate this any further
        // as end users might get confused.
        if (element.getName().indexOf(originalVerb) &lt; 0) {
            originalVerb = "";
        }
    }
    let targetMappingSettingId = dtoField.getParent().getMapping().mappingSettingsId;
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : domainName;
    let dtoName = `${originalVerb}${baseName}`;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), targetMappingSettingId);
    if (originalVerb !== "") {
        dto.setMetadata("originalVerb", originalVerb);
    }
    dto.setMetadata("baseName", baseName);
    ensureDtoFields(autoAddPrimaryKey, mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
function onMapQuery(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; x.getMapping().getElement().specialization.startsWith("Association"); });
    fields.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d, _e;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (complexTypes.includes((_e = (_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()) === null || _e === void 0 ? void 0 : _e.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
}
function getOrCreateQueryCrudDto(element, dtoField) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    let mappedElement = dtoField.getMapping().getElement();
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : `${domainName}`;
    let dtoName = baseName;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMappingSettingId);
    dto.setMetadata("baseName", baseName);
    ensureDtoFieldsQuery(mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
function ensureDtoFieldsQuery(mappedElement, dto) {
    let dtoUpdated = false;
    let mappedElementAttributes = mappedElement
        .typeReference
        .getType()
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; !dtoFields.some(y =&gt; x.getName() === y.getName()))) {
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == attribute.getName())) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.getName(), dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
var _a, _b;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../_common/onMapCommand.ts" /&gt;
/// &lt;reference path="../_common/onMapDto.ts" /&gt;
/// &lt;reference path="../_common/onMapQuery.ts" /&gt;
const privateSettersOnly = ((_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")) === null || _b === void 0 ? void 0 : _b.value) == "true";
const mapToDomainOperationSettingId = "7c31c459-6229-4f10-bf13-507348cd8828";
var cqrsCrud;
(function (cqrsCrud) {
    async function execute(element) {
        var _a;
        let entity = await DomainHelper.openSelectEntityDialog();
        if (entity == null) {
            return;
        }
        const owningEntity = DomainHelper.getOwningAggregate(entity);
        const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? owningEntity.getName() : entity.getName());
        const folder = (_a = element.getChildren().find(x =&gt; x.getName() == pluralize(folderName))) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Folder", pluralize(folderName), element.id);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const hasPrimaryKey = primaryKeys.length &gt; 0;
        const resultDto = createCqrsResultTypeDto(entity, folder);
        if (owningEntity == null || !privateSettersOnly) {
            createCqrsCreateCommand(entity, folder, primaryKeys);
        }
        if (hasPrimaryKey) {
            createCqrsFindByIdQuery(entity, folder, resultDto);
        }
        createCqrsFindAllQuery(entity, folder, resultDto);
        if (hasPrimaryKey &amp;&amp; !privateSettersOnly) {
            createCqrsUpdateCommand(entity, folder);
        }
        const allowedOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !allowedOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        for (const operation of operations) {
            createCqrsCallOperationCommand(entity, operation, folder);
        }
        if (hasPrimaryKey &amp;&amp; (owningEntity == null || !privateSettersOnly)) {
            createCqrsDeleteCommand(entity, folder);
        }
    }
    cqrsCrud.execute = execute;
    function createCqrsCreateCommand(entity, folder, primaryKeys) {
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = getBaseNameForElement(owningAggregate, entity, false);
        const expectedCommandName = `Create${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            const returnType = primaryKeys.length == 1
                ? primaryKeys[0].typeId
                : null;
            const command = folder.getChildren().filter(x =&gt; x.getName() == expectedCommandName)[0];
            command.typeReference.setType(returnType);
            return command;
        }
        const commandManager = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        const entityCtor = entity
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (entityCtor != null) {
            commandManager.mapToElement(entityCtor, mapToDomainOperationSettingId);
            commandManager.getElement().setMapping([entity.id, entityCtor.id], mapToDomainOperationSettingId);
        }
        else if (!privateSettersOnly) {
            commandManager.mapToElement(entity);
        }
        else {
            console.warn(`Private Setters are enabled with no constructor present on entity '${entity.getName()}'. In order for '${expectedCommandName}' to map to that entity, either disable private setters or model a constructor element and try again.`);
        }
        commandManager.getElement().setMetadata("baseName", baseName);
        const surrogateKey = primaryKeys.length === 1;
        if (surrogateKey) {
            commandManager.setReturnType(primaryKeys[0].typeId);
        }
        if (entityCtor) {
            commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(entityCtor, "Parameter")
                .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        }
        else {
            if (!surrogateKey) {
                const toAdd = primaryKeys.filter(x =&gt; DomainHelper.isUserSuppliedPrimaryKey(lookup(x.id)));
                ServicesHelper.addDtoFieldsFromDomain(commandManager.getElement(), toAdd);
            }
            commandManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
            commandManager.addChildrenFrom(getMandatoryAssociationsWithMapPath(entity));
        }
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandManager.getElement());
        }
        onMapCommand(commandManager.getElement(), true, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCreateCommand = createCqrsCreateCommand;
    function createCqrsFindByIdQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedQueryName = `Get${baseName}ByIdQuery`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(query, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        onMapQuery(query);
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindByIdQuery = createCqrsFindByIdQuery;
    function createCqrsFindAllQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, true);
        let expectedQueryName = `Get${baseName}Query`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.typeReference.setIsCollection(true);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindAllQuery = createCqrsFindAllQuery;
    function createCqrsUpdateCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Update${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        command.mapToElement(entity);
        command.getElement().setMetadata("baseName", baseName);
        command.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        command.addChildrenFrom(getMandatoryAssociationsWithMapPath(entity));
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command.getElement(), primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command.getElement());
        }
        onMapCommand(command.getElement(), true);
        command.collapse();
        return command.getElement();
    }
    cqrsCrud.createCqrsUpdateCommand = createCqrsUpdateCommand;
    function createCqrsCallOperationCommand(entity, operation, folder) {
        var _a;
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = (_a = owningAggregate === null || owningAggregate === void 0 ? void 0 : owningAggregate.getName()) !== null &amp;&amp; _a !== void 0 ? _a : "";
        let operationName = operation.getName();
        operationName = removeSuffix(operationName, "Async");
        operationName = toPascalCase(operationName);
        const commandName = `${operationName}${entity.getName()}Command`;
        const existing = folder.getChildren().find(x =&gt; {
            var _a, _b;
            return x.getName() == commandName ||
                ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) === operation.id;
        });
        if (existing) {
            return existing;
        }
        const commandElement = createElement("Command", commandName, folder.id);
        commandElement.setMetadata("baseName", baseName);
        const commandManager = new ElementManager(commandElement, { childSpecialization: "DTO-Field" });
        commandManager.mapToElement([entity.id, operation.id], mapToDomainOperationSettingId);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        for (const key of primaryKeys) {
            commandManager.addChild(key.name, lookup(key.id).typeReference);
        }
        commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(operation, "Parameter")
            .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandElement);
        }
        onMapCommand(commandElement, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCallOperationCommand = createCqrsCallOperationCommand;
    function createCqrsDeleteCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Delete${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = createElement("Command", expectedCommandName, folder.id);
        command.setMapping(entity.id);
        command.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), command.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command);
        }
        onMapCommand(command, true);
        command.collapse();
        return command;
    }
    cqrsCrud.createCqrsDeleteCommand = createCqrsDeleteCommand;
    function createCqrsResultTypeDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedDtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedDtoName);
        if (existing) {
            return existing;
        }
        let dto = createElement("DTO", expectedDtoName, folder.id);
        dto.setMetadata("baseName", baseName);
        dto.setMapping(entity.id);
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), dto.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        ServicesHelper.addDtoFieldsFromDomain(dto, primaryKeys);
        let attributesWithMapPaths = DomainHelper.getAttributesWithMapPath(entity);
        for (var attr of attributesWithMapPaths) {
            if (dto.getChildren("DTO-Field").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == attr.id; })) {
                continue;
            }
            let field = createElement("DTO-Field", attr.name, dto.id);
            field.typeReference.setType(attr.typeId);
            field.setMapping(attr.mapPath);
        }
        onMapDto(dto);
        dto.collapse();
        return dto;
    }
    cqrsCrud.createCqrsResultTypeDto = createCqrsResultTypeDto;
    function addAggregatePkToCommandOrQuery(owningAggregate, commandOrQuery) {
        if (owningAggregate != null) {
            var aggPks = DomainHelper.getPrimaryKeys(owningAggregate);
            aggPks.forEach(x =&gt; {
                if (x.name.toLowerCase() == "id") {
                    x.name = `${owningAggregate.getName()}Id`;
                }
                x.id = null;
                x.mapPath = null;
                x.isCollection = false;
                x.isNullable = false;
            });
            ServicesHelper.addDtoFieldsFromDomain(commandOrQuery, aggPks);
        }
    }
    function getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
})(cqrsCrud || (cqrsCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/create-crud-macro/create-crud-macro.ts
 */
await cqrsCrud.execute(element);
</script>
        </option>
        <option>
          <text>Create CRUD CQRS Operations</text>
          <shortcut>alt + c</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>function folderHasCommandOrQueries(element) {
    return element.specialization === "Folder" &amp;&amp; (element.getChildren("Command").length &gt; 0 || element.getChildren("Query").length &gt; 0);
}

return application.isModuleInstalled("Intent.Modelers.Services.CQRS") &amp;&amp;
    application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "advanced" &amp;&amp;
    !folderHasCommandOrQueries(element);</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(command, settings) {
        var _a;
        this.command = command;
        this.settings = settings;
        this.mappedElement = (_a = command.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.command.id; }
    ;
    setReturnType(typeId, isCollection) {
        this.command.typeReference.setType(typeId);
        if (isCollection != null) {
            this.command.typeReference.setIsCollection(isCollection);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.command.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.command.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.command;
    }
    collapse() {
        this.command.collapse();
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b, _c;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; ((_c = entry.name) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", entry.name, dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    if (primaryKeys.length == 0) {
        // Implicit key:
        primaryKeys.push({
            id: null,
            name: "Id",
            typeId: getSurrogateKeyType(),
            mapPath: null,
            isNullable: false,
            isCollection: false
        });
    }
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; {
        var _a;
        return !x.hasStereotype("Primary Key") &amp;&amp;
            !legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
    });
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/**
 * Workaround for element's from referenced packages not having getParent()
 * @param element The element whose parent should be searched for
 * @param parentSpecializationType The specialization type of the parent
 */
function getParent(element, parentSpecializationType) {
    const elements = lookupTypesOf(parentSpecializationType);
    const parent = elements
        .find(x =&gt; x.getChildren(element.specialization)
        .some(child =&gt; child.id === element.id));
    if (parent == null) {
        throw new Error("Could not find parent");
    }
    return parent;
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
/// &lt;reference path="../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/getParent.ts" /&gt;
/**
 * Gets select details of a mapped Command/Query. Intended for centralized logic of working out
 * things like keys for both the entity and owning entity if applicable.
 *
 * If the Command is for entity creation (either due to being mapped to a constructor or being
 * prefixed with "Create"), then primary keys for the entity are not populated.
 * @param request The Command or Query that has been mapped
 */
function getMappedRequestDetails(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    // Advanced mapping:
    if (mappedElement == null) {
        const advancedMappings = request.getAssociations()
            .filter(x =&gt; x.hasMappings(queryEntityMappingTypeId) ||
            x.hasMappings(createEntityMappingTypeId))
            .map(x =&gt; x.getMapping(queryEntityMappingTypeId) ||
            x.getMapping(createEntityMappingTypeId));
        if (advancedMappings.length === 1) {
            mappedElement = advancedMappings[0].getTargetElement();
        }
    }
    if (mappedElement == null) {
        return null;
    }
    let entity = mappedElement;
    if (entity.specialization !== "Class") {
        entity = getParent(entity, "Class");
    }
    const result = {
        entity: entity,
        mappingTargetType: mappedElement.specialization,
        entityKeyFields: [],
        ownerKeyFields: []
    };
    result.owningEntity = DomainHelper.getOwningAggregate(entity);
    // As long as it's not for creation, populate the PKs of the entity:
    if (result.mappingTargetType !== "Class Constructor" &amp;&amp;
        !request.getName().toLowerCase().startsWith("Create")) {
        result.entityKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity)
            : getKeysForOperationMapping(request, entity);
    }
    // If the entity is owned, populate its fields:
    if (result.owningEntity != null) {
        result.ownerKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity, result.owningEntity)
            : getKeysForOperationMapping(request, entity, result.owningEntity);
    }
    return result;
    /**
     * Return field details for primary keys. As requests mapped to operations and constructors can
     * never possibly map the attributes, these fields can only ever be matched by name.
     * @param request The CQRS Command or Query entity
     * @param owningEntity The Owning Aggregate Class
     */
    function getKeysForOperationMapping(request, entity, owningEntity) {
        const pks = DomainHelper.getPrimaryKeys(owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity);
        return pks.map(pk =&gt; {
            let fieldName = toPascalCase(pk.name);
            if (owningEntity != null) {
                fieldName = removePrefix(fieldName, toPascalCase(owningEntity.getName()));
                fieldName = `${owningEntity.getName()}${toCamelCase(fieldName)}`;
            }
            fieldName = ServicesHelper.getFieldFormat(fieldName);
            const existingField = request.getChildren("DTO-Field").find(field =&gt; field.getName().toLowerCase() == fieldName.toLowerCase());
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: [],
                name: fieldName,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
    function getKeysForClassMapping(request, entity, owningEntity) {
        const keys = owningEntity != null
            ? DomainHelper.getForeignKeys(entity, owningEntity)
            : DomainHelper.getPrimaryKeys(entity);
        return keys.map(pk =&gt; {
            const existingField = request.getChildren("DTO-Field").find(field =&gt; {
                if (field.getMapping() != null) {
                    return field.getMapping().getPath().some(x =&gt; x.id == pk.id);
                }
                return (pk.name.toLowerCase() === field.getName().toLowerCase());
            });
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: pk.mapPath,
                name: pk.name,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/**
 * Ensures that for the provided contract, it has the provided field creating it if necessary and
 * then ensure the field has the correct typeReference details and order.
 * The field's element is returned.
 */
function ensureHasField(options) {
    const { contract, fieldDetail, mappingSettingsId, order } = options;
    let field = fieldDetail.existingId != null
        ? contract.getChildren("DTO-Field").find(x =&gt; x.id === fieldDetail.existingId)
        : createElement("DTO-Field", fieldDetail.name, contract.id);
    field.typeReference.setType(fieldDetail.typeId);
    field.typeReference.setIsCollection(fieldDetail.isCollection);
    field.typeReference.setIsNullable(fieldDetail.isNullable);
    if (order != null) {
        field.setOrder(order);
    }
    if (mappingSettingsId != null) {
        field.setMapping(fieldDetail.mappingPath, mappingSettingsId);
    }
    return field;
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/// &lt;reference path="ensureHasField.ts" /&gt;
function onMapCommand(element, isForCrudScript, isForCreate = false) {
    var _a, _b, _c;
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    // const mapToDomainDataSettingsId = "735c87d0-06fc-4491-8b5f-5adc6f953c54";
    const mappingDetails = getMappedRequestDetails(element);
    if (mappingDetails == null) {
        return;
    }
    if (isForCrudScript ||
        mappingDetails.mappingTargetType !== "Class") {
        let order = 0;
        let keyFields = mappingDetails.ownerKeyFields;
        if (!isForCreate) {
            keyFields = keyFields.concat(mappingDetails.entityKeyFields);
        }
        for (const keyField of keyFields) {
            ensureHasField({
                contract: element,
                fieldDetail: keyField,
                order: order++
            });
        }
    }
    if (mappingDetails.mappingTargetType === "Operation" &amp;&amp;
        isComplexType((_c = (_b = (_a = element.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType())) {
        getOrCreateCommandCrudDto(element, element, false, mapFromDomainMappingSettingId);
    }
    const fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; ((_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement().specialization.startsWith("Association")); });
    fields.forEach(field =&gt; {
        getOrCreateCommandCrudDto(element, field, true, projectMappingSettingId);
    });
    const complexFields = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp;
            isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType());
    });
    complexFields.forEach(cf =&gt; {
        getOrCreateCommandCrudDto(element, cf, false, projectMappingSettingId);
    });
    function isComplexType(element) {
        if (element == null) {
            console.warn("isComplexType element parameter received null");
        }
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object";
    }
    function getOrCreateCommandCrudDto(command, dtoField, autoAddPrimaryKey, mappingTypeSettingId) {
        let mappedElement = dtoField.getMapping().getElement();
        if (mappedElement.typeReference == null)
            throw new Error("TypeReference is undefined");
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.typeReference.getType().getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        let dto = getOrCreateDto(dtoName, command.getParent());
        dto.setMetadata("originalVerb", originalVerb);
        dto.setMetadata("baseName", baseName);
        dto.setMapping(mappedElement.typeReference.getTypeId(), mappingTypeSettingId);
        ensureDtoFields(autoAddPrimaryKey, mappedElement, dto);
        dtoField.typeReference.setType(dto.id);
    }
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
function onMapDto(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b, _c; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; ((_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.specialization.startsWith("Association")); });
    fields.forEach(f =&gt; {
        getOrCreateDtoCrudDto(element, f, true);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d, _e;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (complexTypes.includes((_e = (_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()) === null || _e === void 0 ? void 0 : _e.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateDtoCrudDto(element, f, false);
    });
}
function getOrCreateDtoCrudDto(element, dtoField, autoAddPrimaryKey) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const originalDtoMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    let mappedElement = dtoField.getMapping().getElement();
    let originalVerb = "";
    if (element.hasMetadata("originalVerb")) {
        originalVerb = element.getMetadata("originalVerb");
        // In the event that the prefix is no longer the same as the
        // originally called verb, then don't propagate this any further
        // as end users might get confused.
        if (element.getName().indexOf(originalVerb) &lt; 0) {
            originalVerb = "";
        }
    }
    let targetMappingSettingId = dtoField.getParent().getMapping().mappingSettingsId;
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : domainName;
    let dtoName = `${originalVerb}${baseName}`;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), targetMappingSettingId);
    if (originalVerb !== "") {
        dto.setMetadata("originalVerb", originalVerb);
    }
    dto.setMetadata("baseName", baseName);
    ensureDtoFields(autoAddPrimaryKey, mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
function onMapQuery(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; x.getMapping().getElement().specialization.startsWith("Association"); });
    fields.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d, _e;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (complexTypes.includes((_e = (_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()) === null || _e === void 0 ? void 0 : _e.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
}
function getOrCreateQueryCrudDto(element, dtoField) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    let mappedElement = dtoField.getMapping().getElement();
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : `${domainName}`;
    let dtoName = baseName;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMappingSettingId);
    dto.setMetadata("baseName", baseName);
    ensureDtoFieldsQuery(mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
function ensureDtoFieldsQuery(mappedElement, dto) {
    let dtoUpdated = false;
    let mappedElementAttributes = mappedElement
        .typeReference
        .getType()
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; !dtoFields.some(y =&gt; x.getName() === y.getName()))) {
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == attribute.getName())) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.getName(), dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
var _a, _b;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../_common/onMapCommand.ts" /&gt;
/// &lt;reference path="../_common/onMapDto.ts" /&gt;
/// &lt;reference path="../_common/onMapQuery.ts" /&gt;
const privateSettersOnly = ((_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")) === null || _b === void 0 ? void 0 : _b.value) == "true";
const mapToDomainOperationSettingId = "7c31c459-6229-4f10-bf13-507348cd8828";
var cqrsCrud;
(function (cqrsCrud) {
    async function execute(element) {
        var _a;
        let entity = await DomainHelper.openSelectEntityDialog();
        if (entity == null) {
            return;
        }
        const owningEntity = DomainHelper.getOwningAggregate(entity);
        const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? owningEntity.getName() : entity.getName());
        const folder = (_a = element.getChildren().find(x =&gt; x.getName() == pluralize(folderName))) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Folder", pluralize(folderName), element.id);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const hasPrimaryKey = primaryKeys.length &gt; 0;
        const resultDto = createCqrsResultTypeDto(entity, folder);
        if (owningEntity == null || !privateSettersOnly) {
            createCqrsCreateCommand(entity, folder, primaryKeys);
        }
        if (hasPrimaryKey) {
            createCqrsFindByIdQuery(entity, folder, resultDto);
        }
        createCqrsFindAllQuery(entity, folder, resultDto);
        if (hasPrimaryKey &amp;&amp; !privateSettersOnly) {
            createCqrsUpdateCommand(entity, folder);
        }
        const allowedOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !allowedOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        for (const operation of operations) {
            createCqrsCallOperationCommand(entity, operation, folder);
        }
        if (hasPrimaryKey &amp;&amp; (owningEntity == null || !privateSettersOnly)) {
            createCqrsDeleteCommand(entity, folder);
        }
    }
    cqrsCrud.execute = execute;
    function createCqrsCreateCommand(entity, folder, primaryKeys) {
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = getBaseNameForElement(owningAggregate, entity, false);
        const expectedCommandName = `Create${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            const returnType = primaryKeys.length == 1
                ? primaryKeys[0].typeId
                : null;
            const command = folder.getChildren().filter(x =&gt; x.getName() == expectedCommandName)[0];
            command.typeReference.setType(returnType);
            return command;
        }
        const commandManager = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        const entityCtor = entity
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (entityCtor != null) {
            commandManager.mapToElement(entityCtor, mapToDomainOperationSettingId);
            commandManager.getElement().setMapping([entity.id, entityCtor.id], mapToDomainOperationSettingId);
        }
        else if (!privateSettersOnly) {
            commandManager.mapToElement(entity);
        }
        else {
            console.warn(`Private Setters are enabled with no constructor present on entity '${entity.getName()}'. In order for '${expectedCommandName}' to map to that entity, either disable private setters or model a constructor element and try again.`);
        }
        commandManager.getElement().setMetadata("baseName", baseName);
        const surrogateKey = primaryKeys.length === 1;
        if (surrogateKey) {
            commandManager.setReturnType(primaryKeys[0].typeId);
        }
        if (entityCtor) {
            commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(entityCtor, "Parameter")
                .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        }
        else {
            if (!surrogateKey) {
                const toAdd = primaryKeys.filter(x =&gt; DomainHelper.isUserSuppliedPrimaryKey(lookup(x.id)));
                ServicesHelper.addDtoFieldsFromDomain(commandManager.getElement(), toAdd);
            }
            commandManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
            commandManager.addChildrenFrom(getMandatoryAssociationsWithMapPath(entity));
        }
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandManager.getElement());
        }
        onMapCommand(commandManager.getElement(), true, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCreateCommand = createCqrsCreateCommand;
    function createCqrsFindByIdQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedQueryName = `Get${baseName}ByIdQuery`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(query, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        onMapQuery(query);
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindByIdQuery = createCqrsFindByIdQuery;
    function createCqrsFindAllQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, true);
        let expectedQueryName = `Get${baseName}Query`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.typeReference.setIsCollection(true);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindAllQuery = createCqrsFindAllQuery;
    function createCqrsUpdateCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Update${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        command.mapToElement(entity);
        command.getElement().setMetadata("baseName", baseName);
        command.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        command.addChildrenFrom(getMandatoryAssociationsWithMapPath(entity));
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command.getElement(), primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command.getElement());
        }
        onMapCommand(command.getElement(), true);
        command.collapse();
        return command.getElement();
    }
    cqrsCrud.createCqrsUpdateCommand = createCqrsUpdateCommand;
    function createCqrsCallOperationCommand(entity, operation, folder) {
        var _a;
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = (_a = owningAggregate === null || owningAggregate === void 0 ? void 0 : owningAggregate.getName()) !== null &amp;&amp; _a !== void 0 ? _a : "";
        let operationName = operation.getName();
        operationName = removeSuffix(operationName, "Async");
        operationName = toPascalCase(operationName);
        const commandName = `${operationName}${entity.getName()}Command`;
        const existing = folder.getChildren().find(x =&gt; {
            var _a, _b;
            return x.getName() == commandName ||
                ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) === operation.id;
        });
        if (existing) {
            return existing;
        }
        const commandElement = createElement("Command", commandName, folder.id);
        commandElement.setMetadata("baseName", baseName);
        const commandManager = new ElementManager(commandElement, { childSpecialization: "DTO-Field" });
        commandManager.mapToElement([entity.id, operation.id], mapToDomainOperationSettingId);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        for (const key of primaryKeys) {
            commandManager.addChild(key.name, lookup(key.id).typeReference);
        }
        commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(operation, "Parameter")
            .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandElement);
        }
        onMapCommand(commandElement, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCallOperationCommand = createCqrsCallOperationCommand;
    function createCqrsDeleteCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Delete${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = createElement("Command", expectedCommandName, folder.id);
        command.setMapping(entity.id);
        command.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), command.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command);
        }
        onMapCommand(command, true);
        command.collapse();
        return command;
    }
    cqrsCrud.createCqrsDeleteCommand = createCqrsDeleteCommand;
    function createCqrsResultTypeDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedDtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedDtoName);
        if (existing) {
            return existing;
        }
        let dto = createElement("DTO", expectedDtoName, folder.id);
        dto.setMetadata("baseName", baseName);
        dto.setMapping(entity.id);
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), dto.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        ServicesHelper.addDtoFieldsFromDomain(dto, primaryKeys);
        let attributesWithMapPaths = DomainHelper.getAttributesWithMapPath(entity);
        for (var attr of attributesWithMapPaths) {
            if (dto.getChildren("DTO-Field").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == attr.id; })) {
                continue;
            }
            let field = createElement("DTO-Field", attr.name, dto.id);
            field.typeReference.setType(attr.typeId);
            field.setMapping(attr.mapPath);
        }
        onMapDto(dto);
        dto.collapse();
        return dto;
    }
    cqrsCrud.createCqrsResultTypeDto = createCqrsResultTypeDto;
    function addAggregatePkToCommandOrQuery(owningAggregate, commandOrQuery) {
        if (owningAggregate != null) {
            var aggPks = DomainHelper.getPrimaryKeys(owningAggregate);
            aggPks.forEach(x =&gt; {
                if (x.name.toLowerCase() == "id") {
                    x.name = `${owningAggregate.getName()}Id`;
                }
                x.id = null;
                x.mapPath = null;
                x.isCollection = false;
                x.isNullable = false;
            });
            ServicesHelper.addDtoFieldsFromDomain(commandOrQuery, aggPks);
        }
    }
    function getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
})(cqrsCrud || (cqrsCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/create-crud-macro/create-crud-macro.ts
 */
//await cqrsCrud.execute(element);
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        if (element.isMapped() &amp;&amp; element.specialization == "Command") {
            convertCommand(element);
        }
        else if (element.isMapped() &amp;&amp; element.specialization == "Query") {
            convertQuery(element);
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertCommand(command) {
        var _a;
        if (!command) {
            console.warn(`Could not convert null Command.`);
            return;
        }
        if (!command.getMapping()) {
            console.warn(`Could not convert Command '${command.getName()}' without it mapping to an Entity.`);
            return;
        }
        let target = command.getMapping().getElement();
        let entity = (_a = target.getParent("Class")) !== null &amp;&amp; _a !== void 0 ? _a : target;
        if (command.getName().startsWith("Create")) {
            let action = createAssociation("Create Entity Action", command.id, target.id);
            let mapping = action.createMapping(command.id, entity.id);
            mapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            mapContract("Data Mapping", command, [command.id], [target.id], mapping);
        }
        else if (command.getName().startsWith("Delete")) {
            let action = createAssociation("Delete Entity Action", command.id, entity.id);
            let mapping = action.createMapping(command.id, entity.id);
            // Query Entity Mapping
            addFilterMapping(mapping, command, entity);
            command.clearMapping();
        }
        else if (command.isMapped()) {
            let action = createAssociation("Update Entity Action", command.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(command.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, command, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(command.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            if (target.id != entity.id) {
                updateMapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            }
            mapContract("Data Mapping", command, [command.id], [target.id], updateMapping);
        }
    }
    convertToAdvancedMapping.convertCommand = convertCommand;
    function addFilterMapping(mapping, command, entity) {
        var _a, _b;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key")) || (x.getName() == "Id" || x.getName() == `${entity.getName()}Id`));
            let entityPk = entity.getChildren("Attribute").find(x =&gt; x.hasStereotype("Primary Key"));
            if (idField &amp;&amp; (idField.isMapped() || entityPk)) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [entityPk.id]);
                idField.clearMapping();
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a, _b;
                let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp; x.getMapping().getElement().getName() == pk.name) || (x.getName() == pk.name));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [pk.id]);
                    idField.clearMapping();
                }
            });
        }
    }
    function convertQuery(query) {
        if (!query) {
            console.warn(`Could not convert null Query.`);
            return;
        }
        if (!query.getMapping()) {
            console.warn(`Could not convert Query '${query.getName()}' without it mapping to an Entity.`);
            return;
        }
        let entity = query.getMapping().getElement();
        let action = createAssociation("Query Entity Action", query.id, entity.id);
        if (query.typeReference.getIsCollection()) {
            action.typeReference.setIsCollection(true);
        }
        let mapping = action.createMapping(query.id, entity.id);
        mapContract("Filter Mapping", query, [query.id], [entity.id], mapping);
    }
    convertToAdvancedMapping.convertQuery = convertQuery;
    function mapContract(mappingType, dto, sourcePath, targetPathIds, mapping) {
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; !fieldsToSkip(dto, x)).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
    function fieldsToSkip(dto, field) {
        return dto.specialization == "Command" &amp;&amp;
            field.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp;
            (!field.getMapping().getElement().getStereotype("Primary Key").hasProperty("Data source") || field.getMapping().getElement().getStereotype("Primary Key").getProperty("Data source").value != "User supplied");
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
/// &lt;reference path="../create-crud-macro/create-crud-macro.ts"/&gt;
/// &lt;reference path="../_common/convertToAdvancedMapping.ts"/&gt;
async function execute(element) {
    var _a, _b;
    let entity = await DomainHelper.openSelectEntityDialog();
    if (entity == null) {
        return;
    }
    const owningEntity = DomainHelper.getOwningAggregate(entity);
    const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? owningEntity.getName() : entity.getName());
    const folder = (_a = element.getChildren().find(x =&gt; x.getName() == pluralize(folderName))) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Folder", pluralize(folderName), element.id);
    const primaryKeys = DomainHelper.getPrimaryKeys(entity);
    const hasPrimaryKey = primaryKeys.length &gt; 0;
    const resultDto = cqrsCrud.createCqrsResultTypeDto(entity, folder);
    if (owningEntity == null || !privateSettersOnly) {
        convertToAdvancedMapping.convertCommand(cqrsCrud.createCqrsCreateCommand(entity, folder, primaryKeys));
    }
    if (hasPrimaryKey) {
        convertToAdvancedMapping.convertQuery(cqrsCrud.createCqrsFindByIdQuery(entity, folder, resultDto));
    }
    convertToAdvancedMapping.convertQuery(cqrsCrud.createCqrsFindAllQuery(entity, folder, resultDto));
    if (hasPrimaryKey &amp;&amp; !privateSettersOnly) {
        convertToAdvancedMapping.convertCommand(cqrsCrud.createCqrsUpdateCommand(entity, folder));
    }
    const operations = entity.getChildren("Operation").filter(x =&gt; x.typeReference.getType() == null);
    for (const operation of operations) {
        convertToAdvancedMapping.convertCommand(cqrsCrud.createCqrsCallOperationCommand(entity, operation, folder));
    }
    if (hasPrimaryKey &amp;&amp; (owningEntity == null || !privateSettersOnly)) {
        convertToAdvancedMapping.convertCommand(cqrsCrud.createCqrsDeleteCommand(entity, folder));
    }
    const diagramElement = (_b = folder.getChildren("Diagram").find(x =&gt; x.getName() == folderName)) !== null &amp;&amp; _b !== void 0 ? _b : createElement("Diagram", folderName, folder.id);
    diagramElement.loadDiagram();
    const diagram = getCurrentDiagram();
    diagram.layoutVisuals(folder, null, true);
}
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/create-crud-macro-advanced-mapping/create-crud-macro-advanced-mapping.ts
 */
await execute(element);
</script>
        </option>
      </scriptOptions>
      <typeOrder />
    </packageExtension>
  </packageExtensions>
  <elementSettings>
    <elementSetting type="Processing Action" typeId="405a2857-b911-431f-8142-719a0e9f15f3">
      <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAAehJREFUeF7t3L1NA0EQhuE55DrYJijAEiVQAh0QEVl3XRGQQwWk/qGQRYewRGCB5G93dr6ZcT723nOv5GS0k+QHEpig6RyWBAQjSMAEBAXA8WYFll15lI18HHfHN/BMVOMwYFnKg1R5FpG79cknmZbDfJipFIDDXg24nbebvexfROT+wu+/y408RajxasAVrcyl/vXyItTYFfAH13WNGoDfjl5rVAP0WqM2oLsahwB6qnEkoIsahwOy12gFkLZGU4CMNVoEpKrRLCBLjdYBzddIAWi5RiZAkzXSAVqrkRXQTI3UgBZq9AA4tEY3gKNq9AaoXqNLQM0aPQOq1OgesHeNUQC71RgKsEeNEQGb1hgWcFWstX6eltMtsFuEbaj+txuDHExjNgFB5QRMQFAAHM8CAcBW22IR/4Wb7iuGAmxV3e/wowA2rS4UYI/qogB2q849YO/qPAOqVOcSULM6b4Dq1bkBHFWdB8Ch1VEDWqiOFdBMdXSA1qpjAjRZHQWg5eqsA5qvziwgS3UWAamqMwXIWJ0VQNrqhgOyVzcS0EV1QwA9VacN6K46NUCv1bUEfM27s4D9knU0b28DAc/jeX9gI8hoXwPtxkTDuvS8CQhWkIAJCAqA41lgAoIC4HgWmICgADieBYKAX0uidGAd9hNhAAAAAElFTkSuQmCC" />
      <saveAsOwnFile>false</saveAsOwnFile>
      <allowRename>true</allowRename>
      <allowAbstract>false</allowAbstract>
      <allowStatic>false</allowStatic>
      <allowGenericTypes>false</allowGenericTypes>
      <allowMapping>false</allowMapping>
      <allowSorting>true</allowSorting>
      <sortChildren p4:nil="true" xmlns:p4="http://www.w3.org/2001/XMLSchema-instance" />
      <allowFindInView>false</allowFindInView>
      <allowTypeReference>false</allowTypeReference>
      <allowConvertToType p4:nil="true" xmlns:p4="http://www.w3.org/2001/XMLSchema-instance" />
      <allowSetValue>false</allowSetValue>
      <typeOrder />
      <creationOptions />
      <scriptOptions />
      <mappingOptions>
        <option mappingType="Process Action Mapping" mappingTypeId="01bc7593-a6a2-45aa-8497-b4b6a269ab68">
          <text>Map Action</text>
          <shortcut>ctrl + shift + m</shortcut>
        </option>
      </mappingOptions>
      <mappingSettings />
      <childElementSettings />
    </elementSetting>
  </elementSettings>
  <elementExtensions>
    <elementExtension type="Command" typeId="ccf14eb6-3a55-4d81-b5b9-d27311c70cb9">
      <creationOptions>
        <option type="association">
          <text>Query Entity</text>
          <shortcut>ctrl + shift + q</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Query Entity Action Target End</specializationType>
          <specializationTypeId>93ef6675-cba4-4998-adff-cb22d5343ed4</specializationTypeId>
          <defaultName>NewQueryEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option type="association">
          <text>Call Service Operation</text>
          <shortcut>ctrl + shift + o</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Call Service Operation Target End</specializationType>
          <specializationTypeId>093e5909-ffe4-4510-b3ea-532f30212f3c</specializationTypeId>
          <defaultName>NewCallServiceOperation</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option type="association">
          <text>Create Entity</text>
          <shortcut>ctrl + shift + c</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Create Entity Action Target End</specializationType>
          <specializationTypeId>328f54e5-7bad-4b5f-90ca-03ce3105d016</specializationTypeId>
          <defaultName>NewCreateEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option type="association">
          <text>Update Entity</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Update Entity Action Target End</specializationType>
          <specializationTypeId>516069f6-09cc-4de8-8e31-3c71ca823452</specializationTypeId>
          <defaultName>NewUpdateEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option type="association">
          <text>Delete Entity</text>
          <shortcut>ctrl + shift + d</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Delete Entity Action Target End</specializationType>
          <specializationTypeId>4a04cfc2-5841-438c-9c16-fb58b784b365</specializationTypeId>
          <defaultName>NewDeleteEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option type="element">
          <text>Add Processing Action</text>
          <shortcut>ctrl + shift + p</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAAehJREFUeF7t3L1NA0EQhuE55DrYJijAEiVQAh0QEVl3XRGQQwWk/qGQRYewRGCB5G93dr6ZcT723nOv5GS0k+QHEpig6RyWBAQjSMAEBAXA8WYFll15lI18HHfHN/BMVOMwYFnKg1R5FpG79cknmZbDfJipFIDDXg24nbebvexfROT+wu+/y408RajxasAVrcyl/vXyItTYFfAH13WNGoDfjl5rVAP0WqM2oLsahwB6qnEkoIsahwOy12gFkLZGU4CMNVoEpKrRLCBLjdYBzddIAWi5RiZAkzXSAVqrkRXQTI3UgBZq9AA4tEY3gKNq9AaoXqNLQM0aPQOq1OgesHeNUQC71RgKsEeNEQGb1hgWcFWstX6eltMtsFuEbaj+txuDHExjNgFB5QRMQFAAHM8CAcBW22IR/4Wb7iuGAmxV3e/wowA2rS4UYI/qogB2q849YO/qPAOqVOcSULM6b4Dq1bkBHFWdB8Ch1VEDWqiOFdBMdXSA1qpjAjRZHQWg5eqsA5qvziwgS3UWAamqMwXIWJ0VQNrqhgOyVzcS0EV1QwA9VacN6K46NUCv1bUEfM27s4D9knU0b28DAc/jeX9gI8hoXwPtxkTDuvS8CQhWkIAJCAqA41lgAoIC4HgWmICgADieBYKAX0uidGAd9hNhAAAAAElFTkSuQmCC" />
          <specializationType>Processing Action</specializationType>
          <specializationTypeId>405a2857-b911-431f-8142-719a0e9f15f3</specializationTypeId>
          <defaultName>Action</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
      </creationOptions>
      <scriptOptions>
        <option>
          <text>Convert to advanced mapping system</text>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return isMapped();</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        if (element.isMapped() &amp;&amp; element.specialization == "Command") {
            convertCommand(element);
        }
        else if (element.isMapped() &amp;&amp; element.specialization == "Query") {
            convertQuery(element);
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertCommand(command) {
        var _a;
        if (!command) {
            console.warn(`Could not convert null Command.`);
            return;
        }
        if (!command.getMapping()) {
            console.warn(`Could not convert Command '${command.getName()}' without it mapping to an Entity.`);
            return;
        }
        let target = command.getMapping().getElement();
        let entity = (_a = target.getParent("Class")) !== null &amp;&amp; _a !== void 0 ? _a : target;
        if (command.getName().startsWith("Create")) {
            let action = createAssociation("Create Entity Action", command.id, target.id);
            let mapping = action.createMapping(command.id, entity.id);
            mapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            mapContract("Data Mapping", command, [command.id], [target.id], mapping);
        }
        else if (command.getName().startsWith("Delete")) {
            let action = createAssociation("Delete Entity Action", command.id, entity.id);
            let mapping = action.createMapping(command.id, entity.id);
            // Query Entity Mapping
            addFilterMapping(mapping, command, entity);
            command.clearMapping();
        }
        else if (command.isMapped()) {
            let action = createAssociation("Update Entity Action", command.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(command.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, command, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(command.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            if (target.id != entity.id) {
                updateMapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            }
            mapContract("Data Mapping", command, [command.id], [target.id], updateMapping);
        }
    }
    convertToAdvancedMapping.convertCommand = convertCommand;
    function addFilterMapping(mapping, command, entity) {
        var _a, _b;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key")) || (x.getName() == "Id" || x.getName() == `${entity.getName()}Id`));
            let entityPk = entity.getChildren("Attribute").find(x =&gt; x.hasStereotype("Primary Key"));
            if (idField &amp;&amp; (idField.isMapped() || entityPk)) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [entityPk.id]);
                idField.clearMapping();
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a, _b;
                let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp; x.getMapping().getElement().getName() == pk.name) || (x.getName() == pk.name));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [pk.id]);
                    idField.clearMapping();
                }
            });
        }
    }
    function convertQuery(query) {
        if (!query) {
            console.warn(`Could not convert null Query.`);
            return;
        }
        if (!query.getMapping()) {
            console.warn(`Could not convert Query '${query.getName()}' without it mapping to an Entity.`);
            return;
        }
        let entity = query.getMapping().getElement();
        let action = createAssociation("Query Entity Action", query.id, entity.id);
        if (query.typeReference.getIsCollection()) {
            action.typeReference.setIsCollection(true);
        }
        let mapping = action.createMapping(query.id, entity.id);
        mapContract("Filter Mapping", query, [query.id], [entity.id], mapping);
    }
    convertToAdvancedMapping.convertQuery = convertQuery;
    function mapContract(mappingType, dto, sourcePath, targetPathIds, mapping) {
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; !fieldsToSkip(dto, x)).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
    function fieldsToSkip(dto, field) {
        return dto.specialization == "Command" &amp;&amp;
            field.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp;
            (!field.getMapping().getElement().getStereotype("Primary Key").hasProperty("Data source") || field.getMapping().getElement().getStereotype("Primary Key").getProperty("Data source").value != "User supplied");
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
/// &lt;reference path="../_common/convertToAdvancedMapping.ts" /&gt;
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/convert-to-advanced-mapping/convert-to-advanced-mapping.ts
 */
convertToAdvancedMapping.execute();
</script>
        </option>
      </scriptOptions>
      <mappingOptions>
        <option mappingType="Map Return Type" mappingTypeId="b7ae8bf5-f2fd-4a5c-b57e-05410687bfc4">
          <text>Map Return Type</text>
          <shortcut>ctrl + shift + m</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return false &amp;&amp; typeReference?.isTypeFound();</isOptionVisibleFunction>
        </option>
      </mappingOptions>
      <typeOrder>
        <type>Query Entity Action Target End</type>
        <type>Call Service Operation Target End</type>
        <type>Create Entity Action Target End</type>
        <type>Update Entity Action Target End</type>
        <type>Delete Entity Action Target End</type>
        <type>Processing Action</type>
      </typeOrder>
      <mappingSettings />
    </elementExtension>
    <elementExtension type="Diagram" typeId="8c90aca5-86f4-47f1-bd58-116fe79f5c55">
      <mappingSettings />
      <diagramSettings>
        <addNewElementsTo>Package</addNewElementsTo>
        <elementVisualSettings>
          <visualSettings type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10">
            <size width="${w}" height="70" />
            <position x="${x}" y="${y}" />
            <display>
              <drawText>
                <text>return getName();</text>
                <style>`font-size: 12px; 
font-family: Helvetica; 
font-weight: bold; 
text-align: center; 
white-space: inherit;
vertical-align: center`</style>
                <size width="${w}" height="18" />
                <position x="${x}" y="${y + 48}" />
              </drawText>
              <drawSvgResource>
                <path>domain-class.svg</path>
                <size width="${w}" height="40" />
                <position x="${x}" y="${y + 6}" />
              </drawSvgResource>
            </display>
            <defaultSize width="${x}" height="70" />
            <autoResizeEnabledByDefault>true</autoResizeEnabledByDefault>
            <childElementVisualSettings>
              <childElementVisualSetting type="Class Constructor" typeId="dec2bd12-4699-4f45-8ec9-3b62dc692d2b">
                <size width="`${parent.w}`" height="18" />
                <position x="`${parent.x}`" y="`${parent.y + ($index * 20) + 66}`" />
                <anchorPointsFunction>return [getDimensions().getCenterLeft(), getDimensions().getCenterRight()];</anchorPointsFunction>
                <display>
                  <drawText>
                    <text>return label;</text>
                    <size width="${w - 26}" height="${h}" />
                    <position x="${x + 24}" y="${y}" />
                  </drawText>
                  <drawSvgResource>
                    <path>method.svg</path>
                    <size width="20" height="20" />
                    <position x="${x}" y="${y}" />
                  </drawSvgResource>
                </display>
                <defaultSize width="`${parent.w}`" height="18" />
                <autoResizeEnabledByDefault>true</autoResizeEnabledByDefault>
                <childElementVisualSettings />
              </childElementVisualSetting>
              <childElementVisualSetting type="Operation" typeId="e042bb67-a1df-480c-9935-b26210f78591">
                <size width="`${parent.w}`" height="18" />
                <position x="`${parent.x}`" y="`${parent.y + (parent.elements['Class Constructor'].any() ? 2 : 0) + (parent.elements['Class Constructor'].size.height) + ($index * 20) + 66}`" />
                <anchorPointsFunction>return [getDimensions().getCenterLeft(), getDimensions().getCenterRight()];</anchorPointsFunction>
                <display>
                  <drawText>
                    <text>return label;</text>
                    <size width="${w - 26}" height="${h}" />
                    <position x="${x + 24}" y="${y}" />
                  </drawText>
                  <drawSvgResource>
                    <path>method.svg</path>
                    <size width="20" height="20" />
                    <position x="${x}" y="${y}" />
                  </drawSvgResource>
                </display>
                <defaultSize width="`${parent.w}`" height="18" />
                <autoResizeEnabledByDefault>true</autoResizeEnabledByDefault>
                <childElementVisualSettings />
              </childElementVisualSetting>
            </childElementVisualSettings>
          </visualSettings>
          <visualSettings type="Stored Procedure" typeId="575edd35-9438-406d-b0a7-b99d6f29b560">
            <size width="${w}" height="${h}" />
            <position x="${x}" y="${y}" />
            <display>
              <drawText>
                <text>return getName();</text>
                <style>`font-size: 12px; 
font-family: Helvetica; 
font-weight: bold; 
text-align: center; 
white-space: inherit;
vertical-align: center`</style>
                <size width="${w}" height="18" />
                <position x="${x}" y="${y + 48}" />
              </drawText>
              <drawSvgResource>
                <path>stored-procedure.svg</path>
                <size width="${w}" height="40" />
                <position x="${x}" y="${y + 6}" />
              </drawSvgResource>
            </display>
            <defaultSize width="${x}" height="${y}" />
            <autoResizeEnabledByDefault>true</autoResizeEnabledByDefault>
            <childElementVisualSettings />
          </visualSettings>
          <visualSettings type="Domain Service" typeId="07f936ea-3756-48c8-babd-24ac7271daac">
            <size width="${w}" height="70" />
            <position x="${x}" y="${y}" />
            <display>
              <drawText>
                <text>return getName();</text>
                <style>`font-size: 12px; 
font-family: Helvetica; 
font-weight: bold; 
text-align: center; 
white-space: inherit;
vertical-align: center`</style>
                <size width="${w}" height="18" />
                <position x="${x}" y="${y + 48}" />
              </drawText>
              <drawSvgResource>
                <path>domain-service.svg</path>
                <size width="${w}" height="40" />
                <position x="${x}" y="${y + 6}" />
              </drawSvgResource>
            </display>
            <defaultSize width="${x}" height="70" />
            <autoResizeEnabledByDefault>true</autoResizeEnabledByDefault>
            <childElementVisualSettings>
              <childElementVisualSetting type="Operation" typeId="e042bb67-a1df-480c-9935-b26210f78591">
                <size width="`${parent.w}`" height="18" />
                <position x="`${parent.x}`" y="`${parent.y + ($index * 20) + 66}`" />
                <anchorPointsFunction>return [getDimensions().getCenterLeft(), getDimensions().getCenterRight()];</anchorPointsFunction>
                <display>
                  <drawText>
                    <text>return label;</text>
                    <size width="${w - 26}" height="${h}" />
                    <position x="${x + 24}" y="${y}" />
                  </drawText>
                  <drawSvgResource>
                    <path>method.svg</path>
                    <size width="20" height="20" />
                    <position x="${x}" y="${y}" />
                  </drawSvgResource>
                </display>
                <defaultSize width="`${parent.w}`" height="18" />
                <autoResizeEnabledByDefault>true</autoResizeEnabledByDefault>
                <childElementVisualSettings />
              </childElementVisualSetting>
            </childElementVisualSettings>
          </visualSettings>
        </elementVisualSettings>
        <associationVisualSettings>
          <visualSettings type="Domain Event Origin Association" typeId="4c0cc50b-8a9d-43cd-b731-9f354f69f3c9">
            <lineType>Curved</lineType>
            <lineDashArray>return "3,7";</lineDashArray>
            <sourceEnd>
              <pointIndicator>
                <path>return `a 4,4 0 1,0 4,4 
        a 4,4 0 1,0 -4,4`;</path>
              </pointIndicator>
            </sourceEnd>
            <targetEnd>
              <pointIndicator>
                <path>return `l 4 8 l -8 0 l 4 -8 Z`</path>
              </pointIndicator>
            </targetEnd>
          </visualSettings>
        </associationVisualSettings>
      </diagramSettings>
    </elementExtension>
    <elementExtension type="Folder" typeId="4d95d53a-8855-4f35-aa82-e312643f5c5f">
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Create CRUD Service</text>
          <shortcut>alt + s</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "basic";</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(command, settings) {
        var _a;
        this.command = command;
        this.settings = settings;
        this.mappedElement = (_a = command.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.command.id; }
    ;
    setReturnType(typeId, isCollection) {
        this.command.typeReference.setType(typeId);
        if (isCollection != null) {
            this.command.typeReference.setIsCollection(isCollection);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.command.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.command.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.command;
    }
    collapse() {
        this.command.collapse();
    }
}
// services-crud script (see ~/DesignerMacros/src/services-crud folder in Intent.Modules)
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
var servicesCrud;
(function (servicesCrud) {
    async function execute() {
        const package = element.getPackage();
        const entity = await DomainHelper.openSelectEntityDialog({
            includeOwnedRelationships: false
        });
        if (!entity) {
            return;
        }
        const serviceName = `${toPascalCase(pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName()))}Service`;
        const existingService = element.specialization == "Service" ? element : package.getChildren("Service").find(x =&gt; x.getName() == pluralize(serviceName));
        const service = existingService || createElement("Service", serviceName, package.id);
        const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName());
        const existingFolder = package.getChildren("Folder").find(x =&gt; x.getName() == pluralize(folderName));
        const folder = existingFolder || createElement("Folder", pluralize(folderName), package.id);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const resultDto = createMappedResultDto(entity, folder);
        createStandardCreateOperation(service, entity, folder);
        if (primaryKeys.length &gt; 0) {
            createStandardFindByIdOperation(service, entity, resultDto);
        }
        createStandardFindAllOperation(service, entity, resultDto);
        if (primaryKeys.length &gt; 0) {
            createStandardUpdateOperation(service, entity, folder);
            createStandardDeleteOperation(service, entity);
        }
    }
    servicesCrud.execute = execute;
    ;
    function createMappedResultDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == dtoName);
        if (existing) {
            return existing;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoFromEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        dtoManager.collapse();
        return dtoManager.getElement();
    }
    servicesCrud.createMappedResultDto = createMappedResultDto;
    function createStandardCreateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}CreateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Create${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Create${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });
        let operationManager = new ElementManager(createElement("Operation", `Create${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        operationManager.addChild("dto", dtoManager.id);
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        if (primaryKeys.length == 1) {
            operationManager.setReturnType(primaryKeys[0].typeId);
        }
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardCreateOperation = createStandardCreateOperation;
    function createStandardFindByIdOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${entity.getName()}ById`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.addChildrenFrom(DomainHelper.getPrimaryKeys(entity));
        operationManager.collapse();
    }
    servicesCrud.createStandardFindByIdOperation = createStandardFindByIdOperation;
    function createStandardFindAllOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${pluralize(entity.getName())}`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id, true);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.collapse();
    }
    servicesCrud.createStandardFindAllOperation = createStandardFindAllOperation;
    function createStandardUpdateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}UpdateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Update${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Update${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
            childType: "property"
        });
        let operationManager = new ElementManager(createElement("Operation", `Update${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.addChild("dto", dtoManager.id);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardUpdateOperation = createStandardUpdateOperation;
    function createStandardDeleteOperation(service, entity) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        if (service.getChildren().some(x =&gt; x.getName() == `Delete${entity.getName()}`)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", `Delete${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.collapse();
    }
    servicesCrud.createStandardDeleteOperation = createStandardDeleteOperation;
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
})(servicesCrud || (servicesCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/create-crud/create-crud.ts
 */
await servicesCrud.execute();
</script>
        </option>
        <option>
          <text>Create CRUD Service</text>
          <shortcut>alt + s</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAABkFJREFUeF7tm2tsFFUUx8+Z2S2F7bYpIo9WI4rbBYQGaKW8BAkQCH18I1CrkmhCQgyYaOIj8QMPHx8wURM1+klJjN2SGCnpEwrF8BDogiGm0C0SIfFRoxEpLXRp515zWzeU9U53uudud9A7H7v3f/acX//3njMzWQSb65XGos/Hm2c3232u6u/9LP/q2+t+nq4q3ljHQQ2QhlwDpPEDDVADJBIgyrUDNUAiAaJcO1ADJBIgyrUDNUAiAaJcO1ADJBIgyrUDNUAiAaJcO1ADJBIgyrUDNUAiAaJcO1ADJBIgyrUDNUAiAaJcO1ADJBIgyrUDUwVwa+OzheMMNjdRfMsyzR6o2Bu/bpxx4a1MjFxMpOeG948P1nzWnGidWz+3daDThJ9sbfVM683rj1/POVsZKp911Gmce3WdBkj8z2mAGiCRAFGuHagBEgkQ5dqBGiCRAFGuHagBEgkQ5dqBGiCRAFGuHagBEgkQ5dqBGiCRAFFOdmBVw6XZjLH2f+eB26tLAx8CIifm6Go5CeDTtR1By8TvAGC8pErOEV4OlQbfczUBYnJJA6zaf3Eu85jfAPBc2xw4MAB4o7o8+A4xT9fKkwIo4FkePIqAEx1UZnHOd4TKZ77pYO09t2TUACtrOwrBxGMAkD2Kai1gsKu6IrhrFJqkl25ren6hH5u+SjrAKISjAijgcQPaEDFD9h1df/bDlFwvoCyq2M4Gvla9PvBuqhvL9iObV+UO7G0ZBYeklzoG+FR95zzG+TkE+S88f/o9Cse+74FH8zKhKOgDQx6ZIze3F5TN+HgHojgfU3K5DuDGpksLcICFE8GL0QjkZ8KCwAQwbCgCgxeC5QWfpAqiqwA6dV68lR6emgEls/zy7QwAyM1tX5bN+CgV29k1ADceiDyOCMcRQXrm/fhrFE539AC3GZUfmpIBSx7z221TDoivVpcW7FG9j10BsKrhwiLOzIMcQErg8i99EO7sBZbgJBsRIgfGEXeEygp2q4SYdoACHmNmEwDkyAoT8M523gSLObtLG9mJaHHE3aHSwE5VENMKsKrh0iJmsUOAkCUrSGzbM5GehM6L1yaECLBTlRPTBnDT/vYS9HjEkOyVwbv6WxS+vWB/5iVykIC4eLZNYxm87eOvV5cF91AbS1oAVh6ILAMDBDzpdaVrCB71euB+0ViywJSPOByAvwQMw5TvycpoKsozXnyfEsOpdnDcrWroWMoYHk81vFj8BycLJ9pCdJq77boMvALTvWvJcZwEwE11PyxBsE7YLRZn3qmLdOfFxxdOXDbHfk50krzdmjEFWFkXaQSAdbJkGOPQeOY6dN+0KPXYatcU58CkbI/y2GMK8Jnm8z6rP7OWA6ySVRLtZ9Bytls5xFXzs2FyrrRXkYGOKUCR7XO1Hf4+E7+2g9h3m8Hhc+ogrpyXDVMnpgaeqGfMAYovFU4cuD2uHhBX2Dmxue069PYl/xBFPOZaUZgN0+6Tw+MAUc6hpKY8eJ5iw7SMMSLhLZ+GvTfy/EcAYZmsgP4BcSb+lRREMbYsnZMF+ZOkt9UAHLoZeJfXlD9CgifyThvAGLTKuojoyktkEC1rqLHcuOW8sXhMHBxbROeVX/waY+bqmorAOYrzYtq0AxSJqIIonCcGZ1t4wnncWKkKnisceMeJnScB+GI7J9afHnk7izPvibl+2207dOZ5S1Rs2+E5usKBg2diOOzt7vK3IsDSZM7E5YUjwuOcw3xqw5Dl5RqAIrkN+9qzPD5vHXAu7c5ixGlquw63ond350TwwDCKQusD4qW88stVAIcghnNMn78eudyJN6MMDobvQEwnPFedgcOtsaG1Pcvs9bQgQInMMsKBAmJxgQ/ybbqtqjkvkWVd58BYwuJMvNHlF09tFkobC+N2j6mUznn3LMBY4pvqIqfsnCgvDq8xxtfWVATbEhWv4vNth7fM8A2cVPaKYKScHL9Yjw9SWRc5befEu9amYM5TAVlVjKQB/jNsiyfHRSMkE2UpmPNUFa8iDgnghn3tGR6f5wRwKI5PRjyb9zCj+AtFt2cqik1FDBJAkVBFbYd/gomHhp+JAh4gXxgqnUl6t5GKglXHJAMcnBMPXc4xowPNAuL/CZ6oXQnAmBN9JraYzNj6X9+2w138N01uwigUVY8oAAAAAElFTkSuQmCC" />
          <isOptionVisibleFunction>return application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "advanced";</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        var _a, _b, _c, _d, _e, _f;
        if (element.specialization == "Service") {
            let entity = (_c = (_b = (_a = element.getChildren("Operation").find(x =&gt; x.getName().startsWith("Find"))) === null || _a === void 0 ? void 0 : _a.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.getMapping()) === null || _c === void 0 ? void 0 : _c.getElement();
            element.getChildren("Operation").forEach(operation =&gt; {
                convertOperation(operation, entity);
            });
        }
        else if (element.specialization == "Operation") {
            let dtoParam = element.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
            let dto = (_d = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType()) !== null &amp;&amp; _d !== void 0 ? _d : (_e = element.typeReference) === null || _e === void 0 ? void 0 : _e.getType();
            let entity = (_f = dto === null || dto === void 0 ? void 0 : dto.getMapping().getElement()) !== null &amp;&amp; _f !== void 0 ? _f : lookupTypesOf("Class").find(x =&gt; x.getName() == element.getName().replace("Delete", ""));
            if (entity) {
                convertOperation(element, entity);
            }
            else {
                console.warn("Cannot execute conversion script on Operation " + element.getName());
            }
        }
        else {
            console.error("Cannot qualify this script. Please contact Intent Architect support.");
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertOperation(operation, entity) {
        var _a, _b;
        let target = entity;
        let dtoParam = operation.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
        let dto = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType();
        // CREATE OPERATION:
        if (operation.getName().startsWith("Create") &amp;&amp; ((_a = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType().getMapping()) === null || _a === void 0 ? void 0 : _a.getElement().id) == entity.id) {
            let action = createAssociation("Create Entity Action", operation.id, target.id);
            let mapping = action.createMapping(operation.id, entity.id);
            mapping.addMappedEnd("Invocation Mapping", [operation.id], [target.id]);
            mapContract("Data Mapping", dto, [operation.id, dtoParam.id], [target.id], mapping);
            // DELETE OPERATION:
        }
        else if (operation.getName().startsWith("Delete") &amp;&amp; operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Delete Entity Action", operation.id, entity.id);
            let mapping = action.createMapping(operation.id, entity.id);
            addFilterMapping(mapping, operation, entity);
            // UPDATE OPERATION:
        }
        else if (operation.getName().startsWith("Update") &amp;&amp; ((_b = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType().getMapping()) === null || _b === void 0 ? void 0 : _b.getElement().id) == entity.id) {
            let action = createAssociation("Update Entity Action", operation.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(operation.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            mapContract("Data Mapping", dto, [operation.id, dtoParam.id], [target.id], updateMapping);
            // FIND BY ID OPERATION:
        }
        else if (operation.getName().startsWith("Find" + entity.getName()) &amp;&amp; operation.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // FIND ALL OPERATION:
        }
        else if (operation.getName().startsWith("Find" + pluralize(entity.getName()))) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            action.typeReference.setIsCollection(true);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
        }
        else {
            console.warn(`Could not convert operation: ${operation.getName()} (For entity ${entity.getName()}. Has parameters: (${operation.getChildren("Parameter").map(x =&gt; x.getName())}))`);
        }
    }
    convertToAdvancedMapping.convertOperation = convertOperation;
    function addFilterMapping(mapping, operation, entity) {
        var _a;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id");
            let pk = pkFields[0];
            if (idField &amp;&amp; pk) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a;
                let idField = operation.getChildren("Parameter").find(x =&gt; (x.getName().toLowerCase() == pk.name.toLowerCase()));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
                }
            });
        }
    }
    function mapContract(mappingType, dto, sourcePath, targetPathIds, mapping, isNested = false) {
        console.log("mapContract: " + dto.getName());
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; (isNested || !x.getMapping().getElement().hasStereotype("Primary Key"))).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping, true);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(command, settings) {
        var _a;
        this.command = command;
        this.settings = settings;
        this.mappedElement = (_a = command.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.command.id; }
    ;
    setReturnType(typeId, isCollection) {
        this.command.typeReference.setType(typeId);
        if (isCollection != null) {
            this.command.typeReference.setIsCollection(isCollection);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.command.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.command.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.command;
    }
    collapse() {
        this.command.collapse();
    }
}
// services-crud script (see ~/DesignerMacros/src/services-crud folder in Intent.Modules)
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
var servicesCrud;
(function (servicesCrud) {
    async function execute() {
        let package = element.getPackage();
        let entity = await DomainHelper.openSelectEntityDialog({
            includeOwnedRelationships: false
        });
        if (!entity) {
            return;
        }
        let serviceName = `${toPascalCase(pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName()))}Service`;
        var existingService = element.specialization == "Service" ? element : package.getChildren("Service").find(x =&gt; x.getName() == pluralize(serviceName));
        let service = existingService || createElement("Service", serviceName, package.id);
        let folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName());
        var existingFolder = package.getChildren("Folder").find(x =&gt; x.getName() == pluralize(folderName));
        var folder = existingFolder || createElement("Folder", pluralize(folderName), package.id);
        let resultDto = createMappedResultDto(entity, folder);
        createStandardCreateOperation(service, entity, folder);
        createStandardFindByIdOperation(service, entity, resultDto);
        createStandardFindAllOperation(service, entity, resultDto);
        createStandardUpdateOperation(service, entity, folder);
        createStandardDeleteOperation(service, entity);
    }
    servicesCrud.execute = execute;
    ;
    function createMappedResultDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == dtoName);
        if (existing) {
            return existing;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoFromEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        dtoManager.collapse();
        return dtoManager.getElement();
    }
    servicesCrud.createMappedResultDto = createMappedResultDto;
    function createStandardCreateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}CreateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Create${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Create${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });
        let operationManager = new ElementManager(createElement("Operation", `Create${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        operationManager.addChild("dto", dtoManager.id);
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        if (primaryKeys.length == 1) {
            operationManager.setReturnType(primaryKeys[0].typeId);
        }
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardCreateOperation = createStandardCreateOperation;
    function createStandardFindByIdOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${entity.getName()}ById`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.addChildrenFrom(DomainHelper.getPrimaryKeys(entity));
        operationManager.collapse();
    }
    servicesCrud.createStandardFindByIdOperation = createStandardFindByIdOperation;
    function createStandardFindAllOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${pluralize(entity.getName())}`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id, true);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.collapse();
    }
    servicesCrud.createStandardFindAllOperation = createStandardFindAllOperation;
    function createStandardUpdateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}UpdateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Update${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Update${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
            childType: "property"
        });
        let operationManager = new ElementManager(createElement("Operation", `Update${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.addChild("dto", dtoManager.id);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardUpdateOperation = createStandardUpdateOperation;
    function createStandardDeleteOperation(service, entity) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        if (service.getChildren().some(x =&gt; x.getName() == `Delete${entity.getName()}`)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", `Delete${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.collapse();
    }
    servicesCrud.createStandardDeleteOperation = createStandardDeleteOperation;
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
})(servicesCrud || (servicesCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/create-crud/create-crud.ts
 */
//await servicesCrud.execute();
/// &lt;reference path="../_common/convertToAdvancedMapping.ts"/&gt;
/// &lt;reference path="../create-crud/create-crud.ts"/&gt;
async function execute(element) {
    const package = element.getPackage();
    const entity = await DomainHelper.openSelectEntityDialog({
        includeOwnedRelationships: false
    });
    if (!entity) {
        return;
    }
    const serviceName = `${toPascalCase(pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName()))}Service`;
    const existingService = element.specialization == "Service" ? element : package.getChildren("Service").find(x =&gt; x.getName() == pluralize(serviceName));
    const service = existingService !== null &amp;&amp; existingService !== void 0 ? existingService : createElement("Service", serviceName, package.id);
    const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName());
    const existingFolder = package.getChildren("Folder").find(x =&gt; x.getName() == pluralize(folderName));
    const folder = existingFolder !== null &amp;&amp; existingFolder !== void 0 ? existingFolder : createElement("Folder", pluralize(folderName), package.id);
    const primaryKeys = DomainHelper.getPrimaryKeys(entity);
    const resultDto = servicesCrud.createMappedResultDto(entity, folder);
    servicesCrud.createStandardCreateOperation(service, entity, folder);
    if (primaryKeys.length &gt; 0) {
        servicesCrud.createStandardFindByIdOperation(service, entity, resultDto);
    }
    servicesCrud.createStandardFindAllOperation(service, entity, resultDto);
    if (primaryKeys.length &gt; 0) {
        servicesCrud.createStandardUpdateOperation(service, entity, folder);
        servicesCrud.createStandardDeleteOperation(service, entity);
    }
    service.getChildren("Operation").forEach(operation =&gt; {
        convertToAdvancedMapping.convertOperation(operation, entity);
    });
}
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/create-crud-advanced-mapping/create-crud-advanced-mapping.ts
 */
await execute(element);
</script>
        </option>
        <option>
          <text>Create CRUD CQRS Operations</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>function folderHasCommandOrQueries(element) {
    return element.specialization === "Folder" &amp;&amp; (element.getChildren("Command").length &gt; 0 || element.getChildren("Query").length &gt; 0);
}

return application.isModuleInstalled("Intent.Modelers.Services.CQRS") &amp;&amp;
    application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "basic" &amp;&amp;
    !folderHasCommandOrQueries(element);</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(command, settings) {
        var _a;
        this.command = command;
        this.settings = settings;
        this.mappedElement = (_a = command.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.command.id; }
    ;
    setReturnType(typeId, isCollection) {
        this.command.typeReference.setType(typeId);
        if (isCollection != null) {
            this.command.typeReference.setIsCollection(isCollection);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.command.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.command.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.command;
    }
    collapse() {
        this.command.collapse();
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b, _c;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; ((_c = entry.name) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", entry.name, dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    if (primaryKeys.length == 0) {
        // Implicit key:
        primaryKeys.push({
            id: null,
            name: "Id",
            typeId: getSurrogateKeyType(),
            mapPath: null,
            isNullable: false,
            isCollection: false
        });
    }
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; {
        var _a;
        return !x.hasStereotype("Primary Key") &amp;&amp;
            !legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
    });
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/**
 * Workaround for element's from referenced packages not having getParent()
 * @param element The element whose parent should be searched for
 * @param parentSpecializationType The specialization type of the parent
 */
function getParent(element, parentSpecializationType) {
    const elements = lookupTypesOf(parentSpecializationType);
    const parent = elements
        .find(x =&gt; x.getChildren(element.specialization)
        .some(child =&gt; child.id === element.id));
    if (parent == null) {
        throw new Error("Could not find parent");
    }
    return parent;
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
/// &lt;reference path="../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/getParent.ts" /&gt;
/**
 * Gets select details of a mapped Command/Query. Intended for centralized logic of working out
 * things like keys for both the entity and owning entity if applicable.
 *
 * If the Command is for entity creation (either due to being mapped to a constructor or being
 * prefixed with "Create"), then primary keys for the entity are not populated.
 * @param request The Command or Query that has been mapped
 */
function getMappedRequestDetails(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    // Advanced mapping:
    if (mappedElement == null) {
        const advancedMappings = request.getAssociations()
            .filter(x =&gt; x.hasMappings(queryEntityMappingTypeId) ||
            x.hasMappings(createEntityMappingTypeId))
            .map(x =&gt; x.getMapping(queryEntityMappingTypeId) ||
            x.getMapping(createEntityMappingTypeId));
        if (advancedMappings.length === 1) {
            mappedElement = advancedMappings[0].getTargetElement();
        }
    }
    if (mappedElement == null) {
        return null;
    }
    let entity = mappedElement;
    if (entity.specialization !== "Class") {
        entity = getParent(entity, "Class");
    }
    const result = {
        entity: entity,
        mappingTargetType: mappedElement.specialization,
        entityKeyFields: [],
        ownerKeyFields: []
    };
    result.owningEntity = DomainHelper.getOwningAggregate(entity);
    // As long as it's not for creation, populate the PKs of the entity:
    if (result.mappingTargetType !== "Class Constructor" &amp;&amp;
        !request.getName().toLowerCase().startsWith("Create")) {
        result.entityKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity)
            : getKeysForOperationMapping(request, entity);
    }
    // If the entity is owned, populate its fields:
    if (result.owningEntity != null) {
        result.ownerKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity, result.owningEntity)
            : getKeysForOperationMapping(request, entity, result.owningEntity);
    }
    return result;
    /**
     * Return field details for primary keys. As requests mapped to operations and constructors can
     * never possibly map the attributes, these fields can only ever be matched by name.
     * @param request The CQRS Command or Query entity
     * @param owningEntity The Owning Aggregate Class
     */
    function getKeysForOperationMapping(request, entity, owningEntity) {
        const pks = DomainHelper.getPrimaryKeys(owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity);
        return pks.map(pk =&gt; {
            let fieldName = toPascalCase(pk.name);
            if (owningEntity != null) {
                fieldName = removePrefix(fieldName, toPascalCase(owningEntity.getName()));
                fieldName = `${owningEntity.getName()}${toCamelCase(fieldName)}`;
            }
            fieldName = ServicesHelper.getFieldFormat(fieldName);
            const existingField = request.getChildren("DTO-Field").find(field =&gt; field.getName().toLowerCase() == fieldName.toLowerCase());
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: [],
                name: fieldName,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
    function getKeysForClassMapping(request, entity, owningEntity) {
        const keys = owningEntity != null
            ? DomainHelper.getForeignKeys(entity, owningEntity)
            : DomainHelper.getPrimaryKeys(entity);
        return keys.map(pk =&gt; {
            const existingField = request.getChildren("DTO-Field").find(field =&gt; {
                if (field.getMapping() != null) {
                    return field.getMapping().getPath().some(x =&gt; x.id == pk.id);
                }
                return (pk.name.toLowerCase() === field.getName().toLowerCase());
            });
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: pk.mapPath,
                name: pk.name,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/**
 * Ensures that for the provided contract, it has the provided field creating it if necessary and
 * then ensure the field has the correct typeReference details and order.
 * The field's element is returned.
 */
function ensureHasField(options) {
    const { contract, fieldDetail, mappingSettingsId, order } = options;
    let field = fieldDetail.existingId != null
        ? contract.getChildren("DTO-Field").find(x =&gt; x.id === fieldDetail.existingId)
        : createElement("DTO-Field", fieldDetail.name, contract.id);
    field.typeReference.setType(fieldDetail.typeId);
    field.typeReference.setIsCollection(fieldDetail.isCollection);
    field.typeReference.setIsNullable(fieldDetail.isNullable);
    if (order != null) {
        field.setOrder(order);
    }
    if (mappingSettingsId != null) {
        field.setMapping(fieldDetail.mappingPath, mappingSettingsId);
    }
    return field;
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/// &lt;reference path="ensureHasField.ts" /&gt;
function onMapCommand(element, isForCrudScript, isForCreate = false) {
    var _a, _b, _c;
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    // const mapToDomainDataSettingsId = "735c87d0-06fc-4491-8b5f-5adc6f953c54";
    const mappingDetails = getMappedRequestDetails(element);
    if (mappingDetails == null) {
        return;
    }
    if (isForCrudScript ||
        mappingDetails.mappingTargetType !== "Class") {
        let order = 0;
        let keyFields = mappingDetails.ownerKeyFields;
        if (!isForCreate) {
            keyFields = keyFields.concat(mappingDetails.entityKeyFields);
        }
        for (const keyField of keyFields) {
            ensureHasField({
                contract: element,
                fieldDetail: keyField,
                order: order++
            });
        }
    }
    if (mappingDetails.mappingTargetType === "Operation" &amp;&amp;
        isComplexType((_c = (_b = (_a = element.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType())) {
        getOrCreateCommandCrudDto(element, element, false, mapFromDomainMappingSettingId);
    }
    const fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; ((_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement().specialization.startsWith("Association")); });
    fields.forEach(field =&gt; {
        getOrCreateCommandCrudDto(element, field, true, projectMappingSettingId);
    });
    const complexFields = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp;
            isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType());
    });
    complexFields.forEach(cf =&gt; {
        getOrCreateCommandCrudDto(element, cf, false, projectMappingSettingId);
    });
    function isComplexType(element) {
        if (element == null) {
            console.warn("isComplexType element parameter received null");
        }
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object";
    }
    function getOrCreateCommandCrudDto(command, dtoField, autoAddPrimaryKey, mappingTypeSettingId) {
        let mappedElement = dtoField.getMapping().getElement();
        if (mappedElement.typeReference == null)
            throw new Error("TypeReference is undefined");
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.typeReference.getType().getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        let dto = getOrCreateDto(dtoName, command.getParent());
        dto.setMetadata("originalVerb", originalVerb);
        dto.setMetadata("baseName", baseName);
        dto.setMapping(mappedElement.typeReference.getTypeId(), mappingTypeSettingId);
        ensureDtoFields(autoAddPrimaryKey, mappedElement, dto);
        dtoField.typeReference.setType(dto.id);
    }
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
function onMapDto(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b, _c; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; ((_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.specialization.startsWith("Association")); });
    fields.forEach(f =&gt; {
        getOrCreateDtoCrudDto(element, f, true);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d, _e;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (complexTypes.includes((_e = (_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()) === null || _e === void 0 ? void 0 : _e.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateDtoCrudDto(element, f, false);
    });
}
function getOrCreateDtoCrudDto(element, dtoField, autoAddPrimaryKey) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const originalDtoMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    let mappedElement = dtoField.getMapping().getElement();
    let originalVerb = "";
    if (element.hasMetadata("originalVerb")) {
        originalVerb = element.getMetadata("originalVerb");
        // In the event that the prefix is no longer the same as the
        // originally called verb, then don't propagate this any further
        // as end users might get confused.
        if (element.getName().indexOf(originalVerb) &lt; 0) {
            originalVerb = "";
        }
    }
    let targetMappingSettingId = dtoField.getParent().getMapping().mappingSettingsId;
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : domainName;
    let dtoName = `${originalVerb}${baseName}`;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), targetMappingSettingId);
    if (originalVerb !== "") {
        dto.setMetadata("originalVerb", originalVerb);
    }
    dto.setMetadata("baseName", baseName);
    ensureDtoFields(autoAddPrimaryKey, mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
function onMapQuery(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; x.getMapping().getElement().specialization.startsWith("Association"); });
    fields.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d, _e;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (complexTypes.includes((_e = (_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()) === null || _e === void 0 ? void 0 : _e.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
}
function getOrCreateQueryCrudDto(element, dtoField) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    let mappedElement = dtoField.getMapping().getElement();
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : `${domainName}`;
    let dtoName = baseName;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMappingSettingId);
    dto.setMetadata("baseName", baseName);
    ensureDtoFieldsQuery(mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
function ensureDtoFieldsQuery(mappedElement, dto) {
    let dtoUpdated = false;
    let mappedElementAttributes = mappedElement
        .typeReference
        .getType()
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; !dtoFields.some(y =&gt; x.getName() === y.getName()))) {
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == attribute.getName())) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.getName(), dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
var _a, _b;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../_common/onMapCommand.ts" /&gt;
/// &lt;reference path="../_common/onMapDto.ts" /&gt;
/// &lt;reference path="../_common/onMapQuery.ts" /&gt;
const privateSettersOnly = ((_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")) === null || _b === void 0 ? void 0 : _b.value) == "true";
const mapToDomainOperationSettingId = "7c31c459-6229-4f10-bf13-507348cd8828";
var cqrsCrud;
(function (cqrsCrud) {
    async function execute(element) {
        var _a;
        let entity = await DomainHelper.openSelectEntityDialog();
        if (entity == null) {
            return;
        }
        const owningEntity = DomainHelper.getOwningAggregate(entity);
        const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? owningEntity.getName() : entity.getName());
        const folder = (_a = element.getChildren().find(x =&gt; x.getName() == pluralize(folderName))) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Folder", pluralize(folderName), element.id);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const hasPrimaryKey = primaryKeys.length &gt; 0;
        const resultDto = createCqrsResultTypeDto(entity, folder);
        if (owningEntity == null || !privateSettersOnly) {
            createCqrsCreateCommand(entity, folder, primaryKeys);
        }
        if (hasPrimaryKey) {
            createCqrsFindByIdQuery(entity, folder, resultDto);
        }
        createCqrsFindAllQuery(entity, folder, resultDto);
        if (hasPrimaryKey &amp;&amp; !privateSettersOnly) {
            createCqrsUpdateCommand(entity, folder);
        }
        const allowedOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !allowedOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        for (const operation of operations) {
            createCqrsCallOperationCommand(entity, operation, folder);
        }
        if (hasPrimaryKey &amp;&amp; (owningEntity == null || !privateSettersOnly)) {
            createCqrsDeleteCommand(entity, folder);
        }
    }
    cqrsCrud.execute = execute;
    function createCqrsCreateCommand(entity, folder, primaryKeys) {
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = getBaseNameForElement(owningAggregate, entity, false);
        const expectedCommandName = `Create${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            const returnType = primaryKeys.length == 1
                ? primaryKeys[0].typeId
                : null;
            const command = folder.getChildren().filter(x =&gt; x.getName() == expectedCommandName)[0];
            command.typeReference.setType(returnType);
            return command;
        }
        const commandManager = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        const entityCtor = entity
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (entityCtor != null) {
            commandManager.mapToElement(entityCtor, mapToDomainOperationSettingId);
            commandManager.getElement().setMapping([entity.id, entityCtor.id], mapToDomainOperationSettingId);
        }
        else if (!privateSettersOnly) {
            commandManager.mapToElement(entity);
        }
        else {
            console.warn(`Private Setters are enabled with no constructor present on entity '${entity.getName()}'. In order for '${expectedCommandName}' to map to that entity, either disable private setters or model a constructor element and try again.`);
        }
        commandManager.getElement().setMetadata("baseName", baseName);
        const surrogateKey = primaryKeys.length === 1;
        if (surrogateKey) {
            commandManager.setReturnType(primaryKeys[0].typeId);
        }
        if (entityCtor) {
            commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(entityCtor, "Parameter")
                .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        }
        else {
            if (!surrogateKey) {
                const toAdd = primaryKeys.filter(x =&gt; DomainHelper.isUserSuppliedPrimaryKey(lookup(x.id)));
                ServicesHelper.addDtoFieldsFromDomain(commandManager.getElement(), toAdd);
            }
            commandManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
            commandManager.addChildrenFrom(getMandatoryAssociationsWithMapPath(entity));
        }
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandManager.getElement());
        }
        onMapCommand(commandManager.getElement(), true, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCreateCommand = createCqrsCreateCommand;
    function createCqrsFindByIdQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedQueryName = `Get${baseName}ByIdQuery`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(query, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        onMapQuery(query);
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindByIdQuery = createCqrsFindByIdQuery;
    function createCqrsFindAllQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, true);
        let expectedQueryName = `Get${baseName}Query`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.typeReference.setIsCollection(true);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindAllQuery = createCqrsFindAllQuery;
    function createCqrsUpdateCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Update${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        command.mapToElement(entity);
        command.getElement().setMetadata("baseName", baseName);
        command.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        command.addChildrenFrom(getMandatoryAssociationsWithMapPath(entity));
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command.getElement(), primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command.getElement());
        }
        onMapCommand(command.getElement(), true);
        command.collapse();
        return command.getElement();
    }
    cqrsCrud.createCqrsUpdateCommand = createCqrsUpdateCommand;
    function createCqrsCallOperationCommand(entity, operation, folder) {
        var _a;
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = (_a = owningAggregate === null || owningAggregate === void 0 ? void 0 : owningAggregate.getName()) !== null &amp;&amp; _a !== void 0 ? _a : "";
        let operationName = operation.getName();
        operationName = removeSuffix(operationName, "Async");
        operationName = toPascalCase(operationName);
        const commandName = `${operationName}${entity.getName()}Command`;
        const existing = folder.getChildren().find(x =&gt; {
            var _a, _b;
            return x.getName() == commandName ||
                ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) === operation.id;
        });
        if (existing) {
            return existing;
        }
        const commandElement = createElement("Command", commandName, folder.id);
        commandElement.setMetadata("baseName", baseName);
        const commandManager = new ElementManager(commandElement, { childSpecialization: "DTO-Field" });
        commandManager.mapToElement([entity.id, operation.id], mapToDomainOperationSettingId);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        for (const key of primaryKeys) {
            commandManager.addChild(key.name, lookup(key.id).typeReference);
        }
        commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(operation, "Parameter")
            .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandElement);
        }
        onMapCommand(commandElement, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCallOperationCommand = createCqrsCallOperationCommand;
    function createCqrsDeleteCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Delete${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = createElement("Command", expectedCommandName, folder.id);
        command.setMapping(entity.id);
        command.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), command.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command);
        }
        onMapCommand(command, true);
        command.collapse();
        return command;
    }
    cqrsCrud.createCqrsDeleteCommand = createCqrsDeleteCommand;
    function createCqrsResultTypeDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedDtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedDtoName);
        if (existing) {
            return existing;
        }
        let dto = createElement("DTO", expectedDtoName, folder.id);
        dto.setMetadata("baseName", baseName);
        dto.setMapping(entity.id);
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), dto.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        ServicesHelper.addDtoFieldsFromDomain(dto, primaryKeys);
        let attributesWithMapPaths = DomainHelper.getAttributesWithMapPath(entity);
        for (var attr of attributesWithMapPaths) {
            if (dto.getChildren("DTO-Field").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == attr.id; })) {
                continue;
            }
            let field = createElement("DTO-Field", attr.name, dto.id);
            field.typeReference.setType(attr.typeId);
            field.setMapping(attr.mapPath);
        }
        onMapDto(dto);
        dto.collapse();
        return dto;
    }
    cqrsCrud.createCqrsResultTypeDto = createCqrsResultTypeDto;
    function addAggregatePkToCommandOrQuery(owningAggregate, commandOrQuery) {
        if (owningAggregate != null) {
            var aggPks = DomainHelper.getPrimaryKeys(owningAggregate);
            aggPks.forEach(x =&gt; {
                if (x.name.toLowerCase() == "id") {
                    x.name = `${owningAggregate.getName()}Id`;
                }
                x.id = null;
                x.mapPath = null;
                x.isCollection = false;
                x.isNullable = false;
            });
            ServicesHelper.addDtoFieldsFromDomain(commandOrQuery, aggPks);
        }
    }
    function getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
})(cqrsCrud || (cqrsCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/create-crud-macro/create-crud-macro.ts
 */
await cqrsCrud.execute(element);
</script>
        </option>
        <option>
          <text>Create CRUD CQRS Operations</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>function folderHasCommandOrQueries(element) {
    return element.specialization === "Folder" &amp;&amp; (element.getChildren("Command").length &gt; 0 || element.getChildren("Query").length &gt; 0);
}

return application.isModuleInstalled("Intent.Modelers.Services.CQRS") &amp;&amp;
    application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "advanced" &amp;&amp;
    !folderHasCommandOrQueries(element);</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(command, settings) {
        var _a;
        this.command = command;
        this.settings = settings;
        this.mappedElement = (_a = command.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.command.id; }
    ;
    setReturnType(typeId, isCollection) {
        this.command.typeReference.setType(typeId);
        if (isCollection != null) {
            this.command.typeReference.setIsCollection(isCollection);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.command.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.command.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.command;
    }
    collapse() {
        this.command.collapse();
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b, _c;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; ((_c = entry.name) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", entry.name, dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    if (primaryKeys.length == 0) {
        // Implicit key:
        primaryKeys.push({
            id: null,
            name: "Id",
            typeId: getSurrogateKeyType(),
            mapPath: null,
            isNullable: false,
            isCollection: false
        });
    }
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; {
        var _a;
        return !x.hasStereotype("Primary Key") &amp;&amp;
            !legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
    });
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/**
 * Workaround for element's from referenced packages not having getParent()
 * @param element The element whose parent should be searched for
 * @param parentSpecializationType The specialization type of the parent
 */
function getParent(element, parentSpecializationType) {
    const elements = lookupTypesOf(parentSpecializationType);
    const parent = elements
        .find(x =&gt; x.getChildren(element.specialization)
        .some(child =&gt; child.id === element.id));
    if (parent == null) {
        throw new Error("Could not find parent");
    }
    return parent;
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
/// &lt;reference path="../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/getParent.ts" /&gt;
/**
 * Gets select details of a mapped Command/Query. Intended for centralized logic of working out
 * things like keys for both the entity and owning entity if applicable.
 *
 * If the Command is for entity creation (either due to being mapped to a constructor or being
 * prefixed with "Create"), then primary keys for the entity are not populated.
 * @param request The Command or Query that has been mapped
 */
function getMappedRequestDetails(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    // Advanced mapping:
    if (mappedElement == null) {
        const advancedMappings = request.getAssociations()
            .filter(x =&gt; x.hasMappings(queryEntityMappingTypeId) ||
            x.hasMappings(createEntityMappingTypeId))
            .map(x =&gt; x.getMapping(queryEntityMappingTypeId) ||
            x.getMapping(createEntityMappingTypeId));
        if (advancedMappings.length === 1) {
            mappedElement = advancedMappings[0].getTargetElement();
        }
    }
    if (mappedElement == null) {
        return null;
    }
    let entity = mappedElement;
    if (entity.specialization !== "Class") {
        entity = getParent(entity, "Class");
    }
    const result = {
        entity: entity,
        mappingTargetType: mappedElement.specialization,
        entityKeyFields: [],
        ownerKeyFields: []
    };
    result.owningEntity = DomainHelper.getOwningAggregate(entity);
    // As long as it's not for creation, populate the PKs of the entity:
    if (result.mappingTargetType !== "Class Constructor" &amp;&amp;
        !request.getName().toLowerCase().startsWith("Create")) {
        result.entityKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity)
            : getKeysForOperationMapping(request, entity);
    }
    // If the entity is owned, populate its fields:
    if (result.owningEntity != null) {
        result.ownerKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity, result.owningEntity)
            : getKeysForOperationMapping(request, entity, result.owningEntity);
    }
    return result;
    /**
     * Return field details for primary keys. As requests mapped to operations and constructors can
     * never possibly map the attributes, these fields can only ever be matched by name.
     * @param request The CQRS Command or Query entity
     * @param owningEntity The Owning Aggregate Class
     */
    function getKeysForOperationMapping(request, entity, owningEntity) {
        const pks = DomainHelper.getPrimaryKeys(owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity);
        return pks.map(pk =&gt; {
            let fieldName = toPascalCase(pk.name);
            if (owningEntity != null) {
                fieldName = removePrefix(fieldName, toPascalCase(owningEntity.getName()));
                fieldName = `${owningEntity.getName()}${toCamelCase(fieldName)}`;
            }
            fieldName = ServicesHelper.getFieldFormat(fieldName);
            const existingField = request.getChildren("DTO-Field").find(field =&gt; field.getName().toLowerCase() == fieldName.toLowerCase());
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: [],
                name: fieldName,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
    function getKeysForClassMapping(request, entity, owningEntity) {
        const keys = owningEntity != null
            ? DomainHelper.getForeignKeys(entity, owningEntity)
            : DomainHelper.getPrimaryKeys(entity);
        return keys.map(pk =&gt; {
            const existingField = request.getChildren("DTO-Field").find(field =&gt; {
                if (field.getMapping() != null) {
                    return field.getMapping().getPath().some(x =&gt; x.id == pk.id);
                }
                return (pk.name.toLowerCase() === field.getName().toLowerCase());
            });
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: pk.mapPath,
                name: pk.name,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/**
 * Ensures that for the provided contract, it has the provided field creating it if necessary and
 * then ensure the field has the correct typeReference details and order.
 * The field's element is returned.
 */
function ensureHasField(options) {
    const { contract, fieldDetail, mappingSettingsId, order } = options;
    let field = fieldDetail.existingId != null
        ? contract.getChildren("DTO-Field").find(x =&gt; x.id === fieldDetail.existingId)
        : createElement("DTO-Field", fieldDetail.name, contract.id);
    field.typeReference.setType(fieldDetail.typeId);
    field.typeReference.setIsCollection(fieldDetail.isCollection);
    field.typeReference.setIsNullable(fieldDetail.isNullable);
    if (order != null) {
        field.setOrder(order);
    }
    if (mappingSettingsId != null) {
        field.setMapping(fieldDetail.mappingPath, mappingSettingsId);
    }
    return field;
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/// &lt;reference path="ensureHasField.ts" /&gt;
function onMapCommand(element, isForCrudScript, isForCreate = false) {
    var _a, _b, _c;
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    // const mapToDomainDataSettingsId = "735c87d0-06fc-4491-8b5f-5adc6f953c54";
    const mappingDetails = getMappedRequestDetails(element);
    if (mappingDetails == null) {
        return;
    }
    if (isForCrudScript ||
        mappingDetails.mappingTargetType !== "Class") {
        let order = 0;
        let keyFields = mappingDetails.ownerKeyFields;
        if (!isForCreate) {
            keyFields = keyFields.concat(mappingDetails.entityKeyFields);
        }
        for (const keyField of keyFields) {
            ensureHasField({
                contract: element,
                fieldDetail: keyField,
                order: order++
            });
        }
    }
    if (mappingDetails.mappingTargetType === "Operation" &amp;&amp;
        isComplexType((_c = (_b = (_a = element.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType())) {
        getOrCreateCommandCrudDto(element, element, false, mapFromDomainMappingSettingId);
    }
    const fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; ((_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement().specialization.startsWith("Association")); });
    fields.forEach(field =&gt; {
        getOrCreateCommandCrudDto(element, field, true, projectMappingSettingId);
    });
    const complexFields = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp;
            isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType());
    });
    complexFields.forEach(cf =&gt; {
        getOrCreateCommandCrudDto(element, cf, false, projectMappingSettingId);
    });
    function isComplexType(element) {
        if (element == null) {
            console.warn("isComplexType element parameter received null");
        }
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object";
    }
    function getOrCreateCommandCrudDto(command, dtoField, autoAddPrimaryKey, mappingTypeSettingId) {
        let mappedElement = dtoField.getMapping().getElement();
        if (mappedElement.typeReference == null)
            throw new Error("TypeReference is undefined");
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.typeReference.getType().getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        let dto = getOrCreateDto(dtoName, command.getParent());
        dto.setMetadata("originalVerb", originalVerb);
        dto.setMetadata("baseName", baseName);
        dto.setMapping(mappedElement.typeReference.getTypeId(), mappingTypeSettingId);
        ensureDtoFields(autoAddPrimaryKey, mappedElement, dto);
        dtoField.typeReference.setType(dto.id);
    }
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
function onMapDto(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b, _c; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; ((_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.specialization.startsWith("Association")); });
    fields.forEach(f =&gt; {
        getOrCreateDtoCrudDto(element, f, true);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d, _e;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (complexTypes.includes((_e = (_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()) === null || _e === void 0 ? void 0 : _e.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateDtoCrudDto(element, f, false);
    });
}
function getOrCreateDtoCrudDto(element, dtoField, autoAddPrimaryKey) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const originalDtoMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    let mappedElement = dtoField.getMapping().getElement();
    let originalVerb = "";
    if (element.hasMetadata("originalVerb")) {
        originalVerb = element.getMetadata("originalVerb");
        // In the event that the prefix is no longer the same as the
        // originally called verb, then don't propagate this any further
        // as end users might get confused.
        if (element.getName().indexOf(originalVerb) &lt; 0) {
            originalVerb = "";
        }
    }
    let targetMappingSettingId = dtoField.getParent().getMapping().mappingSettingsId;
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : domainName;
    let dtoName = `${originalVerb}${baseName}`;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), targetMappingSettingId);
    if (originalVerb !== "") {
        dto.setMetadata("originalVerb", originalVerb);
    }
    dto.setMetadata("baseName", baseName);
    ensureDtoFields(autoAddPrimaryKey, mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
function onMapQuery(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; x.getMapping().getElement().specialization.startsWith("Association"); });
    fields.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d, _e;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (complexTypes.includes((_e = (_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()) === null || _e === void 0 ? void 0 : _e.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
}
function getOrCreateQueryCrudDto(element, dtoField) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    let mappedElement = dtoField.getMapping().getElement();
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : `${domainName}`;
    let dtoName = baseName;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMappingSettingId);
    dto.setMetadata("baseName", baseName);
    ensureDtoFieldsQuery(mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
function ensureDtoFieldsQuery(mappedElement, dto) {
    let dtoUpdated = false;
    let mappedElementAttributes = mappedElement
        .typeReference
        .getType()
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; !dtoFields.some(y =&gt; x.getName() === y.getName()))) {
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == attribute.getName())) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.getName(), dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
var _a, _b;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../_common/onMapCommand.ts" /&gt;
/// &lt;reference path="../_common/onMapDto.ts" /&gt;
/// &lt;reference path="../_common/onMapQuery.ts" /&gt;
const privateSettersOnly = ((_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")) === null || _b === void 0 ? void 0 : _b.value) == "true";
const mapToDomainOperationSettingId = "7c31c459-6229-4f10-bf13-507348cd8828";
var cqrsCrud;
(function (cqrsCrud) {
    async function execute(element) {
        var _a;
        let entity = await DomainHelper.openSelectEntityDialog();
        if (entity == null) {
            return;
        }
        const owningEntity = DomainHelper.getOwningAggregate(entity);
        const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? owningEntity.getName() : entity.getName());
        const folder = (_a = element.getChildren().find(x =&gt; x.getName() == pluralize(folderName))) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Folder", pluralize(folderName), element.id);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const hasPrimaryKey = primaryKeys.length &gt; 0;
        const resultDto = createCqrsResultTypeDto(entity, folder);
        if (owningEntity == null || !privateSettersOnly) {
            createCqrsCreateCommand(entity, folder, primaryKeys);
        }
        if (hasPrimaryKey) {
            createCqrsFindByIdQuery(entity, folder, resultDto);
        }
        createCqrsFindAllQuery(entity, folder, resultDto);
        if (hasPrimaryKey &amp;&amp; !privateSettersOnly) {
            createCqrsUpdateCommand(entity, folder);
        }
        const allowedOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !allowedOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        for (const operation of operations) {
            createCqrsCallOperationCommand(entity, operation, folder);
        }
        if (hasPrimaryKey &amp;&amp; (owningEntity == null || !privateSettersOnly)) {
            createCqrsDeleteCommand(entity, folder);
        }
    }
    cqrsCrud.execute = execute;
    function createCqrsCreateCommand(entity, folder, primaryKeys) {
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = getBaseNameForElement(owningAggregate, entity, false);
        const expectedCommandName = `Create${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            const returnType = primaryKeys.length == 1
                ? primaryKeys[0].typeId
                : null;
            const command = folder.getChildren().filter(x =&gt; x.getName() == expectedCommandName)[0];
            command.typeReference.setType(returnType);
            return command;
        }
        const commandManager = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        const entityCtor = entity
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (entityCtor != null) {
            commandManager.mapToElement(entityCtor, mapToDomainOperationSettingId);
            commandManager.getElement().setMapping([entity.id, entityCtor.id], mapToDomainOperationSettingId);
        }
        else if (!privateSettersOnly) {
            commandManager.mapToElement(entity);
        }
        else {
            console.warn(`Private Setters are enabled with no constructor present on entity '${entity.getName()}'. In order for '${expectedCommandName}' to map to that entity, either disable private setters or model a constructor element and try again.`);
        }
        commandManager.getElement().setMetadata("baseName", baseName);
        const surrogateKey = primaryKeys.length === 1;
        if (surrogateKey) {
            commandManager.setReturnType(primaryKeys[0].typeId);
        }
        if (entityCtor) {
            commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(entityCtor, "Parameter")
                .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        }
        else {
            if (!surrogateKey) {
                const toAdd = primaryKeys.filter(x =&gt; DomainHelper.isUserSuppliedPrimaryKey(lookup(x.id)));
                ServicesHelper.addDtoFieldsFromDomain(commandManager.getElement(), toAdd);
            }
            commandManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
            commandManager.addChildrenFrom(getMandatoryAssociationsWithMapPath(entity));
        }
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandManager.getElement());
        }
        onMapCommand(commandManager.getElement(), true, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCreateCommand = createCqrsCreateCommand;
    function createCqrsFindByIdQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedQueryName = `Get${baseName}ByIdQuery`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(query, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        onMapQuery(query);
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindByIdQuery = createCqrsFindByIdQuery;
    function createCqrsFindAllQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, true);
        let expectedQueryName = `Get${baseName}Query`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.typeReference.setIsCollection(true);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindAllQuery = createCqrsFindAllQuery;
    function createCqrsUpdateCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Update${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        command.mapToElement(entity);
        command.getElement().setMetadata("baseName", baseName);
        command.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        command.addChildrenFrom(getMandatoryAssociationsWithMapPath(entity));
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command.getElement(), primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command.getElement());
        }
        onMapCommand(command.getElement(), true);
        command.collapse();
        return command.getElement();
    }
    cqrsCrud.createCqrsUpdateCommand = createCqrsUpdateCommand;
    function createCqrsCallOperationCommand(entity, operation, folder) {
        var _a;
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = (_a = owningAggregate === null || owningAggregate === void 0 ? void 0 : owningAggregate.getName()) !== null &amp;&amp; _a !== void 0 ? _a : "";
        let operationName = operation.getName();
        operationName = removeSuffix(operationName, "Async");
        operationName = toPascalCase(operationName);
        const commandName = `${operationName}${entity.getName()}Command`;
        const existing = folder.getChildren().find(x =&gt; {
            var _a, _b;
            return x.getName() == commandName ||
                ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) === operation.id;
        });
        if (existing) {
            return existing;
        }
        const commandElement = createElement("Command", commandName, folder.id);
        commandElement.setMetadata("baseName", baseName);
        const commandManager = new ElementManager(commandElement, { childSpecialization: "DTO-Field" });
        commandManager.mapToElement([entity.id, operation.id], mapToDomainOperationSettingId);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        for (const key of primaryKeys) {
            commandManager.addChild(key.name, lookup(key.id).typeReference);
        }
        commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(operation, "Parameter")
            .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandElement);
        }
        onMapCommand(commandElement, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCallOperationCommand = createCqrsCallOperationCommand;
    function createCqrsDeleteCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Delete${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = createElement("Command", expectedCommandName, folder.id);
        command.setMapping(entity.id);
        command.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), command.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command);
        }
        onMapCommand(command, true);
        command.collapse();
        return command;
    }
    cqrsCrud.createCqrsDeleteCommand = createCqrsDeleteCommand;
    function createCqrsResultTypeDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedDtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedDtoName);
        if (existing) {
            return existing;
        }
        let dto = createElement("DTO", expectedDtoName, folder.id);
        dto.setMetadata("baseName", baseName);
        dto.setMapping(entity.id);
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), dto.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        ServicesHelper.addDtoFieldsFromDomain(dto, primaryKeys);
        let attributesWithMapPaths = DomainHelper.getAttributesWithMapPath(entity);
        for (var attr of attributesWithMapPaths) {
            if (dto.getChildren("DTO-Field").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == attr.id; })) {
                continue;
            }
            let field = createElement("DTO-Field", attr.name, dto.id);
            field.typeReference.setType(attr.typeId);
            field.setMapping(attr.mapPath);
        }
        onMapDto(dto);
        dto.collapse();
        return dto;
    }
    cqrsCrud.createCqrsResultTypeDto = createCqrsResultTypeDto;
    function addAggregatePkToCommandOrQuery(owningAggregate, commandOrQuery) {
        if (owningAggregate != null) {
            var aggPks = DomainHelper.getPrimaryKeys(owningAggregate);
            aggPks.forEach(x =&gt; {
                if (x.name.toLowerCase() == "id") {
                    x.name = `${owningAggregate.getName()}Id`;
                }
                x.id = null;
                x.mapPath = null;
                x.isCollection = false;
                x.isNullable = false;
            });
            ServicesHelper.addDtoFieldsFromDomain(commandOrQuery, aggPks);
        }
    }
    function getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
})(cqrsCrud || (cqrsCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/create-crud-macro/create-crud-macro.ts
 */
//await cqrsCrud.execute(element);
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        if (element.isMapped() &amp;&amp; element.specialization == "Command") {
            convertCommand(element);
        }
        else if (element.isMapped() &amp;&amp; element.specialization == "Query") {
            convertQuery(element);
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertCommand(command) {
        var _a;
        if (!command) {
            console.warn(`Could not convert null Command.`);
            return;
        }
        if (!command.getMapping()) {
            console.warn(`Could not convert Command '${command.getName()}' without it mapping to an Entity.`);
            return;
        }
        let target = command.getMapping().getElement();
        let entity = (_a = target.getParent("Class")) !== null &amp;&amp; _a !== void 0 ? _a : target;
        if (command.getName().startsWith("Create")) {
            let action = createAssociation("Create Entity Action", command.id, target.id);
            let mapping = action.createMapping(command.id, entity.id);
            mapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            mapContract("Data Mapping", command, [command.id], [target.id], mapping);
        }
        else if (command.getName().startsWith("Delete")) {
            let action = createAssociation("Delete Entity Action", command.id, entity.id);
            let mapping = action.createMapping(command.id, entity.id);
            // Query Entity Mapping
            addFilterMapping(mapping, command, entity);
            command.clearMapping();
        }
        else if (command.isMapped()) {
            let action = createAssociation("Update Entity Action", command.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(command.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, command, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(command.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            if (target.id != entity.id) {
                updateMapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            }
            mapContract("Data Mapping", command, [command.id], [target.id], updateMapping);
        }
    }
    convertToAdvancedMapping.convertCommand = convertCommand;
    function addFilterMapping(mapping, command, entity) {
        var _a, _b;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key")) || (x.getName() == "Id" || x.getName() == `${entity.getName()}Id`));
            let entityPk = entity.getChildren("Attribute").find(x =&gt; x.hasStereotype("Primary Key"));
            if (idField &amp;&amp; (idField.isMapped() || entityPk)) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [entityPk.id]);
                idField.clearMapping();
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a, _b;
                let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp; x.getMapping().getElement().getName() == pk.name) || (x.getName() == pk.name));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [pk.id]);
                    idField.clearMapping();
                }
            });
        }
    }
    function convertQuery(query) {
        if (!query) {
            console.warn(`Could not convert null Query.`);
            return;
        }
        if (!query.getMapping()) {
            console.warn(`Could not convert Query '${query.getName()}' without it mapping to an Entity.`);
            return;
        }
        let entity = query.getMapping().getElement();
        let action = createAssociation("Query Entity Action", query.id, entity.id);
        if (query.typeReference.getIsCollection()) {
            action.typeReference.setIsCollection(true);
        }
        let mapping = action.createMapping(query.id, entity.id);
        mapContract("Filter Mapping", query, [query.id], [entity.id], mapping);
    }
    convertToAdvancedMapping.convertQuery = convertQuery;
    function mapContract(mappingType, dto, sourcePath, targetPathIds, mapping) {
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; !fieldsToSkip(dto, x)).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
    function fieldsToSkip(dto, field) {
        return dto.specialization == "Command" &amp;&amp;
            field.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp;
            (!field.getMapping().getElement().getStereotype("Primary Key").hasProperty("Data source") || field.getMapping().getElement().getStereotype("Primary Key").getProperty("Data source").value != "User supplied");
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
/// &lt;reference path="../create-crud-macro/create-crud-macro.ts"/&gt;
/// &lt;reference path="../_common/convertToAdvancedMapping.ts"/&gt;
async function execute(element) {
    var _a, _b;
    let entity = await DomainHelper.openSelectEntityDialog();
    if (entity == null) {
        return;
    }
    const owningEntity = DomainHelper.getOwningAggregate(entity);
    const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? owningEntity.getName() : entity.getName());
    const folder = (_a = element.getChildren().find(x =&gt; x.getName() == pluralize(folderName))) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Folder", pluralize(folderName), element.id);
    const primaryKeys = DomainHelper.getPrimaryKeys(entity);
    const hasPrimaryKey = primaryKeys.length &gt; 0;
    const resultDto = cqrsCrud.createCqrsResultTypeDto(entity, folder);
    if (owningEntity == null || !privateSettersOnly) {
        convertToAdvancedMapping.convertCommand(cqrsCrud.createCqrsCreateCommand(entity, folder, primaryKeys));
    }
    if (hasPrimaryKey) {
        convertToAdvancedMapping.convertQuery(cqrsCrud.createCqrsFindByIdQuery(entity, folder, resultDto));
    }
    convertToAdvancedMapping.convertQuery(cqrsCrud.createCqrsFindAllQuery(entity, folder, resultDto));
    if (hasPrimaryKey &amp;&amp; !privateSettersOnly) {
        convertToAdvancedMapping.convertCommand(cqrsCrud.createCqrsUpdateCommand(entity, folder));
    }
    const operations = entity.getChildren("Operation").filter(x =&gt; x.typeReference.getType() == null);
    for (const operation of operations) {
        convertToAdvancedMapping.convertCommand(cqrsCrud.createCqrsCallOperationCommand(entity, operation, folder));
    }
    if (hasPrimaryKey &amp;&amp; (owningEntity == null || !privateSettersOnly)) {
        convertToAdvancedMapping.convertCommand(cqrsCrud.createCqrsDeleteCommand(entity, folder));
    }
    const diagramElement = (_b = folder.getChildren("Diagram").find(x =&gt; x.getName() == folderName)) !== null &amp;&amp; _b !== void 0 ? _b : createElement("Diagram", folderName, folder.id);
    diagramElement.loadDiagram();
    const diagram = getCurrentDiagram();
    diagram.layoutVisuals(folder, null, true);
}
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/create-crud-macro-advanced-mapping/create-crud-macro-advanced-mapping.ts
 */
await execute(element);
</script>
        </option>
      </scriptOptions>
      <mappingOptions />
      <typeOrder />
      <mappingSettings />
    </elementExtension>
    <elementExtension type="Operation" typeId="e030c97a-e066-40a7-8188-808c275df3cb">
      <creationOptions>
        <option order="0" type="association">
          <text>Query Entity</text>
          <shortcut>ctrl + shift + q</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Query Entity Action Target End</specializationType>
          <specializationTypeId>93ef6675-cba4-4998-adff-cb22d5343ed4</specializationTypeId>
          <defaultName>NewQueryEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option order="1" type="association">
          <text>Call Service Operation</text>
          <shortcut>ctrl + shift + o</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Call Service Operation Target End</specializationType>
          <specializationTypeId>093e5909-ffe4-4510-b3ea-532f30212f3c</specializationTypeId>
          <defaultName>NewCallServiceOperation</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option type="association">
          <text>Create Entity</text>
          <shortcut>ctrl + shift + c</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Create Entity Action Target End</specializationType>
          <specializationTypeId>328f54e5-7bad-4b5f-90ca-03ce3105d016</specializationTypeId>
          <defaultName>NewCreateEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option type="association">
          <text>Update Entity</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Update Entity Action Target End</specializationType>
          <specializationTypeId>516069f6-09cc-4de8-8e31-3c71ca823452</specializationTypeId>
          <defaultName>NewUpdateEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option type="association">
          <text>Delete Entity</text>
          <shortcut>ctrl + shift + d</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Delete Entity Action Target End</specializationType>
          <specializationTypeId>4a04cfc2-5841-438c-9c16-fb58b784b365</specializationTypeId>
          <defaultName>NewDeleteEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option type="element">
          <text>Add Processing Action</text>
          <shortcut>ctrl + shift + p</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAAehJREFUeF7t3L1NA0EQhuE55DrYJijAEiVQAh0QEVl3XRGQQwWk/qGQRYewRGCB5G93dr6ZcT723nOv5GS0k+QHEpig6RyWBAQjSMAEBAXA8WYFll15lI18HHfHN/BMVOMwYFnKg1R5FpG79cknmZbDfJipFIDDXg24nbebvexfROT+wu+/y408RajxasAVrcyl/vXyItTYFfAH13WNGoDfjl5rVAP0WqM2oLsahwB6qnEkoIsahwOy12gFkLZGU4CMNVoEpKrRLCBLjdYBzddIAWi5RiZAkzXSAVqrkRXQTI3UgBZq9AA4tEY3gKNq9AaoXqNLQM0aPQOq1OgesHeNUQC71RgKsEeNEQGb1hgWcFWstX6eltMtsFuEbaj+txuDHExjNgFB5QRMQFAAHM8CAcBW22IR/4Wb7iuGAmxV3e/wowA2rS4UYI/qogB2q849YO/qPAOqVOcSULM6b4Dq1bkBHFWdB8Ch1VEDWqiOFdBMdXSA1qpjAjRZHQWg5eqsA5qvziwgS3UWAamqMwXIWJ0VQNrqhgOyVzcS0EV1QwA9VacN6K46NUCv1bUEfM27s4D9knU0b28DAc/jeX9gI8hoXwPtxkTDuvS8CQhWkIAJCAqA41lgAoIC4HgWmICgADieBYKAX0uidGAd9hNhAAAAAElFTkSuQmCC" />
          <specializationType>Processing Action</specializationType>
          <specializationTypeId>405a2857-b911-431f-8142-719a0e9f15f3</specializationTypeId>
          <defaultName>NewProcessingAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
      </creationOptions>
      <scriptOptions>
        <option>
          <text>Convert to advanced mapping system</text>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>let dtoParam = element.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
let dto = dtoParam?.typeReference.getType() ?? element.typeReference?.getType();
return dto?.isMapped() || (element.getName().startsWith("Delete") &amp;&amp; element.getChildren("Parameter").length == 1);</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        var _a, _b, _c, _d, _e, _f;
        if (element.specialization == "Service") {
            let entity = (_c = (_b = (_a = element.getChildren("Operation").find(x =&gt; x.getName().startsWith("Find"))) === null || _a === void 0 ? void 0 : _a.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.getMapping()) === null || _c === void 0 ? void 0 : _c.getElement();
            element.getChildren("Operation").forEach(operation =&gt; {
                convertOperation(operation, entity);
            });
        }
        else if (element.specialization == "Operation") {
            let dtoParam = element.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
            let dto = (_d = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType()) !== null &amp;&amp; _d !== void 0 ? _d : (_e = element.typeReference) === null || _e === void 0 ? void 0 : _e.getType();
            let entity = (_f = dto === null || dto === void 0 ? void 0 : dto.getMapping().getElement()) !== null &amp;&amp; _f !== void 0 ? _f : lookupTypesOf("Class").find(x =&gt; x.getName() == element.getName().replace("Delete", ""));
            if (entity) {
                convertOperation(element, entity);
            }
            else {
                console.warn("Cannot execute conversion script on Operation " + element.getName());
            }
        }
        else {
            console.error("Cannot qualify this script. Please contact Intent Architect support.");
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertOperation(operation, entity) {
        var _a, _b;
        let target = entity;
        let dtoParam = operation.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
        let dto = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType();
        // CREATE OPERATION:
        if (operation.getName().startsWith("Create") &amp;&amp; ((_a = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType().getMapping()) === null || _a === void 0 ? void 0 : _a.getElement().id) == entity.id) {
            let action = createAssociation("Create Entity Action", operation.id, target.id);
            let mapping = action.createMapping(operation.id, entity.id);
            mapping.addMappedEnd("Invocation Mapping", [operation.id], [target.id]);
            mapContract("Data Mapping", dto, [operation.id, dtoParam.id], [target.id], mapping);
            // DELETE OPERATION:
        }
        else if (operation.getName().startsWith("Delete") &amp;&amp; operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Delete Entity Action", operation.id, entity.id);
            let mapping = action.createMapping(operation.id, entity.id);
            addFilterMapping(mapping, operation, entity);
            // UPDATE OPERATION:
        }
        else if (operation.getName().startsWith("Update") &amp;&amp; ((_b = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType().getMapping()) === null || _b === void 0 ? void 0 : _b.getElement().id) == entity.id) {
            let action = createAssociation("Update Entity Action", operation.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(operation.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            mapContract("Data Mapping", dto, [operation.id, dtoParam.id], [target.id], updateMapping);
            // FIND BY ID OPERATION:
        }
        else if (operation.getName().startsWith("Find" + entity.getName()) &amp;&amp; operation.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // FIND ALL OPERATION:
        }
        else if (operation.getName().startsWith("Find" + pluralize(entity.getName()))) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            action.typeReference.setIsCollection(true);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
        }
        else {
            console.warn(`Could not convert operation: ${operation.getName()} (For entity ${entity.getName()}. Has parameters: (${operation.getChildren("Parameter").map(x =&gt; x.getName())}))`);
        }
    }
    convertToAdvancedMapping.convertOperation = convertOperation;
    function addFilterMapping(mapping, operation, entity) {
        var _a;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id");
            let pk = pkFields[0];
            if (idField &amp;&amp; pk) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a;
                let idField = operation.getChildren("Parameter").find(x =&gt; (x.getName().toLowerCase() == pk.name.toLowerCase()));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
                }
            });
        }
    }
    function mapContract(mappingType, dto, sourcePath, targetPathIds, mapping, isNested = false) {
        console.log("mapContract: " + dto.getName());
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; (isNested || !x.getMapping().getElement().hasStereotype("Primary Key"))).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping, true);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
/// &lt;reference path="../_common/convertToAdvancedMapping.ts" /&gt;
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/convert-to-advanced-mapping/convert-to-advanced-mapping.ts
 */
convertToAdvancedMapping.execute();
</script>
        </option>
      </scriptOptions>
      <mappingOptions />
      <typeOrder>
        <type order="0">Query Entity Action Target End</type>
        <type order="1">Call Service Operation Target End</type>
        <type>Create Entity Action Target End</type>
        <type>Update Entity Action Target End</type>
        <type>Delete Entity Action Target End</type>
        <type>Processing Action</type>
      </typeOrder>
      <mappingSettings />
    </elementExtension>
    <elementExtension type="Query" typeId="e71b0662-e29d-4db2-868b-8a12464b25d0">
      <creationOptions>
        <option type="association">
          <text>Query Entity</text>
          <shortcut>ctrl + shift + q</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Query Entity Action Target End</specializationType>
          <specializationTypeId>93ef6675-cba4-4998-adff-cb22d5343ed4</specializationTypeId>
          <defaultName>NewQueryEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option type="association">
          <text>Call Service Operation</text>
          <shortcut>ctrl + shift + p</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Call Service Operation Target End</specializationType>
          <specializationTypeId>093e5909-ffe4-4510-b3ea-532f30212f3c</specializationTypeId>
          <defaultName>NewCallServiceOperation</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
      </creationOptions>
      <scriptOptions>
        <option>
          <text>Convert to advanced mapping system</text>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return isMapped();</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        if (element.isMapped() &amp;&amp; element.specialization == "Command") {
            convertCommand(element);
        }
        else if (element.isMapped() &amp;&amp; element.specialization == "Query") {
            convertQuery(element);
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertCommand(command) {
        var _a;
        if (!command) {
            console.warn(`Could not convert null Command.`);
            return;
        }
        if (!command.getMapping()) {
            console.warn(`Could not convert Command '${command.getName()}' without it mapping to an Entity.`);
            return;
        }
        let target = command.getMapping().getElement();
        let entity = (_a = target.getParent("Class")) !== null &amp;&amp; _a !== void 0 ? _a : target;
        if (command.getName().startsWith("Create")) {
            let action = createAssociation("Create Entity Action", command.id, target.id);
            let mapping = action.createMapping(command.id, entity.id);
            mapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            mapContract("Data Mapping", command, [command.id], [target.id], mapping);
        }
        else if (command.getName().startsWith("Delete")) {
            let action = createAssociation("Delete Entity Action", command.id, entity.id);
            let mapping = action.createMapping(command.id, entity.id);
            // Query Entity Mapping
            addFilterMapping(mapping, command, entity);
            command.clearMapping();
        }
        else if (command.isMapped()) {
            let action = createAssociation("Update Entity Action", command.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(command.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, command, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(command.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            if (target.id != entity.id) {
                updateMapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            }
            mapContract("Data Mapping", command, [command.id], [target.id], updateMapping);
        }
    }
    convertToAdvancedMapping.convertCommand = convertCommand;
    function addFilterMapping(mapping, command, entity) {
        var _a, _b;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key")) || (x.getName() == "Id" || x.getName() == `${entity.getName()}Id`));
            let entityPk = entity.getChildren("Attribute").find(x =&gt; x.hasStereotype("Primary Key"));
            if (idField &amp;&amp; (idField.isMapped() || entityPk)) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [entityPk.id]);
                idField.clearMapping();
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a, _b;
                let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp; x.getMapping().getElement().getName() == pk.name) || (x.getName() == pk.name));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [pk.id]);
                    idField.clearMapping();
                }
            });
        }
    }
    function convertQuery(query) {
        if (!query) {
            console.warn(`Could not convert null Query.`);
            return;
        }
        if (!query.getMapping()) {
            console.warn(`Could not convert Query '${query.getName()}' without it mapping to an Entity.`);
            return;
        }
        let entity = query.getMapping().getElement();
        let action = createAssociation("Query Entity Action", query.id, entity.id);
        if (query.typeReference.getIsCollection()) {
            action.typeReference.setIsCollection(true);
        }
        let mapping = action.createMapping(query.id, entity.id);
        mapContract("Filter Mapping", query, [query.id], [entity.id], mapping);
    }
    convertToAdvancedMapping.convertQuery = convertQuery;
    function mapContract(mappingType, dto, sourcePath, targetPathIds, mapping) {
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; !fieldsToSkip(dto, x)).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
    function fieldsToSkip(dto, field) {
        return dto.specialization == "Command" &amp;&amp;
            field.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp;
            (!field.getMapping().getElement().getStereotype("Primary Key").hasProperty("Data source") || field.getMapping().getElement().getStereotype("Primary Key").getProperty("Data source").value != "User supplied");
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
/// &lt;reference path="../_common/convertToAdvancedMapping.ts" /&gt;
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/convert-to-advanced-mapping/convert-to-advanced-mapping.ts
 */
convertToAdvancedMapping.execute();
</script>
        </option>
      </scriptOptions>
      <mappingOptions>
        <option mappingType="Map Return Type" mappingTypeId="b7ae8bf5-f2fd-4a5c-b57e-05410687bfc4">
          <text>Map Return Type</text>
          <shortcut>ctrl + shift + m</shortcut>
          <isOptionVisibleFunction>return false &amp;&amp; typeReference?.isTypeFound();</isOptionVisibleFunction>
        </option>
      </mappingOptions>
      <typeOrder>
        <type>Query Entity Action Target End</type>
        <type>Call Service Operation Target End</type>
      </typeOrder>
      <mappingSettings />
    </elementExtension>
    <elementExtension type="Service" typeId="b16578a5-27b1-4047-a8df-f0b783d706bd">
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Convert to advanced mapping system</text>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return element.getChildren("Operation").every(x =&gt; x.getAssociations().length == 0);</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        var _a, _b, _c, _d, _e, _f;
        if (element.specialization == "Service") {
            let entity = (_c = (_b = (_a = element.getChildren("Operation").find(x =&gt; x.getName().startsWith("Find"))) === null || _a === void 0 ? void 0 : _a.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.getMapping()) === null || _c === void 0 ? void 0 : _c.getElement();
            element.getChildren("Operation").forEach(operation =&gt; {
                convertOperation(operation, entity);
            });
        }
        else if (element.specialization == "Operation") {
            let dtoParam = element.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
            let dto = (_d = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType()) !== null &amp;&amp; _d !== void 0 ? _d : (_e = element.typeReference) === null || _e === void 0 ? void 0 : _e.getType();
            let entity = (_f = dto === null || dto === void 0 ? void 0 : dto.getMapping().getElement()) !== null &amp;&amp; _f !== void 0 ? _f : lookupTypesOf("Class").find(x =&gt; x.getName() == element.getName().replace("Delete", ""));
            if (entity) {
                convertOperation(element, entity);
            }
            else {
                console.warn("Cannot execute conversion script on Operation " + element.getName());
            }
        }
        else {
            console.error("Cannot qualify this script. Please contact Intent Architect support.");
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertOperation(operation, entity) {
        var _a, _b;
        let target = entity;
        let dtoParam = operation.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
        let dto = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType();
        // CREATE OPERATION:
        if (operation.getName().startsWith("Create") &amp;&amp; ((_a = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType().getMapping()) === null || _a === void 0 ? void 0 : _a.getElement().id) == entity.id) {
            let action = createAssociation("Create Entity Action", operation.id, target.id);
            let mapping = action.createMapping(operation.id, entity.id);
            mapping.addMappedEnd("Invocation Mapping", [operation.id], [target.id]);
            mapContract("Data Mapping", dto, [operation.id, dtoParam.id], [target.id], mapping);
            // DELETE OPERATION:
        }
        else if (operation.getName().startsWith("Delete") &amp;&amp; operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Delete Entity Action", operation.id, entity.id);
            let mapping = action.createMapping(operation.id, entity.id);
            addFilterMapping(mapping, operation, entity);
            // UPDATE OPERATION:
        }
        else if (operation.getName().startsWith("Update") &amp;&amp; ((_b = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType().getMapping()) === null || _b === void 0 ? void 0 : _b.getElement().id) == entity.id) {
            let action = createAssociation("Update Entity Action", operation.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(operation.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            mapContract("Data Mapping", dto, [operation.id, dtoParam.id], [target.id], updateMapping);
            // FIND BY ID OPERATION:
        }
        else if (operation.getName().startsWith("Find" + entity.getName()) &amp;&amp; operation.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // FIND ALL OPERATION:
        }
        else if (operation.getName().startsWith("Find" + pluralize(entity.getName()))) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            action.typeReference.setIsCollection(true);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
        }
        else {
            console.warn(`Could not convert operation: ${operation.getName()} (For entity ${entity.getName()}. Has parameters: (${operation.getChildren("Parameter").map(x =&gt; x.getName())}))`);
        }
    }
    convertToAdvancedMapping.convertOperation = convertOperation;
    function addFilterMapping(mapping, operation, entity) {
        var _a;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id");
            let pk = pkFields[0];
            if (idField &amp;&amp; pk) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a;
                let idField = operation.getChildren("Parameter").find(x =&gt; (x.getName().toLowerCase() == pk.name.toLowerCase()));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
                }
            });
        }
    }
    function mapContract(mappingType, dto, sourcePath, targetPathIds, mapping, isNested = false) {
        console.log("mapContract: " + dto.getName());
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; (isNested || !x.getMapping().getElement().hasStereotype("Primary Key"))).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping, true);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
/// &lt;reference path="../_common/convertToAdvancedMapping.ts" /&gt;
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/convert-to-advanced-mapping/convert-to-advanced-mapping.ts
 */
convertToAdvancedMapping.execute();
</script>
        </option>
      </scriptOptions>
      <mappingOptions />
      <typeOrder />
      <mappingSettings />
    </elementExtension>
  </elementExtensions>
  <associationSettings>
    <associationSetting type="Call Service Operation" typeId="3e69085c-fa2f-44bd-93eb-41075fd472f8">
      <sourceEnd type="Call Service Operation Source End" typeId="ee56bd48-8eff-4fff-8d3a-87731d002335">
        <displayFunction>return `called by : ${typeReference.getType().getParent().getName()}.${typeReference.display}`</displayFunction>
        <nameAccessibilityMode>hidden</nameAccessibilityMode>
        <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAACSlJREFUeF7tm39sHEcVx79vdvfuYjulQiEtoChQUn6kSE1S7NACVSuEaEWpoDiXIhRoY9IktlUFpCZBEJo6QnajUIXKsaNYcRuglbM1tJVSRKWigCqIYpc2FSqpCrRWAgpNgZDgX3e7Ow/NOeee7bv9cbv22Xc3/96b2Xmfe/PdNzNvafnu5U8T6KGh3UOnUG2BCdDy3ctZ9WLwfoyj7UzHmQuBR6ngDpMAMwwIF4ipbWj30P4KZhLI9akA3+166vKyfibQaBVoXAhgFsUzVX10jwovgJneVX0sDNEXwKo+RgGwqo95KfqPwJndq/qoEpdsHljsC7TS9TE0wErXx2gAVrA+Rg2w4vLH2QJYMfnjrAKsBH2cfYBlro9zCbAs9bEUAMtKH0sGsFz0sbQAy0AfqwCL3cNe7ldagGVwhVAygFEdQmxeffRmGHStCghhO290v/z1F0MGVaDupQAYyTHYd+qfuGacjF6APweQmPCaJUC/04CmzoHkW4FIFGk8lwAjuaja+LFnF8evSD8C4g0A4vn8ZmBcEP2s62TjZoAy17az1WYfYIQ617LWvE8y2gG81yeQ/xCwvWsgedinfWCzWQUYlc61rP7ljRyze5n54+ryOlhjEOg0WXrTgVfuOhGsr7f1bAGMROfuu+HJJZpmPMHEnyeG5u1OYQsmOMT8grhkfOPA63f9O8xYuX2jBhiJzqkJNq99ah+zbAZokauzxBdY0l4icY5ZthPh/W72DIwScKB7ILk9CojRAIxQ57Z8qv9rJORBAEtcQTDSIByySfQ40G1lK6WgBMbuFqDvglDjDp7Os0PNB19q/EUYkKEBRqVzm9eaKzWJPib6JMAFhY4AyUTH0oJ/JGVsOK/zJBIJZ3w7CI2Ay9JnKIH8k6OJ9YdONL5eDMgwACPRuW2rnr4ybViHQbiTAd19+dErNvEOB7F/+HHWAF2lceoRgFd5vHxUBJvxtNGy/9RX/+tn7KxNMQAj07mtDU/tIMhdDKr1WK7nwNqOlKb9MYhzWduEtNcw5F4vfSTwCEPs6R5Y97Df5/gHGKHObfq0each0cnAMveJ8iVy9J+M6VqfX4fc7BLS+iaIWwG4/mEAztiglp6Bdce8nusLYFQ613SjuSIm8XMwGjLViIVbGqA+R6vZZ0nL8XIiyO+OsOO1Un6fga+4pUYZrQUG0ho2HD6R/GuhZ3gBjETn1MO3NvR3AbIJQMzD4Rdh6bvGY+KdIGCC2sYtLCPdagd4tUfakyamnu7BdSpyZ7Q5KbDcVG+u0gm/BfAel8metiXvsrX46aAwwtgbbN0kmNs89PGizbilZzA5o458KsAIdS7Xqa0NR3sISDLoiunOEqCE+4fjpP86DIiwfRNsNwG8BeB8+eP/AD7aPbB+04z5z0WR+dZ68zgR1jAwA6CaEAG/SrH2sBTav8KCKLZ/DPYXBPMDAH8w75/MGOweTN6aD+Csf+agAIJwA4DFBR1kjLKgbilqjkT94nCDKtj5cAzOgwDqC74ogDFmnMwLsNh/LEi/TAQCtUz4qIcOqmHfkkR70jBOBnlGYFvbXpzQ5P0A1rvtVggYBuMNBi6VFOCkg4SlYHwElP8wNGvHwPO2oA6HjfOB4bh0EI4UOtnrBEHBu9LF1CLGmww6p6rEVZsfACdmrDHRS4BsIZBbWjPmgA7a0I4wCSssSF1aq3XBu8FY4TKWw0S9xPwJMDKHFNk2nwBihPTGuG4v02x0EPBFDzhnJdGDxS7riT1xejvAt7k9h4hOpi2xLa3TX2rZ7p9uO+8AZidYA76Z4OwDcI2bg0z8gs1Gu0Pin36iUe06ahgbSTrfBihR+CVBf1d/0CiLZ7M2CwqgmnSMNN1AajMYDwCoKwyIx5nEoTRrvW7LOpOWSKmOtD5QcCxGShIetYz4fttyUrl2Cw5gdvK6oS2Jp1MPgZD02C+fZRZ7UkL/fa7jftKSy/bP2Tp+kLL1s/kAL1iA7y5r+3oCHgVwncdyPW4R2h1bXPKTlgB4U7LYNkbiD27jLniAWecS0tmgCd7l4yrzomuOyRhhQvsodHVd4NnKBqDy1NC5zrDl9wisTnNcT63zkGECPTkMpw2I+b6NKyuAWSgxm681dOfHAG7yDKHMR5J4lVm7f4zoNT/2ZfES8eNojbC/TA7aQPlPtInxjmS0XeRFfYZmFVXaUZYRmAtXN7R43EodAvPtoGxxUeaW7TcknY3DFB/182cUsil7gMrxGraTgrCBgczlOwHjkvHTUdLNMPBU34oBqA5qc2ExYFYB+gwfFYFVgD5h5TOrAgwBL6uB1QgMAbEagSHgVSOQdFU5FapVIzAUvok8sKqBISBWNEAw7R0R2kAIfrMWgbXSaQDxjBLgeXUnMgGOX3Ok1jmuFVdIFHUEJhz5Pk04rQDlPcQtGcAt9eZOt5s3Bh8TiJvDJAMdAEQFsI5FjUQqSaA7Cq0IdU99cDDZMf33oB9dFLXimleadVyHPnDhwkYmHhUQR4ehPef3IVEArIPzJQm5npgKF6UTRmgYd3f9OTmjJntOACogzfXm1VJgJ0lc7waIiM47LA74OQQNA3AR83UayRZmXuo2HxZ4VUh0dA0m816lzhnA7CSb15qfZQlVrHiV68SJB6SjPeamj8UAVDonNOdeYlJVsm7tbRvoyFcTmNtpzgFOgqw372H1GYLLss68ZgBTIHYsnz4GATihc+k7pueNMwiq5cro7xpMPu5HSkoGMLOsV5p1shatXqUdSh8h0TsqDFXlOtn8AqyR1i0Q2OiqcxN/1vNiBJ35tK4QzJICnIzGNeYKaaDVSx9ZYIil9lhWH70AKp0j4dxLEh/y1DkLnV0vFy4mn9cAc5b1bQzc46WPEDju2MIUQt6abysnpTiu6TIJiRkVpdNAvE3A412DyaLLi+dFBOY6pZY1atHopY+ZZU10fnp0qSgF81LPtITRjxH0B1mu+aJw3gHMicarJaGVGJ/xI+Z+bTI6NxF1viq8vMadtwCzE7/8iURrpqo1TCP8zWZ0eqUlQR8x7wFO0UeCAun1mdZUBhNpSWcYnXODumAAZtOejD4C3/ITKQQciULnygbgFH102RZ6bb/8wPdrs6AicLpTGX0EduakPb62X37h+LH7P9FwJ5zw96I5AAAAAElFTkSuQmCC" />
        <allowSorting>false</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type>Operation</type>
            <type>Command</type>
            <type>Query</type>
            <type>Domain Event Handler Association Target End</type>
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>false</allowIsNullable>
          <allowIsCollection>false</allowIsCollection>
          <isNavigableDefault>false</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
      </sourceEnd>
      <targetEnd type="Call Service Operation Target End" typeId="093e5909-ffe4-4510-b3ea-532f30212f3c">
        <displayFunction>const returnType = typeReference.getType()?.typeReference?.display ?? "void";
return `[call] ${getName()}: ${`${typeReference.getType()?.getName()}(...): ${returnType}` ?? "&lt;not set&gt;"}`</displayFunction>
        <nameAccessibilityMode>optional</nameAccessibilityMode>
        <defaultNameFunction>return typeReference.getType()?.typeReference.getTypeId() != null ? "result" : null;</defaultNameFunction>
        <icon type="UrlImagePath" source="data:image/png;base64,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" />
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type>Operation</type>
            <type>Operation</type>
            <type>Stored Procedure</type>
          </targetTypes>
          <allowIsNavigable>true</allowIsNavigable>
          <allowIsNullable>true</allowIsNullable>
          <allowIsCollection>true</allowIsCollection>
          <isNavigableDefault>true</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
        <typeOrder />
        <creationOptions />
        <scriptOptions />
        <mappingOptions>
          <option mappingType="Service Operation Mapping" mappingTypeId="df692ffe-5d0c-40ee-9362-a483d929a8ec">
            <text>Map Call Operation</text>
            <shortcut>ctrl + shift + m</shortcut>
          </option>
        </mappingOptions>
      </targetEnd>
      <visualSettings>
        <lineType>Curved</lineType>
        <lineDashArray>return "3,7";</lineDashArray>
        <sourceEnd>
          <pointIndicator>
            <lineWidth>return 3;</lineWidth>
            <path>return `a 4,4 0 1,0 4,4 
        a 4,4 0 1,0 -4,4`;</path>
          </pointIndicator>
        </sourceEnd>
        <targetEnd>
          <pointIndicator>
            <path>return `l 4 8 l -8 0 l 4 -8 Z`</path>
          </pointIndicator>
        </targetEnd>
      </visualSettings>
      <macros>
        <macro trigger="on-type-changed">
          <script>if (association.isTargetEnd() &amp;&amp; association.typeReference.getType()?.typeReference != null) {
    association.typeReference.setIsCollection(association.typeReference.getType().typeReference.getIsCollection());
    association.typeReference.setIsNullable(association.typeReference.getType().typeReference.getIsNullable());
}</script>
        </macro>
      </macros>
    </associationSetting>
    <associationSetting type="Create Entity Action" typeId="7a3f0474-3cf8-4249-baac-8c07c49465e0">
      <sourceEnd type="Create Entity Action Source End" typeId="a3e7c59e-b0a1-47e1-ba29-66f2c7047b0a">
        <displayFunction>return `created by : ${typeReference.getType().getParent().getName()}.${typeReference.display}`</displayFunction>
        <nameAccessibilityMode>optional</nameAccessibilityMode>
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type>Command</type>
            <type>Operation</type>
            <type>Domain Event Handler Association Target End</type>
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>false</allowIsNullable>
          <allowIsCollection>false</allowIsCollection>
          <isNavigableDefault>true</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
      </sourceEnd>
      <targetEnd type="Create Entity Action Target End" typeId="328f54e5-7bad-4b5f-90ca-03ce3105d016">
        <displayFunction>return `[create] ${getName()}: ${typeReference.display}`</displayFunction>
        <nameAccessibilityMode>required</nameAccessibilityMode>
        <defaultNameFunction>let name = (typeReference.getType()?.getParent("Class") ?? typeReference.getType())?.getName() ?? "entity"
return typeReference.getIsCollection() 
    ? pluralize(toCamelCase(name))
    : toCamelCase(name);</defaultNameFunction>
        <icon type="UrlImagePath" source="data:image/png;base64,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" />
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type>Class</type>
            <type>Class Constructor</type>
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>false</allowIsNullable>
          <allowIsCollection>false</allowIsCollection>
          <isNavigableDefault>true</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
        <typeOrder>
          <type order="0">Processing Action</type>
        </typeOrder>
        <creationOptions>
          <option type="element">
            <text>Add Processing Action</text>
            <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAAehJREFUeF7t3L1NA0EQhuE55DrYJijAEiVQAh0QEVl3XRGQQwWk/qGQRYewRGCB5G93dr6ZcT723nOv5GS0k+QHEpig6RyWBAQjSMAEBAXA8WYFll15lI18HHfHN/BMVOMwYFnKg1R5FpG79cknmZbDfJipFIDDXg24nbebvexfROT+wu+/y408RajxasAVrcyl/vXyItTYFfAH13WNGoDfjl5rVAP0WqM2oLsahwB6qnEkoIsahwOy12gFkLZGU4CMNVoEpKrRLCBLjdYBzddIAWi5RiZAkzXSAVqrkRXQTI3UgBZq9AA4tEY3gKNq9AaoXqNLQM0aPQOq1OgesHeNUQC71RgKsEeNEQGb1hgWcFWstX6eltMtsFuEbaj+txuDHExjNgFB5QRMQFAAHM8CAcBW22IR/4Wb7iuGAmxV3e/wowA2rS4UYI/qogB2q849YO/qPAOqVOcSULM6b4Dq1bkBHFWdB8Ch1VEDWqiOFdBMdXSA1qpjAjRZHQWg5eqsA5qvziwgS3UWAamqMwXIWJ0VQNrqhgOyVzcS0EV1QwA9VacN6K46NUCv1bUEfM27s4D9knU0b28DAc/jeX9gI8hoXwPtxkTDuvS8CQhWkIAJCAqA41lgAoIC4HgWmICgADieBYKAX0uidGAd9hNhAAAAAElFTkSuQmCC" />
            <isOptionVisibleFunction>return false;</isOptionVisibleFunction>
            <specializationType>Processing Action</specializationType>
            <specializationTypeId>405a2857-b911-431f-8142-719a0e9f15f3</specializationTypeId>
            <defaultName>Action</defaultName>
            <allowMultiple>true</allowMultiple>
          </option>
        </creationOptions>
        <scriptOptions />
        <mappingOptions>
          <option mappingType="Create Entity Mapping" mappingTypeId="5f172141-fdba-426b-980e-163e782ff53e">
            <text>Map Entity Creation</text>
            <shortcut>ctrl + shift + m</shortcut>
          </option>
        </mappingOptions>
      </targetEnd>
      <visualSettings>
        <lineType>Curved</lineType>
        <lineDashArray>return "3,7";</lineDashArray>
        <sourceEnd>
          <pointIndicator>
            <fillColor>return 'limegreen'</fillColor>
            <lineWidth>return 3;</lineWidth>
            <path>return `a 4,4 0 1,0 4,4 
        a 4,4 0 1,0 -4,4`;</path>
          </pointIndicator>
        </sourceEnd>
        <targetEnd>
          <pointIndicator>
            <path>return `l 4 8 l -8 0 l 4 -8 Z`</path>
          </pointIndicator>
        </targetEnd>
      </visualSettings>
    </associationSetting>
    <associationSetting type="Delete Entity Action" typeId="bfc823fb-60ab-451d-ba62-12671fe7e28e">
      <sourceEnd type="Delete Entity Action Source End" typeId="8c2d9fed-bd14-44b2-9f98-8a801aaf157e">
        <displayFunction>return `deleted by : ${typeReference.getType().getParent().getName()}.${typeReference.display}`</displayFunction>
        <nameAccessibilityMode>optional</nameAccessibilityMode>
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type>Command</type>
            <type>Operation</type>
            <type>Domain Event Handler Association Target End</type>
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>false</allowIsNullable>
          <allowIsCollection>false</allowIsCollection>
          <isNavigableDefault>true</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
      </sourceEnd>
      <targetEnd type="Delete Entity Action Target End" typeId="4a04cfc2-5841-438c-9c16-fb58b784b365">
        <displayFunction>return `[delete] ${getName()}: ${typeReference.display}`</displayFunction>
        <nameAccessibilityMode>required</nameAccessibilityMode>
        <defaultNameFunction>let name = (typeReference.getType()?.getParent("Class") ?? typeReference.getType())?.getName() ?? "entity"
return typeReference.getIsCollection() 
    ? pluralize(toCamelCase(name))
    : toCamelCase(name);</defaultNameFunction>
        <icon type="UrlImagePath" source="data:image/png;base64,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" />
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type>Class</type>
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>false</allowIsNullable>
          <allowIsCollection>true</allowIsCollection>
          <isNavigableDefault>true</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
        <typeOrder />
        <creationOptions />
        <scriptOptions />
        <mappingOptions>
          <option mappingType="Query Entity Mapping" mappingTypeId="25f25af9-c38b-4053-9474-b0fabe9d7ea7">
            <text>Map Entity Filter</text>
            <shortcut>ctrl + shift + m</shortcut>
          </option>
        </mappingOptions>
      </targetEnd>
      <visualSettings>
        <lineType>Curved</lineType>
        <lineDashArray>return "3,7";</lineDashArray>
        <sourceEnd>
          <pointIndicator>
            <fillColor>return 'indianred'</fillColor>
            <lineWidth>return 3;</lineWidth>
            <path>return `a 4,4 0 1,0 4,4 
        a 4,4 0 1,0 -4,4`;</path>
          </pointIndicator>
        </sourceEnd>
        <targetEnd>
          <pointIndicator>
            <path>return `l 4 8 l -8 0 l 4 -8 Z`</path>
          </pointIndicator>
        </targetEnd>
      </visualSettings>
      <macros>
        <macro trigger="on-created">
          <script>let mapping = association.createMapping(association.getOtherEnd().typeReference.getTypeId(), association.typeReference.getTypeId(), "25f25af9-c38b-4053-9474-b0fabe9d7ea7") // Query Entity Mapping
association.typeReference.getType().getChildren("Attribute")
    .filter(x =&gt; x.hasStereotype("Primary Key"))
    .forEach(attr =&gt; {
        let handler = association.getOtherEnd().typeReference.getType();
        let childSpecialization = handler.specialization == "Command" ? "DTO-Field"
            : handler.specialization == "Operation" ? "Parameter"
            : null
        if (childSpecialization == null) {
            return;
        }
        let pkField = handler.getChildren(childSpecialization).find(x =&gt; x.getName().toLowerCase() == attr.getName().toLowerCase()
            &amp;&amp; x.typeReference.getTypeId() == attr.typeReference.getTypeId())
        if (!pkField) {
            let newField = createElement(childSpecialization, attr.getName(), handler.id);
            newField.typeReference.setType(attr.typeReference.getTypeId());
            newField.typeReference.setIsNullable(attr.typeReference.getIsNullable())
            newField.typeReference.setIsCollection(attr.typeReference.getIsCollection())
            pkField = newField;
        }
        mapping.addMappedEnd("Filter Mapping", [pkField.id], [attr.id]);
    })</script>
        </macro>
      </macros>
    </associationSetting>
    <associationSetting type="Query Entity Action" typeId="47ab5888-a258-4bec-a9fc-a83de69eb79d">
      <sourceEnd type="Query Entity Action Source End" typeId="32a65f26-2555-4616-8a2c-6a90805600bb">
        <nameAccessibilityMode>optional</nameAccessibilityMode>
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type>Query</type>
            <type>Operation</type>
            <type>Command</type>
            <type>Domain Event Handler Association Target End</type>
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>false</allowIsNullable>
          <allowIsCollection>false</allowIsCollection>
          <isNavigableDefault>false</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
      </sourceEnd>
      <targetEnd type="Query Entity Action Target End" typeId="93ef6675-cba4-4998-adff-cb22d5343ed4">
        <displayFunction>return `[query] ${getName()}: ${typeReference.display}`</displayFunction>
        <nameAccessibilityMode>required</nameAccessibilityMode>
        <defaultNameFunction>let name = (typeReference.getType()?.getParent("Class") ?? typeReference.getType())?.getName() ?? "entity"
return typeReference.getIsCollection() 
    ? pluralize(toCamelCase(name))
    : toCamelCase(name);</defaultNameFunction>
        <icon type="UrlImagePath" source="data:image/png;base64,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" />
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type>Class</type>
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>true</allowIsNullable>
          <allowIsCollection>true</allowIsCollection>
          <isNavigableDefault>true</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
        <typeOrder />
        <creationOptions />
        <scriptOptions />
        <mappingOptions>
          <option mappingType="Query Entity Mapping" mappingTypeId="25f25af9-c38b-4053-9474-b0fabe9d7ea7">
            <text>Map Entity Query</text>
            <shortcut>ctrl + shift + m</shortcut>
          </option>
        </mappingOptions>
      </targetEnd>
      <visualSettings>
        <lineType>Curved</lineType>
        <lineDashArray>return "3,7";</lineDashArray>
        <sourceEnd>
          <pointIndicator>
            <fillColor>return 'dodgerblue'</fillColor>
            <lineWidth>return 3;</lineWidth>
            <path>return `a 4,4 0 1,0 4,4 
        a 4,4 0 1,0 -4,4`;</path>
          </pointIndicator>
        </sourceEnd>
        <targetEnd>
          <pointIndicator>
            <path>return `l 4 8 l -8 0 l 4 -8 Z`</path>
          </pointIndicator>
        </targetEnd>
      </visualSettings>
      <macros />
    </associationSetting>
    <associationSetting type="Update Entity Action" typeId="9ea0382a-4617-412a-a8c8-af987bbce226">
      <sourceEnd type="Update Entity Action Source End" typeId="6bc95978-6def-4d0c-a4f5-25bdeda8a9f6">
        <displayFunction>return `updated by : ${typeReference.getType().getParent().getName()}.${typeReference.display}`</displayFunction>
        <nameAccessibilityMode>optional</nameAccessibilityMode>
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type>Command</type>
            <type>Operation</type>
            <type>Domain Event Handler Association Target End</type>
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>false</allowIsNullable>
          <allowIsCollection>false</allowIsCollection>
          <isNavigableDefault>true</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
      </sourceEnd>
      <targetEnd type="Update Entity Action Target End" typeId="516069f6-09cc-4de8-8e31-3c71ca823452">
        <displayFunction>return `[update] ${getName()}: ${typeReference.display}`</displayFunction>
        <nameAccessibilityMode>required</nameAccessibilityMode>
        <defaultNameFunction>let name = (typeReference.getType()?.getParent("Class") ?? typeReference.getType())?.getName() ?? "entity"
return typeReference.getIsCollection() 
    ? pluralize(toCamelCase(name))
    : toCamelCase(name);</defaultNameFunction>
        <icon type="UrlImagePath" source="data:image/png;base64,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" />
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type>Class</type>
            <type>Operation</type>
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>false</allowIsNullable>
          <allowIsCollection>true</allowIsCollection>
          <isNavigableDefault>true</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
        <typeOrder />
        <creationOptions />
        <scriptOptions />
        <mappingOptions>
          <option mappingType="Query Entity Mapping" mappingTypeId="25f25af9-c38b-4053-9474-b0fabe9d7ea7">
            <text>Map Entity Query</text>
            <shortcut>ctrl + shift + q</shortcut>
          </option>
          <option mappingType="Update Entity Mapping" mappingTypeId="01721b1a-a85d-4320-a5cd-8bd39247196a">
            <text>Map Entity Update</text>
            <shortcut>ctrl + shift + m</shortcut>
          </option>
        </mappingOptions>
      </targetEnd>
      <visualSettings>
        <lineType>Curved</lineType>
        <lineDashArray>return "3,7";</lineDashArray>
        <sourceEnd>
          <pointIndicator>
            <fillColor>return 'orange'</fillColor>
            <lineWidth>return 3;</lineWidth>
            <path>return `a 4,4 0 1,0 4,4 
        a 4,4 0 1,0 -4,4`;</path>
          </pointIndicator>
        </sourceEnd>
        <targetEnd>
          <pointIndicator>
            <path>return `l 4 8 l -8 0 l 4 -8 Z`</path>
          </pointIndicator>
        </targetEnd>
      </visualSettings>
      <macros>
        <macro trigger="on-created">
          <script>if (association.getParent().specialization !== "Command") {
    return;
}
let mapping = association.createMapping(association.getOtherEnd().typeReference.getTypeId(), association.typeReference.getTypeId(), "25f25af9-c38b-4053-9474-b0fabe9d7ea7") // Query Entity Mapping
association.typeReference.getType().getChildren("Attribute")
    .filter(x =&gt; x.hasStereotype("Primary Key"))
    .forEach(attr =&gt; {
        let sourceType = association.getOtherEnd().typeReference.getType();
        let pkField = sourceType.specialization == "Command" 
            ? getOrCreatePkField(sourceType, attr, "DTO-Field")
            : getOrCreatePkField(sourceType, attr, "Parameter")
        mapping.addMappedEnd("Filter Mapping", [pkField.id], [attr.id]);
    })

function getOrCreatePkField(sourceType, attr, fieldType) {
    let pkField = sourceType.getChildren(fieldType).find(x =&gt; x.getName().toLowerCase() == attr.getName().toLowerCase()
    &amp;&amp; x.typeReference.getTypeId() == attr.typeReference.getTypeId())
    if (!pkField) {
        let newField = createElement(fieldType, attr.getName(), sourceType.id);
        newField.typeReference.setType(attr.typeReference.getTypeId());
        newField.typeReference.setIsNullable(attr.typeReference.getIsNullable())
        newField.typeReference.setIsCollection(attr.typeReference.getIsCollection())
        pkField = newField;
    }
    return pkField;
}</script>
        </macro>
      </macros>
    </associationSetting>
  </associationSettings>
  <associationExtensions>
    <associationExtension type="Domain Event Handler Association" typeId="90831494-f069-44eb-b488-ab2dba7518ea">
      <sourceEndExtension>
        <typeOrder />
        <typeReferenceExtension>
          <isRequired>true</isRequired>
          <targetTypes />
          <allowIsNavigable>inherit</allowIsNavigable>
          <allowIsNullable>inherit</allowIsNullable>
          <allowIsCollection>inherit</allowIsCollection>
        </typeReferenceExtension>
      </sourceEndExtension>
      <targetEndExtension>
        <typeOrder>
          <type>Query Entity Action Target End</type>
          <type>Call Service Operation Target End</type>
          <type>Create Entity Action Target End</type>
          <type>Update Entity Action Target End</type>
          <type>Delete Entity Action Target End</type>
          <type>Processing Action</type>
        </typeOrder>
        <creationOptions>
          <option type="association">
            <text>Query Entity</text>
            <shortcut>ctrl + shift + q</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,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" />
            <specializationType>Query Entity Action Target End</specializationType>
            <specializationTypeId>93ef6675-cba4-4998-adff-cb22d5343ed4</specializationTypeId>
            <defaultName>NewQueryEntityAction</defaultName>
            <allowMultiple>true</allowMultiple>
          </option>
          <option type="association">
            <text>Call Service Operation</text>
            <shortcut>ctrl + shift + o</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,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" />
            <specializationType>Call Service Operation Target End</specializationType>
            <specializationTypeId>093e5909-ffe4-4510-b3ea-532f30212f3c</specializationTypeId>
            <defaultName>NewCallServiceOperation</defaultName>
            <allowMultiple>true</allowMultiple>
          </option>
          <option type="association">
            <text>Create Entity</text>
            <shortcut>ctrl + shift + c</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,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" />
            <specializationType>Create Entity Action Target End</specializationType>
            <specializationTypeId>328f54e5-7bad-4b5f-90ca-03ce3105d016</specializationTypeId>
            <defaultName>NewCreateEntityAction</defaultName>
            <allowMultiple>true</allowMultiple>
          </option>
          <option type="association">
            <text>Update Entity</text>
            <shortcut>ctrl + shift + u</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,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" />
            <specializationType>Update Entity Action Target End</specializationType>
            <specializationTypeId>516069f6-09cc-4de8-8e31-3c71ca823452</specializationTypeId>
            <defaultName>NewUpdateEntityAction</defaultName>
            <allowMultiple>true</allowMultiple>
          </option>
          <option type="association">
            <text>Delete Entity</text>
            <shortcut>ctrl + shift + d</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,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" />
            <specializationType>Delete Entity Action Target End</specializationType>
            <specializationTypeId>4a04cfc2-5841-438c-9c16-fb58b784b365</specializationTypeId>
            <defaultName>NewDeleteEntityAction</defaultName>
            <allowMultiple>true</allowMultiple>
          </option>
          <option type="element">
            <text>Add Processing Action</text>
            <shortcut>ctrl + shift + p</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAAehJREFUeF7t3L1NA0EQhuE55DrYJijAEiVQAh0QEVl3XRGQQwWk/qGQRYewRGCB5G93dr6ZcT723nOv5GS0k+QHEpig6RyWBAQjSMAEBAXA8WYFll15lI18HHfHN/BMVOMwYFnKg1R5FpG79cknmZbDfJipFIDDXg24nbebvexfROT+wu+/y408RajxasAVrcyl/vXyItTYFfAH13WNGoDfjl5rVAP0WqM2oLsahwB6qnEkoIsahwOy12gFkLZGU4CMNVoEpKrRLCBLjdYBzddIAWi5RiZAkzXSAVqrkRXQTI3UgBZq9AA4tEY3gKNq9AaoXqNLQM0aPQOq1OgesHeNUQC71RgKsEeNEQGb1hgWcFWstX6eltMtsFuEbaj+txuDHExjNgFB5QRMQFAAHM8CAcBW22IR/4Wb7iuGAmxV3e/wowA2rS4UYI/qogB2q849YO/qPAOqVOcSULM6b4Dq1bkBHFWdB8Ch1VEDWqiOFdBMdXSA1qpjAjRZHQWg5eqsA5qvziwgS3UWAamqMwXIWJ0VQNrqhgOyVzcS0EV1QwA9VacN6K46NUCv1bUEfM27s4D9knU0b28DAc/jeX9gI8hoXwPtxkTDuvS8CQhWkIAJCAqA41lgAoIC4HgWmICgADieBYKAX0uidGAd9hNhAAAAAElFTkSuQmCC" />
            <specializationType>Processing Action</specializationType>
            <specializationTypeId>405a2857-b911-431f-8142-719a0e9f15f3</specializationTypeId>
            <defaultName>Action</defaultName>
            <allowMultiple>true</allowMultiple>
          </option>
        </creationOptions>
        <scriptOptions />
        <mappingOptions />
        <typeReferenceExtension>
          <isRequired>true</isRequired>
          <targetTypes />
          <allowIsNavigable>inherit</allowIsNavigable>
          <allowIsNullable>inherit</allowIsNullable>
          <allowIsCollection>inherit</allowIsCollection>
        </typeReferenceExtension>
      </targetEndExtension>
      <macros />
    </associationExtension>
  </associationExtensions>
  <mappingSettings>
    <mappingSetting type="Create Entity Mapping" typeId="5f172141-fdba-426b-980e-163e782ff53e">
      <title>Create Entity Mapping</title>
      <isRequiredFunction>return true;</isRequiredFunction>
      <targetRootElementFunction>return element.getParent("Class")?.id ?? element.id;</targetRootElementFunction>
      <sourceMappings>
        <importSettings id="2b74b9ec-75bb-4eb2-8b3c-5b4fd755f019" name="Application Source Mappables" />
      </sourceMappings>
      <targetMappings>
        <importSettings id="d7aea784-eb96-472e-919d-a0e71315a0ed" name="Common Domain Mappables" />
        <mapping id="e04ab087-8c1a-42b9-aac7-d76ed674e319" name="Create Class" type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10">
          <isRequiredFunction>return element.id == mappingContext.targetElementId</isRequiredFunction>
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>function getAllChildrenInHierarchy(element, type) {
    let children = element.getChildren(type);
    element.getChildren("Generalization Target End").forEach(x =&gt; children.push(...getAllChildrenInHierarchy(x, type)))
    return children;
}

return element.id == mappingContext.targetElementId &amp;&amp; getAllChildrenInHierarchy(element, "Class Constructor").length == 0</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>invokable</represents>
          <childSettings>
            <childSetting id="53e8bc33-5930-4364-9526-7f8f181b14a1" name="Set Attribute" type="Attribute" typeId="0090fb93-483e-41af-a11d-5ad2dc796adf">
              <isRequiredFunction>let isPartOfAssociation = (element.getParent().specialization == "Association Target End" || element.getParent().specialization == "Association Source End");
let isPartOfAggregationSubEntity = (isPartOfAssociation 
    &amp;&amp; element.getParent().getOtherEnd().typeReference.getIsCollection() == false 
    &amp;&amp; element.getParent().getOtherEnd().typeReference.getIsNullable() == false);

return !element.typeReference.getIsNullable() &amp;&amp; !element.typeReference.getIsCollection()
    &amp;&amp; (element.getParent("Class").getIsMapped())
    &amp;&amp; !isPartOfAggregationSubEntity;</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>let fkAssociation = element.getStereotype("Foreign Key")?.getProperty("Association")?.getSelected();
let isFk = fkAssociation != null;
let isChildOfTargetClassOrCtor = element.getParent("Class").id == mappingContext.targetElementId || element.getParent("Class Constructor")?.id == mappingContext.targetElementId
let isAutoGeneratedPk = element.hasStereotype('Primary Key') &amp;&amp; element.getStereotype('Primary Key').getProperty('Data source')?.value !== "User supplied";

//let fkAssociation = element.getStereotype("Foreign Key")?.getProperty("Association")?.getSelected();  
return isChildOfTargetClassOrCtor
    &amp;&amp; !isAutoGeneratedPk
    // Entity Settings -&gt; Ensure Private Property Settings != true
    &amp;&amp; (application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")?.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")?.value != "true")
    // if is FK under root class, include if is for aggregational relationahip:
    &amp;&amp; (!isFk || element.getParent().specialization == "Class" || fkAssociation.getOtherEnd().typeReference.getIsCollection() || fkAssociation.getOtherEnd().typeReference.getIsNullable())
    ;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
            <childSetting id="a4a2572b-57d1-4782-8ace-dd22540211dc" name="Set Association Target End" type="Association Target End" typeId="0a66489f-30aa-417b-a75d-b945863366fd">
              <filterFunction>return element.typeReference.isNavigable 
    &amp;&amp; ((element.getOtherEnd().typeReference.getIsCollection() == false &amp;&amp; element.getOtherEnd().typeReference.getIsNullable() == false)
        || application.isModuleInstalled("Intent.EntityFrameworkCore"))</filterFunction>
              <isRequiredFunction>return !association.typeReference.getIsNullable() &amp;&amp; !association.typeReference.getIsCollection()
    &amp;&amp; !association.getOtherEnd().typeReference.getIsNullable() &amp;&amp; !association.getOtherEnd().typeReference.getIsCollection()
    &amp;&amp; association.getParent("Class").getIsMapped();</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>// Attribute is under mapped to Class or Constructor
let underClassOrCtor = element.getParent("Class").id == mappingContext.targetElementId || element.getParent("Class Constructor")?.id == mappingContext.targetElementId

return underClassOrCtor
    // Entity Settings -&gt; Ensure Private Property Settings != true
    &amp;&amp; (application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")?.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")?.value != "true")</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>e04ab087-8c1a-42b9-aac7-d76ed674e319</mappingId>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <useChildSettingsFrom>e04ab087-8c1a-42b9-aac7-d76ed674e319</useChildSettingsFrom>
              <represents>data</represents>
              <childSettings />
            </childSetting>
            <childSetting id="adb76398-4759-40ce-9b58-f98c1358f8e9" name="Set Association Source End" type="Association Source End" typeId="8d9d2e5b-bd55-4f36-9ae4-2b9e84fd4e58">
              <filterFunction>return element.typeReference.isNavigable &amp;&amp; application.isModuleInstalled("Intent.EntityFrameworkCore")</filterFunction>
              <isRequiredFunction>return false;</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>// anemic mapping
return element.getParent("Class")?.id == mappingContext.targetElementId</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>e04ab087-8c1a-42b9-aac7-d76ed674e319</mappingId>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <useChildSettingsFrom>e04ab087-8c1a-42b9-aac7-d76ed674e319</useChildSettingsFrom>
              <represents>data</represents>
              <childSettings />
            </childSetting>
            <childSetting id="1fba46e9-3cf7-4154-ad38-451c9696c413" name="Invoke Constructor" type="Class Constructor" typeId="dec2bd12-4699-4f45-8ec9-3b62dc692d2b">
              <isRequiredFunction>return element.id == mappingContext.targetElementId</isRequiredFunction>
              <allowMultipleMappings>false</allowMultipleMappings>
              <isMappableFunction>return element.id == mappingContext.targetElementId || lookup(mappingContext.targetElementId).specialization != "Class Constructor"</isMappableFunction>
              <isTraversable>false</isTraversable>
              <traversableTypes />
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings>
                <childSetting id="8ec45776-c6cc-4174-84f8-efb5d4308ed4" name="Constructor Parameter" type="Parameter" typeId="c26d8d0a-a26b-4b5f-b449-e9bdb60b3a4b">
                  <isRequiredFunction>return true;</isRequiredFunction>
                  <allowMultipleMappings>true</allowMultipleMappings>
                  <isMappableFunction>return element.getParent()?.getIsMapped();</isMappableFunction>
                  <isTraversable>true</isTraversable>
                  <traversableTypes>
                    <mappingId>e04ab087-8c1a-42b9-aac7-d76ed674e319</mappingId>
                    <mappingId>15b84be5-c79b-41bf-881c-447fe70f5f5b</mappingId>
                    <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
                  </traversableTypes>
                  <canBeModified>false</canBeModified>
                  <represents>data</represents>
                  <childSettings />
                </childSetting>
              </childSettings>
            </childSetting>
            <childSetting id="22a4b2cf-3791-42c3-846c-8ea4fd917289" name="Inheritance" type="Generalization Target End" typeId="4686cc1d-b4d8-4b99-b45b-f77bd5496946">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return false;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>e04ab087-8c1a-42b9-aac7-d76ed674e319</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
          </childSettings>
        </mapping>
      </targetMappings>
      <mappingTypes>
        <mappingType type="Invocation Mapping" typeId="47dc4a51-30a3-4ee8-8c7d-25a35bb965b9">
          <represents>invokable</represents>
          <sources>
            <source id="5a3018a8-38bc-450f-bf82-631e2d9475b3" name="Command" />
            <source id="8a986f57-e0bd-4b81-ac39-cbe0e5b44ac7" name="Service Operation" />
            <source id="5b5676ef-333f-4f52-859d-925ee8c43578" name="Domain Event Handler Association" />
          </sources>
          <targets>
            <target id="e04ab087-8c1a-42b9-aac7-d76ed674e319" name="Create Class" />
            <target id="1fba46e9-3cf7-4154-ad38-451c9696c413" name="Invoke Constructor" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
        <mappingType type="Data Mapping" typeId="50dccfb2-bd24-4135-adf6-ed31f28f8fe0">
          <represents>data</represents>
          <sources>
            <source id="98041049-0f91-4c21-99dc-50cd18fd1dae" name="Field" />
            <source id="7767267b-2e01-42cd-8a03-103d296a6306" name="Parameter" />
            <source id="daf3a2fa-0b35-4549-8b65-26b3a74dc7e0" name="Attribute" />
            <source id="c0682bc4-2b6a-4638-a35e-39188d253694" name="Association Target End" />
            <source id="cfe9c4d4-9c26-4f11-a585-f1e3863fb658" name="Invoke Domain Operation" />
            <source id="792374ff-6b97-45df-96de-01acd2488cc0" name="Property" />
            <source id="eb1478af-4b69-4d33-826f-3f195ebbed79" name="Collection Field" />
            <source id="ef61ebc7-f442-4b5f-bb5a-2ef68a1e4da8" name="Collection Parameter" />
          </sources>
          <targets>
            <target id="53e8bc33-5930-4364-9526-7f8f181b14a1" name="Set Attribute" />
            <target id="a4a2572b-57d1-4782-8ace-dd22540211dc" name="Set Association Target End" />
            <target id="8ec45776-c6cc-4174-84f8-efb5d4308ed4" name="Constructor Parameter" />
            <target id="e2ccdf82-ec44-4eb3-b32d-513ac3833d3b" name="Set Value Object Attribute" />
            <target id="82927c4e-1b48-4ab8-90ad-7c4d0b02067e" name="Set Data Contract Attribute" />
            <target id="adb76398-4759-40ce-9b58-f98c1358f8e9" name="Set Association Source End" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
      </mappingTypes>
    </mappingSetting>
    <mappingSetting type="Map Return Type" typeId="b7ae8bf5-f2fd-4a5c-b57e-05410687bfc4">
      <title>Map Return Type</title>
      <sourceMappings>
        <importSettings id="2b74b9ec-75bb-4eb2-8b3c-5b4fd755f019" name="Application Source Mappables" />
      </sourceMappings>
      <targetMappings>
        <mapping id="7e501670-11af-47fa-bf05-b0da94c85225" name="Return DTO" type="DTO" typeId="fee0edca-4aa0-4f77-a524-6bbd84e78734">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>true</canBeModified>
          <createNameFunction>return element.getParent('DTO').getName() + element.getName() + 'Dto'</createNameFunction>
          <represents>data</represents>
          <childSettings>
            <childSetting id="ee4038a2-7109-4ae2-b667-983ef574070b" name="Return DTO-Field" type="DTO-Field" typeId="7baed1fd-469b-4980-8fd9-4cefb8331eb2">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>7e501670-11af-47fa-bf05-b0da94c85225</mappingId>
              </traversableTypes>
              <canBeModified>true</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
          </childSettings>
        </mapping>
        <mapping id="e2e407d6-4f3e-41bb-8ec2-12f110b620a5" name="Type-Defintion" type="Type-Definition" typeId="d4e577cd-ad05-4180-9a2e-fff4ddea0e1e">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings />
        </mapping>
      </targetMappings>
      <mappingTypes />
    </mappingSetting>
    <mappingSetting type="Process Action Mapping" typeId="01bc7593-a6a2-45aa-8497-b4b6a269ab68">
      <title>Process Action Mapping</title>
      <isRequiredFunction>return true;</isRequiredFunction>
      <sourceRootElementFunction>return element.getParent().id;</sourceRootElementFunction>
      <targetRootElementFunction>return element.getParent().id;
</targetRootElementFunction>
      <sourceMappings>
        <importSettings id="2b74b9ec-75bb-4eb2-8b3c-5b4fd755f019" name="Application Source Mappables" />
      </sourceMappings>
      <targetMappings>
        <importSettings id="93c752a0-161d-4ef5-9c88-09995f59c263" name="Application Target Mappables" />
      </targetMappings>
      <mappingTypes>
        <mappingType type="Invocation Mapping" typeId="19c5ccad-f41f-4613-bd0b-b8e2adba6245">
          <represents>invokable</represents>
          <sources>
            <source id="5a3018a8-38bc-450f-bf82-631e2d9475b3" name="Command" />
            <source id="8a986f57-e0bd-4b81-ac39-cbe0e5b44ac7" name="Service Operation" />
            <source id="eb1478af-4b69-4d33-826f-3f195ebbed79" name="Collection Field" />
            <source id="ef61ebc7-f442-4b5f-bb5a-2ef68a1e4da8" name="Collection Parameter" />
          </sources>
          <targets>
            <target id="091c6b4d-5cf7-4561-9d4c-b025905152e3" name="Invoke Class Operation" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
        <mappingType type="Data Mapping" typeId="ac40ddfb-4d32-495d-928e-ddb991434a87">
          <represents>data</represents>
          <sources>
            <source id="98041049-0f91-4c21-99dc-50cd18fd1dae" name="Field" />
            <source id="7767267b-2e01-42cd-8a03-103d296a6306" name="Parameter" />
            <source id="eb1478af-4b69-4d33-826f-3f195ebbed79" name="Collection Field" />
            <source id="ef61ebc7-f442-4b5f-bb5a-2ef68a1e4da8" name="Collection Parameter" />
            <source id="daf3a2fa-0b35-4549-8b65-26b3a74dc7e0" name="Attribute" />
            <source id="cfe9c4d4-9c26-4f11-a585-f1e3863fb658" name="Invoke Domain Operation" />
          </sources>
          <targets>
            <target id="84e9dcc5-8765-48ef-b2a6-39744498a4af" name="Set Attribute" />
            <target id="e2ccdf82-ec44-4eb3-b32d-513ac3833d3b" name="Set Value Object Attribute" />
            <target id="82927c4e-1b48-4ab8-90ad-7c4d0b02067e" name="Set Data Contract Attribute" />
            <target id="8acf7530-30fd-49fc-b082-75e0060c249e" name="Set Association Target End" />
            <target id="95db9e8b-5db5-4a46-815c-53948a16fe7c" name="Set Operation Parameter" />
            <target id="49bfbdb3-9697-4d84-9194-df60ee7dfd9a" name="Set Association Source End" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
      </mappingTypes>
    </mappingSetting>
    <mappingSetting type="Query Entity Mapping" typeId="25f25af9-c38b-4053-9474-b0fabe9d7ea7">
      <title>Query Entity Mapping</title>
      <isRequiredFunction>return true;</isRequiredFunction>
      <targetRootElementFunction>return element.getParent("Class")?.id ?? element.id;</targetRootElementFunction>
      <sourceMappings>
        <importSettings id="2b74b9ec-75bb-4eb2-8b3c-5b4fd755f019" name="Application Source Mappables" />
      </sourceMappings>
      <targetMappings>
        <mapping id="0cd3919e-8d19-4b35-8c2b-dc8037efc3d5" name="Create Class" type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings>
            <childSetting id="a861cc4a-9aed-41f5-ad5d-fdc651497de4" name="Attribute" type="Attribute" typeId="0090fb93-483e-41af-a11d-5ad2dc796adf">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>c5a629db-c717-400b-9204-7cdb6acfa13e</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
            <childSetting id="4e6c69aa-dfdb-4f34-b9dd-80ad18cfe855" name="Association Target End" type="Association Target End" typeId="0a66489f-30aa-417b-a75d-b945863366fd">
              <filterFunction>return element.getOtherEnd().typeReference.getIsCollection() == false</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return false;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>0cd3919e-8d19-4b35-8c2b-dc8037efc3d5</mappingId>
                <mappingId>c5a629db-c717-400b-9204-7cdb6acfa13e</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <useChildSettingsFrom>0cd3919e-8d19-4b35-8c2b-dc8037efc3d5</useChildSettingsFrom>
              <represents>data</represents>
              <childSettings />
            </childSetting>
            <childSetting id="c15d409c-2707-419e-bb07-0c0df98b2aea" name="Inheritance" type="Generalization Target End" typeId="4686cc1d-b4d8-4b99-b45b-f77bd5496946">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return false;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>0cd3919e-8d19-4b35-8c2b-dc8037efc3d5</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
          </childSettings>
        </mapping>
        <mapping id="c5a629db-c717-400b-9204-7cdb6acfa13e" name="Create Value Object" type="Value Object" typeId="5fe6bb0a-7fc3-42ae-a351-d9188f5b8bc5">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <useChildSettingsFrom>0cd3919e-8d19-4b35-8c2b-dc8037efc3d5</useChildSettingsFrom>
          <represents>data</represents>
          <childSettings />
        </mapping>
      </targetMappings>
      <mappingTypes>
        <mappingType type="Filter Mapping" typeId="01d09a7f-0e7c-4670-b7bc-395d7e893ef2">
          <represents>data</represents>
          <sources>
            <source id="98041049-0f91-4c21-99dc-50cd18fd1dae" name="Field" />
            <source id="7767267b-2e01-42cd-8a03-103d296a6306" name="Parameter" />
            <source id="ef61ebc7-f442-4b5f-bb5a-2ef68a1e4da8" name="Collection Parameter" />
            <source id="daf3a2fa-0b35-4549-8b65-26b3a74dc7e0" name="Attribute" />
            <source id="c0682bc4-2b6a-4638-a35e-39188d253694" name="Association Target End" />
            <source id="cfe9c4d4-9c26-4f11-a585-f1e3863fb658" name="Invoke Domain Operation" />
            <source id="792374ff-6b97-45df-96de-01acd2488cc0" name="Property" />
            <source id="eb1478af-4b69-4d33-826f-3f195ebbed79" name="Collection Field" />
          </sources>
          <targets>
            <target id="a861cc4a-9aed-41f5-ad5d-fdc651497de4" name="Attribute" />
            <target id="4e6c69aa-dfdb-4f34-b9dd-80ad18cfe855" name="Association Target End" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <lineColor>lawngreen</lineColor>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
      </mappingTypes>
    </mappingSetting>
    <mappingSetting type="Service Operation Mapping" typeId="df692ffe-5d0c-40ee-9362-a483d929a8ec">
      <title>Service Operation Mapping</title>
      <isRequiredFunction>return true;</isRequiredFunction>
      <sourceMappings>
        <importSettings id="2b74b9ec-75bb-4eb2-8b3c-5b4fd755f019" name="Application Source Mappables" />
      </sourceMappings>
      <targetMappings>
        <importSettings id="d7aea784-eb96-472e-919d-a0e71315a0ed" name="Common Domain Mappables" />
        <mapping id="120f60ff-f242-4f5c-ac03-14f0ecaafdcf" name="Call Application Service Operation" type="Operation" typeId="e030c97a-e066-40a7-8188-808c275df3cb">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings>
            <childSetting id="ca7d6d11-0e19-4326-b95b-6451c9ca4d9d" name="Application Service Operation Parameter" type="Parameter" typeId="00208d20-469d-41cb-8501-768fd5eb796b">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes />
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
          </childSettings>
        </mapping>
        <mapping id="842b0753-adfc-4215-a772-65f4a033aedd" name="Call Domain Service Operation" type="Operation" typeId="e042bb67-a1df-480c-9935-b26210f78591">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings>
            <childSetting id="bd766e67-6d4a-44d9-aadc-feef8882840f" name="Domain Service Operation Parameter" type="Parameter" typeId="c26d8d0a-a26b-4b5f-b449-e9bdb60b3a4b">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
                <mappingId>15b84be5-c79b-41bf-881c-447fe70f5f5b</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
          </childSettings>
        </mapping>
        <mapping id="2e036907-5caf-4598-bd61-33d079871677" name="DTO" type="DTO" typeId="fee0edca-4aa0-4f77-a524-6bbd84e78734">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>true</canBeModified>
          <createNameFunction>return element.getParent('Command').getName() + element.getName() + 'Dto'</createNameFunction>
          <represents>data</represents>
          <childSettings>
            <childSetting id="fa557ba7-7faa-4ce3-bd23-32e821f71f84" name="Field" type="DTO-Field" typeId="7baed1fd-469b-4980-8fd9-4cefb8331eb2">
              <filterFunction>return !element.typeReference.getIsCollection()</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>2e036907-5caf-4598-bd61-33d079871677</mappingId>
              </traversableTypes>
              <canBeModified>true</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
            <childSetting id="24c8c608-ce45-4d64-a8b1-bbbd2486b186" name="Collection Field" type="DTO-Field" typeId="7baed1fd-469b-4980-8fd9-4cefb8331eb2">
              <filterFunction>return element.typeReference.getIsCollection()</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>2e036907-5caf-4598-bd61-33d079871677</mappingId>
              </traversableTypes>
              <canBeModified>true</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
          </childSettings>
        </mapping>
        <mapping id="8d23de60-8871-4365-ab36-2a2b4b5fa31d" name="Command" type="Command" typeId="ccf14eb6-3a55-4d81-b5b9-d27311c70cb9">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>true</canBeModified>
          <useChildSettingsFrom>2e036907-5caf-4598-bd61-33d079871677</useChildSettingsFrom>
          <represents>data</represents>
          <childSettings />
        </mapping>
        <mapping id="10596d74-4283-4bfc-a6b5-043e5b9b1939" name="Query" type="Query" typeId="e71b0662-e29d-4db2-868b-8a12464b25d0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>true</canBeModified>
          <useChildSettingsFrom>2e036907-5caf-4598-bd61-33d079871677</useChildSettingsFrom>
          <represents>data</represents>
          <childSettings />
        </mapping>
        <mapping id="809a0d2b-fbb6-4f09-9302-5d13a19d1607" name="Stored Procedure" type="Stored Procedure" typeId="575edd35-9438-406d-b0a7-b99d6f29b560">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings>
            <childSetting id="dba64983-a232-4042-89f6-fe70e966fa32" name="Stored Procedure Parameter" type="Stored Procedure Parameter" typeId="5823b192-eb03-47c8-90d8-5501c922e9a5">
              <filterFunction>return !element.typeReference.getIsCollection()</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>false</isTraversable>
              <traversableTypes />
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
            <childSetting id="5cf85beb-5228-4f1a-969c-bc72b0c14a0c" name="Collection Stored Procedure Parameter" type="Stored Procedure Parameter" typeId="5823b192-eb03-47c8-90d8-5501c922e9a5">
              <filterFunction>return element.typeReference.getIsCollection()</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>15b84be5-c79b-41bf-881c-447fe70f5f5b</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
          </childSettings>
        </mapping>
      </targetMappings>
      <mappingTypes>
        <mappingType type="Invocation Mapping" typeId="10fc25ac-92c7-49a5-9c42-4dd842a97500">
          <represents>invokable</represents>
          <sources>
            <source id="5a3018a8-38bc-450f-bf82-631e2d9475b3" name="Command" />
            <source id="eb1478af-4b69-4d33-826f-3f195ebbed79" name="Collection Field" />
            <source id="8a986f57-e0bd-4b81-ac39-cbe0e5b44ac7" name="Service Operation" />
            <source id="ef61ebc7-f442-4b5f-bb5a-2ef68a1e4da8" name="Collection Parameter" />
            <source id="5b5676ef-333f-4f52-859d-925ee8c43578" name="Domain Event Handler Association" />
            <source id="0556825b-177b-4093-b13a-5dfabb13c9b6" name="Query" />
          </sources>
          <targets>
            <target id="120f60ff-f242-4f5c-ac03-14f0ecaafdcf" name="Call Application Service Operation" />
            <target id="842b0753-adfc-4215-a772-65f4a033aedd" name="Call Domain Service Operation" />
            <target id="809a0d2b-fbb6-4f09-9302-5d13a19d1607" name="Stored Procedure" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
        <mappingType type="Data Mapping" typeId="7d27572c-2171-430e-8ab5-dc68fd02fb6c">
          <represents>data</represents>
          <sources>
            <source id="98041049-0f91-4c21-99dc-50cd18fd1dae" name="Field" />
            <source id="7767267b-2e01-42cd-8a03-103d296a6306" name="Parameter" />
            <source id="eb1478af-4b69-4d33-826f-3f195ebbed79" name="Collection Field" />
            <source id="ef61ebc7-f442-4b5f-bb5a-2ef68a1e4da8" name="Collection Parameter" />
            <source id="792374ff-6b97-45df-96de-01acd2488cc0" name="Property" />
            <source id="daf3a2fa-0b35-4549-8b65-26b3a74dc7e0" name="Attribute" />
            <source id="c0682bc4-2b6a-4638-a35e-39188d253694" name="Association Target End" />
            <source id="cfe9c4d4-9c26-4f11-a585-f1e3863fb658" name="Invoke Domain Operation" />
          </sources>
          <targets>
            <target id="e2ccdf82-ec44-4eb3-b32d-513ac3833d3b" name="Set Value Object Attribute" />
            <target id="ca7d6d11-0e19-4326-b95b-6451c9ca4d9d" name="Application Service Operation Parameter" />
            <target id="82927c4e-1b48-4ab8-90ad-7c4d0b02067e" name="Set Data Contract Attribute" />
            <target id="fa557ba7-7faa-4ce3-bd23-32e821f71f84" name="Field" />
            <target id="24c8c608-ce45-4d64-a8b1-bbbd2486b186" name="Collection Field" />
            <target id="dba64983-a232-4042-89f6-fe70e966fa32" name="Stored Procedure Parameter" />
            <target id="5cf85beb-5228-4f1a-969c-bc72b0c14a0c" name="Collection Stored Procedure Parameter" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
      </mappingTypes>
    </mappingSetting>
    <mappingSetting type="Update Entity Mapping" typeId="01721b1a-a85d-4320-a5cd-8bd39247196a">
      <title>Update Entity Mapping</title>
      <isRequiredFunction>return true;</isRequiredFunction>
      <targetRootElementFunction>return element.getParent("Class")?.id ?? element.id;</targetRootElementFunction>
      <sourceMappings>
        <importSettings id="2b74b9ec-75bb-4eb2-8b3c-5b4fd755f019" name="Application Source Mappables" />
      </sourceMappings>
      <targetMappings>
        <importSettings id="128a6e65-c165-400a-800d-71c7e67e7b01" name="Update Entity Mappables" />
      </targetMappings>
      <mappingTypes>
        <mappingType type="Invocation Mapping" typeId="d30bdba1-9c47-4917-b81d-29230fed5d6a">
          <represents>invokable</represents>
          <sources>
            <source id="5a3018a8-38bc-450f-bf82-631e2d9475b3" name="Command" />
            <source id="eb1478af-4b69-4d33-826f-3f195ebbed79" name="Collection Field" />
            <source id="8a986f57-e0bd-4b81-ac39-cbe0e5b44ac7" name="Service Operation" />
            <source id="ef61ebc7-f442-4b5f-bb5a-2ef68a1e4da8" name="Collection Parameter" />
            <source id="5b5676ef-333f-4f52-859d-925ee8c43578" name="Domain Event Handler Association" />
          </sources>
          <targets>
            <target id="091c6b4d-5cf7-4561-9d4c-b025905152e3" name="Invoke Class Operation" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
        <mappingType type="Data Mapping" typeId="ca88649b-f20b-44db-a9c0-017c26155ba8">
          <represents>data</represents>
          <sources>
            <source id="98041049-0f91-4c21-99dc-50cd18fd1dae" name="Field" />
            <source id="7767267b-2e01-42cd-8a03-103d296a6306" name="Parameter" />
            <source id="eb1478af-4b69-4d33-826f-3f195ebbed79" name="Collection Field" />
            <source id="ef61ebc7-f442-4b5f-bb5a-2ef68a1e4da8" name="Collection Parameter" />
            <source id="792374ff-6b97-45df-96de-01acd2488cc0" name="Property" />
            <source id="daf3a2fa-0b35-4549-8b65-26b3a74dc7e0" name="Attribute" />
            <source id="c0682bc4-2b6a-4638-a35e-39188d253694" name="Association Target End" />
            <source id="cfe9c4d4-9c26-4f11-a585-f1e3863fb658" name="Invoke Domain Operation" />
          </sources>
          <targets>
            <target id="84e9dcc5-8765-48ef-b2a6-39744498a4af" name="Set Attribute" />
            <target id="8acf7530-30fd-49fc-b082-75e0060c249e" name="Set Association Target End" />
            <target id="82927c4e-1b48-4ab8-90ad-7c4d0b02067e" name="Set Data Contract Attribute" />
            <target id="e2ccdf82-ec44-4eb3-b32d-513ac3833d3b" name="Set Value Object Attribute" />
            <target id="95db9e8b-5db5-4a46-815c-53948a16fe7c" name="Set Operation Parameter" />
            <target id="49bfbdb3-9697-4d84-9194-df60ee7dfd9a" name="Set Association Source End" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
      </mappingTypes>
    </mappingSetting>
  </mappingSettings>
  <mappableElementPackages>
    <mappableElementPackage id="93c752a0-161d-4ef5-9c88-09995f59c263" name="Application Target Mappables">
      <imports>
        <import id="128a6e65-c165-400a-800d-71c7e67e7b01" name="Update Entity Mappables" />
      </imports>
      <mappableElementSettings>
        <mappableElement id="05cdd272-2140-4e9a-90ab-2395bfe28be0" name="Call Operation Action" type="Call Service Operation Target End" typeId="093e5909-ffe4-4510-b3ea-532f30212f3c">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <getTraversableTypeFunction>return element.typeReference.getType().typeReference.getTypeId()</getTraversableTypeFunction>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>invokable</represents>
          <childSettings />
        </mappableElement>
        <mappableElement id="6dad8aff-d0f4-4630-9ca3-ae36943ef302" name="Create Entity Action" type="Create Entity Action Target End" typeId="328f54e5-7bad-4b5f-90ca-03ce3105d016">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <getTraversableTypeFunction>return element.typeReference.getType().getParent("Class")?.id ?? element.typeReference.getType().id;</getTraversableTypeFunction>
          <traversableTypes>
            <mappingId>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</mappingId>
          </traversableTypes>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings />
        </mappableElement>
        <mappableElement id="459be12d-ded5-40cb-9b5d-a57d2683375d" name="Delete Entity Action" type="Delete Entity Action Target End" typeId="4a04cfc2-5841-438c-9c16-fb58b784b365">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <traversableTypes>
            <mappingId>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</mappingId>
          </traversableTypes>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings />
        </mappableElement>
        <mappableElement id="13b6c853-ef60-4dc9-8c6b-a0fe24fc80b8" name="DTO" type="DTO" typeId="fee0edca-4aa0-4f77-a524-6bbd84e78734">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>true</canBeModified>
          <createNameFunction>return element.getParent('Command').getName() + element.getName() + 'Dto'</createNameFunction>
          <represents>data</represents>
          <childSettings>
            <childSetting id="643689ae-7903-447e-8ed3-1d492427b5ba" name="Field" type="DTO-Field" typeId="7baed1fd-469b-4980-8fd9-4cefb8331eb2">
              <filterFunction>return !element.typeReference.getIsCollection()</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>13b6c853-ef60-4dc9-8c6b-a0fe24fc80b8</mappingId>
              </traversableTypes>
              <canBeModified>true</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
            <childSetting id="9af8578c-b2fe-4f65-8014-6acfc258e6d5" name="Collection Field" type="DTO-Field" typeId="7baed1fd-469b-4980-8fd9-4cefb8331eb2">
              <filterFunction>return element.typeReference.getIsCollection()</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>13b6c853-ef60-4dc9-8c6b-a0fe24fc80b8</mappingId>
              </traversableTypes>
              <canBeModified>true</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
          </childSettings>
        </mappableElement>
        <mappableElement id="85f8d87f-3d9f-49a2-a882-eefae06a5e9a" name="Query Entity Action" type="Query Entity Action Target End" typeId="93ef6675-cba4-4998-adff-cb22d5343ed4">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <traversableTypes>
            <mappingId>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</mappingId>
          </traversableTypes>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings />
        </mappableElement>
        <mappableElement id="e65cd91b-d605-4341-9fdf-470a54c06d47" name="Service Operation" type="Operation" typeId="e030c97a-e066-40a7-8188-808c275df3cb">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>true</canBeModified>
          <represents>data</represents>
          <childSettings>
            <childSetting id="fffe6f4e-bcf6-4c7a-887e-6aca52d66806" name="Parameter" type="Parameter" typeId="00208d20-469d-41cb-8501-768fd5eb796b">
              <filterFunction>return !element.typeReference.getIsCollection()</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>13b6c853-ef60-4dc9-8c6b-a0fe24fc80b8</mappingId>
              </traversableTypes>
              <canBeModified>true</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
            <childSetting id="57def1e1-4cbe-497a-8f9c-c01f8bd14b7b" name="Collection Parameter" type="Parameter" typeId="00208d20-469d-41cb-8501-768fd5eb796b">
              <filterFunction>return element.typeReference.getIsCollection()</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>13b6c853-ef60-4dc9-8c6b-a0fe24fc80b8</mappingId>
              </traversableTypes>
              <canBeModified>true</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
          </childSettings>
        </mappableElement>
        <mappableElement id="95e12352-27ab-4d94-96a1-4d2cb0fb06be" name="Update Entity Action" type="Update Entity Action Target End" typeId="516069f6-09cc-4de8-8e31-3c71ca823452">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <getTraversableTypeFunction>return element.typeReference.getType().getParent("Class")?.id ?? element.typeReference.getType().id;</getTraversableTypeFunction>
          <traversableTypes>
            <mappingId>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</mappingId>
          </traversableTypes>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings />
        </mappableElement>
      </mappableElementSettings>
    </mappableElementPackage>
    <mappableElementPackage id="d7aea784-eb96-472e-919d-a0e71315a0ed" name="Common Domain Mappables">
      <imports />
      <mappableElementSettings>
        <mappableElement id="15b84be5-c79b-41bf-881c-447fe70f5f5b" name="Create Data Contract" type="Data Contract" typeId="4464fabe-c59e-4d90-81fc-c9245bdd1afd">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings>
            <childSetting id="82927c4e-1b48-4ab8-90ad-7c4d0b02067e" name="Set Data Contract Attribute" type="Attribute" typeId="0090fb93-483e-41af-a11d-5ad2dc796adf">
              <isRequiredFunction>return true;</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
          </childSettings>
        </mappableElement>
        <mappableElement id="32b2649c-7d86-42ba-807f-d9449ed15980" name="Create Value Object" type="Value Object" typeId="5fe6bb0a-7fc3-42ae-a351-d9188f5b8bc5">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings>
            <childSetting id="e2ccdf82-ec44-4eb3-b32d-513ac3833d3b" name="Set Value Object Attribute" type="Attribute" typeId="0090fb93-483e-41af-a11d-5ad2dc796adf">
              <isRequiredFunction>return true;</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
          </childSettings>
        </mappableElement>
      </mappableElementSettings>
    </mappableElementPackage>
    <mappableElementPackage id="128a6e65-c165-400a-800d-71c7e67e7b01" name="Update Entity Mappables">
      <imports>
        <import id="d7aea784-eb96-472e-919d-a0e71315a0ed" name="Common Domain Mappables" />
      </imports>
      <mappableElementSettings>
        <mappableElement id="72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8" name="Update Class" type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings>
            <childSetting id="84e9dcc5-8765-48ef-b2a6-39744498a4af" name="Set Attribute" type="Attribute" typeId="0090fb93-483e-41af-a11d-5ad2dc796adf">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>
let fkAssociation = element.getStereotype("Foreign Key")?.getProperty("Association")?.getSelected();
let isFk = fkAssociation != null;
let isAutoGeneratedPk = element.hasStereotype('Primary Key') &amp;&amp; element.getStereotype('Primary Key').getProperty('Data source')?.value !== "User supplied";
let isPartOfAssociation = (element.getParent().specialization == "Association Target End" || element.getParent().specialization == "Association Source End");


return (!isAutoGeneratedPk || isPartOfAssociation)
    // Entity Settings -&gt; Ensure Private Property Settings != true
    &amp;&amp; (application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")?.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")?.value != "true")
    // mapping association is not to an Operation:
    &amp;&amp; (lookup(mappingContext.targetElementId).specialization != "Operation")
    // if is FK under root class, include if is for aggregational relationahip:
    &amp;&amp; (!isFk || element.getParent().specialization == "Class" || fkAssociation.getOtherEnd().typeReference.getIsCollection() || fkAssociation.getOtherEnd().typeReference.getIsNullable())
    ;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
            <childSetting id="8acf7530-30fd-49fc-b082-75e0060c249e" name="Set Association Target End" type="Association Target End" typeId="0a66489f-30aa-417b-a75d-b945863366fd">
              <filterFunction>return element.typeReference.isNavigable 
    &amp;&amp; ((element.getOtherEnd().typeReference.getIsCollection() == false &amp;&amp; element.getOtherEnd().typeReference.getIsNullable() == false)
        || application.isModuleInstalled("Intent.EntityFrameworkCore"))</filterFunction>
              <isRequiredFunction>return false;</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>// anemic mapping
return element.getParent("Class")?.id == mappingContext.targetElementId</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</mappingId>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <useChildSettingsFrom>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</useChildSettingsFrom>
              <represents>data</represents>
              <childSettings />
            </childSetting>
            <childSetting id="49bfbdb3-9697-4d84-9194-df60ee7dfd9a" name="Set Association Source End" type="Association Source End" typeId="8d9d2e5b-bd55-4f36-9ae4-2b9e84fd4e58">
              <filterFunction>return element.typeReference.isNavigable &amp;&amp; application.isModuleInstalled("Intent.EntityFrameworkCore")</filterFunction>
              <isRequiredFunction>return false;</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>// anemic mapping
return element.getParent("Class")?.id == mappingContext.targetElementId</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</mappingId>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <useChildSettingsFrom>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</useChildSettingsFrom>
              <represents>data</represents>
              <childSettings />
            </childSetting>
            <childSetting id="091c6b4d-5cf7-4561-9d4c-b025905152e3" name="Invoke Class Operation" type="Operation" typeId="e042bb67-a1df-480c-9935-b26210f78591">
              <filterFunction>return !element.getIsStatic()</filterFunction>
              <isRequiredFunction>return element.id == mappingContext.targetElementId</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return element.id == mappingContext.targetElementId || lookup(mappingContext.targetElementId).specialization != "Operation"</isMappableFunction>
              <isTraversable>false</isTraversable>
              <traversableTypes />
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings>
                <childSetting id="95db9e8b-5db5-4a46-815c-53948a16fe7c" name="Set Operation Parameter" type="Parameter" typeId="c26d8d0a-a26b-4b5f-b449-e9bdb60b3a4b">
                  <isRequiredFunction>return true;</isRequiredFunction>
                  <allowMultipleMappings>true</allowMultipleMappings>
                  <isMappableFunction>return element.getParent().getIsMapped();</isMappableFunction>
                  <isTraversable>true</isTraversable>
                  <traversableTypes>
                    <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
                  </traversableTypes>
                  <canBeModified>false</canBeModified>
                  <represents>data</represents>
                  <childSettings />
                </childSetting>
              </childSettings>
            </childSetting>
            <childSetting id="b705b26f-b317-4278-9458-0d2442d46182" name="Inheritance" type="Generalization Target End" typeId="4686cc1d-b4d8-4b99-b45b-f77bd5496946">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return false;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings />
            </childSetting>
          </childSettings>
        </mappableElement>
      </mappableElementSettings>
    </mappableElementPackage>
  </mappableElementPackages>
  <mappableElementPackageExtensions>
    <mappableElementPackageExtension id="f7772228-e409-4998-92b7-d0ab6b7b338a" name="Application Source Action Extensions" extendPackageId="2b74b9ec-75bb-4eb2-8b3c-5b4fd755f019" extendPackage="Application Source Mappables">
      <imports />
      <mappableElementSettings>
        <mappableElement id="df404369-916e-4385-a29b-cbf86aa99846" name="Call Operation Action" type="Call Service Operation Target End" typeId="093e5909-ffe4-4510-b3ea-532f30212f3c">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <getTraversableTypeFunction>return element.typeReference.getType().typeReference.getTypeId()</getTraversableTypeFunction>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>invokable</represents>
          <childSettings />
        </mappableElement>
        <mappableElement id="f11b799f-24a9-4a8c-ae3b-576c8571c771" name="Create Entity Action" type="Create Entity Action Target End" typeId="328f54e5-7bad-4b5f-90ca-03ce3105d016">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <getTraversableTypeFunction>return element.typeReference.getType().getParent("Class")?.id ?? element.typeReference.getType().id;</getTraversableTypeFunction>
          <traversableTypes>
            <mappingId>5ef8e1c3-9626-4501-8968-6d9e432fb3b5</mappingId>
          </traversableTypes>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings />
        </mappableElement>
        <mappableElement id="a9b0bd2b-9b5a-45d5-992b-48430fc7579d" name="Delete Entity Action" type="Delete Entity Action Target End" typeId="4a04cfc2-5841-438c-9c16-fb58b784b365">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <traversableTypes>
            <mappingId>5ef8e1c3-9626-4501-8968-6d9e432fb3b5</mappingId>
          </traversableTypes>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings />
        </mappableElement>
        <mappableElement id="049127ae-ee8f-40d0-bed8-a3c9a559d7e5" name="Query Entity Action" type="Query Entity Action Target End" typeId="93ef6675-cba4-4998-adff-cb22d5343ed4">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <traversableTypes>
            <mappingId>5ef8e1c3-9626-4501-8968-6d9e432fb3b5</mappingId>
          </traversableTypes>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings />
        </mappableElement>
        <mappableElement id="f1c2f529-7818-4f89-a9b6-1b327e100470" name="Update Entity Action" type="Update Entity Action Target End" typeId="516069f6-09cc-4de8-8e31-3c71ca823452">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <traversableTypes>
            <mappingId>5ef8e1c3-9626-4501-8968-6d9e432fb3b5</mappingId>
          </traversableTypes>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings />
        </mappableElement>
      </mappableElementSettings>
    </mappableElementPackageExtension>
    <mappableElementPackageExtension id="07fcf100-ebed-44ee-8eb2-e65f418ae042" name="CQRS Application Mappables Extension" extendPackageId="93c752a0-161d-4ef5-9c88-09995f59c263" extendPackage="Application Target Mappables">
      <imports />
      <mappableElementSettings>
        <mappableElement id="e7d79c6a-1df9-4a1b-92f6-f198080165aa" name="Command" type="Command" typeId="ccf14eb6-3a55-4d81-b5b9-d27311c70cb9">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>true</canBeModified>
          <useChildSettingsFrom>13b6c853-ef60-4dc9-8c6b-a0fe24fc80b8</useChildSettingsFrom>
          <represents>data</represents>
          <childSettings />
        </mappableElement>
        <mappableElement id="9deeb131-a9cd-41cd-bc20-1bd5989f7bde" name="Query" type="Query" typeId="e71b0662-e29d-4db2-868b-8a12464b25d0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>true</canBeModified>
          <useChildSettingsFrom>13b6c853-ef60-4dc9-8c6b-a0fe24fc80b8</useChildSettingsFrom>
          <represents>data</represents>
          <childSettings />
        </mappableElement>
      </mappableElementSettings>
    </mappableElementPackageExtension>
    <mappableElementPackageExtension id="b6d97897-19a6-475b-bd06-f51dd1a11bc6" name="Domain Event Mappable Extension" extendPackageId="93c752a0-161d-4ef5-9c88-09995f59c263" extendPackage="Application Target Mappables">
      <imports />
      <mappableElementSettings>
        <mappableElement id="0d7e67b8-f056-443d-906d-665c0da26895" name="Domain Event Handler Target" type="Domain Event Handler Association Target End" typeId="f45dfee9-f62b-45ac-bfce-a3878e04b73f">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings />
        </mappableElement>
      </mappableElementSettings>
    </mappableElementPackageExtension>
  </mappableElementPackageExtensions>
</settings>