<?xml version="1.0" encoding="utf-8"?>
<settings version="3.1.1">
  <id>f36cb21a-faf9-46ff-85e7-41f38345253d</id>
  <name>Services Domain Interactions</name>
  <designerReferences />
  <packageSettings />
  <packageExtensions>
    <packageExtension type="Services Package" typeId="df45eaf6-9202-4c25-8dd5-677e9ba1e906">
      <requiredPackages />
      <contextMenuOptions>
        <runScript group="1" type="run-script">
          <text>Create CRUD Traditional Service</text>
          <shortcut>alt + s</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAX2klEQVR4Xu2cCXxU1b3Hf///nUkyIWFL2FEQQUAEAiibIERF6v4qLX3iVi2ofdhXEBQzVYiggFjS+sG2D5fKoq2Ppq0SS4u17MGwyi6bsiUhQCDs2WbueZ9z7j6TAUIo0NfMp3Um95577jnf+9/PuRBqPzUiQDW6uvZi1AKsoRDUAqwFWEMCNby8VgJrAdaQQA0v/5eRQPFuoCVQ2RbMjUFcF9CbgzgAoKliQEiAQFMQAeyiombIRSCUqaOC9qlvpgNgHAFQDC20D9tKD1Im9OryvKoACgHCz5GIFCSi3HcDfDwIEA8A1AUEzQBlDll+uX+bFFVcYR232luzVN+k/ud8m8iMa1aCaRk08SeUiz1ITj6L+wpLiSBigb0qAIp50FCi3Q/gByDqBEGtwKgbBcyKuqqCZ8N0TUkes+G5wNsQq3gIzkM5ClABGJuh00eoU7KI7kF5JMgrClDMjL8eovJ7AI0FUWqUZHgkzAZwFkRnABwHIaS+DSBhEB2XSmpDY5teqj1xohTzfAqI6gHwnfe+xgPbAWAm4rXf071Hiqz+rhhAMVMbBoG3QVRf6VOkWjkSVQCBPwP0FUjkwu8vgaAwQqcqkKxUq0JNZhtAmebvCDER8xBnHzqVGg+JM1weh5Duh661BlFnMNIh0A9E1zjpRYQEG6pcAuDH9N1j80xDUF2zWbP2IhM+NPFNAuElR71sm1QMQUvBWAPW1yEcv5lGnDlUsztW72rxaWpzVFTeBOYeIPQF0BuwtMMep3RIr+HBo1MuuwSKd9EFId86MHym3ZeqVygHRCMq36nedP/5rcUCxKO84bMAxgLUHAQ2nVQpgNsuP8CZviwAo22VBZ7G6coP6XnIAV21H5GTnAo97ikleSC/6e1HXQGA/nkg8X1XONGVRlRsumrJuQYmPktNRxjzQUgytIfHXX6A72j3AZzjCi9OA5iBQOBNeuSENNBX3UfMaxlAfNn7IDwAoI7L6997+QG+57sDgv5qq4F6ktLbUQkg/gFgKYSeRz+qXHulSIqFTeqgorILdO4LIfqB+G5AxHsiBaJy6Prgyw/wHd9CEN9VdYBrwVToQgB9Cta/QJj+BuE7g7i4cpw5FkIDhGho1SHLhUJXoU2guQ+lpX6gMg7xCQ2h63eDcC9AtwIInD8+pODlB/i+PxeC+qrBCdoPRjGA7oZNqSpzsId4EoRiEJ2EEKfBMmim0yCxRyW/LM4gzHvhc+ezRvYH6NcBSFI5MnNbCCSAVDSYaAbTDUCQQbUrPawyc9kIovaAul42vkIAQX0NOyJW0lMVt4r34+8G06MgdAOoDQjx3snY8ZfBIzJDqVa65n5Isfq14cnI4FsQrQPofxDw70RZ5Q4QUtT4GVcA4G+lBLIhgTAAql8yAfsD6uBMnSSwuAck7gUwCETJnsT/ksFzgfTkxtI00J8A+hsg/o4E7QQNPiRTR4gvWqQYAM10kK4IwLhcKAlUkrSSnixTAGN9xEd12wF6MwhxHQRdB0ZjkCw0qKDWKGcZqp8IyHMRxQSj42IwSW8vP4UgVIA4H9BPgrgARPsQFgdB4W/pu8f3xhyLBFgRkjmxlU9fCQmMywWxAZCxkp44N8Bzwb3c55QESoCWCkNcCYAJr4LRzpz8Lvph2YTLDeJi76cAVoYdCaQrAPBiB381XGcDVBKoTJAjgfXfXPMg69QWmlEPt6viMkKwRm/9YPZUzQHNKBdbUYOKFlx1dfXT/Nv95W6jWS3sH8YVrjbm0Oy+1Hl1T3PM7lI+xP5t32/1h0sJXgEMWRKobG2QUt9Y3zwkwp8Q4RZpgI3wxvVt1umUbY487jpHroqwXdoz4zrVm0o2DAOvvu3KOpl23/yW93DVBq3fUfdXHVXRp9uJgFayiB+8dWhjy4HUiKcCGNYdFZZhTL2pq0cQSJWR5MTs+58LogeqMRMjG/MC8sCKghcJ0brWfFARD858rvY9oh+mqybrgsjMz2wd0vKSlMlsgHYcSEGqN2V1BoDJ7slfkAR4JDI2REcyq5LAKiCeSzIt7bDiXEuS3dLvPqeehZ617Xutx9RI9MyLxcLm14DEJoDqm+UsB6AtLR5JtFTvAtX6vBP0QoxUz6olNuLe7nuo4cUyD9bxmgMUi1snoLL8NoAmAuhlwIOAoJFU7/W8DBBP9tgkDwjHNhltIgfsQFFqFaHe0XbPyQBsk1GFufDat4uHSFwzgOJvzYeD9HEgbgXAKKQaDE5Bpx4KoAAZKuwGZEM8t8H32KZzORyP84i4VwynEgkx2sZGOh7LQTn2kCGytg29MBUWC1q0BIe7AugB4lsAMdAonlaZ9ulgPGkD9HrHSNV1/W06jGiP7fau5g2jJCu6jUeiI+2f63qPk3M96Cipt02QZQxF1vahrceoXHt+ahLqxMehIsyoDPkR7++DsN4RjFsA+g7IXL2LlW+Dzqr00Rq0JoKU/HpeBglSKuwdZIRXtFXXcRgxw55z2KaqH1QVEnnecCfCnLil3x0VkAlwYZPGqBTLzTzWZ5axoncpVA3vGIimg3gFoH8CkCx/yRJakOpOXPW4IPEsWYvQ7qdrhahs2Tb2xG+KuAq03RKq/lLH3R5YHbJCGTM4dry98bDUYbcUKtpO5G09eHXEAmZeaMWJ5q2d80S/3/6frWao5UofF3grO7Y9s6THcA4EuSvhAAQ2gfXP6M6ibNlAhTFygd3KRJiDhHnzNGzr5MohYjj8G4FOlyIWqHYfN1b7CvcFjbYt0ZdkpocUQL9WYJ9zBesAToEoD0T/gBBfQOO9SKSz1Dffs1KoALLaoSBBelO5Go3yX+Bi8WlqMnw8BuAjYJyGToegiWPQsYfuKZK7tM77sQHa20OuQEX6vKO8ihsogBq7ylkcpKTM5QMFaXc59syyOWaCTjh5IthzqjWvlDdW36GD77CMVmShQWP++vDotLlW+8ZvbX6MoHd02zjjnHGlIF5fNLKTsjHy03Lm1mEk+Ca7iWF2lYFUV4T1z/eO6LjEan/97N3PCBKtZH+emoX1h6AVOx9pveBSPBcHoFWR5iDVeTUvA9Anx4ro5baLk8GeLawB1J+yKpNYm+ANqt2BLucUP58m10/Vp9FbG+czcL/jsSNSOsaswh/f9KQLYDZAQ9xxqSc/Jw7ufardFKt9mzm7cyHQN7LYYMSQctkFWTsfaXNpUjkpgT7NcSKaBVDok+14KioEocKTP4sASDzBWkGLiuMIOcXPd/cAJIH7Y1VzCDSrcKQL4G+2ZoNpiARkQ/TGk8G9T7V3AM7enQsItUhV1T0IImvnI9dfeoDyZkxSAldmCIHJdhnLyPNcKRtHAQTxBE977+Bzise6AP5iw3witwR60z1BNKvIBbDFb7ZmE9GQWBJOoODe4W6Au3KFJYHucZhelukSAlwlF5WkBFoqbAHUhSGBEU/dtEOFp37W21bhuq+vymSWEmitLkbV8XKORgJUKuyUqSypNUVmVtFzjgRKgAA8Kmzfi9TWKC/AD3blCmMbmqfOaEkvBLJ2P3aJJHBx81SwfzvYXNaUq3IJ41dmMInJCpZZDIiwh4WnXvECJKYJTl4alejnHH2hh6PCWRvkZpz7Y0k4iD0Am/16SzZHSaBTZ2TyAmz92125RKKvO6Wz7Z/hfi4dwOWtHwbELIDizMwtSEmvrOgUJu4iS+Oeirg8II8JlJ56pdcnltFuMHFlZ/j9N7nL97aHYw1CDxUef7HnUutYatb6ARppze027pBd/g5jz6H/7ppnnW/2qy39fJp2TXR7YzwUqty0/+lOW63z132wc5AgpBpjN9qYv5SnF77Q9t0Pt/vqYr2wyGtbFxWhbmDxEwgMsTMZQiVA95kZ8MV2///3OrG4pVwfGgHQMBAaK6lTWmrOmagUGvf/twcocps0RrmvGVi7ASRugKA0sNyrQ20cYFalxcnBTZAvUMIryx+HwDNkrX65qhFmWFB8dnyfBy1ZS5606kdgkjs17aKBXSQwIt7cknE9XrTaN/z5umlEdKtTSLAGYygdCf2vh0alvWar8NubXyemgdbfJIsJVjBNMvDGzIIRN86xzl/77o6ZpOEmsxxhbFlRRQnTbgp8/M0TbWeoqnIodC9YpBm7GKg3CJ0BSnYVSY1uq67InALha4A6Gzsi1I2ClPDyigzA8cLeIqYaROGZzL62F06a9GUmkduJRBVic0peusV2IilvrjecSGSx1ZH9WYdHpdmBdNO3N2cTYIQxyqk5T186N8EULHi6ox0HXvv+9lwSqMKJ2AtkWd8+0W6M+Pya5tBEgUsFTVimKDiq6T0OrAfjPQhahDIcR6LYCrCxtYNMgEKIyd4g1JMteAG++mWm7YXNSVqibnrvnOMegOsUwNhLpvACnLE5G4Qhbq/tLYtxsOBZF8B3t+fK3fReL+9ZlnUA+oRRjYlVMDU2ux8CYR+YF0HT/ky9d+db0i5WdUhBuNyIA1U/EmBwRYYgfXKsSF5K4NlXb3Uk0AToDXStMEMNLgqgQBWZiDkRokiAG7MBHmI8UEM63EumIAQLnu3kSKAECCmBVa87Eyjr2ydNCfTDBKimvxWgPSCxAWHOg+bbBK48DU0vQ5/8sqpe71IAdQugGmCQ4oJShXUlgTHWHCIA5maCZSYSq4qMnOMZPR0VnrZuvgToqKTtxUw+NOvIaEeFG7+1MZtVKmcF6FGVZy/Ad75WgXSsZVm2AMrXyRo1vQa+uBPUf/9F7cVWAEWls7AuJMCXlmWAoQJp98K6HcmDCksnuiQw0wDokUALpnxshJyTLoANpq2bTxBKhWPcY9aR0d1sGygBylQuKq+1TJW0gW4JlADhFBO895APQWTtebL9pcmFLYDuvTG+cUv7MtEAVS7yRtKm96PTpRNvnWF74Ykr+kP4+tlRt3vvjLHVdveJjF72npSGU9Z+XzDa2n2bG1qsfS+CxObiUWmfWf03/sWGh4ipvbNHxynpyz5EWF9aOLLzSqt9i3e3Pa4JamEsLURMgAGdsXr/D9vLzes1/igJhJRA+327y7+9rcazuIIdGACt/YEq0akFWJ3noQCStUNVFRuDpL2w+D5ltO341lQDIyiWi2LHyyf1G23dKDFz2X8A/gftMM4uYJs2Dth48uXev7Ta15+cNwrsk4vV6sPW6p8ZHAtw7rGx3d6zzjf6xaaRRPrNRmPjP+5tbgLij4ee62yrfItfb3kZTNe7t7gZC3lmRR3hhXuH3/hxdUDFamsADBsFVSNCCJLvxSUZILMeyFQGiBNEvFiD2BAmvoGJ2pa91m+ADXD88kxZD4zeAmfvCsg59XIv2wvXnbJ6PgGDiCD7XUMEWWjoBFAPIrQC4Y9Hx/ZQmY38NMraYMSBnhjTHddx8OBzThhjlr/OArSDSXQRRH2IOJWMBXAZemftG97x0jiRta2aQcRtAaGhMVoLoJGJZJPgNytLm23EjHZRb2ZbE0wYvzyTwBOiJmjGbUTsAVh/ct5jQqOvTwQabsZ/u/qdN0+r+8311/nitfhjz6fZ1ZVG09dng9msSEfvuxFEwUPPdbbjwEhpafSrrUkJfl9HQIwlwlDphS8FQLG2XS/omAZGf3ujpMBI8r+waLQgSgxNS39dvXrP9eS7Gl2gaU2gUSU03gjiDdbSX8L4Fa8QMDHWnkAB5JwZ38eWQDlBMQ8BhOt2gV/rDo3rqxddybcGfmyiwYcOuyGkTF9v1gMj9vs5QfW4op90mab6nZPUGAEtDUyd4dPiwD75vvEGJBd9RekItXp3+wuCkLJ/eIeXqqvCaivIV+2boVLvLvfAGG8wyfdX7H0yBRD6AMLolQHU+7xctPl5KuJogfo3CzROUGGEjBuYdfi4BMzDaXDhJwmZy9tQmL5xCpjetYtIgOJ3yfKNoGz4qDeY4+1+NQpD007AR8No0MGF1gRTpq/LJmInlVOaYgbVjBN+3X9L/k9v3CU+SkqHRh+CuQk01lS/xpjLwLQZLO6jEzOOpp7qklj8ow6nLhSg2NopDqfKHwVjBAjtzWKD+W6zbfkPgyt6Ube9e9UR8ZukxqgrFoI5TUHTyBqM8a0GRifh4+F0R8EfAi+veAiEj0Hkj8yhZSpnSaCSEA3LYMV10oEk1Af0s4aNV33L9zf4v+iuArUUqgBCOrXobcYaiccP/jRtrpibNBSM2dAowRiv6//yHgbIPHD4Ebrz0LdueGKFLCposrbXGqQ1BURTgFsZpSzcAKa2hnlzlbBsqRNnIehTABPp5p3bVTOltuWBL0A80JYOHwPxDQBRClDYmqi14bs9bVuyL1B8aAoErrVF2vSqxLT2zPi+U4UAY07gC2ialBSjj7i6wN0bgbVPAiVfWg9GfksJuZnuLNiZmrVhjBDhPoYflepiuXk6cGRU19FKokPhfdA4UfUbG6CEMB8lBQ/RUIQVOPadr5hg+gY3POggkqWsz6FjvAXOeigkPozrDF37Esx1bIBJzYEBC4BtmcDhv3oBMk2k2/PP+26HmB2QEFZCk2V2E2C7Z4C0N4Aji4DVD7sBShBj6PYD8m32c37ErMAMaPScrSlthgFlBUDJauD6EcDxVcDpLRbYk/CH2tJtRUcMgH6jnGXaU0PSzP9El7MOgkialvkgbT12f50vH0Tk4Ej8NvAD+OhjSNH3aUDStUC99kDvOcCuLODQX4CKIoDKrUH9ndIPGDsZzvERs+N/CvAvbYDJ1wL9s4G67YFwKbBjKrD/PZcq8xeUfmDQOfuUr6ieDSyCRrfaAPvPA5oMAA78L3Dtw8DG54DDn5ljVcHug3R74XxDdU2AdtAr3+wkuS/mGIATYOwCeDV0LKdeOzeeb46GCn+Q8BI0nqIABlKAwcuA+EaALwDoFYBeCWx4GihZYg1qCaXnpyePWZwaCvie8KafMvCmb85m9v1EfJCQCaYJCmCgodFv4QKg7dOGZLcbBXx5H1C+z7Jhmyn9QBf52oUOPMzW4pOpwboIzTtav+dxaAmroXEHG6A0CwNzgAbdgB1vAN++pVbC7POkTaPb949Ti0NCnwBQCYi/BtFuaOWHUZFUjnJUoLS8ku7ZHTN8iwWTxJyExwCeY0igH2iWDjTsCnQcBxRkA8fygKOLAP24JYFKUuKDS+4GaQtsJ2KbDc45O7HvA2J2YByAqQpgfDKQlgmk9ATCp4HQGaBOK2DdMEO6pX308TIaeGBAwzfX94EQK+21YKusBXH/kY49/o5DgaXwUS8b0E0vAu1HASe3AfW6AOseA0pWOACZHqX0/I8uRJoupg2JWYFbwbQITHG2DazXBrh9CbAlAyjM9tpAjd6m9PyfJASXThBEsrxvG17jJ+eUSoCz4u8F8WceGzj4S2DpIKDnbGD/+8DRxdK7W7bwTbo9/8UGb6xWm96lD7aLqtIjC4wtHtt9upiVMBsaP+6o8MfAwb8ABz8D+mYDe94Gij+3AJZDxLWiO/f80/7tGemFk1BeZxUINzpe2Ac07gec2QGEjnkBEg+g5dPz4iuafg5gQBWV4JzSif0eEDORiITAOmhaB9uJDM4DQieB+BRgz0wgf64F8Cw0HkDpB9Y2nLomW1j1QNdWDbnD+eiY7g+K2YndwHKdwgy3zuWFfZSHssDAi1HNC5VGIw78XXIH6PpiaNz0HHFgCKz9kgblv+Aft7wrWF9ORMmexSKjKJtTOqmfykTEB3EdEBe3BEwy2AXqdzI8spy0fDChoxKgDtayZL/ymvpT15iLSlFbRiqYuPeRMWlfiTmJk6BxBjTSYoYxGhdD8Pfornx7kf9CoVSnnR1ai7nJ/eHHX0CcXGUgTTwRqc1eo5xfBeLKy7YJohaehRx77QI5pZP6GwBlOvRhYjdo2kL4ONVRV3fwi3E4XjTdChEkQGNvTMSWEeNmB3xCu7mobtcSJCX9DBpNqBKgj09D4A76TtHq6sC4mLY2QDXheQ3qQYQfhU+TFeem0LTTYN4Ov/YxDT64TrbxvbT4TgI9Yt1MbvdRnpiMspOAvrH89dvscpbqd25iM8T5HoLGveHTWoJxHBpvga7l0P3eSTaYumakABnlLPnvLFnVNbswTR8cGdt9mer3o/pp8Ith8LH8t64CYMqHJvc6h+fSPcdOXgyQ6l7jAVjdi2vbOzs9allcJIFaCbxIcI4Jq2EH/+6X10pgDSWgFmAtwBoSqOHl/wfCkA2o2wygUAAAAABJRU5ErkJggg==" />
          <isOptionVisibleFunction>return application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "basic";</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
;
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x),
            additionalInfo: `(${x.getParents().map(item =&gt; item.getName()).join("/")})`
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    /**
     * Returns true if the attribute is a foreign key on a compositional one-to-many relationship (i.e. is managed by the DB and should not be set).
     * @param attribute
     * @returns
     */
    static isManagedForeignKey(attribute) {
        var _a, _b;
        let fkAssociation = (_b = (_a = attribute.getStereotype("Foreign Key")) === null || _a === void 0 ? void 0 : _a.getProperty("Association")) === null || _b === void 0 ? void 0 : _b.getSelected();
        return fkAssociation != null &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsCollection() &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsNullable();
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
class CrudConstants {
}
CrudConstants.mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
CrudConstants.mapToDomainConstructorForDtosSettingId = "8d1f6a8a-77c8-43a2-8e60-421559725419";
CrudConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class CrudHelper {
    static getName(command, mappedElement, dtoPrefix = null) {
        if (mappedElement.typeReference != null)
            mappedElement = mappedElement.typeReference.getType();
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        if (dtoPrefix)
            dtoName = `${dtoPrefix}${dtoName}`;
        return dtoName;
    }
    static getOrCreateCrudDto(dtoName, mappedElement, autoAddPrimaryKey, mappingTypeSettingId, folder, inbound = false) {
        let dto = CrudHelper.getOrCreateDto(dtoName, folder);
        //dtoField.typeReference.setType(dto.id);
        const entityCtor = mappedElement
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (inbound &amp;&amp; entityCtor != null) {
            dto.setMapping([mappedElement.id, entityCtor.id], CrudConstants.mapToDomainConstructorForDtosSettingId);
            CrudHelper.addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto, folder);
        }
        else {
            dto.setMapping(mappedElement.id, mappingTypeSettingId);
            CrudHelper.addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder);
        }
        return dto;
    }
    static getOrCreateDto(elementName, parentElement) {
        const expectedDtoName = elementName.replace(/Dto$/, "") + "Dto";
        let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
        if (existingDto) {
            return existingDto;
        }
        let dto = createElement("DTO", expectedDtoName, parentElement.id);
        return dto;
    }
    static addDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto, folder) {
        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        childrenToAdd.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
            field.setMapping(e.mapPath);
            if (DomainHelper.isComplexTypeById(e.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(e.typeId);
            }
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
        });
        dto.collapse();
    }
    static addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder) {
        var _a, _b;
        let dtoUpdated = false;
        let domainElement = mappedElement;
        let attributesWithMapPaths = CrudHelper.getAttributesWithMapPath(domainElement);
        let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
        for (var keyName of Object.keys(attributesWithMapPaths)) {
            let entry = attributesWithMapPaths[keyName];
            if (isCreateMode &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {
                continue;
            }
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                continue;
            }
            let field = createElement("DTO-Field", entry.name, dto.id);
            field.setMapping(entry.mapPath);
            if (DomainHelper.isComplexTypeById(entry.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(entry.typeId);
            }
            field.typeReference.setIsNullable(entry.isNullable);
            field.typeReference.setIsCollection(entry.isCollection);
            dtoUpdated = true;
        }
        if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
            CrudHelper.addPrimaryKeys(dto, domainElement, true);
        }
        if (dtoUpdated) {
            dto.collapse();
        }
    }
    static isOwnerForeignKey(attributeName, domainElement) {
        for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
            if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
                return true;
            }
        }
        return false;
    }
    static addPrimaryKeys(dto, entity, map) {
        const primaryKeys = CrudHelper.getPrimaryKeysWithMapPath(entity);
        for (const primaryKey of primaryKeys) {
            const name = CrudHelper.getDomainAttributeNameFormat(primaryKey.name);
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
                continue;
            }
            const dtoField = createElement("DTO-Field", CrudHelper.getFieldFormat(name), dto.id);
            dtoField.typeReference.setType(primaryKey.typeId);
            if (map &amp;&amp; primaryKey.mapPath != null) {
                console.log(`Doing mapping for ${dtoField.id}`);
                dtoField.setMapping(primaryKey.mapPath);
            }
        }
    }
    static getPrimaryKeysWithMapPath(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return Object.values(keydict);
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.isManagedForeignKey(x) &amp;&amp; // essentially also an attribute set by infrastructure
                !CrudHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return attrDict;
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !CrudHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static getDomainAttributeNameFormat(str) {
        let convention = CrudHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
            default:
                return str;
        }
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
}
/// &lt;reference path="attributeWithMapPath.ts" /&gt;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
ServicesConstants.dtoToDomainOperation = "8d1f6a8a-77c8-43a2-8e60-421559725419";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(innerElement, settings) {
        var _a;
        this.innerElement = innerElement;
        this.settings = settings;
        this.mappedElement = (_a = innerElement.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.innerElement.id; }
    ;
    setReturnType(typeId, isCollection, isNullable) {
        this.innerElement.typeReference.setType(typeId);
        if (isCollection != null) {
            this.innerElement.typeReference.setIsCollection(isCollection);
        }
        if (isNullable != null) {
            this.innerElement.typeReference.setIsNullable(isNullable);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.innerElement.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.innerElement.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.innerElement;
    }
    collapse() {
        this.innerElement.collapse();
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="../../common/attributeWithMapPath.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto) {
    let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
    childrenToAdd.forEach(e =&gt; {
        if (e.mapPath != null) {
            if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                return;
            }
        }
        else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
            return;
        }
        let field = createElement("DTO-Field", e.name, dto.id);
        field.typeReference.setType(e.typeId);
        field.typeReference.setIsCollection(e.isCollection);
        field.typeReference.setIsNullable(e.isNullable);
        if (this.mappedElement != null &amp;&amp; e.mapPath) {
            field.setMapping(e.mapPath);
        }
    });
    dto.collapse();
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", toPascalCase(entry.name), dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; {
        var _a;
        return !x.hasStereotype("Primary Key") &amp;&amp;
            !legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
    });
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
function onMapDto(element, folder, autoAddPrimaryKey = true, dtoPrefix = null, inbound = false) {
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b, _c; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; ((_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.specialization.startsWith("Association")); });
    fields.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement().typeReference.getType(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (DomainHelper.isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()));
    });
    complexAttributes.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), false, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
}
// services-crud script (see ~/DesignerMacros/src/services-crud folder in Intent.Modules)
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../../common/elementManager.ts" /&gt;
/// &lt;reference path="../../services-cqrs-crud/_common/onMapDto.ts" /&gt;
var _a, _b;
const privateSettersOnly = ((_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")) === null || _b === void 0 ? void 0 : _b.value) == "true";
var servicesCrud;
(function (servicesCrud) {
    async function execute() {
        const package = element.getPackage();
        const entity = await DomainHelper.openSelectEntityDialog({
            includeOwnedRelationships: false
        });
        if (!entity) {
            return;
        }
        if (privateSettersOnly &amp;&amp; !hasConstructor(entity)) {
            await dialogService.warn(`Partial Service Operation Creation.
Some service operations were created successfully, but was limited due to private setters being enabled, and no constructor is present for entity '${entity.getName()}'.

To avoid this limitation in the future, either disable private setters or add a constructor element to the entity.`);
        }
        const serviceName = `${toPascalCase(pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName()))}Service`;
        const existingService = element.specialization == "Service" ? element : package.getChildren("Service").find(x =&gt; x.getName() == pluralize(serviceName));
        const service = existingService || createElement("Service", serviceName, package.id);
        const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName());
        const existingFolder = package.getChildren("Folder").find(x =&gt; x.getName() == pluralize(folderName));
        const folder = existingFolder || createElement("Folder", pluralize(folderName), package.id);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const resultDto = createMappedResultDto(entity, folder);
        if (!privateSettersOnly || hasConstructor(entity)) {
            createStandardCreateOperation(service, entity, folder);
        }
        if (primaryKeys.length &gt; 0) {
            createStandardFindByIdOperation(service, entity, resultDto);
        }
        createStandardFindAllOperation(service, entity, resultDto);
        if (primaryKeys.length &gt; 0) {
            if (!privateSettersOnly) {
                createStandardUpdateOperation(service, entity, folder);
            }
            createStandardDeleteOperation(service, entity);
            const operations = DomainHelper.getCommandOperations(entity);
            for (const operation of operations) {
                createCallOperationCommand(service, operation, entity, folder);
            }
        }
    }
    servicesCrud.execute = execute;
    ;
    function hasConstructor(entity) {
        return entity.getChildren("Class Constructor").length &gt; 0;
    }
    function createMappedResultDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == dtoName);
        if (existing) {
            return existing;
        }
        let result = CrudHelper.getOrCreateCrudDto(dtoName, entity, true, CrudConstants.dtoFromEntityMappingId, folder, false);
        onMapDto(result, folder);
        return result;
        /*
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });


        dtoManager.mapToElement(entity, ServicesConstants.dtoFromEntityMappingId);

        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys)
        }

        let primaryKeys = DomainHelper.getPrimaryKeys(entity);

        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity))

        dtoManager.collapse();
        return dtoManager.getElement();*/
    }
    servicesCrud.createMappedResultDto = createMappedResultDto;
    function createStandardCreateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}CreateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Create${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Create${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });
        let operationManager = new ElementManager(createElement("Operation", `Create${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        const entityCtor = entity
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (entityCtor != null) {
            dtoManager.mapToElement(entityCtor, ServicesConstants.dtoToDomainOperation);
            dtoManager.getElement().setMapping([entity.id, entityCtor.id], ServicesConstants.dtoToDomainOperation);
        }
        else if (!privateSettersOnly) {
            dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        }
        else {
            console.warn(`Private Setters are enabled with no constructor present on entity '${entity.getName()}'. In order for 'Create${entity.getName()}' to map to that entity, either disable private setters or model a constructor element and try again.`);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const surrogateKey = primaryKeys.length === 1;
        if (primaryKeys.length == 1) {
            operationManager.setReturnType(primaryKeys[0].typeId);
        }
        if (entityCtor) {
            dtoManager.addChildrenFrom(DomainHelper.getChildrenOfType(entityCtor, "Parameter")
                .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        }
        else {
            if (!surrogateKey) {
                const toAdd = primaryKeys.filter(x =&gt; DomainHelper.isUserSuppliedPrimaryKey(lookup(x.id)));
                ServicesHelper.addDtoFieldsFromDomain(dtoManager.getElement(), toAdd);
            }
            dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
            dtoManager.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        }
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.addChild("dto", dtoManager.id);
        onMapDto(dtoManager.getElement(), folder, false, `${baseName}Create`, true);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardCreateOperation = createStandardCreateOperation;
    function createStandardFindByIdOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${entity.getName()}ById`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.addChildrenFrom(DomainHelper.getPrimaryKeys(entity));
        operationManager.collapse();
    }
    servicesCrud.createStandardFindByIdOperation = createStandardFindByIdOperation;
    function createStandardFindAllOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${pluralize(entity.getName())}`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id, true);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.collapse();
    }
    servicesCrud.createStandardFindAllOperation = createStandardFindAllOperation;
    function createStandardUpdateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}UpdateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Update${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Update${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
            childType: "property"
        });
        let operationManager = new ElementManager(createElement("Operation", `Update${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        dtoManager.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.addChild("dto", dtoManager.id);
        onMapDto(dtoManager.getElement(), folder, false, `${baseName}Update`);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardUpdateOperation = createStandardUpdateOperation;
    function createStandardDeleteOperation(service, entity) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        if (service.getChildren().some(x =&gt; x.getName() == `Delete${entity.getName()}`)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", `Delete${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.collapse();
    }
    servicesCrud.createStandardDeleteOperation = createStandardDeleteOperation;
    function createCallOperationCommand(service, operation, entity, folder) {
        var _a, _b;
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${operation.getName()}Dto`;
        if (service.getChildren().some(x =&gt; x.getName() == `${operation.getName()}`)) {
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
            childType: "property"
        });
        let operationManager = new ElementManager(createElement("Operation", `${operation.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(operation, ServicesConstants.dtoToDomainOperation);
        dtoManager.getElement().setMapping([entity.id, operation.id], ServicesConstants.dtoToDomainOperation);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        for (const key of primaryKeys) {
            dtoManager.addChild(key.name, lookup(key.id).typeReference);
        }
        dtoManager.addChildrenFrom(DomainHelper.getChildrenOfType(operation, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.addChild("dto", dtoManager.id);
        if (DomainHelper.isComplexType((_a = operation.typeReference) === null || _a === void 0 ? void 0 : _a.getType())) {
            var resultDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(operationManager.getElement(), operation) + "Result", (_b = operation.typeReference) === null || _b === void 0 ? void 0 : _b.getType(), false, CrudConstants.dtoFromEntityMappingId, folder, false);
            operationManager.setReturnType(resultDto.id, operation.typeReference.isCollection, operation.typeReference.isNullable);
        }
        onMapDto(dtoManager.getElement(), folder, false, `${operation.getName()}`);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createCallOperationCommand = createCallOperationCommand;
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
    /*
        function getOrCreateCrudDto(
            command: MacroApi.Context.IElementApi,
            mappedElement: MacroApi.Context.IElementApi,
            autoAddPrimaryKey: boolean,
            mappingTypeSettingId: string,
            inbound: boolean = false
        ): MacroApi.Context.IElementApi {
            if (mappedElement.typeReference == null) throw new Error("TypeReference is undefined");
    
            let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
            let domainName = mappedElement.typeReference.getType().getName();
            let baseName = command.getMetadata("baseName")
                ? `${command.getMetadata("baseName")}${domainName}`
                : domainName;
            let dtoName = `${originalVerb}${baseName}`;
            let dto = getOrCreateDto(dtoName, command.getParent());
            dto.setMetadata("originalVerb", originalVerb);
            dto.setMetadata("baseName", baseName);
    
            //dtoField.typeReference.setType(dto.id);
            const entityCtor: MacroApi.Context.IElementApi = mappedElement.typeReference.getType()
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
                // In descending order:
                return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
            })[0];
            if (inbound &amp;&amp; entityCtor != null) {
                dto.setMapping([mappedElement.typeReference.getTypeId(), entityCtor.id], mapToDomainConstructorForDtosSettingId);
                addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto);
            } else {
                dto.setMapping(mappedElement.typeReference.getTypeId(), mappingTypeSettingId);
                addDtoFields(autoAddPrimaryKey, mappedElement, dto);
            }
    
            return dto;
        }
    
        function addDtoFieldsForCtor(autoAddPrimaryKey: boolean, ctor: MacroApi.Context.IElementApi, dto: MacroApi.Context.IElementApi) {
        
            let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        
            childrenToAdd.forEach(e =&gt; {
                if (e.mapPath != null) {
                    if (dto.getChildren("Parameter").some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {
                        return;
                    }
                }
                else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                    return;
                }
        
                let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
                field.setMapping(e.mapPath);
                if (DomainHelper.isComplexTypeById(e.typeId)){
                    let newDto = getOrCreateCommandCrudDto(dto, field, autoAddPrimaryKey, mapFromDomainMappingSettingId, true );
                    field.typeReference.setType(newDto.id);
                }else{
                    field.typeReference.setType(e.typeId);
                }
                field.typeReference.setIsCollection(e.isCollection);
                field.typeReference.setIsNullable(e.isNullable);
            });
        
            dto.collapse();
        }
        
        function addDtoFields(autoAddPrimaryKey: boolean, mappedElement: MacroApi.Context.IElementApi, dto: MacroApi.Context.IElementApi) {
            let dtoUpdated = false;
            let domainElement = mappedElement
                .typeReference
                .getType();
            let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
            let isCreateMode = dto.getMetadata("originalVerb")?.toLowerCase()?.startsWith("create") == true;
            for (var keyName of Object.keys(attributesWithMapPaths)) {
                let entry = attributesWithMapPaths[keyName];
                if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
                    continue;
                }
                if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                    continue;
                }
                let field = createElement("DTO-Field", entry.name, dto.id);
                field.typeReference.setType(entry.typeId);
                field.typeReference.setIsNullable(entry.isNullable);
                field.typeReference.setIsCollection(entry.isCollection);
                field.setMapping(entry.mapPath);
                dtoUpdated = true;
            }
        
            if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
                addPrimaryKeys(dto, domainElement, true);
            }
        
            if (dtoUpdated) {
                dto.collapse();
            }
        }  */
})(servicesCrud || (servicesCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/create-crud/create-crud.ts
 */
await servicesCrud.execute();
</script>
        </runScript>
        <runScript group="1" type="run-script">
          <text>Create CRUD Traditional Service</text>
          <shortcut>alt + s</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "advanced";</isOptionVisibleFunction>
          <dependencies>
            <dependency name="Crud Api" id="61a8411f-b5bc-4a00-9a37-a967e0893d9d" />
          </dependencies>
          <script>await CrudApi.createTraditionalService(element);</script>
        </runScript>
        <runScript group="1" type="run-script">
          <text>Create CRUD CQRS Operations</text>
          <shortcut>alt + c</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>function folderHasCommandOrQueries(element) {
    return element.specialization === "Folder" &amp;&amp; (element.getChildren("Command").length &gt; 0 || element.getChildren("Query").length &gt; 0);
}

return application.isModuleInstalled("Intent.Modelers.Services.CQRS") &amp;&amp;
    application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "basic" &amp;&amp;
    !folderHasCommandOrQueries(element);</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
;
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x),
            additionalInfo: `(${x.getParents().map(item =&gt; item.getName()).join("/")})`
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    /**
     * Returns true if the attribute is a foreign key on a compositional one-to-many relationship (i.e. is managed by the DB and should not be set).
     * @param attribute
     * @returns
     */
    static isManagedForeignKey(attribute) {
        var _a, _b;
        let fkAssociation = (_b = (_a = attribute.getStereotype("Foreign Key")) === null || _a === void 0 ? void 0 : _a.getProperty("Association")) === null || _b === void 0 ? void 0 : _b.getSelected();
        return fkAssociation != null &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsCollection() &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsNullable();
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
/// &lt;reference path="attributeWithMapPath.ts" /&gt;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
ServicesConstants.dtoToDomainOperation = "8d1f6a8a-77c8-43a2-8e60-421559725419";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="../../common/attributeWithMapPath.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto) {
    let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
    childrenToAdd.forEach(e =&gt; {
        if (e.mapPath != null) {
            if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                return;
            }
        }
        else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
            return;
        }
        let field = createElement("DTO-Field", e.name, dto.id);
        field.typeReference.setType(e.typeId);
        field.typeReference.setIsCollection(e.isCollection);
        field.typeReference.setIsNullable(e.isNullable);
        if (this.mappedElement != null &amp;&amp; e.mapPath) {
            field.setMapping(e.mapPath);
        }
    });
    dto.collapse();
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", toPascalCase(entry.name), dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; {
        var _a;
        return !x.hasStereotype("Primary Key") &amp;&amp;
            !legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
    });
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
class CrudConstants {
}
CrudConstants.mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
CrudConstants.mapToDomainConstructorForDtosSettingId = "8d1f6a8a-77c8-43a2-8e60-421559725419";
CrudConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class CrudHelper {
    static getName(command, mappedElement, dtoPrefix = null) {
        if (mappedElement.typeReference != null)
            mappedElement = mappedElement.typeReference.getType();
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        if (dtoPrefix)
            dtoName = `${dtoPrefix}${dtoName}`;
        return dtoName;
    }
    static getOrCreateCrudDto(dtoName, mappedElement, autoAddPrimaryKey, mappingTypeSettingId, folder, inbound = false) {
        let dto = CrudHelper.getOrCreateDto(dtoName, folder);
        //dtoField.typeReference.setType(dto.id);
        const entityCtor = mappedElement
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (inbound &amp;&amp; entityCtor != null) {
            dto.setMapping([mappedElement.id, entityCtor.id], CrudConstants.mapToDomainConstructorForDtosSettingId);
            CrudHelper.addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto, folder);
        }
        else {
            dto.setMapping(mappedElement.id, mappingTypeSettingId);
            CrudHelper.addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder);
        }
        return dto;
    }
    static getOrCreateDto(elementName, parentElement) {
        const expectedDtoName = elementName.replace(/Dto$/, "") + "Dto";
        let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
        if (existingDto) {
            return existingDto;
        }
        let dto = createElement("DTO", expectedDtoName, parentElement.id);
        return dto;
    }
    static addDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto, folder) {
        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        childrenToAdd.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
            field.setMapping(e.mapPath);
            if (DomainHelper.isComplexTypeById(e.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(e.typeId);
            }
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
        });
        dto.collapse();
    }
    static addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder) {
        var _a, _b;
        let dtoUpdated = false;
        let domainElement = mappedElement;
        let attributesWithMapPaths = CrudHelper.getAttributesWithMapPath(domainElement);
        let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
        for (var keyName of Object.keys(attributesWithMapPaths)) {
            let entry = attributesWithMapPaths[keyName];
            if (isCreateMode &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {
                continue;
            }
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                continue;
            }
            let field = createElement("DTO-Field", entry.name, dto.id);
            field.setMapping(entry.mapPath);
            if (DomainHelper.isComplexTypeById(entry.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(entry.typeId);
            }
            field.typeReference.setIsNullable(entry.isNullable);
            field.typeReference.setIsCollection(entry.isCollection);
            dtoUpdated = true;
        }
        if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
            CrudHelper.addPrimaryKeys(dto, domainElement, true);
        }
        if (dtoUpdated) {
            dto.collapse();
        }
    }
    static isOwnerForeignKey(attributeName, domainElement) {
        for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
            if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
                return true;
            }
        }
        return false;
    }
    static addPrimaryKeys(dto, entity, map) {
        const primaryKeys = CrudHelper.getPrimaryKeysWithMapPath(entity);
        for (const primaryKey of primaryKeys) {
            const name = CrudHelper.getDomainAttributeNameFormat(primaryKey.name);
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
                continue;
            }
            const dtoField = createElement("DTO-Field", CrudHelper.getFieldFormat(name), dto.id);
            dtoField.typeReference.setType(primaryKey.typeId);
            if (map &amp;&amp; primaryKey.mapPath != null) {
                console.log(`Doing mapping for ${dtoField.id}`);
                dtoField.setMapping(primaryKey.mapPath);
            }
        }
    }
    static getPrimaryKeysWithMapPath(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return Object.values(keydict);
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.isManagedForeignKey(x) &amp;&amp; // essentially also an attribute set by infrastructure
                !CrudHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return attrDict;
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !CrudHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static getDomainAttributeNameFormat(str) {
        let convention = CrudHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
            default:
                return str;
        }
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
}
/**
 * Workaround for element's from referenced packages not having getParent()
 * @param element The element whose parent should be searched for
 * @param parentSpecializationType The specialization type of the parent
 */
function getParent(element, parentSpecializationType) {
    const elements = lookupTypesOf(parentSpecializationType);
    const parent = elements
        .find(x =&gt; x.getChildren(element.specialization)
        .some(child =&gt; child.id === element.id));
    if (parent == null) {
        throw new Error("Could not find parent");
    }
    return parent;
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
/// &lt;reference path="../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/getParent.ts" /&gt;
/**
 * Gets select details of a mapped Command/Query. Intended for centralized logic of working out
 * things like keys for both the entity and owning entity if applicable.
 *
 * If the Command is for entity creation (either due to being mapped to a constructor or being
 * prefixed with "Create"), then primary keys for the entity are not populated.
 * @param request The Command or Query that has been mapped
 */
function getMappedRequestDetails(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    // Advanced mapping:
    if (mappedElement == null) {
        const advancedMappings = request.getAssociations()
            .filter(x =&gt; x.hasMappings(queryEntityMappingTypeId) ||
            x.hasMappings(createEntityMappingTypeId))
            .map(x =&gt; x.getMapping(queryEntityMappingTypeId) ||
            x.getMapping(createEntityMappingTypeId));
        if (advancedMappings.length === 1) {
            mappedElement = advancedMappings[0].getTargetElement();
        }
    }
    if (mappedElement == null) {
        return null;
    }
    let entity = mappedElement;
    if (entity.specialization !== "Class") {
        entity = getParent(entity, "Class");
    }
    const result = {
        entity: entity,
        mappingTargetType: mappedElement.specialization,
        entityKeyFields: [],
        ownerKeyFields: []
    };
    result.owningEntity = DomainHelper.getOwningAggregate(entity);
    // As long as it's not for creation, populate the PKs of the entity:
    if (result.mappingTargetType !== "Class Constructor" &amp;&amp;
        !request.getName().toLowerCase().startsWith("Create")) {
        result.entityKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity)
            : getKeysForOperationMapping(request, entity);
    }
    // If the entity is owned, populate its fields:
    if (result.owningEntity != null) {
        result.ownerKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity, result.owningEntity)
            : getKeysForOperationMapping(request, entity, result.owningEntity);
    }
    return result;
    /**
     * Return field details for primary keys. As requests mapped to operations and constructors can
     * never possibly map the attributes, these fields can only ever be matched by name.
     * @param request The CQRS Command or Query entity
     * @param owningEntity The Owning Aggregate Class
     */
    function getKeysForOperationMapping(request, entity, owningEntity) {
        const pks = DomainHelper.getPrimaryKeys(owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity);
        return pks.map(pk =&gt; {
            let fieldName = toPascalCase(pk.name);
            if (owningEntity != null) {
                fieldName = removePrefix(fieldName, toPascalCase(owningEntity.getName()));
                fieldName = `${owningEntity.getName()}${toCamelCase(fieldName)}`;
            }
            fieldName = ServicesHelper.getFieldFormat(fieldName);
            const existingField = request.getChildren("DTO-Field").find(field =&gt; field.getName().toLowerCase() == fieldName.toLowerCase());
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: [],
                name: fieldName,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
    function getKeysForClassMapping(request, entity, owningEntity) {
        const keys = owningEntity != null
            ? DomainHelper.getForeignKeys(entity, owningEntity)
            : DomainHelper.getPrimaryKeys(entity);
        return keys.map(pk =&gt; {
            const existingField = request.getChildren("DTO-Field").find(field =&gt; {
                if (field.getMapping() != null) {
                    return field.getMapping().getPath().some(x =&gt; x.id == pk.id);
                }
                return (pk.name.toLowerCase() === field.getName().toLowerCase());
            });
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: pk.mapPath,
                name: pk.name,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/**
 * Ensures that for the provided contract, it has the provided field creating it if necessary and
 * then ensure the field has the correct typeReference details and order.
 * The field's element is returned.
 */
function ensureHasField(options) {
    const { contract, fieldDetail, mappingSettingsId, order } = options;
    let field = fieldDetail.existingId != null
        ? contract.getChildren("DTO-Field").find(x =&gt; x.id === fieldDetail.existingId)
        : createElement("DTO-Field", fieldDetail.name, contract.id);
    field.typeReference.setType(fieldDetail.typeId);
    field.typeReference.setIsCollection(fieldDetail.isCollection);
    field.typeReference.setIsNullable(fieldDetail.isNullable);
    if (order != null) {
        field.setOrder(order);
    }
    if (mappingSettingsId != null) {
        field.setMapping(fieldDetail.mappingPath, mappingSettingsId);
        console.warn("mapping:" + fieldDetail.mappingPath);
    }
    return field;
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/// &lt;reference path="ensureHasField.ts" /&gt;
function onMapCommand(element, isForCrudScript, excludePrimaryKeys = false, inbound = false) {
    var _a, _b, _c;
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    const mappingDetails = getMappedRequestDetails(element);
    if (mappingDetails &amp;&amp; (isForCrudScript || mappingDetails.mappingTargetType !== "Class")) {
        let order = 0;
        let keyFields = mappingDetails.ownerKeyFields;
        if (!excludePrimaryKeys) {
            keyFields = keyFields.concat(mappingDetails.entityKeyFields);
        }
        for (const keyField of keyFields) {
            ensureHasField({
                contract: element,
                fieldDetail: keyField,
                order: order++
            });
        }
    }
    if (mappingDetails &amp;&amp;
        mappingDetails.mappingTargetType === "Operation" &amp;&amp;
        DomainHelper.isComplexType((_c = (_b = (_a = element.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType())) {
        let mappedElement = element.getMapping().getElement();
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, mappedElement), mappedElement.typeReference.getType(), false, mapFromDomainMappingSettingId, element.getParent(), false);
        setTypeRef(element, newDto, mappedElement);
    }
    const fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; ((_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement().specialization.startsWith("Association")); });
    fields.forEach(field =&gt; {
        let mappedElement = field.getMapping().getElement();
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, mappedElement), mappedElement.typeReference.getType(), !excludePrimaryKeys, projectMappingSettingId, element.getParent(), inbound);
        setTypeRef(field, newDto, mappedElement);
    });
    const complexFields = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp;
            DomainHelper.isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType());
    });
    complexFields.forEach(cf =&gt; {
        let mappedElement = cf.getMapping().getElement();
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, mappedElement), mappedElement.typeReference.getType(), false, projectMappingSettingId, element.getParent(), inbound);
        setTypeRef(cf, newDto, mappedElement);
    });
    function setTypeRef(element, newDto, mappedElement) {
        var _a, _b;
        element.typeReference.setType(newDto.id);
        if (((_a = mappedElement === null || mappedElement === void 0 ? void 0 : mappedElement.typeReference) === null || _a === void 0 ? void 0 : _a.isCollection) != null) {
            element.typeReference.setIsCollection(mappedElement.typeReference.isCollection);
        }
        if ((_b = mappedElement === null || mappedElement === void 0 ? void 0 : mappedElement.typeReference) === null || _b === void 0 ? void 0 : _b.isNullable) {
            element.typeReference.setIsNullable(mappedElement.typeReference.isNullable);
        }
    }
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
function onMapDto(element, folder, autoAddPrimaryKey = true, dtoPrefix = null, inbound = false) {
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b, _c; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; ((_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.specialization.startsWith("Association")); });
    fields.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement().typeReference.getType(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (DomainHelper.isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()));
    });
    complexAttributes.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), false, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
function onMapQuery(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; x.getMapping().getElement().specialization.startsWith("Association"); });
    fields.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d, _e;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (complexTypes.includes((_e = (_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()) === null || _e === void 0 ? void 0 : _e.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
}
function getOrCreateQueryCrudDto(element, dtoField) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    let mappedElement = dtoField.getMapping().getElement();
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : `${domainName}`;
    let dtoName = baseName;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMappingSettingId);
    dto.setMetadata("baseName", baseName);
    ensureDtoFieldsQuery(mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
function ensureDtoFieldsQuery(mappedElement, dto) {
    let dtoUpdated = false;
    let mappedElementAttributes = mappedElement
        .typeReference
        .getType()
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; !dtoFields.some(y =&gt; x.getName() === y.getName()))) {
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == attribute.getName())) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.getName(), dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
class ElementManager {
    constructor(innerElement, settings) {
        var _a;
        this.innerElement = innerElement;
        this.settings = settings;
        this.mappedElement = (_a = innerElement.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.innerElement.id; }
    ;
    setReturnType(typeId, isCollection, isNullable) {
        this.innerElement.typeReference.setType(typeId);
        if (isCollection != null) {
            this.innerElement.typeReference.setIsCollection(isCollection);
        }
        if (isNullable != null) {
            this.innerElement.typeReference.setIsNullable(isNullable);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.innerElement.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.innerElement.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.innerElement;
    }
    collapse() {
        this.innerElement.collapse();
    }
}
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../_common/onMapCommand.ts" /&gt;
/// &lt;reference path="../_common/onMapDto.ts" /&gt;
/// &lt;reference path="../_common/onMapQuery.ts" /&gt;
/// &lt;reference path="../../common/attributeWithMapPath.ts" /&gt;
/// &lt;reference path="../../common/elementManager.ts" /&gt;
var _a, _b;
const privateSettersOnly = ((_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")) === null || _b === void 0 ? void 0 : _b.value) == "true";
const mapToDomainOperationSettingId = "7c31c459-6229-4f10-bf13-507348cd8828";
var cqrsCrud;
(function (cqrsCrud) {
    async function execute(element) {
        var _a;
        let entity = await DomainHelper.openSelectEntityDialog();
        if (entity == null) {
            return;
        }
        if (privateSettersOnly &amp;&amp; !hasConstructor(entity)) {
            await dialogService.warn(`Partial CQRS Operation Creation.
Some CQRS operations were created successfully, but was limited due to private setters being enabled, and no constructor is present for entity '${entity.getName()}'.

To avoid this limitation in the future, either disable private setters or add a constructor element to the entity.`);
        }
        const owningEntity = DomainHelper.getOwningAggregate(entity);
        const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? owningEntity.getName() : entity.getName());
        const folder = (_a = element.getChildren().find(x =&gt; x.getName() == pluralize(folderName))) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Folder", pluralize(folderName), element.id);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const hasPrimaryKey = primaryKeys.length &gt; 0;
        const resultDto = createCqrsResultTypeDto(entity, folder);
        if (!privateSettersOnly || hasConstructor(entity)) {
            createCqrsCreateCommand(entity, folder, primaryKeys);
        }
        if (hasPrimaryKey) {
            createCqrsFindByIdQuery(entity, folder, resultDto);
        }
        createCqrsFindAllQuery(entity, folder, resultDto);
        if (hasPrimaryKey &amp;&amp; !privateSettersOnly) {
            createCqrsUpdateCommand(entity, folder);
        }
        const operations = DomainHelper.getCommandOperations(entity);
        for (const operation of operations) {
            createCqrsCallOperationCommand(entity, operation, folder);
        }
        if (hasPrimaryKey) {
            createCqrsDeleteCommand(entity, folder);
        }
    }
    cqrsCrud.execute = execute;
    function hasConstructor(entity) {
        return entity.getChildren("Class Constructor").length &gt; 0;
    }
    function createCqrsCreateCommand(entity, folder, primaryKeys) {
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = getBaseNameForElement(owningAggregate, entity, false);
        const expectedCommandName = `Create${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            const returnType = primaryKeys.length == 1
                ? primaryKeys[0].typeId
                : null;
            const command = folder.getChildren().filter(x =&gt; x.getName() == expectedCommandName)[0];
            command.typeReference.setType(returnType);
            return command;
        }
        const commandManager = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        const entityCtor = entity
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (entityCtor != null) {
            commandManager.mapToElement(entityCtor, mapToDomainOperationSettingId);
            commandManager.getElement().setMapping([entity.id, entityCtor.id], mapToDomainOperationSettingId);
        }
        else if (!privateSettersOnly) {
            commandManager.mapToElement(entity);
        }
        else {
            console.warn(`Private Setters are enabled with no constructor present on entity '${entity.getName()}'. In order for '${expectedCommandName}' to map to that entity, either disable private setters or model a constructor element and try again.`);
        }
        commandManager.getElement().setMetadata("baseName", baseName);
        const surrogateKey = primaryKeys.length === 1;
        if (surrogateKey) {
            commandManager.setReturnType(primaryKeys[0].typeId);
        }
        if (entityCtor) {
            commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(entityCtor, "Parameter")
                .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        }
        else {
            const toAdd = primaryKeys.filter(x =&gt; DomainHelper.isUserSuppliedPrimaryKey(lookup(x.id)));
            if (toAdd.length &gt; 0) {
                ServicesHelper.addDtoFieldsFromDomain(commandManager.getElement(), toAdd);
            }
            commandManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
            commandManager.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        }
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandManager.getElement());
        }
        onMapCommand(commandManager.getElement(), true, true, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCreateCommand = createCqrsCreateCommand;
    function createCqrsFindByIdQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedQueryName = `Get${baseName}ByIdQuery`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(query, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        onMapQuery(query);
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindByIdQuery = createCqrsFindByIdQuery;
    function createCqrsFindAllQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, true);
        let expectedQueryName = `Get${baseName}Query`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.typeReference.setIsCollection(true);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindAllQuery = createCqrsFindAllQuery;
    function createCqrsUpdateCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Update${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        command.mapToElement(entity);
        command.getElement().setMetadata("baseName", baseName);
        command.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        command.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command.getElement(), primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command.getElement());
        }
        onMapCommand(command.getElement(), true, true);
        command.collapse();
        return command.getElement();
    }
    cqrsCrud.createCqrsUpdateCommand = createCqrsUpdateCommand;
    function createCqrsCallOperationCommand(entity, operation, folder) {
        var _a;
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = (_a = owningAggregate === null || owningAggregate === void 0 ? void 0 : owningAggregate.getName()) !== null &amp;&amp; _a !== void 0 ? _a : "";
        let operationName = operation.getName();
        operationName = removeSuffix(operationName, "Async");
        operationName = toPascalCase(operationName);
        const commandName = `${operationName}${entity.getName()}Command`;
        const existing = folder.getChildren().find(x =&gt; {
            var _a, _b;
            return x.getName() == commandName ||
                ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) === operation.id;
        });
        if (existing) {
            return existing;
        }
        const commandElement = createElement("Command", commandName, folder.id);
        commandElement.setMetadata("baseName", baseName);
        const commandManager = new ElementManager(commandElement, { childSpecialization: "DTO-Field" });
        commandManager.mapToElement([entity.id, operation.id], mapToDomainOperationSettingId);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        for (const key of primaryKeys) {
            commandManager.addChild(key.name, lookup(key.id).typeReference);
        }
        commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(operation, "Parameter")
            .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandElement);
        }
        onMapCommand(commandElement, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCallOperationCommand = createCqrsCallOperationCommand;
    function createCqrsDeleteCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Delete${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = createElement("Command", expectedCommandName, folder.id);
        command.setMapping(entity.id);
        command.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), command.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command);
        }
        onMapCommand(command, true);
        command.collapse();
        return command;
    }
    cqrsCrud.createCqrsDeleteCommand = createCqrsDeleteCommand;
    function createCqrsResultTypeDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedDtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedDtoName);
        if (existing) {
            return existing;
        }
        let dto = createElement("DTO", expectedDtoName, folder.id);
        dto.setMetadata("baseName", baseName);
        dto.setMapping(entity.id);
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), dto.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        ServicesHelper.addDtoFieldsFromDomain(dto, primaryKeys);
        let attributesWithMapPaths = DomainHelper.getAttributesWithMapPath(entity);
        for (var attr of attributesWithMapPaths) {
            if (dto.getChildren("DTO-Field").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == attr.id; })) {
                continue;
            }
            let field = createElement("DTO-Field", attr.name, dto.id);
            field.typeReference.setType(attr.typeId);
            field.setMapping(attr.mapPath);
        }
        onMapDto(dto, folder);
        dto.collapse();
        return dto;
    }
    cqrsCrud.createCqrsResultTypeDto = createCqrsResultTypeDto;
    function addAggregatePkToCommandOrQuery(owningAggregate, commandOrQuery) {
        if (owningAggregate != null) {
            var aggPks = DomainHelper.getPrimaryKeys(owningAggregate);
            aggPks.forEach(x =&gt; {
                if (x.name.toLowerCase() == "id") {
                    x.name = `${owningAggregate.getName()}Id`;
                }
                x.id = null;
                x.mapPath = null;
                x.isCollection = false;
                x.isNullable = false;
            });
            ServicesHelper.addDtoFieldsFromDomain(commandOrQuery, aggPks);
        }
    }
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
})(cqrsCrud || (cqrsCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/create-crud-macro/create-crud-macro.ts
 */
await cqrsCrud.execute(element);
</script>
        </runScript>
        <runScript group="1" type="run-script">
          <text>Create CRUD CQRS Operations</text>
          <shortcut>alt + c</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return application.isModuleInstalled("Intent.Modelers.Services.CQRS") &amp;&amp;
    application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "advanced";</isOptionVisibleFunction>
          <dependencies>
            <dependency name="Crud Api" id="61a8411f-b5bc-4a00-9a37-a967e0893d9d" />
          </dependencies>
          <script>await CrudApi.createCQRSService(element);</script>
        </runScript>
      </contextMenuOptions>
      <creationOptions />
      <scriptOptions>
        <option group="1" type="run-script">
          <text>Create CRUD Traditional Service</text>
          <shortcut>alt + s</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAX2klEQVR4Xu2cCXxU1b3Hf///nUkyIWFL2FEQQUAEAiibIERF6v4qLX3iVi2ofdhXEBQzVYiggFjS+sG2D5fKoq2Ppq0SS4u17MGwyi6bsiUhQCDs2WbueZ9z7j6TAUIo0NfMp3Um95577jnf+9/PuRBqPzUiQDW6uvZi1AKsoRDUAqwFWEMCNby8VgJrAdaQQA0v/5eRQPFuoCVQ2RbMjUFcF9CbgzgAoKliQEiAQFMQAeyiombIRSCUqaOC9qlvpgNgHAFQDC20D9tKD1Im9OryvKoACgHCz5GIFCSi3HcDfDwIEA8A1AUEzQBlDll+uX+bFFVcYR232luzVN+k/ud8m8iMa1aCaRk08SeUiz1ITj6L+wpLiSBigb0qAIp50FCi3Q/gByDqBEGtwKgbBcyKuqqCZ8N0TUkes+G5wNsQq3gIzkM5ClABGJuh00eoU7KI7kF5JMgrClDMjL8eovJ7AI0FUWqUZHgkzAZwFkRnABwHIaS+DSBhEB2XSmpDY5teqj1xohTzfAqI6gHwnfe+xgPbAWAm4rXf071Hiqz+rhhAMVMbBoG3QVRf6VOkWjkSVQCBPwP0FUjkwu8vgaAwQqcqkKxUq0JNZhtAmebvCDER8xBnHzqVGg+JM1weh5Duh661BlFnMNIh0A9E1zjpRYQEG6pcAuDH9N1j80xDUF2zWbP2IhM+NPFNAuElR71sm1QMQUvBWAPW1yEcv5lGnDlUsztW72rxaWpzVFTeBOYeIPQF0BuwtMMep3RIr+HBo1MuuwSKd9EFId86MHym3ZeqVygHRCMq36nedP/5rcUCxKO84bMAxgLUHAQ2nVQpgNsuP8CZviwAo22VBZ7G6coP6XnIAV21H5GTnAo97ikleSC/6e1HXQGA/nkg8X1XONGVRlRsumrJuQYmPktNRxjzQUgytIfHXX6A72j3AZzjCi9OA5iBQOBNeuSENNBX3UfMaxlAfNn7IDwAoI7L6997+QG+57sDgv5qq4F6ktLbUQkg/gFgKYSeRz+qXHulSIqFTeqgorILdO4LIfqB+G5AxHsiBaJy6Prgyw/wHd9CEN9VdYBrwVToQgB9Cta/QJj+BuE7g7i4cpw5FkIDhGho1SHLhUJXoU2guQ+lpX6gMg7xCQ2h63eDcC9AtwIInD8+pODlB/i+PxeC+qrBCdoPRjGA7oZNqSpzsId4EoRiEJ2EEKfBMmim0yCxRyW/LM4gzHvhc+ezRvYH6NcBSFI5MnNbCCSAVDSYaAbTDUCQQbUrPawyc9kIovaAul42vkIAQX0NOyJW0lMVt4r34+8G06MgdAOoDQjx3snY8ZfBIzJDqVa65n5Isfq14cnI4FsQrQPofxDw70RZ5Q4QUtT4GVcA4G+lBLIhgTAAql8yAfsD6uBMnSSwuAck7gUwCETJnsT/ksFzgfTkxtI00J8A+hsg/o4E7QQNPiRTR4gvWqQYAM10kK4IwLhcKAlUkrSSnixTAGN9xEd12wF6MwhxHQRdB0ZjkCw0qKDWKGcZqp8IyHMRxQSj42IwSW8vP4UgVIA4H9BPgrgARPsQFgdB4W/pu8f3xhyLBFgRkjmxlU9fCQmMywWxAZCxkp44N8Bzwb3c55QESoCWCkNcCYAJr4LRzpz8Lvph2YTLDeJi76cAVoYdCaQrAPBiB381XGcDVBKoTJAjgfXfXPMg69QWmlEPt6viMkKwRm/9YPZUzQHNKBdbUYOKFlx1dfXT/Nv95W6jWS3sH8YVrjbm0Oy+1Hl1T3PM7lI+xP5t32/1h0sJXgEMWRKobG2QUt9Y3zwkwp8Q4RZpgI3wxvVt1umUbY487jpHroqwXdoz4zrVm0o2DAOvvu3KOpl23/yW93DVBq3fUfdXHVXRp9uJgFayiB+8dWhjy4HUiKcCGNYdFZZhTL2pq0cQSJWR5MTs+58LogeqMRMjG/MC8sCKghcJ0brWfFARD858rvY9oh+mqybrgsjMz2wd0vKSlMlsgHYcSEGqN2V1BoDJ7slfkAR4JDI2REcyq5LAKiCeSzIt7bDiXEuS3dLvPqeehZ617Xutx9RI9MyLxcLm14DEJoDqm+UsB6AtLR5JtFTvAtX6vBP0QoxUz6olNuLe7nuo4cUyD9bxmgMUi1snoLL8NoAmAuhlwIOAoJFU7/W8DBBP9tgkDwjHNhltIgfsQFFqFaHe0XbPyQBsk1GFufDat4uHSFwzgOJvzYeD9HEgbgXAKKQaDE5Bpx4KoAAZKuwGZEM8t8H32KZzORyP84i4VwynEgkx2sZGOh7LQTn2kCGytg29MBUWC1q0BIe7AugB4lsAMdAonlaZ9ulgPGkD9HrHSNV1/W06jGiP7fau5g2jJCu6jUeiI+2f63qPk3M96Cipt02QZQxF1vahrceoXHt+ahLqxMehIsyoDPkR7++DsN4RjFsA+g7IXL2LlW+Dzqr00Rq0JoKU/HpeBglSKuwdZIRXtFXXcRgxw55z2KaqH1QVEnnecCfCnLil3x0VkAlwYZPGqBTLzTzWZ5axoncpVA3vGIimg3gFoH8CkCx/yRJakOpOXPW4IPEsWYvQ7qdrhahs2Tb2xG+KuAq03RKq/lLH3R5YHbJCGTM4dry98bDUYbcUKtpO5G09eHXEAmZeaMWJ5q2d80S/3/6frWao5UofF3grO7Y9s6THcA4EuSvhAAQ2gfXP6M6ibNlAhTFygd3KRJiDhHnzNGzr5MohYjj8G4FOlyIWqHYfN1b7CvcFjbYt0ZdkpocUQL9WYJ9zBesAToEoD0T/gBBfQOO9SKSz1Dffs1KoALLaoSBBelO5Go3yX+Bi8WlqMnw8BuAjYJyGToegiWPQsYfuKZK7tM77sQHa20OuQEX6vKO8ihsogBq7ylkcpKTM5QMFaXc59syyOWaCTjh5IthzqjWvlDdW36GD77CMVmShQWP++vDotLlW+8ZvbX6MoHd02zjjnHGlIF5fNLKTsjHy03Lm1mEk+Ca7iWF2lYFUV4T1z/eO6LjEan/97N3PCBKtZH+emoX1h6AVOx9pveBSPBcHoFWR5iDVeTUvA9Anx4ro5baLk8GeLawB1J+yKpNYm+ANqt2BLucUP58m10/Vp9FbG+czcL/jsSNSOsaswh/f9KQLYDZAQ9xxqSc/Jw7ufardFKt9mzm7cyHQN7LYYMSQctkFWTsfaXNpUjkpgT7NcSKaBVDok+14KioEocKTP4sASDzBWkGLiuMIOcXPd/cAJIH7Y1VzCDSrcKQL4G+2ZoNpiARkQ/TGk8G9T7V3AM7enQsItUhV1T0IImvnI9dfeoDyZkxSAldmCIHJdhnLyPNcKRtHAQTxBE977+Bzise6AP5iw3witwR60z1BNKvIBbDFb7ZmE9GQWBJOoODe4W6Au3KFJYHucZhelukSAlwlF5WkBFoqbAHUhSGBEU/dtEOFp37W21bhuq+vymSWEmitLkbV8XKORgJUKuyUqSypNUVmVtFzjgRKgAA8Kmzfi9TWKC/AD3blCmMbmqfOaEkvBLJ2P3aJJHBx81SwfzvYXNaUq3IJ41dmMInJCpZZDIiwh4WnXvECJKYJTl4alejnHH2hh6PCWRvkZpz7Y0k4iD0Am/16SzZHSaBTZ2TyAmz92125RKKvO6Wz7Z/hfi4dwOWtHwbELIDizMwtSEmvrOgUJu4iS+Oeirg8II8JlJ56pdcnltFuMHFlZ/j9N7nL97aHYw1CDxUef7HnUutYatb6ARppze027pBd/g5jz6H/7ppnnW/2qy39fJp2TXR7YzwUqty0/+lOW63z132wc5AgpBpjN9qYv5SnF77Q9t0Pt/vqYr2wyGtbFxWhbmDxEwgMsTMZQiVA95kZ8MV2///3OrG4pVwfGgHQMBAaK6lTWmrOmagUGvf/twcocps0RrmvGVi7ASRugKA0sNyrQ20cYFalxcnBTZAvUMIryx+HwDNkrX65qhFmWFB8dnyfBy1ZS5606kdgkjs17aKBXSQwIt7cknE9XrTaN/z5umlEdKtTSLAGYygdCf2vh0alvWar8NubXyemgdbfJIsJVjBNMvDGzIIRN86xzl/77o6ZpOEmsxxhbFlRRQnTbgp8/M0TbWeoqnIodC9YpBm7GKg3CJ0BSnYVSY1uq67InALha4A6Gzsi1I2ClPDyigzA8cLeIqYaROGZzL62F06a9GUmkduJRBVic0peusV2IilvrjecSGSx1ZH9WYdHpdmBdNO3N2cTYIQxyqk5T186N8EULHi6ox0HXvv+9lwSqMKJ2AtkWd8+0W6M+Pya5tBEgUsFTVimKDiq6T0OrAfjPQhahDIcR6LYCrCxtYNMgEKIyd4g1JMteAG++mWm7YXNSVqibnrvnOMegOsUwNhLpvACnLE5G4Qhbq/tLYtxsOBZF8B3t+fK3fReL+9ZlnUA+oRRjYlVMDU2ux8CYR+YF0HT/ky9d+db0i5WdUhBuNyIA1U/EmBwRYYgfXKsSF5K4NlXb3Uk0AToDXStMEMNLgqgQBWZiDkRokiAG7MBHmI8UEM63EumIAQLnu3kSKAECCmBVa87Eyjr2ydNCfTDBKimvxWgPSCxAWHOg+bbBK48DU0vQ5/8sqpe71IAdQugGmCQ4oJShXUlgTHWHCIA5maCZSYSq4qMnOMZPR0VnrZuvgToqKTtxUw+NOvIaEeFG7+1MZtVKmcF6FGVZy/Ad75WgXSsZVm2AMrXyRo1vQa+uBPUf/9F7cVWAEWls7AuJMCXlmWAoQJp98K6HcmDCksnuiQw0wDokUALpnxshJyTLoANpq2bTxBKhWPcY9aR0d1sGygBylQuKq+1TJW0gW4JlADhFBO895APQWTtebL9pcmFLYDuvTG+cUv7MtEAVS7yRtKm96PTpRNvnWF74Ykr+kP4+tlRt3vvjLHVdveJjF72npSGU9Z+XzDa2n2bG1qsfS+CxObiUWmfWf03/sWGh4ipvbNHxynpyz5EWF9aOLLzSqt9i3e3Pa4JamEsLURMgAGdsXr/D9vLzes1/igJhJRA+327y7+9rcazuIIdGACt/YEq0akFWJ3noQCStUNVFRuDpL2w+D5ltO341lQDIyiWi2LHyyf1G23dKDFz2X8A/gftMM4uYJs2Dth48uXev7Ta15+cNwrsk4vV6sPW6p8ZHAtw7rGx3d6zzjf6xaaRRPrNRmPjP+5tbgLij4ee62yrfItfb3kZTNe7t7gZC3lmRR3hhXuH3/hxdUDFamsADBsFVSNCCJLvxSUZILMeyFQGiBNEvFiD2BAmvoGJ2pa91m+ADXD88kxZD4zeAmfvCsg59XIv2wvXnbJ6PgGDiCD7XUMEWWjoBFAPIrQC4Y9Hx/ZQmY38NMraYMSBnhjTHddx8OBzThhjlr/OArSDSXQRRH2IOJWMBXAZemftG97x0jiRta2aQcRtAaGhMVoLoJGJZJPgNytLm23EjHZRb2ZbE0wYvzyTwBOiJmjGbUTsAVh/ct5jQqOvTwQabsZ/u/qdN0+r+8311/nitfhjz6fZ1ZVG09dng9msSEfvuxFEwUPPdbbjwEhpafSrrUkJfl9HQIwlwlDphS8FQLG2XS/omAZGf3ujpMBI8r+waLQgSgxNS39dvXrP9eS7Gl2gaU2gUSU03gjiDdbSX8L4Fa8QMDHWnkAB5JwZ38eWQDlBMQ8BhOt2gV/rDo3rqxddybcGfmyiwYcOuyGkTF9v1gMj9vs5QfW4op90mab6nZPUGAEtDUyd4dPiwD75vvEGJBd9RekItXp3+wuCkLJ/eIeXqqvCaivIV+2boVLvLvfAGG8wyfdX7H0yBRD6AMLolQHU+7xctPl5KuJogfo3CzROUGGEjBuYdfi4BMzDaXDhJwmZy9tQmL5xCpjetYtIgOJ3yfKNoGz4qDeY4+1+NQpD007AR8No0MGF1gRTpq/LJmInlVOaYgbVjBN+3X9L/k9v3CU+SkqHRh+CuQk01lS/xpjLwLQZLO6jEzOOpp7qklj8ow6nLhSg2NopDqfKHwVjBAjtzWKD+W6zbfkPgyt6Ube9e9UR8ZukxqgrFoI5TUHTyBqM8a0GRifh4+F0R8EfAi+veAiEj0Hkj8yhZSpnSaCSEA3LYMV10oEk1Af0s4aNV33L9zf4v+iuArUUqgBCOrXobcYaiccP/jRtrpibNBSM2dAowRiv6//yHgbIPHD4Ebrz0LdueGKFLCposrbXGqQ1BURTgFsZpSzcAKa2hnlzlbBsqRNnIehTABPp5p3bVTOltuWBL0A80JYOHwPxDQBRClDYmqi14bs9bVuyL1B8aAoErrVF2vSqxLT2zPi+U4UAY07gC2ialBSjj7i6wN0bgbVPAiVfWg9GfksJuZnuLNiZmrVhjBDhPoYflepiuXk6cGRU19FKokPhfdA4UfUbG6CEMB8lBQ/RUIQVOPadr5hg+gY3POggkqWsz6FjvAXOeigkPozrDF37Esx1bIBJzYEBC4BtmcDhv3oBMk2k2/PP+26HmB2QEFZCk2V2E2C7Z4C0N4Aji4DVD7sBShBj6PYD8m32c37ErMAMaPScrSlthgFlBUDJauD6EcDxVcDpLRbYk/CH2tJtRUcMgH6jnGXaU0PSzP9El7MOgkialvkgbT12f50vH0Tk4Ej8NvAD+OhjSNH3aUDStUC99kDvOcCuLODQX4CKIoDKrUH9ndIPGDsZzvERs+N/CvAvbYDJ1wL9s4G67YFwKbBjKrD/PZcq8xeUfmDQOfuUr6ieDSyCRrfaAPvPA5oMAA78L3Dtw8DG54DDn5ljVcHug3R74XxDdU2AdtAr3+wkuS/mGIATYOwCeDV0LKdeOzeeb46GCn+Q8BI0nqIABlKAwcuA+EaALwDoFYBeCWx4GihZYg1qCaXnpyePWZwaCvie8KafMvCmb85m9v1EfJCQCaYJCmCgodFv4QKg7dOGZLcbBXx5H1C+z7Jhmyn9QBf52oUOPMzW4pOpwboIzTtav+dxaAmroXEHG6A0CwNzgAbdgB1vAN++pVbC7POkTaPb949Ti0NCnwBQCYi/BtFuaOWHUZFUjnJUoLS8ku7ZHTN8iwWTxJyExwCeY0igH2iWDjTsCnQcBxRkA8fygKOLAP24JYFKUuKDS+4GaQtsJ2KbDc45O7HvA2J2YByAqQpgfDKQlgmk9ATCp4HQGaBOK2DdMEO6pX308TIaeGBAwzfX94EQK+21YKusBXH/kY49/o5DgaXwUS8b0E0vAu1HASe3AfW6AOseA0pWOACZHqX0/I8uRJoupg2JWYFbwbQITHG2DazXBrh9CbAlAyjM9tpAjd6m9PyfJASXThBEsrxvG17jJ+eUSoCz4u8F8WceGzj4S2DpIKDnbGD/+8DRxdK7W7bwTbo9/8UGb6xWm96lD7aLqtIjC4wtHtt9upiVMBsaP+6o8MfAwb8ABz8D+mYDe94Gij+3AJZDxLWiO/f80/7tGemFk1BeZxUINzpe2Ac07gec2QGEjnkBEg+g5dPz4iuafg5gQBWV4JzSif0eEDORiITAOmhaB9uJDM4DQieB+BRgz0wgf64F8Cw0HkDpB9Y2nLomW1j1QNdWDbnD+eiY7g+K2YndwHKdwgy3zuWFfZSHssDAi1HNC5VGIw78XXIH6PpiaNz0HHFgCKz9kgblv+Aft7wrWF9ORMmexSKjKJtTOqmfykTEB3EdEBe3BEwy2AXqdzI8spy0fDChoxKgDtayZL/ymvpT15iLSlFbRiqYuPeRMWlfiTmJk6BxBjTSYoYxGhdD8Pfornx7kf9CoVSnnR1ai7nJ/eHHX0CcXGUgTTwRqc1eo5xfBeLKy7YJohaehRx77QI5pZP6GwBlOvRhYjdo2kL4ONVRV3fwi3E4XjTdChEkQGNvTMSWEeNmB3xCu7mobtcSJCX9DBpNqBKgj09D4A76TtHq6sC4mLY2QDXheQ3qQYQfhU+TFeem0LTTYN4Ov/YxDT64TrbxvbT4TgI9Yt1MbvdRnpiMspOAvrH89dvscpbqd25iM8T5HoLGveHTWoJxHBpvga7l0P3eSTaYumakABnlLPnvLFnVNbswTR8cGdt9mer3o/pp8Ith8LH8t64CYMqHJvc6h+fSPcdOXgyQ6l7jAVjdi2vbOzs9allcJIFaCbxIcI4Jq2EH/+6X10pgDSWgFmAtwBoSqOHl/wfCkA2o2wygUAAAAABJRU5ErkJggg==" />
          <isOptionVisibleFunction>return application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "basic";</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
;
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x),
            additionalInfo: `(${x.getParents().map(item =&gt; item.getName()).join("/")})`
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    /**
     * Returns true if the attribute is a foreign key on a compositional one-to-many relationship (i.e. is managed by the DB and should not be set).
     * @param attribute
     * @returns
     */
    static isManagedForeignKey(attribute) {
        var _a, _b;
        let fkAssociation = (_b = (_a = attribute.getStereotype("Foreign Key")) === null || _a === void 0 ? void 0 : _a.getProperty("Association")) === null || _b === void 0 ? void 0 : _b.getSelected();
        return fkAssociation != null &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsCollection() &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsNullable();
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
class CrudConstants {
}
CrudConstants.mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
CrudConstants.mapToDomainConstructorForDtosSettingId = "8d1f6a8a-77c8-43a2-8e60-421559725419";
CrudConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class CrudHelper {
    static getName(command, mappedElement, dtoPrefix = null) {
        if (mappedElement.typeReference != null)
            mappedElement = mappedElement.typeReference.getType();
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        if (dtoPrefix)
            dtoName = `${dtoPrefix}${dtoName}`;
        return dtoName;
    }
    static getOrCreateCrudDto(dtoName, mappedElement, autoAddPrimaryKey, mappingTypeSettingId, folder, inbound = false) {
        let dto = CrudHelper.getOrCreateDto(dtoName, folder);
        //dtoField.typeReference.setType(dto.id);
        const entityCtor = mappedElement
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (inbound &amp;&amp; entityCtor != null) {
            dto.setMapping([mappedElement.id, entityCtor.id], CrudConstants.mapToDomainConstructorForDtosSettingId);
            CrudHelper.addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto, folder);
        }
        else {
            dto.setMapping(mappedElement.id, mappingTypeSettingId);
            CrudHelper.addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder);
        }
        return dto;
    }
    static getOrCreateDto(elementName, parentElement) {
        const expectedDtoName = elementName.replace(/Dto$/, "") + "Dto";
        let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
        if (existingDto) {
            return existingDto;
        }
        let dto = createElement("DTO", expectedDtoName, parentElement.id);
        return dto;
    }
    static addDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto, folder) {
        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        childrenToAdd.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
            field.setMapping(e.mapPath);
            if (DomainHelper.isComplexTypeById(e.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(e.typeId);
            }
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
        });
        dto.collapse();
    }
    static addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder) {
        var _a, _b;
        let dtoUpdated = false;
        let domainElement = mappedElement;
        let attributesWithMapPaths = CrudHelper.getAttributesWithMapPath(domainElement);
        let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
        for (var keyName of Object.keys(attributesWithMapPaths)) {
            let entry = attributesWithMapPaths[keyName];
            if (isCreateMode &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {
                continue;
            }
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                continue;
            }
            let field = createElement("DTO-Field", entry.name, dto.id);
            field.setMapping(entry.mapPath);
            if (DomainHelper.isComplexTypeById(entry.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(entry.typeId);
            }
            field.typeReference.setIsNullable(entry.isNullable);
            field.typeReference.setIsCollection(entry.isCollection);
            dtoUpdated = true;
        }
        if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
            CrudHelper.addPrimaryKeys(dto, domainElement, true);
        }
        if (dtoUpdated) {
            dto.collapse();
        }
    }
    static isOwnerForeignKey(attributeName, domainElement) {
        for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
            if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
                return true;
            }
        }
        return false;
    }
    static addPrimaryKeys(dto, entity, map) {
        const primaryKeys = CrudHelper.getPrimaryKeysWithMapPath(entity);
        for (const primaryKey of primaryKeys) {
            const name = CrudHelper.getDomainAttributeNameFormat(primaryKey.name);
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
                continue;
            }
            const dtoField = createElement("DTO-Field", CrudHelper.getFieldFormat(name), dto.id);
            dtoField.typeReference.setType(primaryKey.typeId);
            if (map &amp;&amp; primaryKey.mapPath != null) {
                console.log(`Doing mapping for ${dtoField.id}`);
                dtoField.setMapping(primaryKey.mapPath);
            }
        }
    }
    static getPrimaryKeysWithMapPath(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return Object.values(keydict);
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.isManagedForeignKey(x) &amp;&amp; // essentially also an attribute set by infrastructure
                !CrudHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return attrDict;
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !CrudHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static getDomainAttributeNameFormat(str) {
        let convention = CrudHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
            default:
                return str;
        }
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
}
/// &lt;reference path="attributeWithMapPath.ts" /&gt;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
ServicesConstants.dtoToDomainOperation = "8d1f6a8a-77c8-43a2-8e60-421559725419";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(innerElement, settings) {
        var _a;
        this.innerElement = innerElement;
        this.settings = settings;
        this.mappedElement = (_a = innerElement.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.innerElement.id; }
    ;
    setReturnType(typeId, isCollection, isNullable) {
        this.innerElement.typeReference.setType(typeId);
        if (isCollection != null) {
            this.innerElement.typeReference.setIsCollection(isCollection);
        }
        if (isNullable != null) {
            this.innerElement.typeReference.setIsNullable(isNullable);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.innerElement.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.innerElement.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.innerElement;
    }
    collapse() {
        this.innerElement.collapse();
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="../../common/attributeWithMapPath.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto) {
    let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
    childrenToAdd.forEach(e =&gt; {
        if (e.mapPath != null) {
            if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                return;
            }
        }
        else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
            return;
        }
        let field = createElement("DTO-Field", e.name, dto.id);
        field.typeReference.setType(e.typeId);
        field.typeReference.setIsCollection(e.isCollection);
        field.typeReference.setIsNullable(e.isNullable);
        if (this.mappedElement != null &amp;&amp; e.mapPath) {
            field.setMapping(e.mapPath);
        }
    });
    dto.collapse();
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", toPascalCase(entry.name), dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; {
        var _a;
        return !x.hasStereotype("Primary Key") &amp;&amp;
            !legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
    });
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
function onMapDto(element, folder, autoAddPrimaryKey = true, dtoPrefix = null, inbound = false) {
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b, _c; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; ((_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.specialization.startsWith("Association")); });
    fields.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement().typeReference.getType(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (DomainHelper.isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()));
    });
    complexAttributes.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), false, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
}
// services-crud script (see ~/DesignerMacros/src/services-crud folder in Intent.Modules)
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../../common/elementManager.ts" /&gt;
/// &lt;reference path="../../services-cqrs-crud/_common/onMapDto.ts" /&gt;
var _a, _b;
const privateSettersOnly = ((_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")) === null || _b === void 0 ? void 0 : _b.value) == "true";
var servicesCrud;
(function (servicesCrud) {
    async function execute() {
        const package = element.getPackage();
        const entity = await DomainHelper.openSelectEntityDialog({
            includeOwnedRelationships: false
        });
        if (!entity) {
            return;
        }
        if (privateSettersOnly &amp;&amp; !hasConstructor(entity)) {
            await dialogService.warn(`Partial Service Operation Creation.
Some service operations were created successfully, but was limited due to private setters being enabled, and no constructor is present for entity '${entity.getName()}'.

To avoid this limitation in the future, either disable private setters or add a constructor element to the entity.`);
        }
        const serviceName = `${toPascalCase(pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName()))}Service`;
        const existingService = element.specialization == "Service" ? element : package.getChildren("Service").find(x =&gt; x.getName() == pluralize(serviceName));
        const service = existingService || createElement("Service", serviceName, package.id);
        const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName());
        const existingFolder = package.getChildren("Folder").find(x =&gt; x.getName() == pluralize(folderName));
        const folder = existingFolder || createElement("Folder", pluralize(folderName), package.id);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const resultDto = createMappedResultDto(entity, folder);
        if (!privateSettersOnly || hasConstructor(entity)) {
            createStandardCreateOperation(service, entity, folder);
        }
        if (primaryKeys.length &gt; 0) {
            createStandardFindByIdOperation(service, entity, resultDto);
        }
        createStandardFindAllOperation(service, entity, resultDto);
        if (primaryKeys.length &gt; 0) {
            if (!privateSettersOnly) {
                createStandardUpdateOperation(service, entity, folder);
            }
            createStandardDeleteOperation(service, entity);
            const operations = DomainHelper.getCommandOperations(entity);
            for (const operation of operations) {
                createCallOperationCommand(service, operation, entity, folder);
            }
        }
    }
    servicesCrud.execute = execute;
    ;
    function hasConstructor(entity) {
        return entity.getChildren("Class Constructor").length &gt; 0;
    }
    function createMappedResultDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == dtoName);
        if (existing) {
            return existing;
        }
        let result = CrudHelper.getOrCreateCrudDto(dtoName, entity, true, CrudConstants.dtoFromEntityMappingId, folder, false);
        onMapDto(result, folder);
        return result;
        /*
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });


        dtoManager.mapToElement(entity, ServicesConstants.dtoFromEntityMappingId);

        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys)
        }

        let primaryKeys = DomainHelper.getPrimaryKeys(entity);

        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity))

        dtoManager.collapse();
        return dtoManager.getElement();*/
    }
    servicesCrud.createMappedResultDto = createMappedResultDto;
    function createStandardCreateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}CreateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Create${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Create${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });
        let operationManager = new ElementManager(createElement("Operation", `Create${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        const entityCtor = entity
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (entityCtor != null) {
            dtoManager.mapToElement(entityCtor, ServicesConstants.dtoToDomainOperation);
            dtoManager.getElement().setMapping([entity.id, entityCtor.id], ServicesConstants.dtoToDomainOperation);
        }
        else if (!privateSettersOnly) {
            dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        }
        else {
            console.warn(`Private Setters are enabled with no constructor present on entity '${entity.getName()}'. In order for 'Create${entity.getName()}' to map to that entity, either disable private setters or model a constructor element and try again.`);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const surrogateKey = primaryKeys.length === 1;
        if (primaryKeys.length == 1) {
            operationManager.setReturnType(primaryKeys[0].typeId);
        }
        if (entityCtor) {
            dtoManager.addChildrenFrom(DomainHelper.getChildrenOfType(entityCtor, "Parameter")
                .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        }
        else {
            if (!surrogateKey) {
                const toAdd = primaryKeys.filter(x =&gt; DomainHelper.isUserSuppliedPrimaryKey(lookup(x.id)));
                ServicesHelper.addDtoFieldsFromDomain(dtoManager.getElement(), toAdd);
            }
            dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
            dtoManager.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        }
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.addChild("dto", dtoManager.id);
        onMapDto(dtoManager.getElement(), folder, false, `${baseName}Create`, true);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardCreateOperation = createStandardCreateOperation;
    function createStandardFindByIdOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${entity.getName()}ById`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.addChildrenFrom(DomainHelper.getPrimaryKeys(entity));
        operationManager.collapse();
    }
    servicesCrud.createStandardFindByIdOperation = createStandardFindByIdOperation;
    function createStandardFindAllOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${pluralize(entity.getName())}`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id, true);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.collapse();
    }
    servicesCrud.createStandardFindAllOperation = createStandardFindAllOperation;
    function createStandardUpdateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}UpdateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Update${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Update${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
            childType: "property"
        });
        let operationManager = new ElementManager(createElement("Operation", `Update${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        dtoManager.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.addChild("dto", dtoManager.id);
        onMapDto(dtoManager.getElement(), folder, false, `${baseName}Update`);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardUpdateOperation = createStandardUpdateOperation;
    function createStandardDeleteOperation(service, entity) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        if (service.getChildren().some(x =&gt; x.getName() == `Delete${entity.getName()}`)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", `Delete${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.collapse();
    }
    servicesCrud.createStandardDeleteOperation = createStandardDeleteOperation;
    function createCallOperationCommand(service, operation, entity, folder) {
        var _a, _b;
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${operation.getName()}Dto`;
        if (service.getChildren().some(x =&gt; x.getName() == `${operation.getName()}`)) {
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
            childType: "property"
        });
        let operationManager = new ElementManager(createElement("Operation", `${operation.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(operation, ServicesConstants.dtoToDomainOperation);
        dtoManager.getElement().setMapping([entity.id, operation.id], ServicesConstants.dtoToDomainOperation);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        for (const key of primaryKeys) {
            dtoManager.addChild(key.name, lookup(key.id).typeReference);
        }
        dtoManager.addChildrenFrom(DomainHelper.getChildrenOfType(operation, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.addChild("dto", dtoManager.id);
        if (DomainHelper.isComplexType((_a = operation.typeReference) === null || _a === void 0 ? void 0 : _a.getType())) {
            var resultDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(operationManager.getElement(), operation) + "Result", (_b = operation.typeReference) === null || _b === void 0 ? void 0 : _b.getType(), false, CrudConstants.dtoFromEntityMappingId, folder, false);
            operationManager.setReturnType(resultDto.id, operation.typeReference.isCollection, operation.typeReference.isNullable);
        }
        onMapDto(dtoManager.getElement(), folder, false, `${operation.getName()}`);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createCallOperationCommand = createCallOperationCommand;
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
    /*
        function getOrCreateCrudDto(
            command: MacroApi.Context.IElementApi,
            mappedElement: MacroApi.Context.IElementApi,
            autoAddPrimaryKey: boolean,
            mappingTypeSettingId: string,
            inbound: boolean = false
        ): MacroApi.Context.IElementApi {
            if (mappedElement.typeReference == null) throw new Error("TypeReference is undefined");
    
            let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
            let domainName = mappedElement.typeReference.getType().getName();
            let baseName = command.getMetadata("baseName")
                ? `${command.getMetadata("baseName")}${domainName}`
                : domainName;
            let dtoName = `${originalVerb}${baseName}`;
            let dto = getOrCreateDto(dtoName, command.getParent());
            dto.setMetadata("originalVerb", originalVerb);
            dto.setMetadata("baseName", baseName);
    
            //dtoField.typeReference.setType(dto.id);
            const entityCtor: MacroApi.Context.IElementApi = mappedElement.typeReference.getType()
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
                // In descending order:
                return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
            })[0];
            if (inbound &amp;&amp; entityCtor != null) {
                dto.setMapping([mappedElement.typeReference.getTypeId(), entityCtor.id], mapToDomainConstructorForDtosSettingId);
                addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto);
            } else {
                dto.setMapping(mappedElement.typeReference.getTypeId(), mappingTypeSettingId);
                addDtoFields(autoAddPrimaryKey, mappedElement, dto);
            }
    
            return dto;
        }
    
        function addDtoFieldsForCtor(autoAddPrimaryKey: boolean, ctor: MacroApi.Context.IElementApi, dto: MacroApi.Context.IElementApi) {
        
            let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        
            childrenToAdd.forEach(e =&gt; {
                if (e.mapPath != null) {
                    if (dto.getChildren("Parameter").some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {
                        return;
                    }
                }
                else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                    return;
                }
        
                let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
                field.setMapping(e.mapPath);
                if (DomainHelper.isComplexTypeById(e.typeId)){
                    let newDto = getOrCreateCommandCrudDto(dto, field, autoAddPrimaryKey, mapFromDomainMappingSettingId, true );
                    field.typeReference.setType(newDto.id);
                }else{
                    field.typeReference.setType(e.typeId);
                }
                field.typeReference.setIsCollection(e.isCollection);
                field.typeReference.setIsNullable(e.isNullable);
            });
        
            dto.collapse();
        }
        
        function addDtoFields(autoAddPrimaryKey: boolean, mappedElement: MacroApi.Context.IElementApi, dto: MacroApi.Context.IElementApi) {
            let dtoUpdated = false;
            let domainElement = mappedElement
                .typeReference
                .getType();
            let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
            let isCreateMode = dto.getMetadata("originalVerb")?.toLowerCase()?.startsWith("create") == true;
            for (var keyName of Object.keys(attributesWithMapPaths)) {
                let entry = attributesWithMapPaths[keyName];
                if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
                    continue;
                }
                if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                    continue;
                }
                let field = createElement("DTO-Field", entry.name, dto.id);
                field.typeReference.setType(entry.typeId);
                field.typeReference.setIsNullable(entry.isNullable);
                field.typeReference.setIsCollection(entry.isCollection);
                field.setMapping(entry.mapPath);
                dtoUpdated = true;
            }
        
            if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
                addPrimaryKeys(dto, domainElement, true);
            }
        
            if (dtoUpdated) {
                dto.collapse();
            }
        }  */
})(servicesCrud || (servicesCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/create-crud/create-crud.ts
 */
await servicesCrud.execute();
</script>
        </option>
        <option group="1" type="run-script">
          <text>Create CRUD Traditional Service</text>
          <shortcut>alt + s</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "advanced";</isOptionVisibleFunction>
          <dependencies>
            <dependency name="Crud Api" id="61a8411f-b5bc-4a00-9a37-a967e0893d9d" />
          </dependencies>
          <script>await CrudApi.createTraditionalService(element);</script>
        </option>
        <option group="1" type="run-script">
          <text>Create CRUD CQRS Operations</text>
          <shortcut>alt + c</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>function folderHasCommandOrQueries(element) {
    return element.specialization === "Folder" &amp;&amp; (element.getChildren("Command").length &gt; 0 || element.getChildren("Query").length &gt; 0);
}

return application.isModuleInstalled("Intent.Modelers.Services.CQRS") &amp;&amp;
    application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "basic" &amp;&amp;
    !folderHasCommandOrQueries(element);</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
;
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x),
            additionalInfo: `(${x.getParents().map(item =&gt; item.getName()).join("/")})`
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    /**
     * Returns true if the attribute is a foreign key on a compositional one-to-many relationship (i.e. is managed by the DB and should not be set).
     * @param attribute
     * @returns
     */
    static isManagedForeignKey(attribute) {
        var _a, _b;
        let fkAssociation = (_b = (_a = attribute.getStereotype("Foreign Key")) === null || _a === void 0 ? void 0 : _a.getProperty("Association")) === null || _b === void 0 ? void 0 : _b.getSelected();
        return fkAssociation != null &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsCollection() &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsNullable();
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
/// &lt;reference path="attributeWithMapPath.ts" /&gt;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
ServicesConstants.dtoToDomainOperation = "8d1f6a8a-77c8-43a2-8e60-421559725419";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="../../common/attributeWithMapPath.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto) {
    let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
    childrenToAdd.forEach(e =&gt; {
        if (e.mapPath != null) {
            if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                return;
            }
        }
        else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
            return;
        }
        let field = createElement("DTO-Field", e.name, dto.id);
        field.typeReference.setType(e.typeId);
        field.typeReference.setIsCollection(e.isCollection);
        field.typeReference.setIsNullable(e.isNullable);
        if (this.mappedElement != null &amp;&amp; e.mapPath) {
            field.setMapping(e.mapPath);
        }
    });
    dto.collapse();
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", toPascalCase(entry.name), dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; {
        var _a;
        return !x.hasStereotype("Primary Key") &amp;&amp;
            !legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
    });
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
class CrudConstants {
}
CrudConstants.mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
CrudConstants.mapToDomainConstructorForDtosSettingId = "8d1f6a8a-77c8-43a2-8e60-421559725419";
CrudConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class CrudHelper {
    static getName(command, mappedElement, dtoPrefix = null) {
        if (mappedElement.typeReference != null)
            mappedElement = mappedElement.typeReference.getType();
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        if (dtoPrefix)
            dtoName = `${dtoPrefix}${dtoName}`;
        return dtoName;
    }
    static getOrCreateCrudDto(dtoName, mappedElement, autoAddPrimaryKey, mappingTypeSettingId, folder, inbound = false) {
        let dto = CrudHelper.getOrCreateDto(dtoName, folder);
        //dtoField.typeReference.setType(dto.id);
        const entityCtor = mappedElement
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (inbound &amp;&amp; entityCtor != null) {
            dto.setMapping([mappedElement.id, entityCtor.id], CrudConstants.mapToDomainConstructorForDtosSettingId);
            CrudHelper.addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto, folder);
        }
        else {
            dto.setMapping(mappedElement.id, mappingTypeSettingId);
            CrudHelper.addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder);
        }
        return dto;
    }
    static getOrCreateDto(elementName, parentElement) {
        const expectedDtoName = elementName.replace(/Dto$/, "") + "Dto";
        let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
        if (existingDto) {
            return existingDto;
        }
        let dto = createElement("DTO", expectedDtoName, parentElement.id);
        return dto;
    }
    static addDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto, folder) {
        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        childrenToAdd.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
            field.setMapping(e.mapPath);
            if (DomainHelper.isComplexTypeById(e.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(e.typeId);
            }
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
        });
        dto.collapse();
    }
    static addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder) {
        var _a, _b;
        let dtoUpdated = false;
        let domainElement = mappedElement;
        let attributesWithMapPaths = CrudHelper.getAttributesWithMapPath(domainElement);
        let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
        for (var keyName of Object.keys(attributesWithMapPaths)) {
            let entry = attributesWithMapPaths[keyName];
            if (isCreateMode &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {
                continue;
            }
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                continue;
            }
            let field = createElement("DTO-Field", entry.name, dto.id);
            field.setMapping(entry.mapPath);
            if (DomainHelper.isComplexTypeById(entry.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(entry.typeId);
            }
            field.typeReference.setIsNullable(entry.isNullable);
            field.typeReference.setIsCollection(entry.isCollection);
            dtoUpdated = true;
        }
        if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
            CrudHelper.addPrimaryKeys(dto, domainElement, true);
        }
        if (dtoUpdated) {
            dto.collapse();
        }
    }
    static isOwnerForeignKey(attributeName, domainElement) {
        for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
            if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
                return true;
            }
        }
        return false;
    }
    static addPrimaryKeys(dto, entity, map) {
        const primaryKeys = CrudHelper.getPrimaryKeysWithMapPath(entity);
        for (const primaryKey of primaryKeys) {
            const name = CrudHelper.getDomainAttributeNameFormat(primaryKey.name);
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
                continue;
            }
            const dtoField = createElement("DTO-Field", CrudHelper.getFieldFormat(name), dto.id);
            dtoField.typeReference.setType(primaryKey.typeId);
            if (map &amp;&amp; primaryKey.mapPath != null) {
                console.log(`Doing mapping for ${dtoField.id}`);
                dtoField.setMapping(primaryKey.mapPath);
            }
        }
    }
    static getPrimaryKeysWithMapPath(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return Object.values(keydict);
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.isManagedForeignKey(x) &amp;&amp; // essentially also an attribute set by infrastructure
                !CrudHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return attrDict;
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !CrudHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static getDomainAttributeNameFormat(str) {
        let convention = CrudHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
            default:
                return str;
        }
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
}
/**
 * Workaround for element's from referenced packages not having getParent()
 * @param element The element whose parent should be searched for
 * @param parentSpecializationType The specialization type of the parent
 */
function getParent(element, parentSpecializationType) {
    const elements = lookupTypesOf(parentSpecializationType);
    const parent = elements
        .find(x =&gt; x.getChildren(element.specialization)
        .some(child =&gt; child.id === element.id));
    if (parent == null) {
        throw new Error("Could not find parent");
    }
    return parent;
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
/// &lt;reference path="../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/getParent.ts" /&gt;
/**
 * Gets select details of a mapped Command/Query. Intended for centralized logic of working out
 * things like keys for both the entity and owning entity if applicable.
 *
 * If the Command is for entity creation (either due to being mapped to a constructor or being
 * prefixed with "Create"), then primary keys for the entity are not populated.
 * @param request The Command or Query that has been mapped
 */
function getMappedRequestDetails(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    // Advanced mapping:
    if (mappedElement == null) {
        const advancedMappings = request.getAssociations()
            .filter(x =&gt; x.hasMappings(queryEntityMappingTypeId) ||
            x.hasMappings(createEntityMappingTypeId))
            .map(x =&gt; x.getMapping(queryEntityMappingTypeId) ||
            x.getMapping(createEntityMappingTypeId));
        if (advancedMappings.length === 1) {
            mappedElement = advancedMappings[0].getTargetElement();
        }
    }
    if (mappedElement == null) {
        return null;
    }
    let entity = mappedElement;
    if (entity.specialization !== "Class") {
        entity = getParent(entity, "Class");
    }
    const result = {
        entity: entity,
        mappingTargetType: mappedElement.specialization,
        entityKeyFields: [],
        ownerKeyFields: []
    };
    result.owningEntity = DomainHelper.getOwningAggregate(entity);
    // As long as it's not for creation, populate the PKs of the entity:
    if (result.mappingTargetType !== "Class Constructor" &amp;&amp;
        !request.getName().toLowerCase().startsWith("Create")) {
        result.entityKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity)
            : getKeysForOperationMapping(request, entity);
    }
    // If the entity is owned, populate its fields:
    if (result.owningEntity != null) {
        result.ownerKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity, result.owningEntity)
            : getKeysForOperationMapping(request, entity, result.owningEntity);
    }
    return result;
    /**
     * Return field details for primary keys. As requests mapped to operations and constructors can
     * never possibly map the attributes, these fields can only ever be matched by name.
     * @param request The CQRS Command or Query entity
     * @param owningEntity The Owning Aggregate Class
     */
    function getKeysForOperationMapping(request, entity, owningEntity) {
        const pks = DomainHelper.getPrimaryKeys(owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity);
        return pks.map(pk =&gt; {
            let fieldName = toPascalCase(pk.name);
            if (owningEntity != null) {
                fieldName = removePrefix(fieldName, toPascalCase(owningEntity.getName()));
                fieldName = `${owningEntity.getName()}${toCamelCase(fieldName)}`;
            }
            fieldName = ServicesHelper.getFieldFormat(fieldName);
            const existingField = request.getChildren("DTO-Field").find(field =&gt; field.getName().toLowerCase() == fieldName.toLowerCase());
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: [],
                name: fieldName,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
    function getKeysForClassMapping(request, entity, owningEntity) {
        const keys = owningEntity != null
            ? DomainHelper.getForeignKeys(entity, owningEntity)
            : DomainHelper.getPrimaryKeys(entity);
        return keys.map(pk =&gt; {
            const existingField = request.getChildren("DTO-Field").find(field =&gt; {
                if (field.getMapping() != null) {
                    return field.getMapping().getPath().some(x =&gt; x.id == pk.id);
                }
                return (pk.name.toLowerCase() === field.getName().toLowerCase());
            });
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: pk.mapPath,
                name: pk.name,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/**
 * Ensures that for the provided contract, it has the provided field creating it if necessary and
 * then ensure the field has the correct typeReference details and order.
 * The field's element is returned.
 */
function ensureHasField(options) {
    const { contract, fieldDetail, mappingSettingsId, order } = options;
    let field = fieldDetail.existingId != null
        ? contract.getChildren("DTO-Field").find(x =&gt; x.id === fieldDetail.existingId)
        : createElement("DTO-Field", fieldDetail.name, contract.id);
    field.typeReference.setType(fieldDetail.typeId);
    field.typeReference.setIsCollection(fieldDetail.isCollection);
    field.typeReference.setIsNullable(fieldDetail.isNullable);
    if (order != null) {
        field.setOrder(order);
    }
    if (mappingSettingsId != null) {
        field.setMapping(fieldDetail.mappingPath, mappingSettingsId);
        console.warn("mapping:" + fieldDetail.mappingPath);
    }
    return field;
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/// &lt;reference path="ensureHasField.ts" /&gt;
function onMapCommand(element, isForCrudScript, excludePrimaryKeys = false, inbound = false) {
    var _a, _b, _c;
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    const mappingDetails = getMappedRequestDetails(element);
    if (mappingDetails &amp;&amp; (isForCrudScript || mappingDetails.mappingTargetType !== "Class")) {
        let order = 0;
        let keyFields = mappingDetails.ownerKeyFields;
        if (!excludePrimaryKeys) {
            keyFields = keyFields.concat(mappingDetails.entityKeyFields);
        }
        for (const keyField of keyFields) {
            ensureHasField({
                contract: element,
                fieldDetail: keyField,
                order: order++
            });
        }
    }
    if (mappingDetails &amp;&amp;
        mappingDetails.mappingTargetType === "Operation" &amp;&amp;
        DomainHelper.isComplexType((_c = (_b = (_a = element.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType())) {
        let mappedElement = element.getMapping().getElement();
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, mappedElement), mappedElement.typeReference.getType(), false, mapFromDomainMappingSettingId, element.getParent(), false);
        setTypeRef(element, newDto, mappedElement);
    }
    const fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; ((_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement().specialization.startsWith("Association")); });
    fields.forEach(field =&gt; {
        let mappedElement = field.getMapping().getElement();
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, mappedElement), mappedElement.typeReference.getType(), !excludePrimaryKeys, projectMappingSettingId, element.getParent(), inbound);
        setTypeRef(field, newDto, mappedElement);
    });
    const complexFields = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp;
            DomainHelper.isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType());
    });
    complexFields.forEach(cf =&gt; {
        let mappedElement = cf.getMapping().getElement();
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, mappedElement), mappedElement.typeReference.getType(), false, projectMappingSettingId, element.getParent(), inbound);
        setTypeRef(cf, newDto, mappedElement);
    });
    function setTypeRef(element, newDto, mappedElement) {
        var _a, _b;
        element.typeReference.setType(newDto.id);
        if (((_a = mappedElement === null || mappedElement === void 0 ? void 0 : mappedElement.typeReference) === null || _a === void 0 ? void 0 : _a.isCollection) != null) {
            element.typeReference.setIsCollection(mappedElement.typeReference.isCollection);
        }
        if ((_b = mappedElement === null || mappedElement === void 0 ? void 0 : mappedElement.typeReference) === null || _b === void 0 ? void 0 : _b.isNullable) {
            element.typeReference.setIsNullable(mappedElement.typeReference.isNullable);
        }
    }
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
function onMapDto(element, folder, autoAddPrimaryKey = true, dtoPrefix = null, inbound = false) {
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b, _c; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; ((_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.specialization.startsWith("Association")); });
    fields.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement().typeReference.getType(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (DomainHelper.isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()));
    });
    complexAttributes.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), false, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
function onMapQuery(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; x.getMapping().getElement().specialization.startsWith("Association"); });
    fields.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d, _e;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (complexTypes.includes((_e = (_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()) === null || _e === void 0 ? void 0 : _e.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
}
function getOrCreateQueryCrudDto(element, dtoField) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    let mappedElement = dtoField.getMapping().getElement();
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : `${domainName}`;
    let dtoName = baseName;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMappingSettingId);
    dto.setMetadata("baseName", baseName);
    ensureDtoFieldsQuery(mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
function ensureDtoFieldsQuery(mappedElement, dto) {
    let dtoUpdated = false;
    let mappedElementAttributes = mappedElement
        .typeReference
        .getType()
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; !dtoFields.some(y =&gt; x.getName() === y.getName()))) {
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == attribute.getName())) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.getName(), dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
class ElementManager {
    constructor(innerElement, settings) {
        var _a;
        this.innerElement = innerElement;
        this.settings = settings;
        this.mappedElement = (_a = innerElement.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.innerElement.id; }
    ;
    setReturnType(typeId, isCollection, isNullable) {
        this.innerElement.typeReference.setType(typeId);
        if (isCollection != null) {
            this.innerElement.typeReference.setIsCollection(isCollection);
        }
        if (isNullable != null) {
            this.innerElement.typeReference.setIsNullable(isNullable);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.innerElement.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.innerElement.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.innerElement;
    }
    collapse() {
        this.innerElement.collapse();
    }
}
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../_common/onMapCommand.ts" /&gt;
/// &lt;reference path="../_common/onMapDto.ts" /&gt;
/// &lt;reference path="../_common/onMapQuery.ts" /&gt;
/// &lt;reference path="../../common/attributeWithMapPath.ts" /&gt;
/// &lt;reference path="../../common/elementManager.ts" /&gt;
var _a, _b;
const privateSettersOnly = ((_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")) === null || _b === void 0 ? void 0 : _b.value) == "true";
const mapToDomainOperationSettingId = "7c31c459-6229-4f10-bf13-507348cd8828";
var cqrsCrud;
(function (cqrsCrud) {
    async function execute(element) {
        var _a;
        let entity = await DomainHelper.openSelectEntityDialog();
        if (entity == null) {
            return;
        }
        if (privateSettersOnly &amp;&amp; !hasConstructor(entity)) {
            await dialogService.warn(`Partial CQRS Operation Creation.
Some CQRS operations were created successfully, but was limited due to private setters being enabled, and no constructor is present for entity '${entity.getName()}'.

To avoid this limitation in the future, either disable private setters or add a constructor element to the entity.`);
        }
        const owningEntity = DomainHelper.getOwningAggregate(entity);
        const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? owningEntity.getName() : entity.getName());
        const folder = (_a = element.getChildren().find(x =&gt; x.getName() == pluralize(folderName))) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Folder", pluralize(folderName), element.id);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const hasPrimaryKey = primaryKeys.length &gt; 0;
        const resultDto = createCqrsResultTypeDto(entity, folder);
        if (!privateSettersOnly || hasConstructor(entity)) {
            createCqrsCreateCommand(entity, folder, primaryKeys);
        }
        if (hasPrimaryKey) {
            createCqrsFindByIdQuery(entity, folder, resultDto);
        }
        createCqrsFindAllQuery(entity, folder, resultDto);
        if (hasPrimaryKey &amp;&amp; !privateSettersOnly) {
            createCqrsUpdateCommand(entity, folder);
        }
        const operations = DomainHelper.getCommandOperations(entity);
        for (const operation of operations) {
            createCqrsCallOperationCommand(entity, operation, folder);
        }
        if (hasPrimaryKey) {
            createCqrsDeleteCommand(entity, folder);
        }
    }
    cqrsCrud.execute = execute;
    function hasConstructor(entity) {
        return entity.getChildren("Class Constructor").length &gt; 0;
    }
    function createCqrsCreateCommand(entity, folder, primaryKeys) {
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = getBaseNameForElement(owningAggregate, entity, false);
        const expectedCommandName = `Create${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            const returnType = primaryKeys.length == 1
                ? primaryKeys[0].typeId
                : null;
            const command = folder.getChildren().filter(x =&gt; x.getName() == expectedCommandName)[0];
            command.typeReference.setType(returnType);
            return command;
        }
        const commandManager = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        const entityCtor = entity
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (entityCtor != null) {
            commandManager.mapToElement(entityCtor, mapToDomainOperationSettingId);
            commandManager.getElement().setMapping([entity.id, entityCtor.id], mapToDomainOperationSettingId);
        }
        else if (!privateSettersOnly) {
            commandManager.mapToElement(entity);
        }
        else {
            console.warn(`Private Setters are enabled with no constructor present on entity '${entity.getName()}'. In order for '${expectedCommandName}' to map to that entity, either disable private setters or model a constructor element and try again.`);
        }
        commandManager.getElement().setMetadata("baseName", baseName);
        const surrogateKey = primaryKeys.length === 1;
        if (surrogateKey) {
            commandManager.setReturnType(primaryKeys[0].typeId);
        }
        if (entityCtor) {
            commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(entityCtor, "Parameter")
                .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        }
        else {
            const toAdd = primaryKeys.filter(x =&gt; DomainHelper.isUserSuppliedPrimaryKey(lookup(x.id)));
            if (toAdd.length &gt; 0) {
                ServicesHelper.addDtoFieldsFromDomain(commandManager.getElement(), toAdd);
            }
            commandManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
            commandManager.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        }
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandManager.getElement());
        }
        onMapCommand(commandManager.getElement(), true, true, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCreateCommand = createCqrsCreateCommand;
    function createCqrsFindByIdQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedQueryName = `Get${baseName}ByIdQuery`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(query, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        onMapQuery(query);
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindByIdQuery = createCqrsFindByIdQuery;
    function createCqrsFindAllQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, true);
        let expectedQueryName = `Get${baseName}Query`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.typeReference.setIsCollection(true);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindAllQuery = createCqrsFindAllQuery;
    function createCqrsUpdateCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Update${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        command.mapToElement(entity);
        command.getElement().setMetadata("baseName", baseName);
        command.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        command.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command.getElement(), primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command.getElement());
        }
        onMapCommand(command.getElement(), true, true);
        command.collapse();
        return command.getElement();
    }
    cqrsCrud.createCqrsUpdateCommand = createCqrsUpdateCommand;
    function createCqrsCallOperationCommand(entity, operation, folder) {
        var _a;
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = (_a = owningAggregate === null || owningAggregate === void 0 ? void 0 : owningAggregate.getName()) !== null &amp;&amp; _a !== void 0 ? _a : "";
        let operationName = operation.getName();
        operationName = removeSuffix(operationName, "Async");
        operationName = toPascalCase(operationName);
        const commandName = `${operationName}${entity.getName()}Command`;
        const existing = folder.getChildren().find(x =&gt; {
            var _a, _b;
            return x.getName() == commandName ||
                ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) === operation.id;
        });
        if (existing) {
            return existing;
        }
        const commandElement = createElement("Command", commandName, folder.id);
        commandElement.setMetadata("baseName", baseName);
        const commandManager = new ElementManager(commandElement, { childSpecialization: "DTO-Field" });
        commandManager.mapToElement([entity.id, operation.id], mapToDomainOperationSettingId);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        for (const key of primaryKeys) {
            commandManager.addChild(key.name, lookup(key.id).typeReference);
        }
        commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(operation, "Parameter")
            .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandElement);
        }
        onMapCommand(commandElement, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCallOperationCommand = createCqrsCallOperationCommand;
    function createCqrsDeleteCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Delete${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = createElement("Command", expectedCommandName, folder.id);
        command.setMapping(entity.id);
        command.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), command.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command);
        }
        onMapCommand(command, true);
        command.collapse();
        return command;
    }
    cqrsCrud.createCqrsDeleteCommand = createCqrsDeleteCommand;
    function createCqrsResultTypeDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedDtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedDtoName);
        if (existing) {
            return existing;
        }
        let dto = createElement("DTO", expectedDtoName, folder.id);
        dto.setMetadata("baseName", baseName);
        dto.setMapping(entity.id);
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), dto.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        ServicesHelper.addDtoFieldsFromDomain(dto, primaryKeys);
        let attributesWithMapPaths = DomainHelper.getAttributesWithMapPath(entity);
        for (var attr of attributesWithMapPaths) {
            if (dto.getChildren("DTO-Field").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == attr.id; })) {
                continue;
            }
            let field = createElement("DTO-Field", attr.name, dto.id);
            field.typeReference.setType(attr.typeId);
            field.setMapping(attr.mapPath);
        }
        onMapDto(dto, folder);
        dto.collapse();
        return dto;
    }
    cqrsCrud.createCqrsResultTypeDto = createCqrsResultTypeDto;
    function addAggregatePkToCommandOrQuery(owningAggregate, commandOrQuery) {
        if (owningAggregate != null) {
            var aggPks = DomainHelper.getPrimaryKeys(owningAggregate);
            aggPks.forEach(x =&gt; {
                if (x.name.toLowerCase() == "id") {
                    x.name = `${owningAggregate.getName()}Id`;
                }
                x.id = null;
                x.mapPath = null;
                x.isCollection = false;
                x.isNullable = false;
            });
            ServicesHelper.addDtoFieldsFromDomain(commandOrQuery, aggPks);
        }
    }
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
})(cqrsCrud || (cqrsCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/create-crud-macro/create-crud-macro.ts
 */
await cqrsCrud.execute(element);
</script>
        </option>
        <option group="1" type="run-script">
          <text>Create CRUD CQRS Operations</text>
          <shortcut>alt + c</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return application.isModuleInstalled("Intent.Modelers.Services.CQRS") &amp;&amp;
    application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "advanced";</isOptionVisibleFunction>
          <dependencies>
            <dependency name="Crud Api" id="61a8411f-b5bc-4a00-9a37-a967e0893d9d" />
          </dependencies>
          <script>await CrudApi.createCQRSService(element);</script>
        </option>
      </scriptOptions>
      <typeOrder />
    </packageExtension>
  </packageExtensions>
  <elementSettings>
    <elementSetting type="Processing Action" typeId="405a2857-b911-431f-8142-719a0e9f15f3">
      <implements>
        <trait id="d00a2ab0-9a23-4192-b8bb-166798fc7dba" name="[Processing Action]" />
      </implements>
      <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAAehJREFUeF7t3L1NA0EQhuE55DrYJijAEiVQAh0QEVl3XRGQQwWk/qGQRYewRGCB5G93dr6ZcT723nOv5GS0k+QHEpig6RyWBAQjSMAEBAXA8WYFll15lI18HHfHN/BMVOMwYFnKg1R5FpG79cknmZbDfJipFIDDXg24nbebvexfROT+wu+/y408RajxasAVrcyl/vXyItTYFfAH13WNGoDfjl5rVAP0WqM2oLsahwB6qnEkoIsahwOy12gFkLZGU4CMNVoEpKrRLCBLjdYBzddIAWi5RiZAkzXSAVqrkRXQTI3UgBZq9AA4tEY3gKNq9AaoXqNLQM0aPQOq1OgesHeNUQC71RgKsEeNEQGb1hgWcFWstX6eltMtsFuEbaj+txuDHExjNgFB5QRMQFAAHM8CAcBW22IR/4Wb7iuGAmxV3e/wowA2rS4UYI/qogB2q849YO/qPAOqVOcSULM6b4Dq1bkBHFWdB8Ch1VEDWqiOFdBMdXSA1qpjAjRZHQWg5eqsA5qvziwgS3UWAamqMwXIWJ0VQNrqhgOyVzcS0EV1QwA9VacN6K46NUCv1bUEfM27s4D9knU0b28DAc/jeX9gI8hoXwPtxkTDuvS8CQhWkIAJCAqA41lgAoIC4HgWmICgADieBYKAX0uidGAd9hNhAAAAAElFTkSuQmCC" />
      <saveAsOwnFile>false</saveAsOwnFile>
      <allowRename>true</allowRename>
      <nameMustBeUnique>true</nameMustBeUnique>
      <allowAbstract>false</allowAbstract>
      <allowStatic>false</allowStatic>
      <allowGenericTypes>false</allowGenericTypes>
      <allowMapping>false</allowMapping>
      <allowSorting>true</allowSorting>
      <sortChildren p4:nil="true" xmlns:p4="http://www.w3.org/2001/XMLSchema-instance" />
      <allowFindInView>false</allowFindInView>
      <allowTypeReference>false</allowTypeReference>
      <allowConvertToType p4:nil="true" xmlns:p4="http://www.w3.org/2001/XMLSchema-instance" />
      <allowSetValue>false</allowSetValue>
      <contextMenuOptions>
        <openMapping type="open-advanced-mapping" mappingType="Process Action Mapping" mappingTypeId="01bc7593-a6a2-45aa-8497-b4b6a269ab68">
          <text>Map Action</text>
          <shortcut>ctrl + space</shortcut>
        </openMapping>
      </contextMenuOptions>
      <creationOptions />
      <scriptOptions />
      <mappingOptions>
        <option type="open-advanced-mapping" mappingType="Process Action Mapping" mappingTypeId="01bc7593-a6a2-45aa-8497-b4b6a269ab68">
          <text>Map Action</text>
          <shortcut>ctrl + space</shortcut>
        </option>
      </mappingOptions>
      <mappingSettings />
    </elementSetting>
  </elementSettings>
  <elementExtensions>
    <elementExtension type="Command" typeId="ccf14eb6-3a55-4d81-b5b9-d27311c70cb9">
      <contextMenuOptions>
        <createAssociation group="1" type="association">
          <text>Query Entity</text>
          <shortcut>ctrl + shift + q</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Query Entity Action Target End</specializationType>
          <specializationTypeId>93ef6675-cba4-4998-adff-cb22d5343ed4</specializationTypeId>
          <defaultName>NewQueryEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </createAssociation>
        <createAssociation group="1" type="association">
          <text>Invoke Service</text>
          <shortcut>ctrl + shift + o</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Perform Invocation Target End</specializationType>
          <specializationTypeId>093e5909-ffe4-4510-b3ea-532f30212f3c</specializationTypeId>
          <defaultName>NewPerformInvocation</defaultName>
          <allowMultiple>true</allowMultiple>
        </createAssociation>
        <createAssociation group="1" type="association">
          <text>Create Entity</text>
          <shortcut>ctrl + shift + c</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAFFFJREFUeF7tnHt01dWVx7/fcwNC1UJ1WkrbUdC2alVIIAF5KAm17cysOmLHaleVmogGQR73CgQIj9ybF5AAN1FQQBEUp452pjJOZ7mmnZpQeRgDJoz4mmkRtGp9JhGQV3L2rHN+v5vcJDfJ7+ZeKK7F+Scrye+cs8/nt885++y9z484WxIiwIRqn62MswATVIKzAL/oAJ/Y9y8ZirxMgG+TuFSLXEzwQgBfATEYAoB4H4IGQj7R4EECfwTkj1DqjduuuGVPggwSqn7aNdACU7hZBONAjBRBPxopHFCdfooA3f0fwFEBdkNkO5TvyduvuOWVhIjEWfm0AHz61acvOI6WOwnJFuDKiIwRXtG/uxSPkGwCeNT5n/QXkQEAzxVL2imx6gvkZZIbj6ujW6ZcPuVQnDzifvyUAtzy2pbBEDUXwD0AvtRROlJ9BuH7BPoAGATyXG8jkCMAPgTkpIYMhsj5Mep9BmDNcfRZddeVt3zqrd34nzplAB/f98QKQPI6zkyC/ydQJxSNJhJGoxhr7rpz2uv/Bfo1CPpp6Es6rATHAJTecdXkovjx9Fwj6QAfe/WxURA+BuDySPcCOa7g20PFqyD4sjP52v7r/r6NkEYB6p35yXq0sLH1MaUz3b8PgWAIgAnu9O64eH4mgjcFLRkdhr9btfD2ycMnv9kzFu9PJBXg5n2PF0H04tbViYQCdwPqu4ABF11krxBblUb15KsnV3sXue3JLa9sydRAJslJAIa3a4PyGQQHtLQMi5ZHNObkDLtjdW/6i1UnKQA3vb5pCJr5JIlrxN02CfU2ya9A0LY+EU0ANmvVXJFzRc6BZA3CtGNkUDrFDyAbggFWie2mLoc1cASiB5nd3MhH8rfH+/S9beplP/84URkSBvjovkd/BMHTdmq6rSmo/QAvcUYgEPIgwAqcbNmck5bTNi0TlT5G/U11mwaijy8bED+Bi03/Lsq3NfVF0JFf5QMqdUPOVTm1iYiREMBNrzxypxZuIOEzYirhASp1gZjp6tpvIhJCMypONbiOECzIFBiNLLCGpMPxkNYtn5MY5GI9JoKfTBk25bneQuw1wIf3PryIRHGkY4L7SHVVlCDb2MzsnLTkTtV4B7qpbtMQSZHNbZuOncZvCvRlrbIL7pgy/O7H4207skzEXe+RVzbMhqAiUlHR94YAl0cZtqEpV08Jxt3wKayw8ZWNQQIFkQmtRd4G9EXOzg6tgRtzr879TbwixK2BD9evyxHi0S40rwnQ2XcNm7o1XkFOx/OP/M8jkyB6M0i7yQDYr6XlkraxyPfvHj7t+XhkiQvg+r3rRwC6hkCK6UQp3+sicoUxhEXQJCnIzL0y17HjztCyoW5DKn0wZtMAZ/Dyjhb9t64mfiYn1OVT06e+71V8zwBX71zd/9xzz6kXwXdJg0y9irZzbRO0ysxNO7PhRaAYiFDaQjR/09D7IXKJGZeI/O6e1Ht/mHSA6+vXPiDEDGsWkPsVlFV9AZqodWZu2r1ntOZ1BLKhbm0qlKoWVxM19ScQXGjGR4UZU4fNWOsFoicNfKjuAeN62u4Ca1RCBdKeLER01rS0mb06SXgR8FQ+s77uwUlCecadvoe01v1JSRHhUaL5e9PSAj0a+z0C3PTWpn7Hmg69LrDnTzN1XyFwtYVHCU0bPjOh3XZtfcWtBNd14Q7syk3oOrXknntT/U8lAnnd3gcqIJzt9r/fOCPc9qqmp86a2FPbPQJcW1dhzo0Bu2lQvSyCEe4Zadv0tFnOAT+BsqYu7CcY7k0TAgnMSAu0mlO9acPUeaju/noxZ2lDQ8tfhPJ1Z3/BXfeO8G/srt1uAa7fHR580oe3za4rwHFFdTziFKDooV5UvKdBOQDRCjCiiZF63f0uQJIAhocI1VvuEnUYos9z+3/3o8amIcGsYHNX4+gW4Jq6VWERexwyU/dlECPcTkIz0wIJTd2IQGvqyv0iqlcaSOrAjLR5CWugkeWBurA1tJ11HX8C9KXOMoWcWWlzzEkmZukSYLguPDBFWt4ToD+AZkKZM+SXATl4Eio1kBZIilPAAehO4Rg+ervpR0Tv8H/STOHkADTj7QMxlsTFAA6L0ULnCP3mzNQ5V5BsiyVEoewSYGVd2VwKy637B6wDmeasCxKYNTI5QpvmwnXlfiViNdAxyO2kDRnrDFDWSov8JFW2iFwcIeojkwbQauGe8qCQjhZCf0BwkOOek+tnj5j/+1gq2DXAPWWvg8arLKCoQ6D16zW1MGVIsrTPAVjqV5ISjg7HzR4xP6ZclS+XVQMyIeLp01SBQJI00JElPNAnzcZ0GQDI52LjOFbxtsweMf8XngGufnlFOkXXWo2AvEuobzoaIpWzRy6wa2KySri21E+lwpHYh/kZGLkwJsDwnmXG3pzgymV2zEAgIz8pa2BkPOE9yysIzna0UE4C0oeCY336H//qvVcGD3ccdxeClpYDNNE0M1v2AbRuKlEyNJC2sEfjMh64BiBUezOma4Cl1QDdWIg1OZIPsK4slVrXuQDfAWDPyRTc4k9f+CtPAFfvLjHRfrvj2pXJWUz33jcyPzUeOF6eDdcW+4XtAd6Xvijmi129p6QaEgkmmUEZgIuTqoFG5tV7SushGB4JAbjjWHdf+qJpPQIs31t+rq/5xCERMfXfBzjY3Y1Cc0YuSorpEi1EeW2x30eE7dZhYxbAnPTFXQIUkQmRzVgJTgnAVXtKWk0aJyRgFeiNOemLr+gZ4EuhG0g+6+penQBpFqAga17GEk9n3rKXlt7qUymDvGig1iaqhpuin52bsTQmwPLawmq2hjOtjfaMgnVN9VhadPMHeaMKPR37ymuLMglUmReqBR8R8lULsa8eNG948MPozjoJWr47tIRAoQOeb5Kwru+56bEHFUvylbtDDSIYGNGoeH/OyyjoAmDI2URcTY3nJ4DGuekFX+mRtPvAyt2FEdV7H5TBDg/5wbyM4H93C3BFbcGTBH7mauBhAcyxZlteRtDzubd8d7BBRAZ2zl6JNQE626d5GaGYAMtqg64ZE2mno+XddfskG+elBz0DNH052s6jAm0OE8YenZGXUdDOzdVJ0LLagr0AhrXZZWax5mPzRgWzvb698t1LrQbGTLfq1r/iAMnLKOwC4FKrgb1pl5TGeemF8QDcCsiNbWO2L/qBvIzCWd1r4EtLGgRm8NJEcIBd3IWh+aMLPW8gK2qXdNDAiKZ4+7lgVHFMgCteWlItUYZ0PCBJNM7PKPIMcEXN0iAoNgjlFHMiw2/mjyq+oVuAy19abFLK+oHyMYR/Y6sSoYUZxZ4BLq9d3ACrgU7H1gQXhBaO9t6GV22P9dyymsVB0nEMtM4konFBRrFngO3baO1l94JRxe1ybjq96dKafHGDLR+C/Jodv1JZCzOKPe12pqvS2kUN1DLQ3b0jR9fQwtGlnl9CYgDzTT8F0f2LYmN+RolngKU1CyeRfCY6SUyId/JHlTqhULe0AxisCqb0/dLxk+6IPwLwVZthoCRrYcbyOAAubICGBRhZ8kQYWnSaAJbU5AcJsQBbl1yiMT9jmWeAy2oXZIqwynV9m5yeASBO5I9adk63U7jkxfl2skPkU5AXmO1bhFlLxngHWFIz35nC0QOAAbj8tGhgSc2CIKQDQEjjotFlngEW7VqQqZRUmfEr4hMxASdCLxq9wtctwOIX84zn5TwIHA+MBajiBJjnbkRRGgiElowuOy0Ai2ryok4SzoGeQHwAa/ImEbBTmMQRAc4l0LRodJm7tjsYO62BRS/ONUHlr0PQDDoBdAhCS8as9Dz4opp5DbB2YFSJs41E1sCiXXODaN1EIi1J45JrVsWhgVFtuDlxAN5dcs3Kb3WrgUUvzv1fAN9x/WB2CTDrV0EcAAtr5jTQtQMdN1XbktsxZTfW/5desyqmGVNYM7ca9izctjZ4bV+IxqWjvQMM7ZobVK4ZExFGwNeWXrOyNUk+pgYW7gr8TsDrIwDdoT9WMCbs2ZAOvRhwzRhvdl9He65gTDgmwNCu+9o5VOOxA0FpLLgm7FkDQzsDW0G4hnTriee5gjHhf+hWA4O7AmsJTLfuROBzk11PYFvBmArPRzkHYPRRLj6QBWMqugAYSAAg4gO4y++cegjXHrb2bLhgTPi+bgEu3TVrpgLvdzI45C0RDDUVQmPvjzmoWGtV8MXZDaJ770wIja2M2Vdwl7/aurN640wQNAbHVnrWwIKdsxz3AXBQkRe7u3FuwZjKh7sFuGTnzAmKtDYfRf6kgUvNaEjJCo5Z48kWXLp99q1KcbCXjUDQMgFOkrhTpOuXFdw1q1qMQ7V1UZKthG+bl360lvcLx1d6cmcFd83I1ELrzhKByfW2xrPWHFU0rrJdSnCnNx2syu6nzznvkDjB9JMUMZdgjF86VDhujeed2MugzDOLdt7r94Em/tzqUC0atyamBi7dOcMCjGTs+iCB4Ni1SfdIL90xIyhthrgmqQQ4UjRmzfk2TBRVYgq6ZOeMVreRs4PbN1FfPO5BJ7SZxGIAqqjMBNN00VizDHcu0XJZjQACJacA4OId001MJNXe0WtT9/8sGvvgjztKFVPQxTvuKQBotU2ItyBi18EWhaHLx6xLalBp0fZcP+lrl5lQPO6hLuSa5rqz3NkuLYGS8RuSqoH5O6anEpGgEvYrc9vAWVvmFo9bt8oTwIV/mPo95eOrbvjwMCA2V0SAytJx65Ma1nQAmrBmm1FSMm5dbIA7pzmbiHvAAXWgZGyyAU41JoANawI4CdAsYdJHUr4VHL/mPU8AzUP523NrAaZbc0bkCGiPMo19T54cGszanJS0DrsGbs/1S+sUdtCUjt8QE2D+jtz2UTkzhZOogcGq7IHHU/q8BVpX3OeEcgLr5O9Lx62/Ptay0qVpsmB77gxFPOCkdsibGrjMfTiwbPwjSZs2edvv8qegfWCdZLAtoUNDQZk0XJPglA2RIZHAugKTCjD/hbuCmnADMnyX5DedPUBNLh23/om4AOZtv/N8BfWuuaplHYSiTVTeJNwcOH5Sp1UkSQsNQLuJdMywjEjbVealu4mUJell+quyB56TYlPcjPYdAZWZcUYBP+53QdM3g1f+6kRcAM3DC16YshzEfKcdfcC9JWlNmuXXPpoUk8YB6CQXxVs0GEgWwAUv3OmYLrbwPZLfcDfR+SvGbSzrSrZuTxdzd0z+mtK+dwD2tY2JNhed7aVoXwuHLs/anPCOnLc9249Ielu8BCmBsvGbE15OFlRlD2nxiU2wBOQo6bNROAKH+zf3HxzMerBTTkxE1B6PZ3kv5KwEZI7b+Ici8jXnzUj1ymu3ZMU75o7POwDbMlTjao9ICsB5L/yiDoJU18nzGalsAj1F5q+47rEutc+F3L3IgZ0/7Z/S3N/cCbG2oEAfFCcJ0STchFZOeCKhqTxve86t0HpdXOAiDyt1T/n4TZ6OZ121P2fb7RWgY7YQtKksrv1cX37t4z0eHHrUQNPwnG13XEdq58xJ0aLlqDFr3PXiplXXPXFGXu3q6aXM+cPtkwDnmoOAnyvQfteBJiNXMKxswpbXe2rDE0AH4m0mIj/dbfCQhnYuUgsaTcykIuuXX6iLNv6qn6dSoQpwPefC44q0ASMBFq+e8M8lPcHzNIUjjRgnwyHfiX0iuNT5kIt+T0TsTgWwUfQXB6IDr6UKoA07kPwUwgucq154+cvXfScj6JiiPRbPGmi18IWfj9RaXnKTls2ufFBgvjRk31ojRbIqsn51Rmuiv+qnqSCrTPaFM3h+RCqbfUXgmCheGb72l/t7JOc+EBdAUyew7WdTADwS6UCkxdxiiuTNNVKYU5H19Bm5JvqrbjFXuza5xrI52RwkaTdEC1DJDauvfSquO8NxAzQd+atvWShAaRvEdppojn7B+7N+HfL6Fk/HczOrbg4TYs7dtijyQ0BZk8xxOuG2isynn4xXll4BNJ3Mrr65BGB+K0ToP4tIa8hPwPoUtNxUkbU1YWM73kFFP++vmjSkGb5nCGlLT6ZqUGCUe5+5lZlPt3PVe+2z1wBNBzOr/2kaBMb76dxCoW7QWvqQOC/iYdZAsC9QWZG1NWkeHC+D81dNGtgMzBaBSTRyMnUFnyulFMF+jibyGAU/u3/iv/67lzZjPZMQQNPgrOqf3CSCXzvyOIKK6P2gOI5IxxlwQCCb+0KdcpAG3AlgtvnQGcwNU9cZQeGfqdS3Wh3yxEdK84bKif9W01t47pATqe7Unfb8P17mg3oKxPC22IYc0JQLoeX8tq+OGJsRm0X5KtcleWpPr5qUKrrlDhIG3MDWS4oiRwjfMZAXtkbzgN/6tP5F5fXPfpDo6BPWwGgBZjx/42pzgzL6cpvWLXVQ+HaML6zVm08/UVj90MT/8BRZ6zjYac/fMEFETJK6ieq1v4JBHqbgz4S6vC2RwUwRPWftxGfPrE8/tYNY9eNMLWoLAHdDcXRBS8t+wN7D7fQZPHcfrBZKI92PjwlRryB23dTgQJrDvrMipJIcCJEuAv38hGALGdlhW3VxtwC3PzTx2TP342MRkNOrfnoe5NhKAFM7+0PlI6H+WLR0unORyHQi+QaEF5HKZFJE+WfFfP6u8KGJv1mWSPtd1U3qFO7YSe7vfnyR8ul8CKfGFkDMrv0XEueI6K+D+FJ3F6wjexJA89GwIwpsBvkNgm4WfXQv0gTh/Sebmys2/t1/ffE+wBg9lNw//GgwT6i7oWi+rDa0vYa0TxHSxi9CHhIth0gcFoi2H8rRGECa6d/d5xptr3sA2XikueXxLT/6rXEAn9JySjUwluR3P//3EyhyIwTXgkhvF+dvjVe6Nb39foRArYjsINUv11//3GunlFiHxk87wI6Du/v3PxyrwMtE7GeQvy3O5nMBxH4GeRAEZg1rAPGpnbqCA6T5DDL+RM031v3gOXuz8q9V/uoA/1oDT1a/ZwEmSPIswLMAEySQYPX/B7HF0ckrQsvkAAAAAElFTkSuQmCC" />
          <specializationType>Create Entity Action Target End</specializationType>
          <specializationTypeId>328f54e5-7bad-4b5f-90ca-03ce3105d016</specializationTypeId>
          <defaultName>NewCreateEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </createAssociation>
        <createAssociation group="1" type="association">
          <text>Update Entity</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Update Entity Action Target End</specializationType>
          <specializationTypeId>516069f6-09cc-4de8-8e31-3c71ca823452</specializationTypeId>
          <defaultName>NewUpdateEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </createAssociation>
        <createAssociation group="1" type="association">
          <text>Delete Entity</text>
          <shortcut>ctrl + shift + d</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Delete Entity Action Target End</specializationType>
          <specializationTypeId>4a04cfc2-5841-438c-9c16-fb58b784b365</specializationTypeId>
          <defaultName>NewDeleteEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </createAssociation>
        <createElement group="1" type="element">
          <text>Add Processing Action</text>
          <shortcut>ctrl + shift + p</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAAehJREFUeF7t3L1NA0EQhuE55DrYJijAEiVQAh0QEVl3XRGQQwWk/qGQRYewRGCB5G93dr6ZcT723nOv5GS0k+QHEpig6RyWBAQjSMAEBAXA8WYFll15lI18HHfHN/BMVOMwYFnKg1R5FpG79cknmZbDfJipFIDDXg24nbebvexfROT+wu+/y408RajxasAVrcyl/vXyItTYFfAH13WNGoDfjl5rVAP0WqM2oLsahwB6qnEkoIsahwOy12gFkLZGU4CMNVoEpKrRLCBLjdYBzddIAWi5RiZAkzXSAVqrkRXQTI3UgBZq9AA4tEY3gKNq9AaoXqNLQM0aPQOq1OgesHeNUQC71RgKsEeNEQGb1hgWcFWstX6eltMtsFuEbaj+txuDHExjNgFB5QRMQFAAHM8CAcBW22IR/4Wb7iuGAmxV3e/wowA2rS4UYI/qogB2q849YO/qPAOqVOcSULM6b4Dq1bkBHFWdB8Ch1VEDWqiOFdBMdXSA1qpjAjRZHQWg5eqsA5qvziwgS3UWAamqMwXIWJ0VQNrqhgOyVzcS0EV1QwA9VacN6K46NUCv1bUEfM27s4D9knU0b28DAc/jeX9gI8hoXwPtxkTDuvS8CQhWkIAJCAqA41lgAoIC4HgWmICgADieBYKAX0uidGAd9hNhAAAAAElFTkSuQmCC" />
          <specializationType>Processing Action</specializationType>
          <specializationTypeId>405a2857-b911-431f-8142-719a0e9f15f3</specializationTypeId>
          <defaultName>Action</defaultName>
          <allowMultiple>true</allowMultiple>
        </createElement>
        <runScript group="2" type="run-script">
          <text>Convert to advanced mapping system</text>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return element.isMapped();</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        /*let classes = lookupTypesOf("Class").filter(x =&gt;
            DomainHelper.isAggregateRoot(x) ||
            (options?.includeOwnedRelationships != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) ||
            x.hasStereotype("Repository"));*/
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        if (element.isMapped() &amp;&amp; element.specialization == "Command") {
            convertCommand(element);
        }
        else if (element.isMapped() &amp;&amp; element.specialization == "Query") {
            convertQuery(element);
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertCommand(command) {
        var _a;
        if (!command) {
            console.warn(`Could not convert null Command.`);
            return;
        }
        if (!command.getMapping()) {
            console.warn(`Could not convert Command '${command.getName()}' without it mapping to an Entity.`);
            return;
        }
        let target = command.getMapping().getElement();
        let entity = (_a = target.getParent("Class")) !== null &amp;&amp; _a !== void 0 ? _a : target;
        if (command.getName().startsWith("Create")) {
            let action = createAssociation("Create Entity Action", command.id, target.id);
            let mapping = action.createMapping(command.id, entity.id);
            mapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            mapContract("Data Mapping", command, command, [command.id], [target.id], mapping);
        }
        else if (command.getName().startsWith("Delete")) {
            let action = createAssociation("Delete Entity Action", command.id, entity.id);
            let mapping = action.createMapping(command.id, entity.id);
            // Query Entity Mapping
            addFilterMapping(mapping, command, entity);
            command.clearMapping();
        }
        else if (command.isMapped()) {
            let action = createAssociation("Update Entity Action", command.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(command.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, command, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(command.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            if (target.id != entity.id) {
                updateMapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            }
            mapContract("Data Mapping", command, command, [command.id], [target.id], updateMapping);
        }
    }
    convertToAdvancedMapping.convertCommand = convertCommand;
    function addFilterMapping(mapping, command, entity) {
        var _a, _b;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key")) || (x.getName() == "Id" || x.getName() == `${entity.getName()}Id`));
            let entityPk = entity.getChildren("Attribute").find(x =&gt; x.hasStereotype("Primary Key"));
            if (idField &amp;&amp; (idField.isMapped() || entityPk)) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [entityPk.id]);
                idField.clearMapping();
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a, _b;
                let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp; x.getMapping().getElement().getName() == pk.name) || (x.getName() == pk.name));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [pk.id]);
                    idField.clearMapping();
                }
            });
        }
    }
    function convertQuery(query) {
        if (!query) {
            console.warn(`Could not convert null Query.`);
            return;
        }
        if (!query.getMapping()) {
            console.warn(`Could not convert Query '${query.getName()}' without it mapping to an Entity.`);
            return;
        }
        let entity = query.getMapping().getElement();
        let action = createAssociation("Query Entity Action", query.id, entity.id);
        if (query.typeReference.getIsCollection()) {
            action.typeReference.setIsCollection(true);
        }
        let mapping = action.createMapping(query.id, entity.id);
        mapContract("Filter Mapping", query, query, [query.id], [entity.id], mapping);
    }
    convertToAdvancedMapping.convertQuery = convertQuery;
    function mapContract(mappingType, root, dto, sourcePath, targetPathIds, mapping) {
        if (dto.isMapped() &amp;&amp; dto.getMapping().getElement().specialization == "Class Constructor") {
            if (targetPathIds[targetPathIds.length - 1] != dto.getMapping().getElement().id) {
                targetPathIds.push(dto.getMapping().getElement().id);
                console.warn("Invocation Mapping : " + root.id + "-&gt;" + dto.getMapping().getElement().id);
                mapping.addMappedEnd("Invocation Mapping", [root.id], targetPathIds);
            }
        }
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; !fieldsToSkip(dto, x)).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                console.warn("sourcePath : " + sourcePath);
                console.warn("targetPathIds : " + targetPathIds);
                console.warn("sourceAdd : " + field.id);
                console.warn("targetAdd : " + field.getMapping().getPath().map(x =&gt; x.id));
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, root, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
    function fieldsToSkip(dto, field) {
        return dto.specialization == "Command" &amp;&amp;
            field.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp;
            (!field.getMapping().getElement().getStereotype("Primary Key").hasProperty("Data source") || field.getMapping().getElement().getStereotype("Primary Key").getProperty("Data source").value != "User supplied");
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
/// &lt;reference path="../_common/convertToAdvancedMapping.ts" /&gt;
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/convert-to-advanced-mapping/convert-to-advanced-mapping.ts
 */
convertToAdvancedMapping.execute();
</script>
        </runScript>
        <openMapping type="open-advanced-mapping" mappingType="Map Return Type" mappingTypeId="b7ae8bf5-f2fd-4a5c-b57e-05410687bfc4">
          <text>Map Return Type</text>
          <shortcut>ctrl + shift + m</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAEbtJREFUeF7tXQl4VdW1/te5QxIgAwmEMSEDoBIGFZUqAjcCCejXOtVaZ+sTJ5TBOk9UK9X3ROMAKFrE8T1rW8GB0YeJyhOrIAK5ARWBEISQkeQmJLnDWf3WicEEcs7ZN0MD9q3vu1/gO/vsvdZ/9tl7TXsdQqcQk8ezOwI4GOlyRXXTXdxDDwaiwegBjXowO3qA9WjStHiGHk9MPRkcT0Q9mdGdCG6AnAx2CXsECgAcZIafCLVMXEk6VTBzJWlaBet6BUjzEYVqoHMNCDWa0+XTAlQTCNQdAuLq8/JSGgDijhaXOqrDsWPXRbu6x5+nEf9C13kUiBJAHEeg7gBcYHKC2AGwBpD8COAOGl+AYfnpAOlgCoE4CCDA4FowHQS4jECfh5jWBWoO5q5ff1ZdR8jeZgGmTv0uojYUGKORfi6BMsF8CoiMGXMsE7M8NaoH6ZuY6DME8W6Uy/3lypVDGtrCd9gAXnKJ111cTcMd0OcTtDGNM+p4JtIZ/Bk4NM1X7v9+48bTAuFIExaA4ydvGuLQ3PMAZAOICGeg46DtIYBWBYL+e9etPflbVX6VABx2idedWKVdRhR6CqB41c6Py3aMcp312TUVw9/auFE2L2uyBXD06A2umIRuC0B8rbEZ/HtQgEGLfWWHZti90pYATpy4LUF36jkALgPg/PfA7rCUoja95Qhps9auPancTHZTAGXmRSdELCHSrugM4ESJ0TQylJnGH0H7UbkxxiNCE3OG8iZayo9/dF3+y42KCwO6bAMdruE1Ss2MN3zlddeZzcRWAWxc87CQCNe0deYJKA4Hwe0mxPV0IT7ehZ7xLsTFOhET60S3bg5ERmqIiNDgdMqP4JCfg6AJoM3AbNLwdAZCIUYoyAgaPx0NDTrq63UcOhRCVVUQVQeDqKwMoKIigIOVAfj9bNzTDoBlJr5aEotbCv6a4T9yMrUKoGey91rS8GI4a57LRejTNwKDBkViUEoUkpIiEZ/gQo8eTmOGdQUJaDW+oAFm0Z56FBbWobCwHgeKGxAIhDVlA8zatLw1J71qC+D4SVtPcmj0GYjiVIVOHxyFyy7vh1693HC5tS4DzI5fAdTv11FW5sdbb+7H99+rGyMMVIJDZ+WtGbm9+Tgt5oZYF3Uh/1IiTLVjRq4n9nHjvPN6Y9Qp0XC7jy99WoD8elM1ViwvQ8mBo95ME/FpeaTmuri51dICwAkT80/XnLQOEGPemgYMiMD02wYhrufxvTlXVgSwYP4e7PtByZLzs66PzftwxIYmdA4DeOaZRVGRMdUC3qlK4M0YhLi44xu8JjkPHgxi0cIiY420JeaN9b7qcU3OiMMAerILJoF5TTPtodW++vZ1Y8bslJ8NeE1C+nxBPP1kIfbvt56JhjOCMTn3w4y1hrbV1IEnKz+HiGbZPYFbbk3G8BE97Jodl9fzt/qwcH6RPe9MOblrht3eAsDM7ILNAI+0uvvU0dH43X8MNHS1nyOJQr74z3uxaaPPRjzekrt6+KjDAI6b+lVvpx65HxCHZ+skSu99D6YZqsrxQKKytEX/LC/z40+P7kJdXchKzJAW1PqIiWdMpcws73UgLLa6Iy09CjNnp0AU5mOVBLTvdxzC/62rRG1tCD17ujDe0xP9+0cqgykWzrNPF2LHd4csxdRDoes+/t+RSww0PNn5Swgk3hZTyspOwAUX9TlWsTNMu4/WlmP5+6UtrAxZbn57eV+cNbanMojLlpZgzaoyS1mZsThvTcb15PHkOhGRuI6AMVZ33HBTEk4+JfqYBVA2gEXP7zXs3iNJlPw77k7BwIGRSvxv/lr6st5MmPE5/CXjyOPx9qAIbAQw1Kx38ZLMeWQwevc+dte/Z3IK8c32WlOAhp7QDTNnpRhOCjsqLfHj4Tk7IF4fC/qWGzCaPJ4NvcgdlQ+C6fsp6968nBOP2fVPzLIH7/8OvmrzhT82zok5Dw82PEB2JI6GO2Zvt3Q4MOOAI6Rl0NhJ3mS3A5sBmDoPZDGe+/gQu3G77LrsmHMe2IGaGnMAxYX24Jx0dO9uqmi04P++u7+FWCgWdNAfwigaN9E7zOnEPwCYasepqVG4857ULgPIbuDOAPC/Ht+F3bssTbuaUMh1Bo3L9p7hBD4GYLrCnnJqDKbdONBOji673hkAvrSoCJu+slSo63Xi8SQ2MDGvAJkHjDLPiccll/btMoDsBu4MAN9+az/ycivNh2YOQKOplDlp60VwaG8DMF0cfnV+Iqac28tOji673hkArlxeivffK7WSKcRMv6bM7PyrAXqluWPhyLsuv7Ifzh7Xs8sAshu4MwBc90kl/vvN/VZDS4rINfIKzyTw02YtxZ687voBGH1arJ0cbbpeXR2ErzqIiEgNcXEuI7gULnUGgBs3VOHlP/9gHYxifSZNyPbO1YD7zJiW0ONN05MwfHjHurBE11r692J8+UW1oW9pDiAh3oWrrx2ApGQ1i6GJ584AMD+/Bi8sKDJCpmbEzI/ShKz8BRrRLWaNZEbcOiMZQ0+QLLWOIYmS/f3tYnz9te+oJyxhzutvGIiMMB5YZwD47Te1eO7ZPUYI1RRAYD55sryvE+FKs0Zihcy6fRBS07p1CHrlZQE892yhZSAnPb0bZt+RYgTaVagzANy18xBynipE0DL8ya9RZrZ3GYDzzRgVQ/z3d6UYcd720raCGrzx+n5IIMeKxNwSs0vMLxXqDAAljjzviV0I+M1nIDGWkSc7/yMjQdKE5JW6695U9OvX9mw2WUe8+TV47dV9qLUwt5pYkGXjoT+ko5ei80I2oocf2oG6OnPrPzbWiYceTkdUlJopt39fA8QakcwHi1d4LWVm5X8OIlNXlsyGe+5PQ2Ji2z0xX35RhTdf32ekWahQdLQDjzw6xNiZVWhvUT0e/9NOS++J2PNzHklXjl9LrFj6lLQR800En1NmdsFGgE1DmYYr/4E05dnQfDBxB637tBLv/K1YGTy5/+zxcbj8iv4q2BltVq0sw3vLSizbJw+KxN33pik7VUtL/XjsURsAwRtlE9lKhOFmo0dFSSwkHQkJ4aUGint96xYfFr+0VzkPRXTO/gMiMGPWIERHq61/8oo99cRuFBXVWwIYrjnaGBvZabksALxFNhHJ9TjBHEAH7n8ozciuCofktX3jtX3K4EnfY8+Ow4UX9zEyt1RIvM/L3jmA3I8q7JyfuOOuFKSlq2sSFeUBzP2jAGjuImNgG3myvdsIONESwAfTjEwrVZLAzosvFMHns4xsHe5OVKWs7F6Yel4vI2dQhSQGsnpVKVZ8UGabutY70W34AsOxctQA5O3kySrYQsQjLF/hB9KR0EsNQMkxyXlqt9JuK2MKeL+7fgBGjoxWAk8SKwt31ePtt4uxp7De0lJokmni5ARc/OvwAmKSwSVroNXODpDxCks8xHITufeBNKV4iCQ2yswr3G29HjV/WBJnGTzE/tUS4GRHlHjFgQN+IwqnQjLrRA1TDSg19SnjPDZXbRNZT4RfmDFjqDH3pRmpbFYU8OtYuGAPvtluHU9VEbqj2sim9KsLEpE9JXxXnJIaA1pPmVnetSCcY8a0oUjfk4p+/c0VadlxP3i/BKtXliu9Uh0FkF0/kvgpKXgqgaQj+9q3rwFPKCnStqYc4fd3pVqaclUHA3jgvh2txmTthOys66L433BzEvpbPHirsYv21GHeE7stTTlmLJU18DUAV5l1puJM+O7bWuQ8WdhZWITdr0TeZswe1C77fef3h/B0joIzwZOdP59A0824NNxZM5MxdKi5O6twdx3+87FdYQvaGTekpkXhyqv6Wy45KuOqubN4PmVmb5sL6JYO1ZunJ1n658QakEj+wUrLOKoK321uI2/KqJOjcdkV/ZQdBlaD5W+twQsL7RyqmCsO1dka0VNmnam69LdvqzXySay8F21Gx+JG8RmOGhUNz8QEpKdHKemSKnyouPQZNIs8WfnXENGS9gaVZCdeuaIUK5eXhbWZCACq1kfT4R05eyKZBknJERgzJg7iKFDtQwU8afPpJ5X4H5ugEsDXUuakbRfBoVuGNX95fiKmKoQ1xTZd+rdi5OZW2ppXTYIMGdoNl17Wz9ZLIgaevKbuCA0uOdnkorBMM1XgmtqtWF6KD2zCmqTTJTQha+tkDdpyq8C6JzMev/mtWmBdEhuXLN6LAq95plRzYWRWjRjZwwBRfHbHCv3lrf342CawzqSdS+dke89g29SOaEy7MUlZNjnDJhnvO3cqHBv4sdeBSZG48eaksN1mykyF2fClF/Zi06Zqq7vqg8AEmjjVO0zXbZKL0qJw593hJReJLSkHWNRPAcGwt6+8uj/kte5qUkkuCgYxhiZN8iaHOim9TZwLz88vwt696s4F0TtvuTUJJ57UsXHocB+IcnqbkWAZEZUPWCVYangy5wRj4Q6X5MipJG0XF6ueRwPSB3fD7Xek2G4s4fKi2l4SNu+8/Ru1BMvGFF+SuEinpfjK6/zKyz9gl3W+3WH5jLDmI4MhkbSuIImHSJTPOsWXvnFxQFJ8c51wJ35q5dISIWSBF02/rRQI6Fg4X83dJZn14kG2c6G1lRe7+7Zu9uH5hTZJ5qD1aDgwvvGcyBTvIjBusOpYfGrnX5hoN7bl9ZqaIN57txSfrau0fLoxMU784Y/piIxUi420i6lWbn7v3RKsWmF9zAGMRblrMm5qBDC74GqAjzqN3bxvWZckWtbegzaibL//bgk+zqs0NfsklU5S6rqCVA/aMOGqvFUZbxgAnpntjY8EH5CCX2ZMR0p4U+LDHXDUS9aWrzdV4ZWX9x3lmpcUEvH+qIY1OxrkxliI7VGvQD2q+q5ffVZFs+Ou3q8IOMWKodGnxeDa6wZ0yGFDsZ3FDSbK6oFiv1GcQlxmp50R2yYPckcAKXGXJYt/wIYvLRVoGeqr3NUZo+UfhwGckOV9RiPMsGPk5luTMGJE2zcTu/678nqBtwbzn91jywIDz+StzjCOBv80A6ds80DXP7I7cD1gQCRum5UMWeh/TiQ2fM683ZBYiBU1HrjWMnM/PElONvwE4JlnfhYVERP7MQGn2wGTnByJm6cnK6ef2fXX1del3syLzxep6qn/4IZunry8VMO8amFaeCZ7TyYNn6tUZhMQp8/ousW+o0CXo/4Lnt2DPXuUzM2GAHjMutXD5WSXQS0AlNqAZdUQ36BpwmVzxvv2jcAvL+htZBUcb6fYRZ3astkH0flkE1MhZizrHYtL/9qsgtFRxu34rO2pGoW+IEA5Gj1yVDQuvDgR8fFuw8nZlpPiKgK0t43s/KLnVZT7sfSdEgNAVWJQqc7amE/WnNgiemZV+umlcOpmSQBeslhTUqMMF7vEY6VmluhzXQWoACavqDg0ZHOQXBqxx4v3N4QZuzEK4F6ft2a4fekneSJSfKxPFeWAeFo49bOaP81Wi48JoDEOo56WxG4FdJebWrjofyo+9tNMbiw+xmgqPmYUHgswAkHdSNz0N+jGEX8xFeXIa1PxMfkrOc7tLD4mtQRfLInh25WLjwkQHg87ye1dDKKrVad5uO0ay921LIFnzFap3nZEZ40l8H6s1dus9J0ovzYHo8Nlq0V7Bl5BQ8m0vLzMVmO2/1+A0RxeowBjBGHm6tUZFWbNbD2kRiHG+MiFpJHUEjx2oj7tmle2NweY8bKvvO62dpUAbRpm2DCvO3EAfgMNOeHszrZsHoMNmLmcWZtd+gP/paDg6IKLR7JsOwOb33D2xC1pTodzHmmYAuaoY1D+9rBUy8AqAPfkrc7YodpRWAAe3qGrMYSZnyOi8VbnjFWZ6OJ2ITByQ+y/pbYitNvulW3XDGx+s6yN3RMiTtckuMzsAWgUw/iQQNgP5V8JoGzg8rECMG8gok9Zd7zvq6jZHC5wTTx3mLCG2uMqmECETB18FkC9Wv8YAeT4kfjqO2zsH4URTUeOBbT6MQIClzLoEy2of6jrZV+YqSXhPsyOFqJJllY/h8GaK5pYjyVQDLPei0jro4NjiTkGhB4Mkk9mRB3+HAazq1En/OlzGCDUEdjHTD4QfBqoilk/QKSVMbiaSasiPeD7V30O45+WOt/BqOJnNgAAAABJRU5ErkJggg==" />
          <isOptionVisibleFunction>return false &amp;&amp; typeReference?.isTypeFound();</isOptionVisibleFunction>
        </openMapping>
      </contextMenuOptions>
      <creationOptions>
        <option group="1" type="association">
          <text>Query Entity</text>
          <shortcut>ctrl + shift + q</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAEMxJREFUeF7tnOt2U0eyx/+1bcN8w3mCiCeI/eHMmYQEW8kAIR6wlQycmEuQwiV2GLA0gIMx4G1uhkCQHGKuIZKTAAECkmGMwRmQDCFkcc5a2E9g8wTj+XSCLe06q3tvybL21l0GcmCvlcVy1K1d/euq6urqahFePkURoKJ6v+yMlwCLVIKXAH9PAMP+RzZW8BopWhUINjDZGJBmMP1fHgcwDFLGQBixr6weLnKcM9Z9xjXwTu+jeiatgYBaHZolsVSC0/8GxhmIKIoSsq+q7p0xGgV88YwADPsfVWqK1gLAyWCbWcMy88rUHsA4CCElVtZpd1WPFTDmknYpKUABLkYxLwgNYFSm2iYRjTA4QhoNa9DGylE+bHdVC3Od9vzk/+9aBYpNU2ADUEvgGkvNBUIaa50LXX98ZiZeMoCD/octBFIZqJymQYwhEAcqUBGygpWrOtzy/0+DAnYyUG+hob5ylAuNNE1Grt9faLuiAQ76H1aByQ+garoQ3BujmLrY9XpJzUxo+YQWdRPBDWBO0jvHieBY4PqPSKEwCulXFMDBsw+FRngBVMZfzsx9XKa5Sw0udXA6yAk3QB0pn/kWrf2jpxAYhfQpGODNMw+FrxNaYDz8mFlxLl7/dDVgwP/ARrGyEIDX4pIQKDSrrNz1NEy6IIADp38VJusEEcAsArm+38pnOx15+qCBEw9sXFb2avLMM/Dvug35Lwo3Tv/qI6IWXR4S/ww/qZhlz1emfLUwb4ACHoOc8UCEGZ11n/ynmsuLB848qGWN6kFUC3CVVQidCHCYx4gQ0QihuvV/6svp+08Ll6L5k753xiHmBbD/5K8+gFsSAjJcdc2vBzINLuh/VDlr4rcWMJwA2aZFgHENttiLyHYJDadxMIcURufi5syLUv/ph1XQtAjAc3RN5Mhfml635zIBhbTJGWD/iQfCZP0M1jMQOcDrP/Wgg5ncBK7UNyCEeH/5twhxxEOkx3EstFL+XcXgOab2ev/A5Ow/eDKZ5hREzNHfR911TX9K8teFoLLukxPA/p77VRooDDJWW+bOJRvnpTVb0T5GFCTIQDjpoRGwFlKAUN3GeRmD3+CJB7YK5gYGGgDUpIgv4j3Xkk/fEIuH5XOt54GTiIWvjj+OTO0LRZoTwOs9vzxioMqwqL6lG98Qg0oj+H0nQWjqlAWCMEQxUpdser2gGE3ALGcWE7ZGX7N0RwCCb+mnb6QNWa733FcZ1KG35/GYolQ7sriAfEFmBXjtq5/dDBKxnhD8cWxyosrhsVtG/H1f/eIFOGEqsj1rTsemtwoClzqY68fu1WpQVNCURjIQ4MkJT1qZjt2PxNsTIbR04zxHvpAytc8IUMy8Eo09AkgGyho0ezoYfcfu+wCIBEL8GdKiEw3pBlbMIPq++iUA5jXx72Ag1LDJGkzQ+8BGFdowsb5ryTSGQmTKDLD7Z7HCrjFsps/R8qal6Qa/vC/Cmil/w9TtaJk3I047PsjEO+PpMSDg2PymywpCsPueCorvWDji2PxWyVbltACD3nAllIp/JcIOrWyuw2MOIYLe+1VQ+FGS4L2Oljedhcxmvn0kRI7HfdLpuhyb51mGVVe7fx4j4FU5Hg12h6c0biUtwCveeyoROphl2NL7vme+JZSr3rujILIZzn3ofc9btfmCKKb9Ve89HwgtxgZknDha7fDYTQmMK967ThJhmBgPUeR9d2m0MAPAu6PxwFdBbK61UPdUgDv0dRGPFUTTLjDFQMrW96r3bkikuYz1OfSBZ77lQnHFe28M4FdFOwVRyzFle1fq55YAfzxyt4GJRRwnFH5o2ZYak1YJE4+xMsps5P80zb5sm70kq22+gwh6w7aopowmwhtNsS/bZjbRH48O+ZjRYrTrXLalJqctaN6r8OUjQwEQ5CrHINfyLfNNfuXyF0Pi5R16ppiGlm2Z/1RNN3VQCXmk0BRZtnW+aaG45A1Xkabo/poxvGxrTXW+k5WTBl46EhkF67uIinJ+xSoUuXgkMkpGGwI/M+1LrMrecOVklITvk+FKLMpzG9vMvvDS4YhoIzNA6caWD1STCV/oCtuUcho1vmTkv7bVpmSagYtHwg1gCmZqk48QpWp78fCQHh+KLBvY8+E2u4hNpz0XD4cDAEnrImbX8lZ7xmRINtlMAC8eCov9pw6H0f3hdrspnvvhYFiufHoTdDZ+Zi/al2QTNJfPk2UXvrvxM7vJrVzoCjtJgYxZSyG7lQaKrZKeJme4GtvMM/TDofAjZlSJzjEF1Stb7c/sVCwV7IWDd8YBkmbcuN1uGt+5z8NVigbdD5I15FwmK97G9ILzXXf03YeefrI3tplX1vNdd+ReHsC/V7S9nTgPyefFM9X2/IE7U3vf7PKPrWh7e24xspgBCgGM9NGTCXrFpU5PHAgfycxxHzm0Ysfbz3T1TR38ua7bPmLS3Quxa2XbOyYfd/6A0FJ9sVmx4+2sCZVMgE2dv9t/O0ICIDNW7fyz+fO9P9WSooTF50Q0tLL9necK4Hd7b6ukiPCKwUSdq9vfMfnnc/tvR5i5RmSsV7W/U2KAe29HiLhG2OjqdACJwkY+rnt1+59nNGmQr3l9v++2G2CvlI+pc/UuM8Dv9t6OgLhGZLxX7SwxwG/3/KT7EAY+2r3AUgMZCOtHFtS9etfzBfDbPYPy6ME4UulcvWuBSQPlGIWVEeGjXWYry2fSTIASX44MABlh4yVDH+1e8FyZcG/nTzIJIhWQ0bmmwwrgP0cBlhsFKyUpCmCvOhhhYxFxqgtNgP3qoAhfZBhAhKE1HQufK4B+9ZZKRrUCAy6XutC0iATUwXgUAasxFgXQr94KEahemAAT2V3qAlOCQAqgJzLHnerCV/J54Uy39auDxiKYXX4ijKxRF5p2WvnIaNaw3bdkkkDyUchyBr/ZPSjTQrKzos11qYtLWkCUzwBS2/p33xIhll75qswyhWF+dcAGTRk1EtlDrj2LirIgE8Czuwb140Cpgehcu2eRyQl/s/tWAKyn+pnZs3bvu6Y9ZzEQCu0r3AvH+JFxBDHy8d5FJu1KHh+Iuz/e825RUYQJ4Okdg1VliiaOMcUx9tDafYtNM3R214CTmfx6Z+s2hUIopt/XO2/Kygn9QB7d6/aZ4Xy9cyBAoDW6EyTHun2L0p4t5yKLZRD5dfvNcVkaAcK6/e9maCOieUZZDHNdB5+9GZ9tvzkqSoqF3Bor1RsOLDTt0b9uvykWwKpSyW0J58yOgRDAMkVOzI51Xe+ZZulM240ASKSFpK33ru9a/FQOktJpxZm2G26QOL9mMNPIhq7FJvP1q8HK6MTsfxmp/8frD7yXUjmRi85Nb2MJ8PSOASeY/dIUGH0bDi42HWee2D5gKyeIGdeP3Emr3nCg7plkZSSYJ7NHWZ5fywjfteHAYlP4cmbHgMpsnOEwd284+F5R/k86gXTMT33WL6rh5wh5Zj2ZeMXlc5iqEU5tv5E44GZQpOnQeyU7b81HF05+1u8jcaivH3aMfHKozjI0ObX9xiiYbXK+Y6jecLj4CU8PsFWYKEtnS4TOTw7WmVZjvztY+WT2rEQaHUB306G6omc1H3gntvc7ifUEqRiMRpq9+eASU+x6qvVGA4iDRgQ90pQGcj7vzqiBwkShxcTZiBBs/H8nJ+d6LLTweOv1BppK74thuJoP1xWVJs91ED3b+qsIHKZEjTZ1Nx+2nsAT2/4htp9GRFE6GTOmck5s/UeACWtkI+LO5s+XWKbuT2zrNwov43UMpRMwHcw4PFHgLuVjjDQf+Yul6R5vvdFArMljCmY8fhKdrLJShlwnLrldRoBCSGhaomxDiUXnNvsclruOnr9fC4GoPvHlDHXj0SWdhQiVrU/P3685QeJ2gF70RMDIk1i01gqK1x2snFVWLnYneuac2bXx6NKSWUjWZGLPlus+sFF1RRje+MUSy7NUKahSFmBQvagjNBbnkBKLetJBzwYq9XPxjgqlrIOI3PHFnxkjk5o1PNF/mvzA0MajS4rauqXKlBWgFJqUMTYOagDu3uStT7tQHPP0JY4Np7SR1Cii3cWYzTFPn6jNFi4k+QxmJMoxS80T7z7mvl4L4njqDQrHqjf6HCUNtbICTAgCLRyvDRXVCpt96c3gS/c1sZ/2ydMxUfWjxxfj4v5GjBBq8S7Nqeq+xx2sikFZowDiqFXuMJKK1Ls3+dJPpJBbyiHL7vR+BAr8zbfUsgQuX2uIt88JoGjcvTmogpQOo7h2XCO2ezLMptcdtCmaIhaX+qloMw4A4yTuA4OGmSHiy/h/cmdAxLUGMJtxD8WQV56YjyiK5t7kc+RUh/OlOyj37foXyK1BYHN3Q8kg5gxQh9hnbPGkNOOakhmiaOR1B2sVTRFVXKmF4nlOOo0Qa77Nxxx5LwBfbgo6WaT5jYcJAXeJIOYFUPhDRBEhwmuGYYqL0B5PDoMSGomYrLgXl6/loZXUx2nXQZL+1gc7AkYEGgKe48X5Lu+moJMAf+J9QMBzzFG0JuYF0NAoCTH5bhoA1fOVI6+Qxfu3YPwG+/QNPWEMjDGUYzifRSf+fZkmU0CEsWvRQxoEPD3FQcwbYBwiT7DI0CQ0CYQIxcjlOWkdJ+Zprzk3F1ahTcpzYLfuYdm15fgHac38i0+vTF3D0NsHthz/oGBNLAhgfHRHP70qCxaTUhLjDFK3Hnd050ygiIZHmoMNxmWalPKS7BABwyfqV6YKhlgUQDH2I80/ilI3MePJl5/HQKxuPfHXGfmBiMOfXK0n0sRd4bRBMQGuLSczaGLTFXHXOfkmU2Dryfw1sWiA0qSbgrYox8R10/pE2KcvEmPMCHGZ0tta7CLgDFZG/6C1EMPJ4tc/khYhUWUFaOI4U4Qs+rUMcd6VA0RN+EQjuiJC3hBLAjBuhYebLteyBhWgmmm3MvUzCnl9lRkRYm2k9czyjDuCriYRR8ZqiMXPpchLiFbXYx+DSW09M6Vphzb8GCBZXWas80yu5M9TPcbn6684Ie/Uxdsj0Hrmrzn7xJICTIBcd7lWIwiNqElkrPWdgHFbM/GvOHtJBiludValtkvaScj+IBETkq9iUgl5AuZEr4AoKlWnvkfJClHcM056b84QZwRgHGRX0wUbooq4nyF+BuW1jBess/wiDwOPiTnEFTFf28nGrOfQXesuT9NEUerWdmZ52tW5a/0lJ8kdS1wTObD97PKsmjijAJPNxesMVv6mTDZAkadmteJnn8TNocT9Y2OrZWwVR5gwToxhAke0mDbcFsgOLdU8u9ZeDgBCE/WHGa62bzJA/PiSk2j6wpIN4lMDWES0UlTXA66L+pWNhIsjV3sGiPsFRJGASLTnQPs3H6bVxP/3AAV9CdEoW9brGnOAyPrlSb3OkAPtAWuILwRAwWCf84Kep4yfwoJd7YHGtD5xv/OCk0Wwndi0I7Cz1wzxhQGYgCjiROMhygFiIhUmO5kgvlAABYG9qy7Ig7JEIA64dn9nrYl7Vl8Q1RaJ3QoRend92zitAuOFA5iAmLhIrlcypEJMwEv8kA/3dny/wlS+8kICFBA7V56XC4vxsyiiTM+lnl8pfaK64py8W6wvInID0NtxzgwvrsVFhQm/584CIsu7dcZPWAF6uCKL1I1ML9CrpoH3wgMUAHY3fi93LFOL7VTBkLipr15YlbHq7IU14WTL2f3h94k4Men/9+75ITO8lxqYRCsFYk7wXgJMceAGROSieYlY8ve8CDwPsr/0gUXOwkuALwEWSaDI7v8HEft2ujopHEwAAAAASUVORK5CYII=" />
          <specializationType>Query Entity Action Target End</specializationType>
          <specializationTypeId>93ef6675-cba4-4998-adff-cb22d5343ed4</specializationTypeId>
          <defaultName>NewQueryEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option group="1" type="association">
          <text>Invoke Service</text>
          <shortcut>ctrl + shift + o</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Perform Invocation Target End</specializationType>
          <specializationTypeId>093e5909-ffe4-4510-b3ea-532f30212f3c</specializationTypeId>
          <defaultName>NewPerformInvocation</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option group="1" type="association">
          <text>Create Entity</text>
          <shortcut>ctrl + shift + c</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Create Entity Action Target End</specializationType>
          <specializationTypeId>328f54e5-7bad-4b5f-90ca-03ce3105d016</specializationTypeId>
          <defaultName>NewCreateEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option group="1" type="association">
          <text>Update Entity</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Update Entity Action Target End</specializationType>
          <specializationTypeId>516069f6-09cc-4de8-8e31-3c71ca823452</specializationTypeId>
          <defaultName>NewUpdateEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option group="1" type="association">
          <text>Delete Entity</text>
          <shortcut>ctrl + shift + d</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Delete Entity Action Target End</specializationType>
          <specializationTypeId>4a04cfc2-5841-438c-9c16-fb58b784b365</specializationTypeId>
          <defaultName>NewDeleteEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option group="1" type="element">
          <text>Add Processing Action</text>
          <shortcut>ctrl + shift + p</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAAehJREFUeF7t3L1NA0EQhuE55DrYJijAEiVQAh0QEVl3XRGQQwWk/qGQRYewRGCB5G93dr6ZcT723nOv5GS0k+QHEpig6RyWBAQjSMAEBAXA8WYFll15lI18HHfHN/BMVOMwYFnKg1R5FpG79cknmZbDfJipFIDDXg24nbebvexfROT+wu+/y408RajxasAVrcyl/vXyItTYFfAH13WNGoDfjl5rVAP0WqM2oLsahwB6qnEkoIsahwOy12gFkLZGU4CMNVoEpKrRLCBLjdYBzddIAWi5RiZAkzXSAVqrkRXQTI3UgBZq9AA4tEY3gKNq9AaoXqNLQM0aPQOq1OgesHeNUQC71RgKsEeNEQGb1hgWcFWstX6eltMtsFuEbaj+txuDHExjNgFB5QRMQFAAHM8CAcBW22IR/4Wb7iuGAmxV3e/wowA2rS4UYI/qogB2q849YO/qPAOqVOcSULM6b4Dq1bkBHFWdB8Ch1VEDWqiOFdBMdXSA1qpjAjRZHQWg5eqsA5qvziwgS3UWAamqMwXIWJ0VQNrqhgOyVzcS0EV1QwA9VacN6K46NUCv1bUEfM27s4D9knU0b28DAc/jeX9gI8hoXwPtxkTDuvS8CQhWkIAJCAqA41lgAoIC4HgWmICgADieBYKAX0uidGAd9hNhAAAAAElFTkSuQmCC" />
          <specializationType>Processing Action</specializationType>
          <specializationTypeId>405a2857-b911-431f-8142-719a0e9f15f3</specializationTypeId>
          <defaultName>Action</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
      </creationOptions>
      <scriptOptions>
        <option group="2" type="run-script">
          <text>Convert to advanced mapping system</text>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return element.isMapped();</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        /*let classes = lookupTypesOf("Class").filter(x =&gt;
            DomainHelper.isAggregateRoot(x) ||
            (options?.includeOwnedRelationships != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) ||
            x.hasStereotype("Repository"));*/
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        if (element.isMapped() &amp;&amp; element.specialization == "Command") {
            convertCommand(element);
        }
        else if (element.isMapped() &amp;&amp; element.specialization == "Query") {
            convertQuery(element);
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertCommand(command) {
        var _a;
        if (!command) {
            console.warn(`Could not convert null Command.`);
            return;
        }
        if (!command.getMapping()) {
            console.warn(`Could not convert Command '${command.getName()}' without it mapping to an Entity.`);
            return;
        }
        let target = command.getMapping().getElement();
        let entity = (_a = target.getParent("Class")) !== null &amp;&amp; _a !== void 0 ? _a : target;
        if (command.getName().startsWith("Create")) {
            let action = createAssociation("Create Entity Action", command.id, target.id);
            let mapping = action.createMapping(command.id, entity.id);
            mapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            mapContract("Data Mapping", command, command, [command.id], [target.id], mapping);
        }
        else if (command.getName().startsWith("Delete")) {
            let action = createAssociation("Delete Entity Action", command.id, entity.id);
            let mapping = action.createMapping(command.id, entity.id);
            // Query Entity Mapping
            addFilterMapping(mapping, command, entity);
            command.clearMapping();
        }
        else if (command.isMapped()) {
            let action = createAssociation("Update Entity Action", command.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(command.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, command, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(command.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            if (target.id != entity.id) {
                updateMapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            }
            mapContract("Data Mapping", command, command, [command.id], [target.id], updateMapping);
        }
    }
    convertToAdvancedMapping.convertCommand = convertCommand;
    function addFilterMapping(mapping, command, entity) {
        var _a, _b;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key")) || (x.getName() == "Id" || x.getName() == `${entity.getName()}Id`));
            let entityPk = entity.getChildren("Attribute").find(x =&gt; x.hasStereotype("Primary Key"));
            if (idField &amp;&amp; (idField.isMapped() || entityPk)) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [entityPk.id]);
                idField.clearMapping();
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a, _b;
                let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp; x.getMapping().getElement().getName() == pk.name) || (x.getName() == pk.name));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [pk.id]);
                    idField.clearMapping();
                }
            });
        }
    }
    function convertQuery(query) {
        if (!query) {
            console.warn(`Could not convert null Query.`);
            return;
        }
        if (!query.getMapping()) {
            console.warn(`Could not convert Query '${query.getName()}' without it mapping to an Entity.`);
            return;
        }
        let entity = query.getMapping().getElement();
        let action = createAssociation("Query Entity Action", query.id, entity.id);
        if (query.typeReference.getIsCollection()) {
            action.typeReference.setIsCollection(true);
        }
        let mapping = action.createMapping(query.id, entity.id);
        mapContract("Filter Mapping", query, query, [query.id], [entity.id], mapping);
    }
    convertToAdvancedMapping.convertQuery = convertQuery;
    function mapContract(mappingType, root, dto, sourcePath, targetPathIds, mapping) {
        if (dto.isMapped() &amp;&amp; dto.getMapping().getElement().specialization == "Class Constructor") {
            if (targetPathIds[targetPathIds.length - 1] != dto.getMapping().getElement().id) {
                targetPathIds.push(dto.getMapping().getElement().id);
                console.warn("Invocation Mapping : " + root.id + "-&gt;" + dto.getMapping().getElement().id);
                mapping.addMappedEnd("Invocation Mapping", [root.id], targetPathIds);
            }
        }
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; !fieldsToSkip(dto, x)).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                console.warn("sourcePath : " + sourcePath);
                console.warn("targetPathIds : " + targetPathIds);
                console.warn("sourceAdd : " + field.id);
                console.warn("targetAdd : " + field.getMapping().getPath().map(x =&gt; x.id));
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, root, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
    function fieldsToSkip(dto, field) {
        return dto.specialization == "Command" &amp;&amp;
            field.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp;
            (!field.getMapping().getElement().getStereotype("Primary Key").hasProperty("Data source") || field.getMapping().getElement().getStereotype("Primary Key").getProperty("Data source").value != "User supplied");
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
/// &lt;reference path="../_common/convertToAdvancedMapping.ts" /&gt;
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/convert-to-advanced-mapping/convert-to-advanced-mapping.ts
 */
convertToAdvancedMapping.execute();
</script>
        </option>
      </scriptOptions>
      <mappingOptions>
        <option type="open-advanced-mapping" mappingType="Map Return Type" mappingTypeId="b7ae8bf5-f2fd-4a5c-b57e-05410687bfc4">
          <text>Map Return Type</text>
          <shortcut>ctrl + shift + m</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return false &amp;&amp; typeReference?.isTypeFound();</isOptionVisibleFunction>
        </option>
      </mappingOptions>
      <typeOrder>
        <type type="Query Entity Action Target End" typeId="93ef6675-cba4-4998-adff-cb22d5343ed4" />
        <type type="Perform Invocation Target End" typeId="093e5909-ffe4-4510-b3ea-532f30212f3c" />
        <type type="Create Entity Action Target End" typeId="328f54e5-7bad-4b5f-90ca-03ce3105d016" />
        <type type="Update Entity Action Target End" typeId="516069f6-09cc-4de8-8e31-3c71ca823452" />
        <type type="Delete Entity Action Target End" typeId="4a04cfc2-5841-438c-9c16-fb58b784b365" />
        <type type="Processing Action" typeId="405a2857-b911-431f-8142-719a0e9f15f3" />
      </typeOrder>
      <mappingSettings />
    </elementExtension>
    <elementExtension type="Diagram" typeId="8c90aca5-86f4-47f1-bd58-116fe79f5c55">
      <mappingSettings />
      <diagramSettings>
        <addNewElementsTo>Package</addNewElementsTo>
        <elementVisualSettings>
          <visualSettings type="Stored Procedure" typeId="575edd35-9438-406d-b0a7-b99d6f29b560">
            <size width="${w}" height="${h}" />
            <position x="${x}" y="${y}" />
            <display>
              <drawText>
                <text>return getName();</text>
                <style>`font-size: 12px; 
font-family: Helvetica; 
font-weight: bold; 
text-align: center; 
white-space: inherit;
vertical-align: center`</style>
                <size width="${w}" height="18" />
                <position x="${x}" y="${y + 48}" />
              </drawText>
              <drawSvgResource>
                <path>stored-procedure.svg</path>
                <size width="${w}" height="40" />
                <position x="${x}" y="${y + 6}" />
              </drawSvgResource>
            </display>
            <defaultSize width="${x}" height="${y}" />
            <autoResizeEnabledByDefault>true</autoResizeEnabledByDefault>
            <childElementVisualSettings />
          </visualSettings>
          <visualSettings type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10">
            <size width="${w}" height="70" />
            <position x="${x}" y="${y}" />
            <display>
              <drawText>
                <text>return getName();</text>
                <style>`font-size: 12px; 
font-family: Helvetica; 
font-weight: bold; 
text-align: center; 
white-space: inherit;
vertical-align: center`</style>
                <size width="${w}" height="18" />
                <position x="${x}" y="${y + 48}" />
              </drawText>
              <drawSvgResource>
                <path>domain-class.svg</path>
                <size width="${w}" height="40" />
                <position x="${x}" y="${y + 6}" />
              </drawSvgResource>
            </display>
            <defaultSize width="${x}" height="70" />
            <autoResizeEnabledByDefault>true</autoResizeEnabledByDefault>
            <childElementVisualSettings>
              <childElementVisualSetting type="Class Constructor" typeId="dec2bd12-4699-4f45-8ec9-3b62dc692d2b">
                <size width="`${parent.w}`" height="18" />
                <position x="`${parent.x}`" y="`${parent.y + ($index * 20) + 66}`" />
                <anchorPointsFunction>return [getDimensions().getCenterLeft(), getDimensions().getCenterRight()];</anchorPointsFunction>
                <display>
                  <drawText>
                    <text>return label;</text>
                    <size width="${w - 26}" height="${h}" />
                    <position x="${x + 24}" y="${y}" />
                  </drawText>
                  <drawSvgResource>
                    <path>method.svg</path>
                    <size width="20" height="20" />
                    <position x="${x}" y="${y}" />
                  </drawSvgResource>
                </display>
                <defaultSize width="`${parent.w}`" height="18" />
                <autoResizeEnabledByDefault>true</autoResizeEnabledByDefault>
                <childElementVisualSettings />
              </childElementVisualSetting>
              <childElementVisualSetting type="Operation" typeId="e042bb67-a1df-480c-9935-b26210f78591">
                <size width="`${parent.w}`" height="18" />
                <position x="`${parent.x}`" y="`${parent.y + (parent.elements['Class Constructor'].any() ? 2 : 0) + (parent.elements['Class Constructor'].size.height) + ($index * 20) + 66}`" />
                <anchorPointsFunction>return [getDimensions().getCenterLeft(), getDimensions().getCenterRight()];</anchorPointsFunction>
                <display>
                  <drawText>
                    <text>return label;</text>
                    <size width="${w - 26}" height="${h}" />
                    <position x="${x + 24}" y="${y}" />
                  </drawText>
                  <drawSvgResource>
                    <path>method.svg</path>
                    <size width="20" height="20" />
                    <position x="${x}" y="${y}" />
                  </drawSvgResource>
                </display>
                <defaultSize width="`${parent.w}`" height="18" />
                <autoResizeEnabledByDefault>true</autoResizeEnabledByDefault>
                <childElementVisualSettings />
              </childElementVisualSetting>
            </childElementVisualSettings>
          </visualSettings>
          <visualSettings type="Repository" typeId="96ffceb2-a70a-4b69-869b-0df436c470c3">
            <size width="${w}" height="70" />
            <position x="${x}" y="${y}" />
            <display>
              <drawText>
                <text>return getName();</text>
                <style>`font-size: 12px; 
font-family: Helvetica; 
font-weight: bold; 
text-align: center; 
white-space: inherit;
vertical-align: center`</style>
                <size width="${w}" height="18" />
                <position x="${x}" y="${y + 48}" />
              </drawText>
              <drawSvgResource>
                <path>respository.svg</path>
                <size width="${w}" height="40" />
                <position x="${x}" y="${y + 6}" />
              </drawSvgResource>
            </display>
            <defaultSize width="${x}" height="70" />
            <autoResizeEnabledByDefault>true</autoResizeEnabledByDefault>
            <childElementVisualSettings>
              <childElementVisualSetting type="Operation" typeId="e042bb67-a1df-480c-9935-b26210f78591">
                <size width="`${parent.w}`" height="18" />
                <position x="`${parent.x}`" y="`${parent.y + ($index * 20) + 66}`" />
                <anchorPointsFunction>return [getDimensions().getCenterLeft(), getDimensions().getCenterRight()];</anchorPointsFunction>
                <display>
                  <drawText>
                    <text>return label;</text>
                    <size width="${w - 26}" height="${h}" />
                    <position x="${x + 24}" y="${y}" />
                  </drawText>
                  <drawSvgResource>
                    <path>method.svg</path>
                    <size width="20" height="20" />
                    <position x="${x}" y="${y}" />
                  </drawSvgResource>
                </display>
                <defaultSize width="`${parent.w}`" height="18" />
                <autoResizeEnabledByDefault>true</autoResizeEnabledByDefault>
                <childElementVisualSettings />
              </childElementVisualSetting>
            </childElementVisualSettings>
          </visualSettings>
          <visualSettings type="Domain Service" typeId="07f936ea-3756-48c8-babd-24ac7271daac">
            <size width="${w}" height="70" />
            <position x="${x}" y="${y}" />
            <display>
              <drawText>
                <text>return getName();</text>
                <style>`font-size: 12px; 
font-family: Helvetica; 
font-weight: bold; 
text-align: center; 
white-space: inherit;
vertical-align: center`</style>
                <size width="${w}" height="18" />
                <position x="${x}" y="${y + 48}" />
              </drawText>
              <drawSvgResource>
                <path>domain-service.svg</path>
                <size width="${w}" height="40" />
                <position x="${x}" y="${y + 6}" />
              </drawSvgResource>
            </display>
            <defaultSize width="${x}" height="70" />
            <autoResizeEnabledByDefault>true</autoResizeEnabledByDefault>
            <childElementVisualSettings>
              <childElementVisualSetting type="Operation" typeId="e042bb67-a1df-480c-9935-b26210f78591">
                <size width="`${parent.w}`" height="18" />
                <position x="`${parent.x}`" y="`${parent.y + ($index * 20) + 66}`" />
                <anchorPointsFunction>return [getDimensions().getCenterLeft(), getDimensions().getCenterRight()];</anchorPointsFunction>
                <display>
                  <drawText>
                    <text>return label;</text>
                    <size width="${w - 26}" height="${h}" />
                    <position x="${x + 24}" y="${y}" />
                  </drawText>
                  <drawSvgResource>
                    <path>method.svg</path>
                    <size width="20" height="20" />
                    <position x="${x}" y="${y}" />
                  </drawSvgResource>
                </display>
                <defaultSize width="`${parent.w}`" height="18" />
                <autoResizeEnabledByDefault>true</autoResizeEnabledByDefault>
                <childElementVisualSettings />
              </childElementVisualSetting>
            </childElementVisualSettings>
          </visualSettings>
        </elementVisualSettings>
        <associationVisualSettings>
          <visualSettings type="Domain Event Origin Association" typeId="4c0cc50b-8a9d-43cd-b731-9f354f69f3c9">
            <lineType>Curved</lineType>
            <lineDashArray>return "3,7";</lineDashArray>
            <sourceEnd>
              <pointIndicator>
                <path>return `a 4,4 0 1,0 4,4 
        a 4,4 0 1,0 -4,4`;</path>
              </pointIndicator>
            </sourceEnd>
            <targetEnd>
              <pointIndicator>
                <path>return `l 4 8 l -8 0 l 4 -8 Z`</path>
              </pointIndicator>
            </targetEnd>
          </visualSettings>
        </associationVisualSettings>
      </diagramSettings>
    </elementExtension>
    <elementExtension type="Folder" typeId="4d95d53a-8855-4f35-aa82-e312643f5c5f">
      <contextMenuOptions>
        <runScript group="1" type="run-script">
          <text>Create CRUD Traditional Service</text>
          <shortcut>alt + s</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "basic";</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
;
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x),
            additionalInfo: `(${x.getParents().map(item =&gt; item.getName()).join("/")})`
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    /**
     * Returns true if the attribute is a foreign key on a compositional one-to-many relationship (i.e. is managed by the DB and should not be set).
     * @param attribute
     * @returns
     */
    static isManagedForeignKey(attribute) {
        var _a, _b;
        let fkAssociation = (_b = (_a = attribute.getStereotype("Foreign Key")) === null || _a === void 0 ? void 0 : _a.getProperty("Association")) === null || _b === void 0 ? void 0 : _b.getSelected();
        return fkAssociation != null &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsCollection() &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsNullable();
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
class CrudConstants {
}
CrudConstants.mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
CrudConstants.mapToDomainConstructorForDtosSettingId = "8d1f6a8a-77c8-43a2-8e60-421559725419";
CrudConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class CrudHelper {
    static getName(command, mappedElement, dtoPrefix = null) {
        if (mappedElement.typeReference != null)
            mappedElement = mappedElement.typeReference.getType();
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        if (dtoPrefix)
            dtoName = `${dtoPrefix}${dtoName}`;
        return dtoName;
    }
    static getOrCreateCrudDto(dtoName, mappedElement, autoAddPrimaryKey, mappingTypeSettingId, folder, inbound = false) {
        let dto = CrudHelper.getOrCreateDto(dtoName, folder);
        //dtoField.typeReference.setType(dto.id);
        const entityCtor = mappedElement
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (inbound &amp;&amp; entityCtor != null) {
            dto.setMapping([mappedElement.id, entityCtor.id], CrudConstants.mapToDomainConstructorForDtosSettingId);
            CrudHelper.addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto, folder);
        }
        else {
            dto.setMapping(mappedElement.id, mappingTypeSettingId);
            CrudHelper.addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder);
        }
        return dto;
    }
    static getOrCreateDto(elementName, parentElement) {
        const expectedDtoName = elementName.replace(/Dto$/, "") + "Dto";
        let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
        if (existingDto) {
            return existingDto;
        }
        let dto = createElement("DTO", expectedDtoName, parentElement.id);
        return dto;
    }
    static addDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto, folder) {
        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        childrenToAdd.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
            field.setMapping(e.mapPath);
            if (DomainHelper.isComplexTypeById(e.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(e.typeId);
            }
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
        });
        dto.collapse();
    }
    static addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder) {
        var _a, _b;
        let dtoUpdated = false;
        let domainElement = mappedElement;
        let attributesWithMapPaths = CrudHelper.getAttributesWithMapPath(domainElement);
        let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
        for (var keyName of Object.keys(attributesWithMapPaths)) {
            let entry = attributesWithMapPaths[keyName];
            if (isCreateMode &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {
                continue;
            }
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                continue;
            }
            let field = createElement("DTO-Field", entry.name, dto.id);
            field.setMapping(entry.mapPath);
            if (DomainHelper.isComplexTypeById(entry.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(entry.typeId);
            }
            field.typeReference.setIsNullable(entry.isNullable);
            field.typeReference.setIsCollection(entry.isCollection);
            dtoUpdated = true;
        }
        if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
            CrudHelper.addPrimaryKeys(dto, domainElement, true);
        }
        if (dtoUpdated) {
            dto.collapse();
        }
    }
    static isOwnerForeignKey(attributeName, domainElement) {
        for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
            if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
                return true;
            }
        }
        return false;
    }
    static addPrimaryKeys(dto, entity, map) {
        const primaryKeys = CrudHelper.getPrimaryKeysWithMapPath(entity);
        for (const primaryKey of primaryKeys) {
            const name = CrudHelper.getDomainAttributeNameFormat(primaryKey.name);
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
                continue;
            }
            const dtoField = createElement("DTO-Field", CrudHelper.getFieldFormat(name), dto.id);
            dtoField.typeReference.setType(primaryKey.typeId);
            if (map &amp;&amp; primaryKey.mapPath != null) {
                console.log(`Doing mapping for ${dtoField.id}`);
                dtoField.setMapping(primaryKey.mapPath);
            }
        }
    }
    static getPrimaryKeysWithMapPath(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return Object.values(keydict);
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.isManagedForeignKey(x) &amp;&amp; // essentially also an attribute set by infrastructure
                !CrudHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return attrDict;
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !CrudHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static getDomainAttributeNameFormat(str) {
        let convention = CrudHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
            default:
                return str;
        }
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
}
/// &lt;reference path="attributeWithMapPath.ts" /&gt;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
ServicesConstants.dtoToDomainOperation = "8d1f6a8a-77c8-43a2-8e60-421559725419";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(innerElement, settings) {
        var _a;
        this.innerElement = innerElement;
        this.settings = settings;
        this.mappedElement = (_a = innerElement.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.innerElement.id; }
    ;
    setReturnType(typeId, isCollection, isNullable) {
        this.innerElement.typeReference.setType(typeId);
        if (isCollection != null) {
            this.innerElement.typeReference.setIsCollection(isCollection);
        }
        if (isNullable != null) {
            this.innerElement.typeReference.setIsNullable(isNullable);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.innerElement.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.innerElement.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.innerElement;
    }
    collapse() {
        this.innerElement.collapse();
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="../../common/attributeWithMapPath.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto) {
    let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
    childrenToAdd.forEach(e =&gt; {
        if (e.mapPath != null) {
            if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                return;
            }
        }
        else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
            return;
        }
        let field = createElement("DTO-Field", e.name, dto.id);
        field.typeReference.setType(e.typeId);
        field.typeReference.setIsCollection(e.isCollection);
        field.typeReference.setIsNullable(e.isNullable);
        if (this.mappedElement != null &amp;&amp; e.mapPath) {
            field.setMapping(e.mapPath);
        }
    });
    dto.collapse();
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", toPascalCase(entry.name), dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; {
        var _a;
        return !x.hasStereotype("Primary Key") &amp;&amp;
            !legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
    });
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
function onMapDto(element, folder, autoAddPrimaryKey = true, dtoPrefix = null, inbound = false) {
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b, _c; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; ((_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.specialization.startsWith("Association")); });
    fields.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement().typeReference.getType(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (DomainHelper.isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()));
    });
    complexAttributes.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), false, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
}
// services-crud script (see ~/DesignerMacros/src/services-crud folder in Intent.Modules)
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../../common/elementManager.ts" /&gt;
/// &lt;reference path="../../services-cqrs-crud/_common/onMapDto.ts" /&gt;
var _a, _b;
const privateSettersOnly = ((_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")) === null || _b === void 0 ? void 0 : _b.value) == "true";
var servicesCrud;
(function (servicesCrud) {
    async function execute() {
        const package = element.getPackage();
        const entity = await DomainHelper.openSelectEntityDialog({
            includeOwnedRelationships: false
        });
        if (!entity) {
            return;
        }
        if (privateSettersOnly &amp;&amp; !hasConstructor(entity)) {
            await dialogService.warn(`Partial Service Operation Creation.
Some service operations were created successfully, but was limited due to private setters being enabled, and no constructor is present for entity '${entity.getName()}'.

To avoid this limitation in the future, either disable private setters or add a constructor element to the entity.`);
        }
        const serviceName = `${toPascalCase(pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName()))}Service`;
        const existingService = element.specialization == "Service" ? element : package.getChildren("Service").find(x =&gt; x.getName() == pluralize(serviceName));
        const service = existingService || createElement("Service", serviceName, package.id);
        const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName());
        const existingFolder = package.getChildren("Folder").find(x =&gt; x.getName() == pluralize(folderName));
        const folder = existingFolder || createElement("Folder", pluralize(folderName), package.id);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const resultDto = createMappedResultDto(entity, folder);
        if (!privateSettersOnly || hasConstructor(entity)) {
            createStandardCreateOperation(service, entity, folder);
        }
        if (primaryKeys.length &gt; 0) {
            createStandardFindByIdOperation(service, entity, resultDto);
        }
        createStandardFindAllOperation(service, entity, resultDto);
        if (primaryKeys.length &gt; 0) {
            if (!privateSettersOnly) {
                createStandardUpdateOperation(service, entity, folder);
            }
            createStandardDeleteOperation(service, entity);
            const operations = DomainHelper.getCommandOperations(entity);
            for (const operation of operations) {
                createCallOperationCommand(service, operation, entity, folder);
            }
        }
    }
    servicesCrud.execute = execute;
    ;
    function hasConstructor(entity) {
        return entity.getChildren("Class Constructor").length &gt; 0;
    }
    function createMappedResultDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == dtoName);
        if (existing) {
            return existing;
        }
        let result = CrudHelper.getOrCreateCrudDto(dtoName, entity, true, CrudConstants.dtoFromEntityMappingId, folder, false);
        onMapDto(result, folder);
        return result;
        /*
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });


        dtoManager.mapToElement(entity, ServicesConstants.dtoFromEntityMappingId);

        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys)
        }

        let primaryKeys = DomainHelper.getPrimaryKeys(entity);

        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity))

        dtoManager.collapse();
        return dtoManager.getElement();*/
    }
    servicesCrud.createMappedResultDto = createMappedResultDto;
    function createStandardCreateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}CreateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Create${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Create${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });
        let operationManager = new ElementManager(createElement("Operation", `Create${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        const entityCtor = entity
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (entityCtor != null) {
            dtoManager.mapToElement(entityCtor, ServicesConstants.dtoToDomainOperation);
            dtoManager.getElement().setMapping([entity.id, entityCtor.id], ServicesConstants.dtoToDomainOperation);
        }
        else if (!privateSettersOnly) {
            dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        }
        else {
            console.warn(`Private Setters are enabled with no constructor present on entity '${entity.getName()}'. In order for 'Create${entity.getName()}' to map to that entity, either disable private setters or model a constructor element and try again.`);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const surrogateKey = primaryKeys.length === 1;
        if (primaryKeys.length == 1) {
            operationManager.setReturnType(primaryKeys[0].typeId);
        }
        if (entityCtor) {
            dtoManager.addChildrenFrom(DomainHelper.getChildrenOfType(entityCtor, "Parameter")
                .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        }
        else {
            if (!surrogateKey) {
                const toAdd = primaryKeys.filter(x =&gt; DomainHelper.isUserSuppliedPrimaryKey(lookup(x.id)));
                ServicesHelper.addDtoFieldsFromDomain(dtoManager.getElement(), toAdd);
            }
            dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
            dtoManager.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        }
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.addChild("dto", dtoManager.id);
        onMapDto(dtoManager.getElement(), folder, false, `${baseName}Create`, true);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardCreateOperation = createStandardCreateOperation;
    function createStandardFindByIdOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${entity.getName()}ById`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.addChildrenFrom(DomainHelper.getPrimaryKeys(entity));
        operationManager.collapse();
    }
    servicesCrud.createStandardFindByIdOperation = createStandardFindByIdOperation;
    function createStandardFindAllOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${pluralize(entity.getName())}`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id, true);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.collapse();
    }
    servicesCrud.createStandardFindAllOperation = createStandardFindAllOperation;
    function createStandardUpdateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}UpdateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Update${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Update${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
            childType: "property"
        });
        let operationManager = new ElementManager(createElement("Operation", `Update${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        dtoManager.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.addChild("dto", dtoManager.id);
        onMapDto(dtoManager.getElement(), folder, false, `${baseName}Update`);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardUpdateOperation = createStandardUpdateOperation;
    function createStandardDeleteOperation(service, entity) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        if (service.getChildren().some(x =&gt; x.getName() == `Delete${entity.getName()}`)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", `Delete${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.collapse();
    }
    servicesCrud.createStandardDeleteOperation = createStandardDeleteOperation;
    function createCallOperationCommand(service, operation, entity, folder) {
        var _a, _b;
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${operation.getName()}Dto`;
        if (service.getChildren().some(x =&gt; x.getName() == `${operation.getName()}`)) {
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
            childType: "property"
        });
        let operationManager = new ElementManager(createElement("Operation", `${operation.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(operation, ServicesConstants.dtoToDomainOperation);
        dtoManager.getElement().setMapping([entity.id, operation.id], ServicesConstants.dtoToDomainOperation);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        for (const key of primaryKeys) {
            dtoManager.addChild(key.name, lookup(key.id).typeReference);
        }
        dtoManager.addChildrenFrom(DomainHelper.getChildrenOfType(operation, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.addChild("dto", dtoManager.id);
        if (DomainHelper.isComplexType((_a = operation.typeReference) === null || _a === void 0 ? void 0 : _a.getType())) {
            var resultDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(operationManager.getElement(), operation) + "Result", (_b = operation.typeReference) === null || _b === void 0 ? void 0 : _b.getType(), false, CrudConstants.dtoFromEntityMappingId, folder, false);
            operationManager.setReturnType(resultDto.id, operation.typeReference.isCollection, operation.typeReference.isNullable);
        }
        onMapDto(dtoManager.getElement(), folder, false, `${operation.getName()}`);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createCallOperationCommand = createCallOperationCommand;
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
    /*
        function getOrCreateCrudDto(
            command: MacroApi.Context.IElementApi,
            mappedElement: MacroApi.Context.IElementApi,
            autoAddPrimaryKey: boolean,
            mappingTypeSettingId: string,
            inbound: boolean = false
        ): MacroApi.Context.IElementApi {
            if (mappedElement.typeReference == null) throw new Error("TypeReference is undefined");
    
            let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
            let domainName = mappedElement.typeReference.getType().getName();
            let baseName = command.getMetadata("baseName")
                ? `${command.getMetadata("baseName")}${domainName}`
                : domainName;
            let dtoName = `${originalVerb}${baseName}`;
            let dto = getOrCreateDto(dtoName, command.getParent());
            dto.setMetadata("originalVerb", originalVerb);
            dto.setMetadata("baseName", baseName);
    
            //dtoField.typeReference.setType(dto.id);
            const entityCtor: MacroApi.Context.IElementApi = mappedElement.typeReference.getType()
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
                // In descending order:
                return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
            })[0];
            if (inbound &amp;&amp; entityCtor != null) {
                dto.setMapping([mappedElement.typeReference.getTypeId(), entityCtor.id], mapToDomainConstructorForDtosSettingId);
                addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto);
            } else {
                dto.setMapping(mappedElement.typeReference.getTypeId(), mappingTypeSettingId);
                addDtoFields(autoAddPrimaryKey, mappedElement, dto);
            }
    
            return dto;
        }
    
        function addDtoFieldsForCtor(autoAddPrimaryKey: boolean, ctor: MacroApi.Context.IElementApi, dto: MacroApi.Context.IElementApi) {
        
            let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        
            childrenToAdd.forEach(e =&gt; {
                if (e.mapPath != null) {
                    if (dto.getChildren("Parameter").some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {
                        return;
                    }
                }
                else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                    return;
                }
        
                let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
                field.setMapping(e.mapPath);
                if (DomainHelper.isComplexTypeById(e.typeId)){
                    let newDto = getOrCreateCommandCrudDto(dto, field, autoAddPrimaryKey, mapFromDomainMappingSettingId, true );
                    field.typeReference.setType(newDto.id);
                }else{
                    field.typeReference.setType(e.typeId);
                }
                field.typeReference.setIsCollection(e.isCollection);
                field.typeReference.setIsNullable(e.isNullable);
            });
        
            dto.collapse();
        }
        
        function addDtoFields(autoAddPrimaryKey: boolean, mappedElement: MacroApi.Context.IElementApi, dto: MacroApi.Context.IElementApi) {
            let dtoUpdated = false;
            let domainElement = mappedElement
                .typeReference
                .getType();
            let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
            let isCreateMode = dto.getMetadata("originalVerb")?.toLowerCase()?.startsWith("create") == true;
            for (var keyName of Object.keys(attributesWithMapPaths)) {
                let entry = attributesWithMapPaths[keyName];
                if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
                    continue;
                }
                if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                    continue;
                }
                let field = createElement("DTO-Field", entry.name, dto.id);
                field.typeReference.setType(entry.typeId);
                field.typeReference.setIsNullable(entry.isNullable);
                field.typeReference.setIsCollection(entry.isCollection);
                field.setMapping(entry.mapPath);
                dtoUpdated = true;
            }
        
            if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
                addPrimaryKeys(dto, domainElement, true);
            }
        
            if (dtoUpdated) {
                dto.collapse();
            }
        }  */
})(servicesCrud || (servicesCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/create-crud/create-crud.ts
 */
await servicesCrud.execute();
</script>
        </runScript>
        <runScript group="1" type="run-script">
          <text>Create CRUD Traditional Service</text>
          <shortcut>alt + s</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "advanced";</isOptionVisibleFunction>
          <dependencies>
            <dependency name="Crud Api" id="61a8411f-b5bc-4a00-9a37-a967e0893d9d" />
          </dependencies>
          <script>await CrudApi.createTraditionalService(element);</script>
        </runScript>
        <runScript group="1" type="run-script">
          <text>Create CRUD CQRS Operations</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>function folderHasCommandOrQueries(element) {
    return element.specialization === "Folder" &amp;&amp; (element.getChildren("Command").length &gt; 0 || element.getChildren("Query").length &gt; 0);
}

return application.isModuleInstalled("Intent.Modelers.Services.CQRS") &amp;&amp;
    application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "basic" &amp;&amp;
    !folderHasCommandOrQueries(element);</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
;
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x),
            additionalInfo: `(${x.getParents().map(item =&gt; item.getName()).join("/")})`
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    /**
     * Returns true if the attribute is a foreign key on a compositional one-to-many relationship (i.e. is managed by the DB and should not be set).
     * @param attribute
     * @returns
     */
    static isManagedForeignKey(attribute) {
        var _a, _b;
        let fkAssociation = (_b = (_a = attribute.getStereotype("Foreign Key")) === null || _a === void 0 ? void 0 : _a.getProperty("Association")) === null || _b === void 0 ? void 0 : _b.getSelected();
        return fkAssociation != null &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsCollection() &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsNullable();
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
/// &lt;reference path="attributeWithMapPath.ts" /&gt;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
ServicesConstants.dtoToDomainOperation = "8d1f6a8a-77c8-43a2-8e60-421559725419";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="../../common/attributeWithMapPath.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto) {
    let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
    childrenToAdd.forEach(e =&gt; {
        if (e.mapPath != null) {
            if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                return;
            }
        }
        else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
            return;
        }
        let field = createElement("DTO-Field", e.name, dto.id);
        field.typeReference.setType(e.typeId);
        field.typeReference.setIsCollection(e.isCollection);
        field.typeReference.setIsNullable(e.isNullable);
        if (this.mappedElement != null &amp;&amp; e.mapPath) {
            field.setMapping(e.mapPath);
        }
    });
    dto.collapse();
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", toPascalCase(entry.name), dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; {
        var _a;
        return !x.hasStereotype("Primary Key") &amp;&amp;
            !legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
    });
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
class CrudConstants {
}
CrudConstants.mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
CrudConstants.mapToDomainConstructorForDtosSettingId = "8d1f6a8a-77c8-43a2-8e60-421559725419";
CrudConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class CrudHelper {
    static getName(command, mappedElement, dtoPrefix = null) {
        if (mappedElement.typeReference != null)
            mappedElement = mappedElement.typeReference.getType();
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        if (dtoPrefix)
            dtoName = `${dtoPrefix}${dtoName}`;
        return dtoName;
    }
    static getOrCreateCrudDto(dtoName, mappedElement, autoAddPrimaryKey, mappingTypeSettingId, folder, inbound = false) {
        let dto = CrudHelper.getOrCreateDto(dtoName, folder);
        //dtoField.typeReference.setType(dto.id);
        const entityCtor = mappedElement
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (inbound &amp;&amp; entityCtor != null) {
            dto.setMapping([mappedElement.id, entityCtor.id], CrudConstants.mapToDomainConstructorForDtosSettingId);
            CrudHelper.addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto, folder);
        }
        else {
            dto.setMapping(mappedElement.id, mappingTypeSettingId);
            CrudHelper.addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder);
        }
        return dto;
    }
    static getOrCreateDto(elementName, parentElement) {
        const expectedDtoName = elementName.replace(/Dto$/, "") + "Dto";
        let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
        if (existingDto) {
            return existingDto;
        }
        let dto = createElement("DTO", expectedDtoName, parentElement.id);
        return dto;
    }
    static addDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto, folder) {
        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        childrenToAdd.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
            field.setMapping(e.mapPath);
            if (DomainHelper.isComplexTypeById(e.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(e.typeId);
            }
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
        });
        dto.collapse();
    }
    static addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder) {
        var _a, _b;
        let dtoUpdated = false;
        let domainElement = mappedElement;
        let attributesWithMapPaths = CrudHelper.getAttributesWithMapPath(domainElement);
        let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
        for (var keyName of Object.keys(attributesWithMapPaths)) {
            let entry = attributesWithMapPaths[keyName];
            if (isCreateMode &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {
                continue;
            }
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                continue;
            }
            let field = createElement("DTO-Field", entry.name, dto.id);
            field.setMapping(entry.mapPath);
            if (DomainHelper.isComplexTypeById(entry.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(entry.typeId);
            }
            field.typeReference.setIsNullable(entry.isNullable);
            field.typeReference.setIsCollection(entry.isCollection);
            dtoUpdated = true;
        }
        if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
            CrudHelper.addPrimaryKeys(dto, domainElement, true);
        }
        if (dtoUpdated) {
            dto.collapse();
        }
    }
    static isOwnerForeignKey(attributeName, domainElement) {
        for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
            if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
                return true;
            }
        }
        return false;
    }
    static addPrimaryKeys(dto, entity, map) {
        const primaryKeys = CrudHelper.getPrimaryKeysWithMapPath(entity);
        for (const primaryKey of primaryKeys) {
            const name = CrudHelper.getDomainAttributeNameFormat(primaryKey.name);
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
                continue;
            }
            const dtoField = createElement("DTO-Field", CrudHelper.getFieldFormat(name), dto.id);
            dtoField.typeReference.setType(primaryKey.typeId);
            if (map &amp;&amp; primaryKey.mapPath != null) {
                console.log(`Doing mapping for ${dtoField.id}`);
                dtoField.setMapping(primaryKey.mapPath);
            }
        }
    }
    static getPrimaryKeysWithMapPath(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return Object.values(keydict);
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.isManagedForeignKey(x) &amp;&amp; // essentially also an attribute set by infrastructure
                !CrudHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return attrDict;
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !CrudHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static getDomainAttributeNameFormat(str) {
        let convention = CrudHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
            default:
                return str;
        }
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
}
/**
 * Workaround for element's from referenced packages not having getParent()
 * @param element The element whose parent should be searched for
 * @param parentSpecializationType The specialization type of the parent
 */
function getParent(element, parentSpecializationType) {
    const elements = lookupTypesOf(parentSpecializationType);
    const parent = elements
        .find(x =&gt; x.getChildren(element.specialization)
        .some(child =&gt; child.id === element.id));
    if (parent == null) {
        throw new Error("Could not find parent");
    }
    return parent;
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
/// &lt;reference path="../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/getParent.ts" /&gt;
/**
 * Gets select details of a mapped Command/Query. Intended for centralized logic of working out
 * things like keys for both the entity and owning entity if applicable.
 *
 * If the Command is for entity creation (either due to being mapped to a constructor or being
 * prefixed with "Create"), then primary keys for the entity are not populated.
 * @param request The Command or Query that has been mapped
 */
function getMappedRequestDetails(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    // Advanced mapping:
    if (mappedElement == null) {
        const advancedMappings = request.getAssociations()
            .filter(x =&gt; x.hasMappings(queryEntityMappingTypeId) ||
            x.hasMappings(createEntityMappingTypeId))
            .map(x =&gt; x.getMapping(queryEntityMappingTypeId) ||
            x.getMapping(createEntityMappingTypeId));
        if (advancedMappings.length === 1) {
            mappedElement = advancedMappings[0].getTargetElement();
        }
    }
    if (mappedElement == null) {
        return null;
    }
    let entity = mappedElement;
    if (entity.specialization !== "Class") {
        entity = getParent(entity, "Class");
    }
    const result = {
        entity: entity,
        mappingTargetType: mappedElement.specialization,
        entityKeyFields: [],
        ownerKeyFields: []
    };
    result.owningEntity = DomainHelper.getOwningAggregate(entity);
    // As long as it's not for creation, populate the PKs of the entity:
    if (result.mappingTargetType !== "Class Constructor" &amp;&amp;
        !request.getName().toLowerCase().startsWith("Create")) {
        result.entityKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity)
            : getKeysForOperationMapping(request, entity);
    }
    // If the entity is owned, populate its fields:
    if (result.owningEntity != null) {
        result.ownerKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity, result.owningEntity)
            : getKeysForOperationMapping(request, entity, result.owningEntity);
    }
    return result;
    /**
     * Return field details for primary keys. As requests mapped to operations and constructors can
     * never possibly map the attributes, these fields can only ever be matched by name.
     * @param request The CQRS Command or Query entity
     * @param owningEntity The Owning Aggregate Class
     */
    function getKeysForOperationMapping(request, entity, owningEntity) {
        const pks = DomainHelper.getPrimaryKeys(owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity);
        return pks.map(pk =&gt; {
            let fieldName = toPascalCase(pk.name);
            if (owningEntity != null) {
                fieldName = removePrefix(fieldName, toPascalCase(owningEntity.getName()));
                fieldName = `${owningEntity.getName()}${toCamelCase(fieldName)}`;
            }
            fieldName = ServicesHelper.getFieldFormat(fieldName);
            const existingField = request.getChildren("DTO-Field").find(field =&gt; field.getName().toLowerCase() == fieldName.toLowerCase());
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: [],
                name: fieldName,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
    function getKeysForClassMapping(request, entity, owningEntity) {
        const keys = owningEntity != null
            ? DomainHelper.getForeignKeys(entity, owningEntity)
            : DomainHelper.getPrimaryKeys(entity);
        return keys.map(pk =&gt; {
            const existingField = request.getChildren("DTO-Field").find(field =&gt; {
                if (field.getMapping() != null) {
                    return field.getMapping().getPath().some(x =&gt; x.id == pk.id);
                }
                return (pk.name.toLowerCase() === field.getName().toLowerCase());
            });
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: pk.mapPath,
                name: pk.name,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/**
 * Ensures that for the provided contract, it has the provided field creating it if necessary and
 * then ensure the field has the correct typeReference details and order.
 * The field's element is returned.
 */
function ensureHasField(options) {
    const { contract, fieldDetail, mappingSettingsId, order } = options;
    let field = fieldDetail.existingId != null
        ? contract.getChildren("DTO-Field").find(x =&gt; x.id === fieldDetail.existingId)
        : createElement("DTO-Field", fieldDetail.name, contract.id);
    field.typeReference.setType(fieldDetail.typeId);
    field.typeReference.setIsCollection(fieldDetail.isCollection);
    field.typeReference.setIsNullable(fieldDetail.isNullable);
    if (order != null) {
        field.setOrder(order);
    }
    if (mappingSettingsId != null) {
        field.setMapping(fieldDetail.mappingPath, mappingSettingsId);
        console.warn("mapping:" + fieldDetail.mappingPath);
    }
    return field;
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/// &lt;reference path="ensureHasField.ts" /&gt;
function onMapCommand(element, isForCrudScript, excludePrimaryKeys = false, inbound = false) {
    var _a, _b, _c;
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    const mappingDetails = getMappedRequestDetails(element);
    if (mappingDetails &amp;&amp; (isForCrudScript || mappingDetails.mappingTargetType !== "Class")) {
        let order = 0;
        let keyFields = mappingDetails.ownerKeyFields;
        if (!excludePrimaryKeys) {
            keyFields = keyFields.concat(mappingDetails.entityKeyFields);
        }
        for (const keyField of keyFields) {
            ensureHasField({
                contract: element,
                fieldDetail: keyField,
                order: order++
            });
        }
    }
    if (mappingDetails &amp;&amp;
        mappingDetails.mappingTargetType === "Operation" &amp;&amp;
        DomainHelper.isComplexType((_c = (_b = (_a = element.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType())) {
        let mappedElement = element.getMapping().getElement();
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, mappedElement), mappedElement.typeReference.getType(), false, mapFromDomainMappingSettingId, element.getParent(), false);
        setTypeRef(element, newDto, mappedElement);
    }
    const fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; ((_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement().specialization.startsWith("Association")); });
    fields.forEach(field =&gt; {
        let mappedElement = field.getMapping().getElement();
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, mappedElement), mappedElement.typeReference.getType(), !excludePrimaryKeys, projectMappingSettingId, element.getParent(), inbound);
        setTypeRef(field, newDto, mappedElement);
    });
    const complexFields = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp;
            DomainHelper.isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType());
    });
    complexFields.forEach(cf =&gt; {
        let mappedElement = cf.getMapping().getElement();
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, mappedElement), mappedElement.typeReference.getType(), false, projectMappingSettingId, element.getParent(), inbound);
        setTypeRef(cf, newDto, mappedElement);
    });
    function setTypeRef(element, newDto, mappedElement) {
        var _a, _b;
        element.typeReference.setType(newDto.id);
        if (((_a = mappedElement === null || mappedElement === void 0 ? void 0 : mappedElement.typeReference) === null || _a === void 0 ? void 0 : _a.isCollection) != null) {
            element.typeReference.setIsCollection(mappedElement.typeReference.isCollection);
        }
        if ((_b = mappedElement === null || mappedElement === void 0 ? void 0 : mappedElement.typeReference) === null || _b === void 0 ? void 0 : _b.isNullable) {
            element.typeReference.setIsNullable(mappedElement.typeReference.isNullable);
        }
    }
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
function onMapDto(element, folder, autoAddPrimaryKey = true, dtoPrefix = null, inbound = false) {
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b, _c; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; ((_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.specialization.startsWith("Association")); });
    fields.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement().typeReference.getType(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (DomainHelper.isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()));
    });
    complexAttributes.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), false, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
function onMapQuery(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; x.getMapping().getElement().specialization.startsWith("Association"); });
    fields.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d, _e;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (complexTypes.includes((_e = (_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()) === null || _e === void 0 ? void 0 : _e.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
}
function getOrCreateQueryCrudDto(element, dtoField) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    let mappedElement = dtoField.getMapping().getElement();
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : `${domainName}`;
    let dtoName = baseName;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMappingSettingId);
    dto.setMetadata("baseName", baseName);
    ensureDtoFieldsQuery(mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
function ensureDtoFieldsQuery(mappedElement, dto) {
    let dtoUpdated = false;
    let mappedElementAttributes = mappedElement
        .typeReference
        .getType()
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; !dtoFields.some(y =&gt; x.getName() === y.getName()))) {
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == attribute.getName())) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.getName(), dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
class ElementManager {
    constructor(innerElement, settings) {
        var _a;
        this.innerElement = innerElement;
        this.settings = settings;
        this.mappedElement = (_a = innerElement.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.innerElement.id; }
    ;
    setReturnType(typeId, isCollection, isNullable) {
        this.innerElement.typeReference.setType(typeId);
        if (isCollection != null) {
            this.innerElement.typeReference.setIsCollection(isCollection);
        }
        if (isNullable != null) {
            this.innerElement.typeReference.setIsNullable(isNullable);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.innerElement.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.innerElement.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.innerElement;
    }
    collapse() {
        this.innerElement.collapse();
    }
}
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../_common/onMapCommand.ts" /&gt;
/// &lt;reference path="../_common/onMapDto.ts" /&gt;
/// &lt;reference path="../_common/onMapQuery.ts" /&gt;
/// &lt;reference path="../../common/attributeWithMapPath.ts" /&gt;
/// &lt;reference path="../../common/elementManager.ts" /&gt;
var _a, _b;
const privateSettersOnly = ((_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")) === null || _b === void 0 ? void 0 : _b.value) == "true";
const mapToDomainOperationSettingId = "7c31c459-6229-4f10-bf13-507348cd8828";
var cqrsCrud;
(function (cqrsCrud) {
    async function execute(element) {
        var _a;
        let entity = await DomainHelper.openSelectEntityDialog();
        if (entity == null) {
            return;
        }
        if (privateSettersOnly &amp;&amp; !hasConstructor(entity)) {
            await dialogService.warn(`Partial CQRS Operation Creation.
Some CQRS operations were created successfully, but was limited due to private setters being enabled, and no constructor is present for entity '${entity.getName()}'.

To avoid this limitation in the future, either disable private setters or add a constructor element to the entity.`);
        }
        const owningEntity = DomainHelper.getOwningAggregate(entity);
        const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? owningEntity.getName() : entity.getName());
        const folder = (_a = element.getChildren().find(x =&gt; x.getName() == pluralize(folderName))) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Folder", pluralize(folderName), element.id);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const hasPrimaryKey = primaryKeys.length &gt; 0;
        const resultDto = createCqrsResultTypeDto(entity, folder);
        if (!privateSettersOnly || hasConstructor(entity)) {
            createCqrsCreateCommand(entity, folder, primaryKeys);
        }
        if (hasPrimaryKey) {
            createCqrsFindByIdQuery(entity, folder, resultDto);
        }
        createCqrsFindAllQuery(entity, folder, resultDto);
        if (hasPrimaryKey &amp;&amp; !privateSettersOnly) {
            createCqrsUpdateCommand(entity, folder);
        }
        const operations = DomainHelper.getCommandOperations(entity);
        for (const operation of operations) {
            createCqrsCallOperationCommand(entity, operation, folder);
        }
        if (hasPrimaryKey) {
            createCqrsDeleteCommand(entity, folder);
        }
    }
    cqrsCrud.execute = execute;
    function hasConstructor(entity) {
        return entity.getChildren("Class Constructor").length &gt; 0;
    }
    function createCqrsCreateCommand(entity, folder, primaryKeys) {
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = getBaseNameForElement(owningAggregate, entity, false);
        const expectedCommandName = `Create${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            const returnType = primaryKeys.length == 1
                ? primaryKeys[0].typeId
                : null;
            const command = folder.getChildren().filter(x =&gt; x.getName() == expectedCommandName)[0];
            command.typeReference.setType(returnType);
            return command;
        }
        const commandManager = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        const entityCtor = entity
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (entityCtor != null) {
            commandManager.mapToElement(entityCtor, mapToDomainOperationSettingId);
            commandManager.getElement().setMapping([entity.id, entityCtor.id], mapToDomainOperationSettingId);
        }
        else if (!privateSettersOnly) {
            commandManager.mapToElement(entity);
        }
        else {
            console.warn(`Private Setters are enabled with no constructor present on entity '${entity.getName()}'. In order for '${expectedCommandName}' to map to that entity, either disable private setters or model a constructor element and try again.`);
        }
        commandManager.getElement().setMetadata("baseName", baseName);
        const surrogateKey = primaryKeys.length === 1;
        if (surrogateKey) {
            commandManager.setReturnType(primaryKeys[0].typeId);
        }
        if (entityCtor) {
            commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(entityCtor, "Parameter")
                .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        }
        else {
            const toAdd = primaryKeys.filter(x =&gt; DomainHelper.isUserSuppliedPrimaryKey(lookup(x.id)));
            if (toAdd.length &gt; 0) {
                ServicesHelper.addDtoFieldsFromDomain(commandManager.getElement(), toAdd);
            }
            commandManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
            commandManager.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        }
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandManager.getElement());
        }
        onMapCommand(commandManager.getElement(), true, true, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCreateCommand = createCqrsCreateCommand;
    function createCqrsFindByIdQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedQueryName = `Get${baseName}ByIdQuery`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(query, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        onMapQuery(query);
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindByIdQuery = createCqrsFindByIdQuery;
    function createCqrsFindAllQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, true);
        let expectedQueryName = `Get${baseName}Query`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.typeReference.setIsCollection(true);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindAllQuery = createCqrsFindAllQuery;
    function createCqrsUpdateCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Update${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        command.mapToElement(entity);
        command.getElement().setMetadata("baseName", baseName);
        command.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        command.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command.getElement(), primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command.getElement());
        }
        onMapCommand(command.getElement(), true, true);
        command.collapse();
        return command.getElement();
    }
    cqrsCrud.createCqrsUpdateCommand = createCqrsUpdateCommand;
    function createCqrsCallOperationCommand(entity, operation, folder) {
        var _a;
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = (_a = owningAggregate === null || owningAggregate === void 0 ? void 0 : owningAggregate.getName()) !== null &amp;&amp; _a !== void 0 ? _a : "";
        let operationName = operation.getName();
        operationName = removeSuffix(operationName, "Async");
        operationName = toPascalCase(operationName);
        const commandName = `${operationName}${entity.getName()}Command`;
        const existing = folder.getChildren().find(x =&gt; {
            var _a, _b;
            return x.getName() == commandName ||
                ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) === operation.id;
        });
        if (existing) {
            return existing;
        }
        const commandElement = createElement("Command", commandName, folder.id);
        commandElement.setMetadata("baseName", baseName);
        const commandManager = new ElementManager(commandElement, { childSpecialization: "DTO-Field" });
        commandManager.mapToElement([entity.id, operation.id], mapToDomainOperationSettingId);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        for (const key of primaryKeys) {
            commandManager.addChild(key.name, lookup(key.id).typeReference);
        }
        commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(operation, "Parameter")
            .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandElement);
        }
        onMapCommand(commandElement, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCallOperationCommand = createCqrsCallOperationCommand;
    function createCqrsDeleteCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Delete${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = createElement("Command", expectedCommandName, folder.id);
        command.setMapping(entity.id);
        command.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), command.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command);
        }
        onMapCommand(command, true);
        command.collapse();
        return command;
    }
    cqrsCrud.createCqrsDeleteCommand = createCqrsDeleteCommand;
    function createCqrsResultTypeDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedDtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedDtoName);
        if (existing) {
            return existing;
        }
        let dto = createElement("DTO", expectedDtoName, folder.id);
        dto.setMetadata("baseName", baseName);
        dto.setMapping(entity.id);
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), dto.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        ServicesHelper.addDtoFieldsFromDomain(dto, primaryKeys);
        let attributesWithMapPaths = DomainHelper.getAttributesWithMapPath(entity);
        for (var attr of attributesWithMapPaths) {
            if (dto.getChildren("DTO-Field").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == attr.id; })) {
                continue;
            }
            let field = createElement("DTO-Field", attr.name, dto.id);
            field.typeReference.setType(attr.typeId);
            field.setMapping(attr.mapPath);
        }
        onMapDto(dto, folder);
        dto.collapse();
        return dto;
    }
    cqrsCrud.createCqrsResultTypeDto = createCqrsResultTypeDto;
    function addAggregatePkToCommandOrQuery(owningAggregate, commandOrQuery) {
        if (owningAggregate != null) {
            var aggPks = DomainHelper.getPrimaryKeys(owningAggregate);
            aggPks.forEach(x =&gt; {
                if (x.name.toLowerCase() == "id") {
                    x.name = `${owningAggregate.getName()}Id`;
                }
                x.id = null;
                x.mapPath = null;
                x.isCollection = false;
                x.isNullable = false;
            });
            ServicesHelper.addDtoFieldsFromDomain(commandOrQuery, aggPks);
        }
    }
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
})(cqrsCrud || (cqrsCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/create-crud-macro/create-crud-macro.ts
 */
await cqrsCrud.execute(element);
</script>
        </runScript>
        <runScript group="1" type="run-script">
          <text>Create CRUD CQRS Operations</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return application.isModuleInstalled("Intent.Modelers.Services.CQRS") &amp;&amp;
    application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "advanced";</isOptionVisibleFunction>
          <dependencies>
            <dependency name="Crud Api" id="61a8411f-b5bc-4a00-9a37-a967e0893d9d" />
          </dependencies>
          <script>await CrudApi.createCQRSService(element);</script>
        </runScript>
      </contextMenuOptions>
      <creationOptions />
      <scriptOptions>
        <option group="1" type="run-script">
          <text>Create CRUD Traditional Service</text>
          <shortcut>alt + s</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "basic";</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
;
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x),
            additionalInfo: `(${x.getParents().map(item =&gt; item.getName()).join("/")})`
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    /**
     * Returns true if the attribute is a foreign key on a compositional one-to-many relationship (i.e. is managed by the DB and should not be set).
     * @param attribute
     * @returns
     */
    static isManagedForeignKey(attribute) {
        var _a, _b;
        let fkAssociation = (_b = (_a = attribute.getStereotype("Foreign Key")) === null || _a === void 0 ? void 0 : _a.getProperty("Association")) === null || _b === void 0 ? void 0 : _b.getSelected();
        return fkAssociation != null &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsCollection() &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsNullable();
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
class CrudConstants {
}
CrudConstants.mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
CrudConstants.mapToDomainConstructorForDtosSettingId = "8d1f6a8a-77c8-43a2-8e60-421559725419";
CrudConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class CrudHelper {
    static getName(command, mappedElement, dtoPrefix = null) {
        if (mappedElement.typeReference != null)
            mappedElement = mappedElement.typeReference.getType();
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        if (dtoPrefix)
            dtoName = `${dtoPrefix}${dtoName}`;
        return dtoName;
    }
    static getOrCreateCrudDto(dtoName, mappedElement, autoAddPrimaryKey, mappingTypeSettingId, folder, inbound = false) {
        let dto = CrudHelper.getOrCreateDto(dtoName, folder);
        //dtoField.typeReference.setType(dto.id);
        const entityCtor = mappedElement
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (inbound &amp;&amp; entityCtor != null) {
            dto.setMapping([mappedElement.id, entityCtor.id], CrudConstants.mapToDomainConstructorForDtosSettingId);
            CrudHelper.addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto, folder);
        }
        else {
            dto.setMapping(mappedElement.id, mappingTypeSettingId);
            CrudHelper.addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder);
        }
        return dto;
    }
    static getOrCreateDto(elementName, parentElement) {
        const expectedDtoName = elementName.replace(/Dto$/, "") + "Dto";
        let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
        if (existingDto) {
            return existingDto;
        }
        let dto = createElement("DTO", expectedDtoName, parentElement.id);
        return dto;
    }
    static addDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto, folder) {
        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        childrenToAdd.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
            field.setMapping(e.mapPath);
            if (DomainHelper.isComplexTypeById(e.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(e.typeId);
            }
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
        });
        dto.collapse();
    }
    static addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder) {
        var _a, _b;
        let dtoUpdated = false;
        let domainElement = mappedElement;
        let attributesWithMapPaths = CrudHelper.getAttributesWithMapPath(domainElement);
        let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
        for (var keyName of Object.keys(attributesWithMapPaths)) {
            let entry = attributesWithMapPaths[keyName];
            if (isCreateMode &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {
                continue;
            }
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                continue;
            }
            let field = createElement("DTO-Field", entry.name, dto.id);
            field.setMapping(entry.mapPath);
            if (DomainHelper.isComplexTypeById(entry.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(entry.typeId);
            }
            field.typeReference.setIsNullable(entry.isNullable);
            field.typeReference.setIsCollection(entry.isCollection);
            dtoUpdated = true;
        }
        if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
            CrudHelper.addPrimaryKeys(dto, domainElement, true);
        }
        if (dtoUpdated) {
            dto.collapse();
        }
    }
    static isOwnerForeignKey(attributeName, domainElement) {
        for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
            if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
                return true;
            }
        }
        return false;
    }
    static addPrimaryKeys(dto, entity, map) {
        const primaryKeys = CrudHelper.getPrimaryKeysWithMapPath(entity);
        for (const primaryKey of primaryKeys) {
            const name = CrudHelper.getDomainAttributeNameFormat(primaryKey.name);
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
                continue;
            }
            const dtoField = createElement("DTO-Field", CrudHelper.getFieldFormat(name), dto.id);
            dtoField.typeReference.setType(primaryKey.typeId);
            if (map &amp;&amp; primaryKey.mapPath != null) {
                console.log(`Doing mapping for ${dtoField.id}`);
                dtoField.setMapping(primaryKey.mapPath);
            }
        }
    }
    static getPrimaryKeysWithMapPath(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return Object.values(keydict);
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.isManagedForeignKey(x) &amp;&amp; // essentially also an attribute set by infrastructure
                !CrudHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return attrDict;
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !CrudHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static getDomainAttributeNameFormat(str) {
        let convention = CrudHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
            default:
                return str;
        }
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
}
/// &lt;reference path="attributeWithMapPath.ts" /&gt;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
ServicesConstants.dtoToDomainOperation = "8d1f6a8a-77c8-43a2-8e60-421559725419";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(innerElement, settings) {
        var _a;
        this.innerElement = innerElement;
        this.settings = settings;
        this.mappedElement = (_a = innerElement.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.innerElement.id; }
    ;
    setReturnType(typeId, isCollection, isNullable) {
        this.innerElement.typeReference.setType(typeId);
        if (isCollection != null) {
            this.innerElement.typeReference.setIsCollection(isCollection);
        }
        if (isNullable != null) {
            this.innerElement.typeReference.setIsNullable(isNullable);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.innerElement.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.innerElement.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.innerElement;
    }
    collapse() {
        this.innerElement.collapse();
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="../../common/attributeWithMapPath.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto) {
    let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
    childrenToAdd.forEach(e =&gt; {
        if (e.mapPath != null) {
            if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                return;
            }
        }
        else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
            return;
        }
        let field = createElement("DTO-Field", e.name, dto.id);
        field.typeReference.setType(e.typeId);
        field.typeReference.setIsCollection(e.isCollection);
        field.typeReference.setIsNullable(e.isNullable);
        if (this.mappedElement != null &amp;&amp; e.mapPath) {
            field.setMapping(e.mapPath);
        }
    });
    dto.collapse();
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", toPascalCase(entry.name), dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; {
        var _a;
        return !x.hasStereotype("Primary Key") &amp;&amp;
            !legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
    });
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
function onMapDto(element, folder, autoAddPrimaryKey = true, dtoPrefix = null, inbound = false) {
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b, _c; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; ((_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.specialization.startsWith("Association")); });
    fields.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement().typeReference.getType(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (DomainHelper.isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()));
    });
    complexAttributes.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), false, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
}
// services-crud script (see ~/DesignerMacros/src/services-crud folder in Intent.Modules)
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../../common/elementManager.ts" /&gt;
/// &lt;reference path="../../services-cqrs-crud/_common/onMapDto.ts" /&gt;
var _a, _b;
const privateSettersOnly = ((_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")) === null || _b === void 0 ? void 0 : _b.value) == "true";
var servicesCrud;
(function (servicesCrud) {
    async function execute() {
        const package = element.getPackage();
        const entity = await DomainHelper.openSelectEntityDialog({
            includeOwnedRelationships: false
        });
        if (!entity) {
            return;
        }
        if (privateSettersOnly &amp;&amp; !hasConstructor(entity)) {
            await dialogService.warn(`Partial Service Operation Creation.
Some service operations were created successfully, but was limited due to private setters being enabled, and no constructor is present for entity '${entity.getName()}'.

To avoid this limitation in the future, either disable private setters or add a constructor element to the entity.`);
        }
        const serviceName = `${toPascalCase(pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName()))}Service`;
        const existingService = element.specialization == "Service" ? element : package.getChildren("Service").find(x =&gt; x.getName() == pluralize(serviceName));
        const service = existingService || createElement("Service", serviceName, package.id);
        const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName());
        const existingFolder = package.getChildren("Folder").find(x =&gt; x.getName() == pluralize(folderName));
        const folder = existingFolder || createElement("Folder", pluralize(folderName), package.id);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const resultDto = createMappedResultDto(entity, folder);
        if (!privateSettersOnly || hasConstructor(entity)) {
            createStandardCreateOperation(service, entity, folder);
        }
        if (primaryKeys.length &gt; 0) {
            createStandardFindByIdOperation(service, entity, resultDto);
        }
        createStandardFindAllOperation(service, entity, resultDto);
        if (primaryKeys.length &gt; 0) {
            if (!privateSettersOnly) {
                createStandardUpdateOperation(service, entity, folder);
            }
            createStandardDeleteOperation(service, entity);
            const operations = DomainHelper.getCommandOperations(entity);
            for (const operation of operations) {
                createCallOperationCommand(service, operation, entity, folder);
            }
        }
    }
    servicesCrud.execute = execute;
    ;
    function hasConstructor(entity) {
        return entity.getChildren("Class Constructor").length &gt; 0;
    }
    function createMappedResultDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == dtoName);
        if (existing) {
            return existing;
        }
        let result = CrudHelper.getOrCreateCrudDto(dtoName, entity, true, CrudConstants.dtoFromEntityMappingId, folder, false);
        onMapDto(result, folder);
        return result;
        /*
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });


        dtoManager.mapToElement(entity, ServicesConstants.dtoFromEntityMappingId);

        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys)
        }

        let primaryKeys = DomainHelper.getPrimaryKeys(entity);

        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity))

        dtoManager.collapse();
        return dtoManager.getElement();*/
    }
    servicesCrud.createMappedResultDto = createMappedResultDto;
    function createStandardCreateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}CreateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Create${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Create${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
        });
        let operationManager = new ElementManager(createElement("Operation", `Create${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        const entityCtor = entity
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (entityCtor != null) {
            dtoManager.mapToElement(entityCtor, ServicesConstants.dtoToDomainOperation);
            dtoManager.getElement().setMapping([entity.id, entityCtor.id], ServicesConstants.dtoToDomainOperation);
        }
        else if (!privateSettersOnly) {
            dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        }
        else {
            console.warn(`Private Setters are enabled with no constructor present on entity '${entity.getName()}'. In order for 'Create${entity.getName()}' to map to that entity, either disable private setters or model a constructor element and try again.`);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const surrogateKey = primaryKeys.length === 1;
        if (primaryKeys.length == 1) {
            operationManager.setReturnType(primaryKeys[0].typeId);
        }
        if (entityCtor) {
            dtoManager.addChildrenFrom(DomainHelper.getChildrenOfType(entityCtor, "Parameter")
                .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        }
        else {
            if (!surrogateKey) {
                const toAdd = primaryKeys.filter(x =&gt; DomainHelper.isUserSuppliedPrimaryKey(lookup(x.id)));
                ServicesHelper.addDtoFieldsFromDomain(dtoManager.getElement(), toAdd);
            }
            dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
            dtoManager.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        }
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.addChild("dto", dtoManager.id);
        onMapDto(dtoManager.getElement(), folder, false, `${baseName}Create`, true);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardCreateOperation = createStandardCreateOperation;
    function createStandardFindByIdOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${entity.getName()}ById`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.addChildrenFrom(DomainHelper.getPrimaryKeys(entity));
        operationManager.collapse();
    }
    servicesCrud.createStandardFindByIdOperation = createStandardFindByIdOperation;
    function createStandardFindAllOperation(service, entity, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let operationName = `Find${pluralize(entity.getName())}`;
        if (service.getChildren().some(x =&gt; x.getName() == operationName)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        operationManager.setReturnType(resultDto.id, true);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        operationManager.collapse();
    }
    servicesCrud.createStandardFindAllOperation = createStandardFindAllOperation;
    function createStandardUpdateOperation(service, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}UpdateDto`;
        if (service.getChildren().some(x =&gt; x.getName() == `Update${entity.getName()}`)) {
            let operation = service.getChildren().filter(x =&gt; x.getName() == `Update${entity.getName()}`)[0];
            let pks = DomainHelper.getPrimaryKeys(entity);
            operation.typeReference.setType(pks[0].typeId);
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
            childType: "property"
        });
        let operationManager = new ElementManager(createElement("Operation", `Update${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(entity, ServicesConstants.dtoToEntityMappingId);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        dtoManager.addChildrenFrom(primaryKeys);
        dtoManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        dtoManager.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.addChild("dto", dtoManager.id);
        onMapDto(dtoManager.getElement(), folder, false, `${baseName}Update`);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createStandardUpdateOperation = createStandardUpdateOperation;
    function createStandardDeleteOperation(service, entity) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        if (service.getChildren().some(x =&gt; x.getName() == `Delete${entity.getName()}`)) {
            return;
        }
        let operationManager = new ElementManager(createElement("Operation", `Delete${entity.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.collapse();
    }
    servicesCrud.createStandardDeleteOperation = createStandardDeleteOperation;
    function createCallOperationCommand(service, operation, entity, folder) {
        var _a, _b;
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${operation.getName()}Dto`;
        if (service.getChildren().some(x =&gt; x.getName() == `${operation.getName()}`)) {
            return;
        }
        let dtoManager = new ElementManager(createElement("DTO", dtoName, folder.id), {
            childSpecialization: "DTO-Field",
            childType: "property"
        });
        let operationManager = new ElementManager(createElement("Operation", `${operation.getName()}`, service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        dtoManager.mapToElement(operation, ServicesConstants.dtoToDomainOperation);
        dtoManager.getElement().setMapping([entity.id, operation.id], ServicesConstants.dtoToDomainOperation);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            dtoManager.addChildrenFrom(foreignKeys);
            operationManager.addChildrenFrom(foreignKeys);
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        for (const key of primaryKeys) {
            dtoManager.addChild(key.name, lookup(key.id).typeReference);
        }
        dtoManager.addChildrenFrom(DomainHelper.getChildrenOfType(operation, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        operationManager.addChildrenFrom(primaryKeys);
        operationManager.addChild("dto", dtoManager.id);
        if (DomainHelper.isComplexType((_a = operation.typeReference) === null || _a === void 0 ? void 0 : _a.getType())) {
            var resultDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(operationManager.getElement(), operation) + "Result", (_b = operation.typeReference) === null || _b === void 0 ? void 0 : _b.getType(), false, CrudConstants.dtoFromEntityMappingId, folder, false);
            operationManager.setReturnType(resultDto.id, operation.typeReference.isCollection, operation.typeReference.isNullable);
        }
        onMapDto(dtoManager.getElement(), folder, false, `${operation.getName()}`);
        dtoManager.collapse();
        operationManager.collapse();
    }
    servicesCrud.createCallOperationCommand = createCallOperationCommand;
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
    /*
        function getOrCreateCrudDto(
            command: MacroApi.Context.IElementApi,
            mappedElement: MacroApi.Context.IElementApi,
            autoAddPrimaryKey: boolean,
            mappingTypeSettingId: string,
            inbound: boolean = false
        ): MacroApi.Context.IElementApi {
            if (mappedElement.typeReference == null) throw new Error("TypeReference is undefined");
    
            let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
            let domainName = mappedElement.typeReference.getType().getName();
            let baseName = command.getMetadata("baseName")
                ? `${command.getMetadata("baseName")}${domainName}`
                : domainName;
            let dtoName = `${originalVerb}${baseName}`;
            let dto = getOrCreateDto(dtoName, command.getParent());
            dto.setMetadata("originalVerb", originalVerb);
            dto.setMetadata("baseName", baseName);
    
            //dtoField.typeReference.setType(dto.id);
            const entityCtor: MacroApi.Context.IElementApi = mappedElement.typeReference.getType()
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
                // In descending order:
                return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
            })[0];
            if (inbound &amp;&amp; entityCtor != null) {
                dto.setMapping([mappedElement.typeReference.getTypeId(), entityCtor.id], mapToDomainConstructorForDtosSettingId);
                addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto);
            } else {
                dto.setMapping(mappedElement.typeReference.getTypeId(), mappingTypeSettingId);
                addDtoFields(autoAddPrimaryKey, mappedElement, dto);
            }
    
            return dto;
        }
    
        function addDtoFieldsForCtor(autoAddPrimaryKey: boolean, ctor: MacroApi.Context.IElementApi, dto: MacroApi.Context.IElementApi) {
        
            let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        
            childrenToAdd.forEach(e =&gt; {
                if (e.mapPath != null) {
                    if (dto.getChildren("Parameter").some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {
                        return;
                    }
                }
                else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                    return;
                }
        
                let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
                field.setMapping(e.mapPath);
                if (DomainHelper.isComplexTypeById(e.typeId)){
                    let newDto = getOrCreateCommandCrudDto(dto, field, autoAddPrimaryKey, mapFromDomainMappingSettingId, true );
                    field.typeReference.setType(newDto.id);
                }else{
                    field.typeReference.setType(e.typeId);
                }
                field.typeReference.setIsCollection(e.isCollection);
                field.typeReference.setIsNullable(e.isNullable);
            });
        
            dto.collapse();
        }
        
        function addDtoFields(autoAddPrimaryKey: boolean, mappedElement: MacroApi.Context.IElementApi, dto: MacroApi.Context.IElementApi) {
            let dtoUpdated = false;
            let domainElement = mappedElement
                .typeReference
                .getType();
            let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
            let isCreateMode = dto.getMetadata("originalVerb")?.toLowerCase()?.startsWith("create") == true;
            for (var keyName of Object.keys(attributesWithMapPaths)) {
                let entry = attributesWithMapPaths[keyName];
                if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
                    continue;
                }
                if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                    continue;
                }
                let field = createElement("DTO-Field", entry.name, dto.id);
                field.typeReference.setType(entry.typeId);
                field.typeReference.setIsNullable(entry.isNullable);
                field.typeReference.setIsCollection(entry.isCollection);
                field.setMapping(entry.mapPath);
                dtoUpdated = true;
            }
        
            if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
                addPrimaryKeys(dto, domainElement, true);
            }
        
            if (dtoUpdated) {
                dto.collapse();
            }
        }  */
})(servicesCrud || (servicesCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/create-crud/create-crud.ts
 */
await servicesCrud.execute();
</script>
        </option>
        <option group="1" type="run-script">
          <text>Create CRUD Traditional Service</text>
          <shortcut>alt + s</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "advanced";</isOptionVisibleFunction>
          <dependencies>
            <dependency name="Crud Api" id="61a8411f-b5bc-4a00-9a37-a967e0893d9d" />
          </dependencies>
          <script>await CrudApi.createTraditionalService(element);</script>
        </option>
        <option group="1" type="run-script">
          <text>Create CRUD CQRS Operations</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAX2klEQVR4Xu2cCXxU1b3Hf///nUkyIWFL2FEQQUAEAiibIERF6v4qLX3iVi2ofdhXEBQzVYiggFjS+sG2D5fKoq2Ppq0SS4u17MGwyi6bsiUhQCDs2WbueZ9z7j6TAUIo0NfMp3Um95577jnf+9/PuRBqPzUiQDW6uvZi1AKsoRDUAqwFWEMCNby8VgJrAdaQQA0v/5eRQPFuoCVQ2RbMjUFcF9CbgzgAoKliQEiAQFMQAeyiombIRSCUqaOC9qlvpgNgHAFQDC20D9tKD1Im9OryvKoACgHCz5GIFCSi3HcDfDwIEA8A1AUEzQBlDll+uX+bFFVcYR232luzVN+k/ud8m8iMa1aCaRk08SeUiz1ITj6L+wpLiSBigb0qAIp50FCi3Q/gByDqBEGtwKgbBcyKuqqCZ8N0TUkes+G5wNsQq3gIzkM5ClABGJuh00eoU7KI7kF5JMgrClDMjL8eovJ7AI0FUWqUZHgkzAZwFkRnABwHIaS+DSBhEB2XSmpDY5teqj1xohTzfAqI6gHwnfe+xgPbAWAm4rXf071Hiqz+rhhAMVMbBoG3QVRf6VOkWjkSVQCBPwP0FUjkwu8vgaAwQqcqkKxUq0JNZhtAmebvCDER8xBnHzqVGg+JM1weh5Duh661BlFnMNIh0A9E1zjpRYQEG6pcAuDH9N1j80xDUF2zWbP2IhM+NPFNAuElR71sm1QMQUvBWAPW1yEcv5lGnDlUsztW72rxaWpzVFTeBOYeIPQF0BuwtMMep3RIr+HBo1MuuwSKd9EFId86MHym3ZeqVygHRCMq36nedP/5rcUCxKO84bMAxgLUHAQ2nVQpgNsuP8CZviwAo22VBZ7G6coP6XnIAV21H5GTnAo97ikleSC/6e1HXQGA/nkg8X1XONGVRlRsumrJuQYmPktNRxjzQUgytIfHXX6A72j3AZzjCi9OA5iBQOBNeuSENNBX3UfMaxlAfNn7IDwAoI7L6997+QG+57sDgv5qq4F6ktLbUQkg/gFgKYSeRz+qXHulSIqFTeqgorILdO4LIfqB+G5AxHsiBaJy6Prgyw/wHd9CEN9VdYBrwVToQgB9Cta/QJj+BuE7g7i4cpw5FkIDhGho1SHLhUJXoU2guQ+lpX6gMg7xCQ2h63eDcC9AtwIInD8+pODlB/i+PxeC+qrBCdoPRjGA7oZNqSpzsId4EoRiEJ2EEKfBMmim0yCxRyW/LM4gzHvhc+ezRvYH6NcBSFI5MnNbCCSAVDSYaAbTDUCQQbUrPawyc9kIovaAul42vkIAQX0NOyJW0lMVt4r34+8G06MgdAOoDQjx3snY8ZfBIzJDqVa65n5Isfq14cnI4FsQrQPofxDw70RZ5Q4QUtT4GVcA4G+lBLIhgTAAql8yAfsD6uBMnSSwuAck7gUwCETJnsT/ksFzgfTkxtI00J8A+hsg/o4E7QQNPiRTR4gvWqQYAM10kK4IwLhcKAlUkrSSnixTAGN9xEd12wF6MwhxHQRdB0ZjkCw0qKDWKGcZqp8IyHMRxQSj42IwSW8vP4UgVIA4H9BPgrgARPsQFgdB4W/pu8f3xhyLBFgRkjmxlU9fCQmMywWxAZCxkp44N8Bzwb3c55QESoCWCkNcCYAJr4LRzpz8Lvph2YTLDeJi76cAVoYdCaQrAPBiB381XGcDVBKoTJAjgfXfXPMg69QWmlEPt6viMkKwRm/9YPZUzQHNKBdbUYOKFlx1dfXT/Nv95W6jWS3sH8YVrjbm0Oy+1Hl1T3PM7lI+xP5t32/1h0sJXgEMWRKobG2QUt9Y3zwkwp8Q4RZpgI3wxvVt1umUbY487jpHroqwXdoz4zrVm0o2DAOvvu3KOpl23/yW93DVBq3fUfdXHVXRp9uJgFayiB+8dWhjy4HUiKcCGNYdFZZhTL2pq0cQSJWR5MTs+58LogeqMRMjG/MC8sCKghcJ0brWfFARD858rvY9oh+mqybrgsjMz2wd0vKSlMlsgHYcSEGqN2V1BoDJ7slfkAR4JDI2REcyq5LAKiCeSzIt7bDiXEuS3dLvPqeehZ617Xutx9RI9MyLxcLm14DEJoDqm+UsB6AtLR5JtFTvAtX6vBP0QoxUz6olNuLe7nuo4cUyD9bxmgMUi1snoLL8NoAmAuhlwIOAoJFU7/W8DBBP9tgkDwjHNhltIgfsQFFqFaHe0XbPyQBsk1GFufDat4uHSFwzgOJvzYeD9HEgbgXAKKQaDE5Bpx4KoAAZKuwGZEM8t8H32KZzORyP84i4VwynEgkx2sZGOh7LQTn2kCGytg29MBUWC1q0BIe7AugB4lsAMdAonlaZ9ulgPGkD9HrHSNV1/W06jGiP7fau5g2jJCu6jUeiI+2f63qPk3M96Cipt02QZQxF1vahrceoXHt+ahLqxMehIsyoDPkR7++DsN4RjFsA+g7IXL2LlW+Dzqr00Rq0JoKU/HpeBglSKuwdZIRXtFXXcRgxw55z2KaqH1QVEnnecCfCnLil3x0VkAlwYZPGqBTLzTzWZ5axoncpVA3vGIimg3gFoH8CkCx/yRJakOpOXPW4IPEsWYvQ7qdrhahs2Tb2xG+KuAq03RKq/lLH3R5YHbJCGTM4dry98bDUYbcUKtpO5G09eHXEAmZeaMWJ5q2d80S/3/6frWao5UofF3grO7Y9s6THcA4EuSvhAAQ2gfXP6M6ibNlAhTFygd3KRJiDhHnzNGzr5MohYjj8G4FOlyIWqHYfN1b7CvcFjbYt0ZdkpocUQL9WYJ9zBesAToEoD0T/gBBfQOO9SKSz1Dffs1KoALLaoSBBelO5Go3yX+Bi8WlqMnw8BuAjYJyGToegiWPQsYfuKZK7tM77sQHa20OuQEX6vKO8ihsogBq7ylkcpKTM5QMFaXc59syyOWaCTjh5IthzqjWvlDdW36GD77CMVmShQWP++vDotLlW+8ZvbX6MoHd02zjjnHGlIF5fNLKTsjHy03Lm1mEk+Ca7iWF2lYFUV4T1z/eO6LjEan/97N3PCBKtZH+emoX1h6AVOx9pveBSPBcHoFWR5iDVeTUvA9Anx4ro5baLk8GeLawB1J+yKpNYm+ANqt2BLucUP58m10/Vp9FbG+czcL/jsSNSOsaswh/f9KQLYDZAQ9xxqSc/Jw7ufardFKt9mzm7cyHQN7LYYMSQctkFWTsfaXNpUjkpgT7NcSKaBVDok+14KioEocKTP4sASDzBWkGLiuMIOcXPd/cAJIH7Y1VzCDSrcKQL4G+2ZoNpiARkQ/TGk8G9T7V3AM7enQsItUhV1T0IImvnI9dfeoDyZkxSAldmCIHJdhnLyPNcKRtHAQTxBE977+Bzise6AP5iw3witwR60z1BNKvIBbDFb7ZmE9GQWBJOoODe4W6Au3KFJYHucZhelukSAlwlF5WkBFoqbAHUhSGBEU/dtEOFp37W21bhuq+vymSWEmitLkbV8XKORgJUKuyUqSypNUVmVtFzjgRKgAA8Kmzfi9TWKC/AD3blCmMbmqfOaEkvBLJ2P3aJJHBx81SwfzvYXNaUq3IJ41dmMInJCpZZDIiwh4WnXvECJKYJTl4alejnHH2hh6PCWRvkZpz7Y0k4iD0Am/16SzZHSaBTZ2TyAmz92125RKKvO6Wz7Z/hfi4dwOWtHwbELIDizMwtSEmvrOgUJu4iS+Oeirg8II8JlJ56pdcnltFuMHFlZ/j9N7nL97aHYw1CDxUef7HnUutYatb6ARppze027pBd/g5jz6H/7ppnnW/2qy39fJp2TXR7YzwUqty0/+lOW63z132wc5AgpBpjN9qYv5SnF77Q9t0Pt/vqYr2wyGtbFxWhbmDxEwgMsTMZQiVA95kZ8MV2///3OrG4pVwfGgHQMBAaK6lTWmrOmagUGvf/twcocps0RrmvGVi7ASRugKA0sNyrQ20cYFalxcnBTZAvUMIryx+HwDNkrX65qhFmWFB8dnyfBy1ZS5606kdgkjs17aKBXSQwIt7cknE9XrTaN/z5umlEdKtTSLAGYygdCf2vh0alvWar8NubXyemgdbfJIsJVjBNMvDGzIIRN86xzl/77o6ZpOEmsxxhbFlRRQnTbgp8/M0TbWeoqnIodC9YpBm7GKg3CJ0BSnYVSY1uq67InALha4A6Gzsi1I2ClPDyigzA8cLeIqYaROGZzL62F06a9GUmkduJRBVic0peusV2IilvrjecSGSx1ZH9WYdHpdmBdNO3N2cTYIQxyqk5T186N8EULHi6ox0HXvv+9lwSqMKJ2AtkWd8+0W6M+Pya5tBEgUsFTVimKDiq6T0OrAfjPQhahDIcR6LYCrCxtYNMgEKIyd4g1JMteAG++mWm7YXNSVqibnrvnOMegOsUwNhLpvACnLE5G4Qhbq/tLYtxsOBZF8B3t+fK3fReL+9ZlnUA+oRRjYlVMDU2ux8CYR+YF0HT/ky9d+db0i5WdUhBuNyIA1U/EmBwRYYgfXKsSF5K4NlXb3Uk0AToDXStMEMNLgqgQBWZiDkRokiAG7MBHmI8UEM63EumIAQLnu3kSKAECCmBVa87Eyjr2ydNCfTDBKimvxWgPSCxAWHOg+bbBK48DU0vQ5/8sqpe71IAdQugGmCQ4oJShXUlgTHWHCIA5maCZSYSq4qMnOMZPR0VnrZuvgToqKTtxUw+NOvIaEeFG7+1MZtVKmcF6FGVZy/Ad75WgXSsZVm2AMrXyRo1vQa+uBPUf/9F7cVWAEWls7AuJMCXlmWAoQJp98K6HcmDCksnuiQw0wDokUALpnxshJyTLoANpq2bTxBKhWPcY9aR0d1sGygBylQuKq+1TJW0gW4JlADhFBO895APQWTtebL9pcmFLYDuvTG+cUv7MtEAVS7yRtKm96PTpRNvnWF74Ykr+kP4+tlRt3vvjLHVdveJjF72npSGU9Z+XzDa2n2bG1qsfS+CxObiUWmfWf03/sWGh4ipvbNHxynpyz5EWF9aOLLzSqt9i3e3Pa4JamEsLURMgAGdsXr/D9vLzes1/igJhJRA+327y7+9rcazuIIdGACt/YEq0akFWJ3noQCStUNVFRuDpL2w+D5ltO341lQDIyiWi2LHyyf1G23dKDFz2X8A/gftMM4uYJs2Dth48uXev7Ta15+cNwrsk4vV6sPW6p8ZHAtw7rGx3d6zzjf6xaaRRPrNRmPjP+5tbgLij4ee62yrfItfb3kZTNe7t7gZC3lmRR3hhXuH3/hxdUDFamsADBsFVSNCCJLvxSUZILMeyFQGiBNEvFiD2BAmvoGJ2pa91m+ADXD88kxZD4zeAmfvCsg59XIv2wvXnbJ6PgGDiCD7XUMEWWjoBFAPIrQC4Y9Hx/ZQmY38NMraYMSBnhjTHddx8OBzThhjlr/OArSDSXQRRH2IOJWMBXAZemftG97x0jiRta2aQcRtAaGhMVoLoJGJZJPgNytLm23EjHZRb2ZbE0wYvzyTwBOiJmjGbUTsAVh/ct5jQqOvTwQabsZ/u/qdN0+r+8311/nitfhjz6fZ1ZVG09dng9msSEfvuxFEwUPPdbbjwEhpafSrrUkJfl9HQIwlwlDphS8FQLG2XS/omAZGf3ujpMBI8r+waLQgSgxNS39dvXrP9eS7Gl2gaU2gUSU03gjiDdbSX8L4Fa8QMDHWnkAB5JwZ38eWQDlBMQ8BhOt2gV/rDo3rqxddybcGfmyiwYcOuyGkTF9v1gMj9vs5QfW4op90mab6nZPUGAEtDUyd4dPiwD75vvEGJBd9RekItXp3+wuCkLJ/eIeXqqvCaivIV+2boVLvLvfAGG8wyfdX7H0yBRD6AMLolQHU+7xctPl5KuJogfo3CzROUGGEjBuYdfi4BMzDaXDhJwmZy9tQmL5xCpjetYtIgOJ3yfKNoGz4qDeY4+1+NQpD007AR8No0MGF1gRTpq/LJmInlVOaYgbVjBN+3X9L/k9v3CU+SkqHRh+CuQk01lS/xpjLwLQZLO6jEzOOpp7qklj8ow6nLhSg2NopDqfKHwVjBAjtzWKD+W6zbfkPgyt6Ube9e9UR8ZukxqgrFoI5TUHTyBqM8a0GRifh4+F0R8EfAi+veAiEj0Hkj8yhZSpnSaCSEA3LYMV10oEk1Af0s4aNV33L9zf4v+iuArUUqgBCOrXobcYaiccP/jRtrpibNBSM2dAowRiv6//yHgbIPHD4Ebrz0LdueGKFLCposrbXGqQ1BURTgFsZpSzcAKa2hnlzlbBsqRNnIehTABPp5p3bVTOltuWBL0A80JYOHwPxDQBRClDYmqi14bs9bVuyL1B8aAoErrVF2vSqxLT2zPi+U4UAY07gC2ialBSjj7i6wN0bgbVPAiVfWg9GfksJuZnuLNiZmrVhjBDhPoYflepiuXk6cGRU19FKokPhfdA4UfUbG6CEMB8lBQ/RUIQVOPadr5hg+gY3POggkqWsz6FjvAXOeigkPozrDF37Esx1bIBJzYEBC4BtmcDhv3oBMk2k2/PP+26HmB2QEFZCk2V2E2C7Z4C0N4Aji4DVD7sBShBj6PYD8m32c37ErMAMaPScrSlthgFlBUDJauD6EcDxVcDpLRbYk/CH2tJtRUcMgH6jnGXaU0PSzP9El7MOgkialvkgbT12f50vH0Tk4Ej8NvAD+OhjSNH3aUDStUC99kDvOcCuLODQX4CKIoDKrUH9ndIPGDsZzvERs+N/CvAvbYDJ1wL9s4G67YFwKbBjKrD/PZcq8xeUfmDQOfuUr6ieDSyCRrfaAPvPA5oMAA78L3Dtw8DG54DDn5ljVcHug3R74XxDdU2AdtAr3+wkuS/mGIATYOwCeDV0LKdeOzeeb46GCn+Q8BI0nqIABlKAwcuA+EaALwDoFYBeCWx4GihZYg1qCaXnpyePWZwaCvie8KafMvCmb85m9v1EfJCQCaYJCmCgodFv4QKg7dOGZLcbBXx5H1C+z7Jhmyn9QBf52oUOPMzW4pOpwboIzTtav+dxaAmroXEHG6A0CwNzgAbdgB1vAN++pVbC7POkTaPb949Ti0NCnwBQCYi/BtFuaOWHUZFUjnJUoLS8ku7ZHTN8iwWTxJyExwCeY0igH2iWDjTsCnQcBxRkA8fygKOLAP24JYFKUuKDS+4GaQtsJ2KbDc45O7HvA2J2YByAqQpgfDKQlgmk9ATCp4HQGaBOK2DdMEO6pX308TIaeGBAwzfX94EQK+21YKusBXH/kY49/o5DgaXwUS8b0E0vAu1HASe3AfW6AOseA0pWOACZHqX0/I8uRJoupg2JWYFbwbQITHG2DazXBrh9CbAlAyjM9tpAjd6m9PyfJASXThBEsrxvG17jJ+eUSoCz4u8F8WceGzj4S2DpIKDnbGD/+8DRxdK7W7bwTbo9/8UGb6xWm96lD7aLqtIjC4wtHtt9upiVMBsaP+6o8MfAwb8ABz8D+mYDe94Gij+3AJZDxLWiO/f80/7tGemFk1BeZxUINzpe2Ac07gec2QGEjnkBEg+g5dPz4iuafg5gQBWV4JzSif0eEDORiITAOmhaB9uJDM4DQieB+BRgz0wgf64F8Cw0HkDpB9Y2nLomW1j1QNdWDbnD+eiY7g+K2YndwHKdwgy3zuWFfZSHssDAi1HNC5VGIw78XXIH6PpiaNz0HHFgCKz9kgblv+Aft7wrWF9ORMmexSKjKJtTOqmfykTEB3EdEBe3BEwy2AXqdzI8spy0fDChoxKgDtayZL/ymvpT15iLSlFbRiqYuPeRMWlfiTmJk6BxBjTSYoYxGhdD8Pfornx7kf9CoVSnnR1ai7nJ/eHHX0CcXGUgTTwRqc1eo5xfBeLKy7YJohaehRx77QI5pZP6GwBlOvRhYjdo2kL4ONVRV3fwi3E4XjTdChEkQGNvTMSWEeNmB3xCu7mobtcSJCX9DBpNqBKgj09D4A76TtHq6sC4mLY2QDXheQ3qQYQfhU+TFeem0LTTYN4Ov/YxDT64TrbxvbT4TgI9Yt1MbvdRnpiMspOAvrH89dvscpbqd25iM8T5HoLGveHTWoJxHBpvga7l0P3eSTaYumakABnlLPnvLFnVNbswTR8cGdt9mer3o/pp8Ith8LH8t64CYMqHJvc6h+fSPcdOXgyQ6l7jAVjdi2vbOzs9allcJIFaCbxIcI4Jq2EH/+6X10pgDSWgFmAtwBoSqOHl/wfCkA2o2wygUAAAAABJRU5ErkJggg==" />
          <isOptionVisibleFunction>function folderHasCommandOrQueries(element) {
    return element.specialization === "Folder" &amp;&amp; (element.getChildren("Command").length &gt; 0 || element.getChildren("Query").length &gt; 0);
}

return application.isModuleInstalled("Intent.Modelers.Services.CQRS") &amp;&amp;
    application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "basic" &amp;&amp;
    !folderHasCommandOrQueries(element);</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
;
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x),
            additionalInfo: `(${x.getParents().map(item =&gt; item.getName()).join("/")})`
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    /**
     * Returns true if the attribute is a foreign key on a compositional one-to-many relationship (i.e. is managed by the DB and should not be set).
     * @param attribute
     * @returns
     */
    static isManagedForeignKey(attribute) {
        var _a, _b;
        let fkAssociation = (_b = (_a = attribute.getStereotype("Foreign Key")) === null || _a === void 0 ? void 0 : _a.getProperty("Association")) === null || _b === void 0 ? void 0 : _b.getSelected();
        return fkAssociation != null &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsCollection() &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsNullable();
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
/// &lt;reference path="attributeWithMapPath.ts" /&gt;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
ServicesConstants.dtoToDomainOperation = "8d1f6a8a-77c8-43a2-8e60-421559725419";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="../../common/attributeWithMapPath.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto) {
    let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
    childrenToAdd.forEach(e =&gt; {
        if (e.mapPath != null) {
            if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                return;
            }
        }
        else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
            return;
        }
        let field = createElement("DTO-Field", e.name, dto.id);
        field.typeReference.setType(e.typeId);
        field.typeReference.setIsCollection(e.isCollection);
        field.typeReference.setIsNullable(e.isNullable);
        if (this.mappedElement != null &amp;&amp; e.mapPath) {
            field.setMapping(e.mapPath);
        }
    });
    dto.collapse();
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", toPascalCase(entry.name), dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; {
        var _a;
        return !x.hasStereotype("Primary Key") &amp;&amp;
            !legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
    });
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
class CrudConstants {
}
CrudConstants.mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
CrudConstants.mapToDomainConstructorForDtosSettingId = "8d1f6a8a-77c8-43a2-8e60-421559725419";
CrudConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class CrudHelper {
    static getName(command, mappedElement, dtoPrefix = null) {
        if (mappedElement.typeReference != null)
            mappedElement = mappedElement.typeReference.getType();
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        if (dtoPrefix)
            dtoName = `${dtoPrefix}${dtoName}`;
        return dtoName;
    }
    static getOrCreateCrudDto(dtoName, mappedElement, autoAddPrimaryKey, mappingTypeSettingId, folder, inbound = false) {
        let dto = CrudHelper.getOrCreateDto(dtoName, folder);
        //dtoField.typeReference.setType(dto.id);
        const entityCtor = mappedElement
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (inbound &amp;&amp; entityCtor != null) {
            dto.setMapping([mappedElement.id, entityCtor.id], CrudConstants.mapToDomainConstructorForDtosSettingId);
            CrudHelper.addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto, folder);
        }
        else {
            dto.setMapping(mappedElement.id, mappingTypeSettingId);
            CrudHelper.addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder);
        }
        return dto;
    }
    static getOrCreateDto(elementName, parentElement) {
        const expectedDtoName = elementName.replace(/Dto$/, "") + "Dto";
        let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
        if (existingDto) {
            return existingDto;
        }
        let dto = createElement("DTO", expectedDtoName, parentElement.id);
        return dto;
    }
    static addDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto, folder) {
        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        childrenToAdd.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
            field.setMapping(e.mapPath);
            if (DomainHelper.isComplexTypeById(e.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(e.typeId);
            }
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
        });
        dto.collapse();
    }
    static addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder) {
        var _a, _b;
        let dtoUpdated = false;
        let domainElement = mappedElement;
        let attributesWithMapPaths = CrudHelper.getAttributesWithMapPath(domainElement);
        let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
        for (var keyName of Object.keys(attributesWithMapPaths)) {
            let entry = attributesWithMapPaths[keyName];
            if (isCreateMode &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {
                continue;
            }
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                continue;
            }
            let field = createElement("DTO-Field", entry.name, dto.id);
            field.setMapping(entry.mapPath);
            if (DomainHelper.isComplexTypeById(entry.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(entry.typeId);
            }
            field.typeReference.setIsNullable(entry.isNullable);
            field.typeReference.setIsCollection(entry.isCollection);
            dtoUpdated = true;
        }
        if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
            CrudHelper.addPrimaryKeys(dto, domainElement, true);
        }
        if (dtoUpdated) {
            dto.collapse();
        }
    }
    static isOwnerForeignKey(attributeName, domainElement) {
        for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
            if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
                return true;
            }
        }
        return false;
    }
    static addPrimaryKeys(dto, entity, map) {
        const primaryKeys = CrudHelper.getPrimaryKeysWithMapPath(entity);
        for (const primaryKey of primaryKeys) {
            const name = CrudHelper.getDomainAttributeNameFormat(primaryKey.name);
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
                continue;
            }
            const dtoField = createElement("DTO-Field", CrudHelper.getFieldFormat(name), dto.id);
            dtoField.typeReference.setType(primaryKey.typeId);
            if (map &amp;&amp; primaryKey.mapPath != null) {
                console.log(`Doing mapping for ${dtoField.id}`);
                dtoField.setMapping(primaryKey.mapPath);
            }
        }
    }
    static getPrimaryKeysWithMapPath(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return Object.values(keydict);
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.isManagedForeignKey(x) &amp;&amp; // essentially also an attribute set by infrastructure
                !CrudHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return attrDict;
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !CrudHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static getDomainAttributeNameFormat(str) {
        let convention = CrudHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
            default:
                return str;
        }
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
}
/**
 * Workaround for element's from referenced packages not having getParent()
 * @param element The element whose parent should be searched for
 * @param parentSpecializationType The specialization type of the parent
 */
function getParent(element, parentSpecializationType) {
    const elements = lookupTypesOf(parentSpecializationType);
    const parent = elements
        .find(x =&gt; x.getChildren(element.specialization)
        .some(child =&gt; child.id === element.id));
    if (parent == null) {
        throw new Error("Could not find parent");
    }
    return parent;
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
/// &lt;reference path="../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/getParent.ts" /&gt;
/**
 * Gets select details of a mapped Command/Query. Intended for centralized logic of working out
 * things like keys for both the entity and owning entity if applicable.
 *
 * If the Command is for entity creation (either due to being mapped to a constructor or being
 * prefixed with "Create"), then primary keys for the entity are not populated.
 * @param request The Command or Query that has been mapped
 */
function getMappedRequestDetails(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    // Advanced mapping:
    if (mappedElement == null) {
        const advancedMappings = request.getAssociations()
            .filter(x =&gt; x.hasMappings(queryEntityMappingTypeId) ||
            x.hasMappings(createEntityMappingTypeId))
            .map(x =&gt; x.getMapping(queryEntityMappingTypeId) ||
            x.getMapping(createEntityMappingTypeId));
        if (advancedMappings.length === 1) {
            mappedElement = advancedMappings[0].getTargetElement();
        }
    }
    if (mappedElement == null) {
        return null;
    }
    let entity = mappedElement;
    if (entity.specialization !== "Class") {
        entity = getParent(entity, "Class");
    }
    const result = {
        entity: entity,
        mappingTargetType: mappedElement.specialization,
        entityKeyFields: [],
        ownerKeyFields: []
    };
    result.owningEntity = DomainHelper.getOwningAggregate(entity);
    // As long as it's not for creation, populate the PKs of the entity:
    if (result.mappingTargetType !== "Class Constructor" &amp;&amp;
        !request.getName().toLowerCase().startsWith("Create")) {
        result.entityKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity)
            : getKeysForOperationMapping(request, entity);
    }
    // If the entity is owned, populate its fields:
    if (result.owningEntity != null) {
        result.ownerKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity, result.owningEntity)
            : getKeysForOperationMapping(request, entity, result.owningEntity);
    }
    return result;
    /**
     * Return field details for primary keys. As requests mapped to operations and constructors can
     * never possibly map the attributes, these fields can only ever be matched by name.
     * @param request The CQRS Command or Query entity
     * @param owningEntity The Owning Aggregate Class
     */
    function getKeysForOperationMapping(request, entity, owningEntity) {
        const pks = DomainHelper.getPrimaryKeys(owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity);
        return pks.map(pk =&gt; {
            let fieldName = toPascalCase(pk.name);
            if (owningEntity != null) {
                fieldName = removePrefix(fieldName, toPascalCase(owningEntity.getName()));
                fieldName = `${owningEntity.getName()}${toCamelCase(fieldName)}`;
            }
            fieldName = ServicesHelper.getFieldFormat(fieldName);
            const existingField = request.getChildren("DTO-Field").find(field =&gt; field.getName().toLowerCase() == fieldName.toLowerCase());
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: [],
                name: fieldName,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
    function getKeysForClassMapping(request, entity, owningEntity) {
        const keys = owningEntity != null
            ? DomainHelper.getForeignKeys(entity, owningEntity)
            : DomainHelper.getPrimaryKeys(entity);
        return keys.map(pk =&gt; {
            const existingField = request.getChildren("DTO-Field").find(field =&gt; {
                if (field.getMapping() != null) {
                    return field.getMapping().getPath().some(x =&gt; x.id == pk.id);
                }
                return (pk.name.toLowerCase() === field.getName().toLowerCase());
            });
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: pk.mapPath,
                name: pk.name,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/**
 * Ensures that for the provided contract, it has the provided field creating it if necessary and
 * then ensure the field has the correct typeReference details and order.
 * The field's element is returned.
 */
function ensureHasField(options) {
    const { contract, fieldDetail, mappingSettingsId, order } = options;
    let field = fieldDetail.existingId != null
        ? contract.getChildren("DTO-Field").find(x =&gt; x.id === fieldDetail.existingId)
        : createElement("DTO-Field", fieldDetail.name, contract.id);
    field.typeReference.setType(fieldDetail.typeId);
    field.typeReference.setIsCollection(fieldDetail.isCollection);
    field.typeReference.setIsNullable(fieldDetail.isNullable);
    if (order != null) {
        field.setOrder(order);
    }
    if (mappingSettingsId != null) {
        field.setMapping(fieldDetail.mappingPath, mappingSettingsId);
        console.warn("mapping:" + fieldDetail.mappingPath);
    }
    return field;
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/// &lt;reference path="ensureHasField.ts" /&gt;
function onMapCommand(element, isForCrudScript, excludePrimaryKeys = false, inbound = false) {
    var _a, _b, _c;
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    const mappingDetails = getMappedRequestDetails(element);
    if (mappingDetails &amp;&amp; (isForCrudScript || mappingDetails.mappingTargetType !== "Class")) {
        let order = 0;
        let keyFields = mappingDetails.ownerKeyFields;
        if (!excludePrimaryKeys) {
            keyFields = keyFields.concat(mappingDetails.entityKeyFields);
        }
        for (const keyField of keyFields) {
            ensureHasField({
                contract: element,
                fieldDetail: keyField,
                order: order++
            });
        }
    }
    if (mappingDetails &amp;&amp;
        mappingDetails.mappingTargetType === "Operation" &amp;&amp;
        DomainHelper.isComplexType((_c = (_b = (_a = element.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType())) {
        let mappedElement = element.getMapping().getElement();
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, mappedElement), mappedElement.typeReference.getType(), false, mapFromDomainMappingSettingId, element.getParent(), false);
        setTypeRef(element, newDto, mappedElement);
    }
    const fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; ((_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement().specialization.startsWith("Association")); });
    fields.forEach(field =&gt; {
        let mappedElement = field.getMapping().getElement();
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, mappedElement), mappedElement.typeReference.getType(), !excludePrimaryKeys, projectMappingSettingId, element.getParent(), inbound);
        setTypeRef(field, newDto, mappedElement);
    });
    const complexFields = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp;
            DomainHelper.isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType());
    });
    complexFields.forEach(cf =&gt; {
        let mappedElement = cf.getMapping().getElement();
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, mappedElement), mappedElement.typeReference.getType(), false, projectMappingSettingId, element.getParent(), inbound);
        setTypeRef(cf, newDto, mappedElement);
    });
    function setTypeRef(element, newDto, mappedElement) {
        var _a, _b;
        element.typeReference.setType(newDto.id);
        if (((_a = mappedElement === null || mappedElement === void 0 ? void 0 : mappedElement.typeReference) === null || _a === void 0 ? void 0 : _a.isCollection) != null) {
            element.typeReference.setIsCollection(mappedElement.typeReference.isCollection);
        }
        if ((_b = mappedElement === null || mappedElement === void 0 ? void 0 : mappedElement.typeReference) === null || _b === void 0 ? void 0 : _b.isNullable) {
            element.typeReference.setIsNullable(mappedElement.typeReference.isNullable);
        }
    }
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
function onMapDto(element, folder, autoAddPrimaryKey = true, dtoPrefix = null, inbound = false) {
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b, _c; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; ((_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.specialization.startsWith("Association")); });
    fields.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement().typeReference.getType(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (DomainHelper.isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()));
    });
    complexAttributes.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), false, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
function onMapQuery(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; x.getMapping().getElement().specialization.startsWith("Association"); });
    fields.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d, _e;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (complexTypes.includes((_e = (_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()) === null || _e === void 0 ? void 0 : _e.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
}
function getOrCreateQueryCrudDto(element, dtoField) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    let mappedElement = dtoField.getMapping().getElement();
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : `${domainName}`;
    let dtoName = baseName;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMappingSettingId);
    dto.setMetadata("baseName", baseName);
    ensureDtoFieldsQuery(mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
function ensureDtoFieldsQuery(mappedElement, dto) {
    let dtoUpdated = false;
    let mappedElementAttributes = mappedElement
        .typeReference
        .getType()
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; !dtoFields.some(y =&gt; x.getName() === y.getName()))) {
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == attribute.getName())) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.getName(), dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
class ElementManager {
    constructor(innerElement, settings) {
        var _a;
        this.innerElement = innerElement;
        this.settings = settings;
        this.mappedElement = (_a = innerElement.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.innerElement.id; }
    ;
    setReturnType(typeId, isCollection, isNullable) {
        this.innerElement.typeReference.setType(typeId);
        if (isCollection != null) {
            this.innerElement.typeReference.setIsCollection(isCollection);
        }
        if (isNullable != null) {
            this.innerElement.typeReference.setIsNullable(isNullable);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.innerElement.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.innerElement.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.innerElement;
    }
    collapse() {
        this.innerElement.collapse();
    }
}
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../_common/onMapCommand.ts" /&gt;
/// &lt;reference path="../_common/onMapDto.ts" /&gt;
/// &lt;reference path="../_common/onMapQuery.ts" /&gt;
/// &lt;reference path="../../common/attributeWithMapPath.ts" /&gt;
/// &lt;reference path="../../common/elementManager.ts" /&gt;
var _a, _b;
const privateSettersOnly = ((_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")) === null || _b === void 0 ? void 0 : _b.value) == "true";
const mapToDomainOperationSettingId = "7c31c459-6229-4f10-bf13-507348cd8828";
var cqrsCrud;
(function (cqrsCrud) {
    async function execute(element) {
        var _a;
        let entity = await DomainHelper.openSelectEntityDialog();
        if (entity == null) {
            return;
        }
        if (privateSettersOnly &amp;&amp; !hasConstructor(entity)) {
            await dialogService.warn(`Partial CQRS Operation Creation.
Some CQRS operations were created successfully, but was limited due to private setters being enabled, and no constructor is present for entity '${entity.getName()}'.

To avoid this limitation in the future, either disable private setters or add a constructor element to the entity.`);
        }
        const owningEntity = DomainHelper.getOwningAggregate(entity);
        const folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? owningEntity.getName() : entity.getName());
        const folder = (_a = element.getChildren().find(x =&gt; x.getName() == pluralize(folderName))) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Folder", pluralize(folderName), element.id);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        const hasPrimaryKey = primaryKeys.length &gt; 0;
        const resultDto = createCqrsResultTypeDto(entity, folder);
        if (!privateSettersOnly || hasConstructor(entity)) {
            createCqrsCreateCommand(entity, folder, primaryKeys);
        }
        if (hasPrimaryKey) {
            createCqrsFindByIdQuery(entity, folder, resultDto);
        }
        createCqrsFindAllQuery(entity, folder, resultDto);
        if (hasPrimaryKey &amp;&amp; !privateSettersOnly) {
            createCqrsUpdateCommand(entity, folder);
        }
        const operations = DomainHelper.getCommandOperations(entity);
        for (const operation of operations) {
            createCqrsCallOperationCommand(entity, operation, folder);
        }
        if (hasPrimaryKey) {
            createCqrsDeleteCommand(entity, folder);
        }
    }
    cqrsCrud.execute = execute;
    function hasConstructor(entity) {
        return entity.getChildren("Class Constructor").length &gt; 0;
    }
    function createCqrsCreateCommand(entity, folder, primaryKeys) {
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = getBaseNameForElement(owningAggregate, entity, false);
        const expectedCommandName = `Create${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            const returnType = primaryKeys.length == 1
                ? primaryKeys[0].typeId
                : null;
            const command = folder.getChildren().filter(x =&gt; x.getName() == expectedCommandName)[0];
            command.typeReference.setType(returnType);
            return command;
        }
        const commandManager = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        const entityCtor = entity
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (entityCtor != null) {
            commandManager.mapToElement(entityCtor, mapToDomainOperationSettingId);
            commandManager.getElement().setMapping([entity.id, entityCtor.id], mapToDomainOperationSettingId);
        }
        else if (!privateSettersOnly) {
            commandManager.mapToElement(entity);
        }
        else {
            console.warn(`Private Setters are enabled with no constructor present on entity '${entity.getName()}'. In order for '${expectedCommandName}' to map to that entity, either disable private setters or model a constructor element and try again.`);
        }
        commandManager.getElement().setMetadata("baseName", baseName);
        const surrogateKey = primaryKeys.length === 1;
        if (surrogateKey) {
            commandManager.setReturnType(primaryKeys[0].typeId);
        }
        if (entityCtor) {
            commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(entityCtor, "Parameter")
                .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        }
        else {
            const toAdd = primaryKeys.filter(x =&gt; DomainHelper.isUserSuppliedPrimaryKey(lookup(x.id)));
            if (toAdd.length &gt; 0) {
                ServicesHelper.addDtoFieldsFromDomain(commandManager.getElement(), toAdd);
            }
            commandManager.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
            commandManager.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        }
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandManager.getElement());
        }
        onMapCommand(commandManager.getElement(), true, true, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCreateCommand = createCqrsCreateCommand;
    function createCqrsFindByIdQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedQueryName = `Get${baseName}ByIdQuery`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(query, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        onMapQuery(query);
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindByIdQuery = createCqrsFindByIdQuery;
    function createCqrsFindAllQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, true);
        let expectedQueryName = `Get${baseName}Query`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.typeReference.setIsCollection(true);
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
            addAggregatePkToCommandOrQuery(owningAggregate, query);
        }
        query.collapse();
        return query;
    }
    cqrsCrud.createCqrsFindAllQuery = createCqrsFindAllQuery;
    function createCqrsUpdateCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Update${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
            childSpecialization: "DTO-Field"
        });
        command.mapToElement(entity);
        command.getElement().setMetadata("baseName", baseName);
        command.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
        command.addChildrenFrom(DomainHelper.getMandatoryAssociationsWithMapPath(entity));
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command.getElement(), primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command.getElement());
        }
        onMapCommand(command.getElement(), true, true);
        command.collapse();
        return command.getElement();
    }
    cqrsCrud.createCqrsUpdateCommand = createCqrsUpdateCommand;
    function createCqrsCallOperationCommand(entity, operation, folder) {
        var _a;
        const owningAggregate = DomainHelper.getOwningAggregate(entity);
        const baseName = (_a = owningAggregate === null || owningAggregate === void 0 ? void 0 : owningAggregate.getName()) !== null &amp;&amp; _a !== void 0 ? _a : "";
        let operationName = operation.getName();
        operationName = removeSuffix(operationName, "Async");
        operationName = toPascalCase(operationName);
        const commandName = `${operationName}${entity.getName()}Command`;
        const existing = folder.getChildren().find(x =&gt; {
            var _a, _b;
            return x.getName() == commandName ||
                ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) === operation.id;
        });
        if (existing) {
            return existing;
        }
        const commandElement = createElement("Command", commandName, folder.id);
        commandElement.setMetadata("baseName", baseName);
        const commandManager = new ElementManager(commandElement, { childSpecialization: "DTO-Field" });
        commandManager.mapToElement([entity.id, operation.id], mapToDomainOperationSettingId);
        const primaryKeys = DomainHelper.getPrimaryKeys(entity);
        for (const key of primaryKeys) {
            commandManager.addChild(key.name, lookup(key.id).typeReference);
        }
        commandManager.addChildrenFrom(DomainHelper.getChildrenOfType(operation, "Parameter")
            .filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service"));
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, commandElement);
        }
        onMapCommand(commandElement, true);
        commandManager.collapse();
        return commandManager.getElement();
    }
    cqrsCrud.createCqrsCallOperationCommand = createCqrsCallOperationCommand;
    function createCqrsDeleteCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedCommandName = `Delete${baseName}Command`;
        if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
            return folder.getChildren().find(x =&gt; x.getName() == expectedCommandName);
        }
        let command = createElement("Command", expectedCommandName, folder.id);
        command.setMapping(entity.id);
        command.setMetadata("baseName", baseName);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), command.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        ServicesHelper.addDtoFieldsFromDomain(command, primaryKeys);
        if (owningAggregate != null) {
            addAggregatePkToCommandOrQuery(owningAggregate, command);
        }
        onMapCommand(command, true);
        command.collapse();
        return command;
    }
    cqrsCrud.createCqrsDeleteCommand = createCqrsDeleteCommand;
    function createCqrsResultTypeDto(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = getBaseNameForElement(owningAggregate, entity, false);
        let expectedDtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedDtoName);
        if (existing) {
            return existing;
        }
        let dto = createElement("DTO", expectedDtoName, folder.id);
        dto.setMetadata("baseName", baseName);
        dto.setMapping(entity.id);
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), dto.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        ServicesHelper.addDtoFieldsFromDomain(dto, primaryKeys);
        let attributesWithMapPaths = DomainHelper.getAttributesWithMapPath(entity);
        for (var attr of attributesWithMapPaths) {
            if (dto.getChildren("DTO-Field").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == attr.id; })) {
                continue;
            }
            let field = createElement("DTO-Field", attr.name, dto.id);
            field.typeReference.setType(attr.typeId);
            field.setMapping(attr.mapPath);
        }
        onMapDto(dto, folder);
        dto.collapse();
        return dto;
    }
    cqrsCrud.createCqrsResultTypeDto = createCqrsResultTypeDto;
    function addAggregatePkToCommandOrQuery(owningAggregate, commandOrQuery) {
        if (owningAggregate != null) {
            var aggPks = DomainHelper.getPrimaryKeys(owningAggregate);
            aggPks.forEach(x =&gt; {
                if (x.name.toLowerCase() == "id") {
                    x.name = `${owningAggregate.getName()}Id`;
                }
                x.id = null;
                x.mapPath = null;
                x.isCollection = false;
                x.isNullable = false;
            });
            ServicesHelper.addDtoFieldsFromDomain(commandOrQuery, aggPks);
        }
    }
    function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return owningAggregate ? `${toPascalCase(owningAggregate.getName())}${entityName}` : entityName;
    }
})(cqrsCrud || (cqrsCrud = {}));
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/create-crud-macro/create-crud-macro.ts
 */
await cqrsCrud.execute(element);
</script>
        </option>
        <option group="1" type="run-script">
          <text>Create CRUD CQRS Operations</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return application.isModuleInstalled("Intent.Modelers.Services.CQRS") &amp;&amp;
    application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "advanced";</isOptionVisibleFunction>
          <dependencies>
            <dependency name="Crud Api" id="61a8411f-b5bc-4a00-9a37-a967e0893d9d" />
          </dependencies>
          <script>await CrudApi.createCQRSService(element);</script>
        </option>
      </scriptOptions>
      <mappingOptions />
      <typeOrder />
      <mappingSettings />
    </elementExtension>
    <elementExtension type="Operation" typeId="e030c97a-e066-40a7-8188-808c275df3cb">
      <contextMenuOptions>
        <createAssociation group="1" type="association">
          <text>Query Entity</text>
          <shortcut>ctrl + shift + q</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Query Entity Action Target End</specializationType>
          <specializationTypeId>93ef6675-cba4-4998-adff-cb22d5343ed4</specializationTypeId>
          <defaultName>NewQueryEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </createAssociation>
        <createAssociation group="1" type="association">
          <text>Invoke Service</text>
          <shortcut>ctrl + shift + o</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Perform Invocation Target End</specializationType>
          <specializationTypeId>093e5909-ffe4-4510-b3ea-532f30212f3c</specializationTypeId>
          <defaultName>NewPerformInvocation</defaultName>
          <allowMultiple>true</allowMultiple>
        </createAssociation>
        <createAssociation group="1" type="association">
          <text>Create Entity</text>
          <shortcut>ctrl + shift + c</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAFFFJREFUeF7tnHt01dWVx7/fcwNC1UJ1WkrbUdC2alVIIAF5KAm17cysOmLHaleVmogGQR73CgQIj9ybF5AAN1FQQBEUp452pjJOZ7mmnZpQeRgDJoz4mmkRtGp9JhGQV3L2rHN+v5vcJDfJ7+ZeKK7F+Scrye+cs8/nt885++y9z484WxIiwIRqn62MswATVIKzAL/oAJ/Y9y8ZirxMgG+TuFSLXEzwQgBfATEYAoB4H4IGQj7R4EECfwTkj1DqjduuuGVPggwSqn7aNdACU7hZBONAjBRBPxopHFCdfooA3f0fwFEBdkNkO5TvyduvuOWVhIjEWfm0AHz61acvOI6WOwnJFuDKiIwRXtG/uxSPkGwCeNT5n/QXkQEAzxVL2imx6gvkZZIbj6ujW6ZcPuVQnDzifvyUAtzy2pbBEDUXwD0AvtRROlJ9BuH7BPoAGATyXG8jkCMAPgTkpIYMhsj5Mep9BmDNcfRZddeVt3zqrd34nzplAB/f98QKQPI6zkyC/ydQJxSNJhJGoxhr7rpz2uv/Bfo1CPpp6Es6rATHAJTecdXkovjx9Fwj6QAfe/WxURA+BuDySPcCOa7g20PFqyD4sjP52v7r/r6NkEYB6p35yXq0sLH1MaUz3b8PgWAIgAnu9O64eH4mgjcFLRkdhr9btfD2ycMnv9kzFu9PJBXg5n2PF0H04tbViYQCdwPqu4ABF11krxBblUb15KsnV3sXue3JLa9sydRAJslJAIa3a4PyGQQHtLQMi5ZHNObkDLtjdW/6i1UnKQA3vb5pCJr5JIlrxN02CfU2ya9A0LY+EU0ANmvVXJFzRc6BZA3CtGNkUDrFDyAbggFWie2mLoc1cASiB5nd3MhH8rfH+/S9beplP/84URkSBvjovkd/BMHTdmq6rSmo/QAvcUYgEPIgwAqcbNmck5bTNi0TlT5G/U11mwaijy8bED+Bi03/Lsq3NfVF0JFf5QMqdUPOVTm1iYiREMBNrzxypxZuIOEzYirhASp1gZjp6tpvIhJCMypONbiOECzIFBiNLLCGpMPxkNYtn5MY5GI9JoKfTBk25bneQuw1wIf3PryIRHGkY4L7SHVVlCDb2MzsnLTkTtV4B7qpbtMQSZHNbZuOncZvCvRlrbIL7pgy/O7H4207skzEXe+RVzbMhqAiUlHR94YAl0cZtqEpV08Jxt3wKayw8ZWNQQIFkQmtRd4G9EXOzg6tgRtzr879TbwixK2BD9evyxHi0S40rwnQ2XcNm7o1XkFOx/OP/M8jkyB6M0i7yQDYr6XlkraxyPfvHj7t+XhkiQvg+r3rRwC6hkCK6UQp3+sicoUxhEXQJCnIzL0y17HjztCyoW5DKn0wZtMAZ/Dyjhb9t64mfiYn1OVT06e+71V8zwBX71zd/9xzz6kXwXdJg0y9irZzbRO0ysxNO7PhRaAYiFDaQjR/09D7IXKJGZeI/O6e1Ht/mHSA6+vXPiDEDGsWkPsVlFV9AZqodWZu2r1ntOZ1BLKhbm0qlKoWVxM19ScQXGjGR4UZU4fNWOsFoicNfKjuAeN62u4Ca1RCBdKeLER01rS0mb06SXgR8FQ+s77uwUlCecadvoe01v1JSRHhUaL5e9PSAj0a+z0C3PTWpn7Hmg69LrDnTzN1XyFwtYVHCU0bPjOh3XZtfcWtBNd14Q7syk3oOrXknntT/U8lAnnd3gcqIJzt9r/fOCPc9qqmp86a2FPbPQJcW1dhzo0Bu2lQvSyCEe4Zadv0tFnOAT+BsqYu7CcY7k0TAgnMSAu0mlO9acPUeaju/noxZ2lDQ8tfhPJ1Z3/BXfeO8G/srt1uAa7fHR580oe3za4rwHFFdTziFKDooV5UvKdBOQDRCjCiiZF63f0uQJIAhocI1VvuEnUYos9z+3/3o8amIcGsYHNX4+gW4Jq6VWERexwyU/dlECPcTkIz0wIJTd2IQGvqyv0iqlcaSOrAjLR5CWugkeWBurA1tJ11HX8C9KXOMoWcWWlzzEkmZukSYLguPDBFWt4ToD+AZkKZM+SXATl4Eio1kBZIilPAAehO4Rg+ervpR0Tv8H/STOHkADTj7QMxlsTFAA6L0ULnCP3mzNQ5V5BsiyVEoewSYGVd2VwKy637B6wDmeasCxKYNTI5QpvmwnXlfiViNdAxyO2kDRnrDFDWSov8JFW2iFwcIeojkwbQauGe8qCQjhZCf0BwkOOek+tnj5j/+1gq2DXAPWWvg8arLKCoQ6D16zW1MGVIsrTPAVjqV5ISjg7HzR4xP6ZclS+XVQMyIeLp01SBQJI00JElPNAnzcZ0GQDI52LjOFbxtsweMf8XngGufnlFOkXXWo2AvEuobzoaIpWzRy6wa2KySri21E+lwpHYh/kZGLkwJsDwnmXG3pzgymV2zEAgIz8pa2BkPOE9yysIzna0UE4C0oeCY336H//qvVcGD3ccdxeClpYDNNE0M1v2AbRuKlEyNJC2sEfjMh64BiBUezOma4Cl1QDdWIg1OZIPsK4slVrXuQDfAWDPyRTc4k9f+CtPAFfvLjHRfrvj2pXJWUz33jcyPzUeOF6eDdcW+4XtAd6Xvijmi129p6QaEgkmmUEZgIuTqoFG5tV7SushGB4JAbjjWHdf+qJpPQIs31t+rq/5xCERMfXfBzjY3Y1Cc0YuSorpEi1EeW2x30eE7dZhYxbAnPTFXQIUkQmRzVgJTgnAVXtKWk0aJyRgFeiNOemLr+gZ4EuhG0g+6+penQBpFqAga17GEk9n3rKXlt7qUymDvGig1iaqhpuin52bsTQmwPLawmq2hjOtjfaMgnVN9VhadPMHeaMKPR37ymuLMglUmReqBR8R8lULsa8eNG948MPozjoJWr47tIRAoQOeb5Kwru+56bEHFUvylbtDDSIYGNGoeH/OyyjoAmDI2URcTY3nJ4DGuekFX+mRtPvAyt2FEdV7H5TBDg/5wbyM4H93C3BFbcGTBH7mauBhAcyxZlteRtDzubd8d7BBRAZ2zl6JNQE626d5GaGYAMtqg64ZE2mno+XddfskG+elBz0DNH052s6jAm0OE8YenZGXUdDOzdVJ0LLagr0AhrXZZWax5mPzRgWzvb698t1LrQbGTLfq1r/iAMnLKOwC4FKrgb1pl5TGeemF8QDcCsiNbWO2L/qBvIzCWd1r4EtLGgRm8NJEcIBd3IWh+aMLPW8gK2qXdNDAiKZ4+7lgVHFMgCteWlItUYZ0PCBJNM7PKPIMcEXN0iAoNgjlFHMiw2/mjyq+oVuAy19abFLK+oHyMYR/Y6sSoYUZxZ4BLq9d3ACrgU7H1gQXhBaO9t6GV22P9dyymsVB0nEMtM4konFBRrFngO3baO1l94JRxe1ybjq96dKafHGDLR+C/Jodv1JZCzOKPe12pqvS2kUN1DLQ3b0jR9fQwtGlnl9CYgDzTT8F0f2LYmN+RolngKU1CyeRfCY6SUyId/JHlTqhULe0AxisCqb0/dLxk+6IPwLwVZthoCRrYcbyOAAubICGBRhZ8kQYWnSaAJbU5AcJsQBbl1yiMT9jmWeAy2oXZIqwynV9m5yeASBO5I9adk63U7jkxfl2skPkU5AXmO1bhFlLxngHWFIz35nC0QOAAbj8tGhgSc2CIKQDQEjjotFlngEW7VqQqZRUmfEr4hMxASdCLxq9wtctwOIX84zn5TwIHA+MBajiBJjnbkRRGgiElowuOy0Ai2ryok4SzoGeQHwAa/ImEbBTmMQRAc4l0LRodJm7tjsYO62BRS/ONUHlr0PQDDoBdAhCS8as9Dz4opp5DbB2YFSJs41E1sCiXXODaN1EIi1J45JrVsWhgVFtuDlxAN5dcs3Kb3WrgUUvzv1fAN9x/WB2CTDrV0EcAAtr5jTQtQMdN1XbktsxZTfW/5desyqmGVNYM7ca9izctjZ4bV+IxqWjvQMM7ZobVK4ZExFGwNeWXrOyNUk+pgYW7gr8TsDrIwDdoT9WMCbs2ZAOvRhwzRhvdl9He65gTDgmwNCu+9o5VOOxA0FpLLgm7FkDQzsDW0G4hnTriee5gjHhf+hWA4O7AmsJTLfuROBzk11PYFvBmArPRzkHYPRRLj6QBWMqugAYSAAg4gO4y++cegjXHrb2bLhgTPi+bgEu3TVrpgLvdzI45C0RDDUVQmPvjzmoWGtV8MXZDaJ770wIja2M2Vdwl7/aurN640wQNAbHVnrWwIKdsxz3AXBQkRe7u3FuwZjKh7sFuGTnzAmKtDYfRf6kgUvNaEjJCo5Z48kWXLp99q1KcbCXjUDQMgFOkrhTpOuXFdw1q1qMQ7V1UZKthG+bl360lvcLx1d6cmcFd83I1ELrzhKByfW2xrPWHFU0rrJdSnCnNx2syu6nzznvkDjB9JMUMZdgjF86VDhujeed2MugzDOLdt7r94Em/tzqUC0atyamBi7dOcMCjGTs+iCB4Ni1SfdIL90xIyhthrgmqQQ4UjRmzfk2TBRVYgq6ZOeMVreRs4PbN1FfPO5BJ7SZxGIAqqjMBNN00VizDHcu0XJZjQACJacA4OId001MJNXe0WtT9/8sGvvgjztKFVPQxTvuKQBotU2ItyBi18EWhaHLx6xLalBp0fZcP+lrl5lQPO6hLuSa5rqz3NkuLYGS8RuSqoH5O6anEpGgEvYrc9vAWVvmFo9bt8oTwIV/mPo95eOrbvjwMCA2V0SAytJx65Ma1nQAmrBmm1FSMm5dbIA7pzmbiHvAAXWgZGyyAU41JoANawI4CdAsYdJHUr4VHL/mPU8AzUP523NrAaZbc0bkCGiPMo19T54cGszanJS0DrsGbs/1S+sUdtCUjt8QE2D+jtz2UTkzhZOogcGq7IHHU/q8BVpX3OeEcgLr5O9Lx62/Ptay0qVpsmB77gxFPOCkdsibGrjMfTiwbPwjSZs2edvv8qegfWCdZLAtoUNDQZk0XJPglA2RIZHAugKTCjD/hbuCmnADMnyX5DedPUBNLh23/om4AOZtv/N8BfWuuaplHYSiTVTeJNwcOH5Sp1UkSQsNQLuJdMywjEjbVealu4mUJell+quyB56TYlPcjPYdAZWZcUYBP+53QdM3g1f+6kRcAM3DC16YshzEfKcdfcC9JWlNmuXXPpoUk8YB6CQXxVs0GEgWwAUv3OmYLrbwPZLfcDfR+SvGbSzrSrZuTxdzd0z+mtK+dwD2tY2JNhed7aVoXwuHLs/anPCOnLc9249Ielu8BCmBsvGbE15OFlRlD2nxiU2wBOQo6bNROAKH+zf3HxzMerBTTkxE1B6PZ3kv5KwEZI7b+Ici8jXnzUj1ymu3ZMU75o7POwDbMlTjao9ICsB5L/yiDoJU18nzGalsAj1F5q+47rEutc+F3L3IgZ0/7Z/S3N/cCbG2oEAfFCcJ0STchFZOeCKhqTxve86t0HpdXOAiDyt1T/n4TZ6OZ121P2fb7RWgY7YQtKksrv1cX37t4z0eHHrUQNPwnG13XEdq58xJ0aLlqDFr3PXiplXXPXFGXu3q6aXM+cPtkwDnmoOAnyvQfteBJiNXMKxswpbXe2rDE0AH4m0mIj/dbfCQhnYuUgsaTcykIuuXX6iLNv6qn6dSoQpwPefC44q0ASMBFq+e8M8lPcHzNIUjjRgnwyHfiX0iuNT5kIt+T0TsTgWwUfQXB6IDr6UKoA07kPwUwgucq154+cvXfScj6JiiPRbPGmi18IWfj9RaXnKTls2ufFBgvjRk31ojRbIqsn51Rmuiv+qnqSCrTPaFM3h+RCqbfUXgmCheGb72l/t7JOc+EBdAUyew7WdTADwS6UCkxdxiiuTNNVKYU5H19Bm5JvqrbjFXuza5xrI52RwkaTdEC1DJDauvfSquO8NxAzQd+atvWShAaRvEdppojn7B+7N+HfL6Fk/HczOrbg4TYs7dtijyQ0BZk8xxOuG2isynn4xXll4BNJ3Mrr65BGB+K0ToP4tIa8hPwPoUtNxUkbU1YWM73kFFP++vmjSkGb5nCGlLT6ZqUGCUe5+5lZlPt3PVe+2z1wBNBzOr/2kaBMb76dxCoW7QWvqQOC/iYdZAsC9QWZG1NWkeHC+D81dNGtgMzBaBSTRyMnUFnyulFMF+jibyGAU/u3/iv/67lzZjPZMQQNPgrOqf3CSCXzvyOIKK6P2gOI5IxxlwQCCb+0KdcpAG3AlgtvnQGcwNU9cZQeGfqdS3Wh3yxEdK84bKif9W01t47pATqe7Unfb8P17mg3oKxPC22IYc0JQLoeX8tq+OGJsRm0X5KtcleWpPr5qUKrrlDhIG3MDWS4oiRwjfMZAXtkbzgN/6tP5F5fXPfpDo6BPWwGgBZjx/42pzgzL6cpvWLXVQ+HaML6zVm08/UVj90MT/8BRZ6zjYac/fMEFETJK6ieq1v4JBHqbgz4S6vC2RwUwRPWftxGfPrE8/tYNY9eNMLWoLAHdDcXRBS8t+wN7D7fQZPHcfrBZKI92PjwlRryB23dTgQJrDvrMipJIcCJEuAv38hGALGdlhW3VxtwC3PzTx2TP342MRkNOrfnoe5NhKAFM7+0PlI6H+WLR0unORyHQi+QaEF5HKZFJE+WfFfP6u8KGJv1mWSPtd1U3qFO7YSe7vfnyR8ul8CKfGFkDMrv0XEueI6K+D+FJ3F6wjexJA89GwIwpsBvkNgm4WfXQv0gTh/Sebmys2/t1/ffE+wBg9lNw//GgwT6i7oWi+rDa0vYa0TxHSxi9CHhIth0gcFoi2H8rRGECa6d/d5xptr3sA2XikueXxLT/6rXEAn9JySjUwluR3P//3EyhyIwTXgkhvF+dvjVe6Nb39foRArYjsINUv11//3GunlFiHxk87wI6Du/v3PxyrwMtE7GeQvy3O5nMBxH4GeRAEZg1rAPGpnbqCA6T5DDL+RM031v3gOXuz8q9V/uoA/1oDT1a/ZwEmSPIswLMAEySQYPX/B7HF0ckrQsvkAAAAAElFTkSuQmCC" />
          <specializationType>Create Entity Action Target End</specializationType>
          <specializationTypeId>328f54e5-7bad-4b5f-90ca-03ce3105d016</specializationTypeId>
          <defaultName>NewCreateEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </createAssociation>
        <createAssociation group="1" type="association">
          <text>Update Entity</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Update Entity Action Target End</specializationType>
          <specializationTypeId>516069f6-09cc-4de8-8e31-3c71ca823452</specializationTypeId>
          <defaultName>NewUpdateEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </createAssociation>
        <createAssociation group="1" type="association">
          <text>Delete Entity</text>
          <shortcut>ctrl + shift + d</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Delete Entity Action Target End</specializationType>
          <specializationTypeId>4a04cfc2-5841-438c-9c16-fb58b784b365</specializationTypeId>
          <defaultName>NewDeleteEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </createAssociation>
        <createElement group="1" type="element">
          <text>Add Processing Action</text>
          <shortcut>ctrl + shift + p</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAAehJREFUeF7t3L1NA0EQhuE55DrYJijAEiVQAh0QEVl3XRGQQwWk/qGQRYewRGCB5G93dr6ZcT723nOv5GS0k+QHEpig6RyWBAQjSMAEBAXA8WYFll15lI18HHfHN/BMVOMwYFnKg1R5FpG79cknmZbDfJipFIDDXg24nbebvexfROT+wu+/y408RajxasAVrcyl/vXyItTYFfAH13WNGoDfjl5rVAP0WqM2oLsahwB6qnEkoIsahwOy12gFkLZGU4CMNVoEpKrRLCBLjdYBzddIAWi5RiZAkzXSAVqrkRXQTI3UgBZq9AA4tEY3gKNq9AaoXqNLQM0aPQOq1OgesHeNUQC71RgKsEeNEQGb1hgWcFWstX6eltMtsFuEbaj+txuDHExjNgFB5QRMQFAAHM8CAcBW22IR/4Wb7iuGAmxV3e/wowA2rS4UYI/qogB2q849YO/qPAOqVOcSULM6b4Dq1bkBHFWdB8Ch1VEDWqiOFdBMdXSA1qpjAjRZHQWg5eqsA5qvziwgS3UWAamqMwXIWJ0VQNrqhgOyVzcS0EV1QwA9VacN6K46NUCv1bUEfM27s4D9knU0b28DAc/jeX9gI8hoXwPtxkTDuvS8CQhWkIAJCAqA41lgAoIC4HgWmICgADieBYKAX0uidGAd9hNhAAAAAElFTkSuQmCC" />
          <specializationType>Processing Action</specializationType>
          <specializationTypeId>405a2857-b911-431f-8142-719a0e9f15f3</specializationTypeId>
          <defaultName>NewProcessingAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </createElement>
        <runScript group="2" type="run-script">
          <text>Convert to advanced mapping system</text>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>let dtoParam = element.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
let dto = dtoParam?.typeReference.getType() ?? element.typeReference?.getType();
return dto?.isMapped() || (element.getName().startsWith("Delete") &amp;&amp; element.getChildren("Parameter").length == 1);</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        /*let classes = lookupTypesOf("Class").filter(x =&gt;
            DomainHelper.isAggregateRoot(x) ||
            (options?.includeOwnedRelationships != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) ||
            x.hasStereotype("Repository"));*/
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        var _a, _b, _c, _d, _e, _f;
        if (element.specialization == "Service") {
            let entity = (_c = (_b = (_a = element.getChildren("Operation").find(x =&gt; x.getName().startsWith("Find"))) === null || _a === void 0 ? void 0 : _a.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.getMapping()) === null || _c === void 0 ? void 0 : _c.getElement();
            element.getChildren("Operation").forEach(operation =&gt; {
                convertOperation(operation, entity);
            });
        }
        else if (element.specialization == "Operation") {
            let dtoParam = element.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
            let dto = (_d = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType()) !== null &amp;&amp; _d !== void 0 ? _d : (_e = element.typeReference) === null || _e === void 0 ? void 0 : _e.getType();
            let entity = (_f = dto === null || dto === void 0 ? void 0 : dto.getMapping().getElement()) !== null &amp;&amp; _f !== void 0 ? _f : lookupTypesOf("Class").find(x =&gt; x.getName() == element.getName().replace("Delete", ""));
            if (entity) {
                convertOperation(element, entity);
            }
            else {
                console.warn("Cannot execute conversion script on Operation " + element.getName());
            }
        }
        else {
            console.error("Cannot qualify this script. Please contact Intent Architect support.");
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertOperation(operation, entity) {
        var _a, _b, _c, _d;
        let dtoParam = operation.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
        let dto = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType();
        let target = (_b = (_a = dto === null || dto === void 0 ? void 0 : dto.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) !== null &amp;&amp; _b !== void 0 ? _b : entity;
        let targetEntity = (_c = target.getParent("Class")) !== null &amp;&amp; _c !== void 0 ? _c : target;
        // CREATE OPERATION:
        if (operation.getName().startsWith("Create") /*&amp;&amp; dtoParam?.typeReference.getType().getMapping()?.getElement().id == entity.id*/) {
            let action = createAssociation("Create Entity Action", operation.id, target.id);
            let mapping = action.createMapping(operation.id, targetEntity.id);
            mapping.addMappedEnd("Invocation Mapping", [operation.id], [target.id]);
            mapContract("Data Mapping", operation, dto, [operation.id, dtoParam.id], [target.id], mapping, true);
            // DELETE OPERATION:
        }
        else if (operation.getName().startsWith("Delete") &amp;&amp; operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Delete Entity Action", operation.id, entity.id);
            let mapping = action.createMapping(operation.id, entity.id);
            addFilterMapping(mapping, operation, entity);
            // UPDATE OPERATION:
        }
        else if (operation.getName().startsWith("Update") &amp;&amp; ((_d = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType().getMapping()) === null || _d === void 0 ? void 0 : _d.getElement().id) == entity.id) {
            let action = createAssociation("Update Entity Action", operation.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(operation.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            mapContract("Data Mapping", operation, dto, [operation.id, dtoParam.id], [target.id], updateMapping, true);
            // FIND BY ID OPERATION:
        }
        else if (operation.getName().startsWith("Find" + entity.getName()) &amp;&amp; operation.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // FIND ALL OPERATION:
        }
        else if (operation.getName().startsWith("Find" + pluralize(entity.getName()))) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            action.typeReference.setIsCollection(true);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            //Operations (Command)
        }
        else if (dto.isMapped()) {
            let action = createAssociation("Update Entity Action", operation.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(operation.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            updateMapping.addMappedEnd("Invocation Mapping", [operation.id], [target.id]);
            mapContract("Data Mapping", operation, dto, [operation.id, dtoParam.id], [target.id], updateMapping, true);
        }
        else {
            console.warn(`Could not convert operation: ${operation.getName()} (For entity ${entity.getName()}. Has parameters: (${operation.getChildren("Parameter").map(x =&gt; x.getName())}))`);
        }
    }
    convertToAdvancedMapping.convertOperation = convertOperation;
    function addFilterMapping(mapping, operation, entity) {
        var _a;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id");
            let pk = pkFields[0];
            if (idField &amp;&amp; pk) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a;
                let idField = operation.getChildren("Parameter").find(x =&gt; (x.getName().toLowerCase() == pk.name.toLowerCase()));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
                }
            });
        }
    }
    function mapContract(mappingType, root, dto, sourcePath, targetPathIds, mapping, isCommand = false) {
        if (dto.isMapped() &amp;&amp; dto.getMapping().getElement().specialization == "Class Constructor") {
            if (targetPathIds[targetPathIds.length - 1] != dto.getMapping().getElement().id) {
                targetPathIds.push(dto.getMapping().getElement().id);
                console.warn("Invocation Mapping : " + root.id + "-&gt;" + dto.getMapping().getElement().id);
                mapping.addMappedEnd("Invocation Mapping", [root.id], targetPathIds);
            }
        }
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; !fieldsToSkip(isCommand, dto, x)).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, root, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping, isCommand);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
    function fieldsToSkip(isCommand, dto, field) {
        return isCommand &amp;&amp;
            field.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp;
            (!field.getMapping().getElement().getStereotype("Primary Key").hasProperty("Data source") || field.getMapping().getElement().getStereotype("Primary Key").getProperty("Data source").value != "User supplied");
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
/// &lt;reference path="../_common/convertToAdvancedMapping.ts" /&gt;
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/convert-to-advanced-mapping/convert-to-advanced-mapping.ts
 */
convertToAdvancedMapping.execute();
</script>
        </runScript>
      </contextMenuOptions>
      <creationOptions>
        <option group="1" type="association">
          <text>Query Entity</text>
          <shortcut>ctrl + shift + q</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAEMxJREFUeF7tnOt2U0eyx/+1bcN8w3mCiCeI/eHMmYQEW8kAIR6wlQycmEuQwiV2GLA0gIMx4G1uhkCQHGKuIZKTAAECkmGMwRmQDCFkcc5a2E9g8wTj+XSCLe06q3tvybL21l0GcmCvlcVy1K1d/euq6urqahFePkURoKJ6v+yMlwCLVIKXAH9PAMP+RzZW8BopWhUINjDZGJBmMP1fHgcwDFLGQBixr6weLnKcM9Z9xjXwTu+jeiatgYBaHZolsVSC0/8GxhmIKIoSsq+q7p0xGgV88YwADPsfVWqK1gLAyWCbWcMy88rUHsA4CCElVtZpd1WPFTDmknYpKUABLkYxLwgNYFSm2iYRjTA4QhoNa9DGylE+bHdVC3Od9vzk/+9aBYpNU2ADUEvgGkvNBUIaa50LXX98ZiZeMoCD/octBFIZqJymQYwhEAcqUBGygpWrOtzy/0+DAnYyUG+hob5ylAuNNE1Grt9faLuiAQ76H1aByQ+garoQ3BujmLrY9XpJzUxo+YQWdRPBDWBO0jvHieBY4PqPSKEwCulXFMDBsw+FRngBVMZfzsx9XKa5Sw0udXA6yAk3QB0pn/kWrf2jpxAYhfQpGODNMw+FrxNaYDz8mFlxLl7/dDVgwP/ARrGyEIDX4pIQKDSrrNz1NEy6IIADp38VJusEEcAsArm+38pnOx15+qCBEw9sXFb2avLMM/Dvug35Lwo3Tv/qI6IWXR4S/ww/qZhlz1emfLUwb4ACHoOc8UCEGZ11n/ynmsuLB848qGWN6kFUC3CVVQidCHCYx4gQ0QihuvV/6svp+08Ll6L5k753xiHmBbD/5K8+gFsSAjJcdc2vBzINLuh/VDlr4rcWMJwA2aZFgHENttiLyHYJDadxMIcURufi5syLUv/ph1XQtAjAc3RN5Mhfml635zIBhbTJGWD/iQfCZP0M1jMQOcDrP/Wgg5ncBK7UNyCEeH/5twhxxEOkx3EstFL+XcXgOab2ev/A5Ow/eDKZ5hREzNHfR911TX9K8teFoLLukxPA/p77VRooDDJWW+bOJRvnpTVb0T5GFCTIQDjpoRGwFlKAUN3GeRmD3+CJB7YK5gYGGgDUpIgv4j3Xkk/fEIuH5XOt54GTiIWvjj+OTO0LRZoTwOs9vzxioMqwqL6lG98Qg0oj+H0nQWjqlAWCMEQxUpdser2gGE3ALGcWE7ZGX7N0RwCCb+mnb6QNWa733FcZ1KG35/GYolQ7sriAfEFmBXjtq5/dDBKxnhD8cWxyosrhsVtG/H1f/eIFOGEqsj1rTsemtwoClzqY68fu1WpQVNCURjIQ4MkJT1qZjt2PxNsTIbR04zxHvpAytc8IUMy8Eo09AkgGyho0ezoYfcfu+wCIBEL8GdKiEw3pBlbMIPq++iUA5jXx72Ag1LDJGkzQ+8BGFdowsb5ryTSGQmTKDLD7Z7HCrjFsps/R8qal6Qa/vC/Cmil/w9TtaJk3I047PsjEO+PpMSDg2PymywpCsPueCorvWDji2PxWyVbltACD3nAllIp/JcIOrWyuw2MOIYLe+1VQ+FGS4L2Oljedhcxmvn0kRI7HfdLpuhyb51mGVVe7fx4j4FU5Hg12h6c0biUtwCveeyoROphl2NL7vme+JZSr3rujILIZzn3ofc9btfmCKKb9Ve89HwgtxgZknDha7fDYTQmMK967ThJhmBgPUeR9d2m0MAPAu6PxwFdBbK61UPdUgDv0dRGPFUTTLjDFQMrW96r3bkikuYz1OfSBZ77lQnHFe28M4FdFOwVRyzFle1fq55YAfzxyt4GJRRwnFH5o2ZYak1YJE4+xMsps5P80zb5sm70kq22+gwh6w7aopowmwhtNsS/bZjbRH48O+ZjRYrTrXLalJqctaN6r8OUjQwEQ5CrHINfyLfNNfuXyF0Pi5R16ppiGlm2Z/1RNN3VQCXmk0BRZtnW+aaG45A1Xkabo/poxvGxrTXW+k5WTBl46EhkF67uIinJ+xSoUuXgkMkpGGwI/M+1LrMrecOVklITvk+FKLMpzG9vMvvDS4YhoIzNA6caWD1STCV/oCtuUcho1vmTkv7bVpmSagYtHwg1gCmZqk48QpWp78fCQHh+KLBvY8+E2u4hNpz0XD4cDAEnrImbX8lZ7xmRINtlMAC8eCov9pw6H0f3hdrspnvvhYFiufHoTdDZ+Zi/al2QTNJfPk2UXvrvxM7vJrVzoCjtJgYxZSyG7lQaKrZKeJme4GtvMM/TDofAjZlSJzjEF1Stb7c/sVCwV7IWDd8YBkmbcuN1uGt+5z8NVigbdD5I15FwmK97G9ILzXXf03YeefrI3tplX1vNdd+ReHsC/V7S9nTgPyefFM9X2/IE7U3vf7PKPrWh7e24xspgBCgGM9NGTCXrFpU5PHAgfycxxHzm0Ysfbz3T1TR38ua7bPmLS3Quxa2XbOyYfd/6A0FJ9sVmx4+2sCZVMgE2dv9t/O0ICIDNW7fyz+fO9P9WSooTF50Q0tLL9necK4Hd7b6ukiPCKwUSdq9vfMfnnc/tvR5i5RmSsV7W/U2KAe29HiLhG2OjqdACJwkY+rnt1+59nNGmQr3l9v++2G2CvlI+pc/UuM8Dv9t6OgLhGZLxX7SwxwG/3/KT7EAY+2r3AUgMZCOtHFtS9etfzBfDbPYPy6ME4UulcvWuBSQPlGIWVEeGjXWYry2fSTIASX44MABlh4yVDH+1e8FyZcG/nTzIJIhWQ0bmmwwrgP0cBlhsFKyUpCmCvOhhhYxFxqgtNgP3qoAhfZBhAhKE1HQufK4B+9ZZKRrUCAy6XutC0iATUwXgUAasxFgXQr94KEahemAAT2V3qAlOCQAqgJzLHnerCV/J54Uy39auDxiKYXX4ijKxRF5p2WvnIaNaw3bdkkkDyUchyBr/ZPSjTQrKzos11qYtLWkCUzwBS2/p33xIhll75qswyhWF+dcAGTRk1EtlDrj2LirIgE8Czuwb140Cpgehcu2eRyQl/s/tWAKyn+pnZs3bvu6Y9ZzEQCu0r3AvH+JFxBDHy8d5FJu1KHh+Iuz/e825RUYQJ4Okdg1VliiaOMcUx9tDafYtNM3R214CTmfx6Z+s2hUIopt/XO2/Kygn9QB7d6/aZ4Xy9cyBAoDW6EyTHun2L0p4t5yKLZRD5dfvNcVkaAcK6/e9maCOieUZZDHNdB5+9GZ9tvzkqSoqF3Bor1RsOLDTt0b9uvykWwKpSyW0J58yOgRDAMkVOzI51Xe+ZZulM240ASKSFpK33ru9a/FQOktJpxZm2G26QOL9mMNPIhq7FJvP1q8HK6MTsfxmp/8frD7yXUjmRi85Nb2MJ8PSOASeY/dIUGH0bDi42HWee2D5gKyeIGdeP3Emr3nCg7plkZSSYJ7NHWZ5fywjfteHAYlP4cmbHgMpsnOEwd284+F5R/k86gXTMT33WL6rh5wh5Zj2ZeMXlc5iqEU5tv5E44GZQpOnQeyU7b81HF05+1u8jcaivH3aMfHKozjI0ObX9xiiYbXK+Y6jecLj4CU8PsFWYKEtnS4TOTw7WmVZjvztY+WT2rEQaHUB306G6omc1H3gntvc7ifUEqRiMRpq9+eASU+x6qvVGA4iDRgQ90pQGcj7vzqiBwkShxcTZiBBs/H8nJ+d6LLTweOv1BppK74thuJoP1xWVJs91ED3b+qsIHKZEjTZ1Nx+2nsAT2/4htp9GRFE6GTOmck5s/UeACWtkI+LO5s+XWKbuT2zrNwov43UMpRMwHcw4PFHgLuVjjDQf+Yul6R5vvdFArMljCmY8fhKdrLJShlwnLrldRoBCSGhaomxDiUXnNvsclruOnr9fC4GoPvHlDHXj0SWdhQiVrU/P3685QeJ2gF70RMDIk1i01gqK1x2snFVWLnYneuac2bXx6NKSWUjWZGLPlus+sFF1RRje+MUSy7NUKahSFmBQvagjNBbnkBKLetJBzwYq9XPxjgqlrIOI3PHFnxkjk5o1PNF/mvzA0MajS4rauqXKlBWgFJqUMTYOagDu3uStT7tQHPP0JY4Np7SR1Cii3cWYzTFPn6jNFi4k+QxmJMoxS80T7z7mvl4L4njqDQrHqjf6HCUNtbICTAgCLRyvDRXVCpt96c3gS/c1sZ/2ydMxUfWjxxfj4v5GjBBq8S7Nqeq+xx2sikFZowDiqFXuMJKK1Ls3+dJPpJBbyiHL7vR+BAr8zbfUsgQuX2uIt88JoGjcvTmogpQOo7h2XCO2ezLMptcdtCmaIhaX+qloMw4A4yTuA4OGmSHiy/h/cmdAxLUGMJtxD8WQV56YjyiK5t7kc+RUh/OlOyj37foXyK1BYHN3Q8kg5gxQh9hnbPGkNOOakhmiaOR1B2sVTRFVXKmF4nlOOo0Qa77Nxxx5LwBfbgo6WaT5jYcJAXeJIOYFUPhDRBEhwmuGYYqL0B5PDoMSGomYrLgXl6/loZXUx2nXQZL+1gc7AkYEGgKe48X5Lu+moJMAf+J9QMBzzFG0JuYF0NAoCTH5bhoA1fOVI6+Qxfu3YPwG+/QNPWEMjDGUYzifRSf+fZkmU0CEsWvRQxoEPD3FQcwbYBwiT7DI0CQ0CYQIxcjlOWkdJ+Zprzk3F1ahTcpzYLfuYdm15fgHac38i0+vTF3D0NsHthz/oGBNLAhgfHRHP70qCxaTUhLjDFK3Hnd050ygiIZHmoMNxmWalPKS7BABwyfqV6YKhlgUQDH2I80/ilI3MePJl5/HQKxuPfHXGfmBiMOfXK0n0sRd4bRBMQGuLSczaGLTFXHXOfkmU2Dryfw1sWiA0qSbgrYox8R10/pE2KcvEmPMCHGZ0tta7CLgDFZG/6C1EMPJ4tc/khYhUWUFaOI4U4Qs+rUMcd6VA0RN+EQjuiJC3hBLAjBuhYebLteyBhWgmmm3MvUzCnl9lRkRYm2k9czyjDuCriYRR8ZqiMXPpchLiFbXYx+DSW09M6Vphzb8GCBZXWas80yu5M9TPcbn6684Ie/Uxdsj0Hrmrzn7xJICTIBcd7lWIwiNqElkrPWdgHFbM/GvOHtJBiludValtkvaScj+IBETkq9iUgl5AuZEr4AoKlWnvkfJClHcM056b84QZwRgHGRX0wUbooq4nyF+BuW1jBess/wiDwOPiTnEFTFf28nGrOfQXesuT9NEUerWdmZ52tW5a/0lJ8kdS1wTObD97PKsmjijAJPNxesMVv6mTDZAkadmteJnn8TNocT9Y2OrZWwVR5gwToxhAke0mDbcFsgOLdU8u9ZeDgBCE/WHGa62bzJA/PiSk2j6wpIN4lMDWES0UlTXA66L+pWNhIsjV3sGiPsFRJGASLTnQPs3H6bVxP/3AAV9CdEoW9brGnOAyPrlSb3OkAPtAWuILwRAwWCf84Kep4yfwoJd7YHGtD5xv/OCk0Wwndi0I7Cz1wzxhQGYgCjiROMhygFiIhUmO5kgvlAABYG9qy7Ig7JEIA64dn9nrYl7Vl8Q1RaJ3QoRend92zitAuOFA5iAmLhIrlcypEJMwEv8kA/3dny/wlS+8kICFBA7V56XC4vxsyiiTM+lnl8pfaK64py8W6wvInID0NtxzgwvrsVFhQm/584CIsu7dcZPWAF6uCKL1I1ML9CrpoH3wgMUAHY3fi93LFOL7VTBkLipr15YlbHq7IU14WTL2f3h94k4Men/9+75ITO8lxqYRCsFYk7wXgJMceAGROSieYlY8ve8CDwPsr/0gUXOwkuALwEWSaDI7v8HEft2ujopHEwAAAAASUVORK5CYII=" />
          <specializationType>Query Entity Action Target End</specializationType>
          <specializationTypeId>93ef6675-cba4-4998-adff-cb22d5343ed4</specializationTypeId>
          <defaultName>NewQueryEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option group="1" type="association">
          <text>Invoke Service</text>
          <shortcut>ctrl + shift + o</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Perform Invocation Target End</specializationType>
          <specializationTypeId>093e5909-ffe4-4510-b3ea-532f30212f3c</specializationTypeId>
          <defaultName>NewPerformInvocation</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option group="1" type="association">
          <text>Create Entity</text>
          <shortcut>ctrl + shift + c</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Create Entity Action Target End</specializationType>
          <specializationTypeId>328f54e5-7bad-4b5f-90ca-03ce3105d016</specializationTypeId>
          <defaultName>NewCreateEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option group="1" type="association">
          <text>Update Entity</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Update Entity Action Target End</specializationType>
          <specializationTypeId>516069f6-09cc-4de8-8e31-3c71ca823452</specializationTypeId>
          <defaultName>NewUpdateEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option group="1" type="association">
          <text>Delete Entity</text>
          <shortcut>ctrl + shift + d</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Delete Entity Action Target End</specializationType>
          <specializationTypeId>4a04cfc2-5841-438c-9c16-fb58b784b365</specializationTypeId>
          <defaultName>NewDeleteEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option group="1" type="element">
          <text>Add Processing Action</text>
          <shortcut>ctrl + shift + p</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAAehJREFUeF7t3L1NA0EQhuE55DrYJijAEiVQAh0QEVl3XRGQQwWk/qGQRYewRGCB5G93dr6ZcT723nOv5GS0k+QHEpig6RyWBAQjSMAEBAXA8WYFll15lI18HHfHN/BMVOMwYFnKg1R5FpG79cknmZbDfJipFIDDXg24nbebvexfROT+wu+/y408RajxasAVrcyl/vXyItTYFfAH13WNGoDfjl5rVAP0WqM2oLsahwB6qnEkoIsahwOy12gFkLZGU4CMNVoEpKrRLCBLjdYBzddIAWi5RiZAkzXSAVqrkRXQTI3UgBZq9AA4tEY3gKNq9AaoXqNLQM0aPQOq1OgesHeNUQC71RgKsEeNEQGb1hgWcFWstX6eltMtsFuEbaj+txuDHExjNgFB5QRMQFAAHM8CAcBW22IR/4Wb7iuGAmxV3e/wowA2rS4UYI/qogB2q849YO/qPAOqVOcSULM6b4Dq1bkBHFWdB8Ch1VEDWqiOFdBMdXSA1qpjAjRZHQWg5eqsA5qvziwgS3UWAamqMwXIWJ0VQNrqhgOyVzcS0EV1QwA9VacN6K46NUCv1bUEfM27s4D9knU0b28DAc/jeX9gI8hoXwPtxkTDuvS8CQhWkIAJCAqA41lgAoIC4HgWmICgADieBYKAX0uidGAd9hNhAAAAAElFTkSuQmCC" />
          <specializationType>Processing Action</specializationType>
          <specializationTypeId>405a2857-b911-431f-8142-719a0e9f15f3</specializationTypeId>
          <defaultName>NewProcessingAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
      </creationOptions>
      <scriptOptions>
        <option group="2" type="run-script">
          <text>Convert to advanced mapping system</text>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>let dtoParam = element.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
let dto = dtoParam?.typeReference.getType() ?? element.typeReference?.getType();
return dto?.isMapped() || (element.getName().startsWith("Delete") &amp;&amp; element.getChildren("Parameter").length == 1);</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        /*let classes = lookupTypesOf("Class").filter(x =&gt;
            DomainHelper.isAggregateRoot(x) ||
            (options?.includeOwnedRelationships != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) ||
            x.hasStereotype("Repository"));*/
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        var _a, _b, _c, _d, _e, _f;
        if (element.specialization == "Service") {
            let entity = (_c = (_b = (_a = element.getChildren("Operation").find(x =&gt; x.getName().startsWith("Find"))) === null || _a === void 0 ? void 0 : _a.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.getMapping()) === null || _c === void 0 ? void 0 : _c.getElement();
            element.getChildren("Operation").forEach(operation =&gt; {
                convertOperation(operation, entity);
            });
        }
        else if (element.specialization == "Operation") {
            let dtoParam = element.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
            let dto = (_d = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType()) !== null &amp;&amp; _d !== void 0 ? _d : (_e = element.typeReference) === null || _e === void 0 ? void 0 : _e.getType();
            let entity = (_f = dto === null || dto === void 0 ? void 0 : dto.getMapping().getElement()) !== null &amp;&amp; _f !== void 0 ? _f : lookupTypesOf("Class").find(x =&gt; x.getName() == element.getName().replace("Delete", ""));
            if (entity) {
                convertOperation(element, entity);
            }
            else {
                console.warn("Cannot execute conversion script on Operation " + element.getName());
            }
        }
        else {
            console.error("Cannot qualify this script. Please contact Intent Architect support.");
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertOperation(operation, entity) {
        var _a, _b, _c, _d;
        let dtoParam = operation.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
        let dto = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType();
        let target = (_b = (_a = dto === null || dto === void 0 ? void 0 : dto.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) !== null &amp;&amp; _b !== void 0 ? _b : entity;
        let targetEntity = (_c = target.getParent("Class")) !== null &amp;&amp; _c !== void 0 ? _c : target;
        // CREATE OPERATION:
        if (operation.getName().startsWith("Create") /*&amp;&amp; dtoParam?.typeReference.getType().getMapping()?.getElement().id == entity.id*/) {
            let action = createAssociation("Create Entity Action", operation.id, target.id);
            let mapping = action.createMapping(operation.id, targetEntity.id);
            mapping.addMappedEnd("Invocation Mapping", [operation.id], [target.id]);
            mapContract("Data Mapping", operation, dto, [operation.id, dtoParam.id], [target.id], mapping, true);
            // DELETE OPERATION:
        }
        else if (operation.getName().startsWith("Delete") &amp;&amp; operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Delete Entity Action", operation.id, entity.id);
            let mapping = action.createMapping(operation.id, entity.id);
            addFilterMapping(mapping, operation, entity);
            // UPDATE OPERATION:
        }
        else if (operation.getName().startsWith("Update") &amp;&amp; ((_d = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType().getMapping()) === null || _d === void 0 ? void 0 : _d.getElement().id) == entity.id) {
            let action = createAssociation("Update Entity Action", operation.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(operation.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            mapContract("Data Mapping", operation, dto, [operation.id, dtoParam.id], [target.id], updateMapping, true);
            // FIND BY ID OPERATION:
        }
        else if (operation.getName().startsWith("Find" + entity.getName()) &amp;&amp; operation.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // FIND ALL OPERATION:
        }
        else if (operation.getName().startsWith("Find" + pluralize(entity.getName()))) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            action.typeReference.setIsCollection(true);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            //Operations (Command)
        }
        else if (dto.isMapped()) {
            let action = createAssociation("Update Entity Action", operation.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(operation.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            updateMapping.addMappedEnd("Invocation Mapping", [operation.id], [target.id]);
            mapContract("Data Mapping", operation, dto, [operation.id, dtoParam.id], [target.id], updateMapping, true);
        }
        else {
            console.warn(`Could not convert operation: ${operation.getName()} (For entity ${entity.getName()}. Has parameters: (${operation.getChildren("Parameter").map(x =&gt; x.getName())}))`);
        }
    }
    convertToAdvancedMapping.convertOperation = convertOperation;
    function addFilterMapping(mapping, operation, entity) {
        var _a;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id");
            let pk = pkFields[0];
            if (idField &amp;&amp; pk) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a;
                let idField = operation.getChildren("Parameter").find(x =&gt; (x.getName().toLowerCase() == pk.name.toLowerCase()));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
                }
            });
        }
    }
    function mapContract(mappingType, root, dto, sourcePath, targetPathIds, mapping, isCommand = false) {
        if (dto.isMapped() &amp;&amp; dto.getMapping().getElement().specialization == "Class Constructor") {
            if (targetPathIds[targetPathIds.length - 1] != dto.getMapping().getElement().id) {
                targetPathIds.push(dto.getMapping().getElement().id);
                console.warn("Invocation Mapping : " + root.id + "-&gt;" + dto.getMapping().getElement().id);
                mapping.addMappedEnd("Invocation Mapping", [root.id], targetPathIds);
            }
        }
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; !fieldsToSkip(isCommand, dto, x)).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, root, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping, isCommand);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
    function fieldsToSkip(isCommand, dto, field) {
        return isCommand &amp;&amp;
            field.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp;
            (!field.getMapping().getElement().getStereotype("Primary Key").hasProperty("Data source") || field.getMapping().getElement().getStereotype("Primary Key").getProperty("Data source").value != "User supplied");
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
/// &lt;reference path="../_common/convertToAdvancedMapping.ts" /&gt;
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/convert-to-advanced-mapping/convert-to-advanced-mapping.ts
 */
convertToAdvancedMapping.execute();
</script>
        </option>
      </scriptOptions>
      <mappingOptions />
      <typeOrder>
        <type type="Query Entity Action Target End" typeId="93ef6675-cba4-4998-adff-cb22d5343ed4" />
        <type type="Perform Invocation Target End" typeId="093e5909-ffe4-4510-b3ea-532f30212f3c" />
        <type type="Create Entity Action Target End" typeId="328f54e5-7bad-4b5f-90ca-03ce3105d016" />
        <type type="Update Entity Action Target End" typeId="516069f6-09cc-4de8-8e31-3c71ca823452" />
        <type type="Delete Entity Action Target End" typeId="4a04cfc2-5841-438c-9c16-fb58b784b365" />
        <type type="Processing Action" typeId="405a2857-b911-431f-8142-719a0e9f15f3" />
      </typeOrder>
      <mappingSettings />
    </elementExtension>
    <elementExtension type="Query" typeId="e71b0662-e29d-4db2-868b-8a12464b25d0">
      <contextMenuOptions>
        <createAssociation group="1" type="association">
          <text>Query Entity</text>
          <shortcut>ctrl + shift + q</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Query Entity Action Target End</specializationType>
          <specializationTypeId>93ef6675-cba4-4998-adff-cb22d5343ed4</specializationTypeId>
          <defaultName>NewQueryEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </createAssociation>
        <createAssociation group="1" type="association">
          <text>Invoke Service</text>
          <shortcut>ctrl + shift + p</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Perform Invocation Target End</specializationType>
          <specializationTypeId>093e5909-ffe4-4510-b3ea-532f30212f3c</specializationTypeId>
          <defaultName>NewPerformInvocation</defaultName>
          <allowMultiple>true</allowMultiple>
        </createAssociation>
        <runScript group="2" type="run-script">
          <text>Convert to advanced mapping system</text>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return element.isMapped();</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        /*let classes = lookupTypesOf("Class").filter(x =&gt;
            DomainHelper.isAggregateRoot(x) ||
            (options?.includeOwnedRelationships != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) ||
            x.hasStereotype("Repository"));*/
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        if (element.isMapped() &amp;&amp; element.specialization == "Command") {
            convertCommand(element);
        }
        else if (element.isMapped() &amp;&amp; element.specialization == "Query") {
            convertQuery(element);
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertCommand(command) {
        var _a;
        if (!command) {
            console.warn(`Could not convert null Command.`);
            return;
        }
        if (!command.getMapping()) {
            console.warn(`Could not convert Command '${command.getName()}' without it mapping to an Entity.`);
            return;
        }
        let target = command.getMapping().getElement();
        let entity = (_a = target.getParent("Class")) !== null &amp;&amp; _a !== void 0 ? _a : target;
        if (command.getName().startsWith("Create")) {
            let action = createAssociation("Create Entity Action", command.id, target.id);
            let mapping = action.createMapping(command.id, entity.id);
            mapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            mapContract("Data Mapping", command, command, [command.id], [target.id], mapping);
        }
        else if (command.getName().startsWith("Delete")) {
            let action = createAssociation("Delete Entity Action", command.id, entity.id);
            let mapping = action.createMapping(command.id, entity.id);
            // Query Entity Mapping
            addFilterMapping(mapping, command, entity);
            command.clearMapping();
        }
        else if (command.isMapped()) {
            let action = createAssociation("Update Entity Action", command.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(command.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, command, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(command.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            if (target.id != entity.id) {
                updateMapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            }
            mapContract("Data Mapping", command, command, [command.id], [target.id], updateMapping);
        }
    }
    convertToAdvancedMapping.convertCommand = convertCommand;
    function addFilterMapping(mapping, command, entity) {
        var _a, _b;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key")) || (x.getName() == "Id" || x.getName() == `${entity.getName()}Id`));
            let entityPk = entity.getChildren("Attribute").find(x =&gt; x.hasStereotype("Primary Key"));
            if (idField &amp;&amp; (idField.isMapped() || entityPk)) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [entityPk.id]);
                idField.clearMapping();
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a, _b;
                let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp; x.getMapping().getElement().getName() == pk.name) || (x.getName() == pk.name));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [pk.id]);
                    idField.clearMapping();
                }
            });
        }
    }
    function convertQuery(query) {
        if (!query) {
            console.warn(`Could not convert null Query.`);
            return;
        }
        if (!query.getMapping()) {
            console.warn(`Could not convert Query '${query.getName()}' without it mapping to an Entity.`);
            return;
        }
        let entity = query.getMapping().getElement();
        let action = createAssociation("Query Entity Action", query.id, entity.id);
        if (query.typeReference.getIsCollection()) {
            action.typeReference.setIsCollection(true);
        }
        let mapping = action.createMapping(query.id, entity.id);
        mapContract("Filter Mapping", query, query, [query.id], [entity.id], mapping);
    }
    convertToAdvancedMapping.convertQuery = convertQuery;
    function mapContract(mappingType, root, dto, sourcePath, targetPathIds, mapping) {
        if (dto.isMapped() &amp;&amp; dto.getMapping().getElement().specialization == "Class Constructor") {
            if (targetPathIds[targetPathIds.length - 1] != dto.getMapping().getElement().id) {
                targetPathIds.push(dto.getMapping().getElement().id);
                console.warn("Invocation Mapping : " + root.id + "-&gt;" + dto.getMapping().getElement().id);
                mapping.addMappedEnd("Invocation Mapping", [root.id], targetPathIds);
            }
        }
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; !fieldsToSkip(dto, x)).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                console.warn("sourcePath : " + sourcePath);
                console.warn("targetPathIds : " + targetPathIds);
                console.warn("sourceAdd : " + field.id);
                console.warn("targetAdd : " + field.getMapping().getPath().map(x =&gt; x.id));
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, root, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
    function fieldsToSkip(dto, field) {
        return dto.specialization == "Command" &amp;&amp;
            field.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp;
            (!field.getMapping().getElement().getStereotype("Primary Key").hasProperty("Data source") || field.getMapping().getElement().getStereotype("Primary Key").getProperty("Data source").value != "User supplied");
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
/// &lt;reference path="../_common/convertToAdvancedMapping.ts" /&gt;
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/convert-to-advanced-mapping/convert-to-advanced-mapping.ts
 */
convertToAdvancedMapping.execute();
</script>
        </runScript>
        <openMapping type="open-advanced-mapping" mappingType="Map Return Type" mappingTypeId="b7ae8bf5-f2fd-4a5c-b57e-05410687bfc4">
          <text>Map Return Type</text>
          <shortcut>ctrl + shift + m</shortcut>
          <isOptionVisibleFunction>return false &amp;&amp; typeReference?.isTypeFound();</isOptionVisibleFunction>
        </openMapping>
      </contextMenuOptions>
      <creationOptions>
        <option group="1" type="association">
          <text>Query Entity</text>
          <shortcut>ctrl + shift + q</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Query Entity Action Target End</specializationType>
          <specializationTypeId>93ef6675-cba4-4998-adff-cb22d5343ed4</specializationTypeId>
          <defaultName>NewQueryEntityAction</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
        <option group="1" type="association">
          <text>Invoke Service</text>
          <shortcut>ctrl + shift + p</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <specializationType>Perform Invocation Target End</specializationType>
          <specializationTypeId>093e5909-ffe4-4510-b3ea-532f30212f3c</specializationTypeId>
          <defaultName>NewPerformInvocation</defaultName>
          <allowMultiple>true</allowMultiple>
        </option>
      </creationOptions>
      <scriptOptions>
        <option group="2" type="run-script">
          <text>Convert to advanced mapping system</text>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return element.isMapped();</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        /*let classes = lookupTypesOf("Class").filter(x =&gt;
            DomainHelper.isAggregateRoot(x) ||
            (options?.includeOwnedRelationships != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) ||
            x.hasStereotype("Repository"));*/
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        if (element.isMapped() &amp;&amp; element.specialization == "Command") {
            convertCommand(element);
        }
        else if (element.isMapped() &amp;&amp; element.specialization == "Query") {
            convertQuery(element);
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertCommand(command) {
        var _a;
        if (!command) {
            console.warn(`Could not convert null Command.`);
            return;
        }
        if (!command.getMapping()) {
            console.warn(`Could not convert Command '${command.getName()}' without it mapping to an Entity.`);
            return;
        }
        let target = command.getMapping().getElement();
        let entity = (_a = target.getParent("Class")) !== null &amp;&amp; _a !== void 0 ? _a : target;
        if (command.getName().startsWith("Create")) {
            let action = createAssociation("Create Entity Action", command.id, target.id);
            let mapping = action.createMapping(command.id, entity.id);
            mapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            mapContract("Data Mapping", command, command, [command.id], [target.id], mapping);
        }
        else if (command.getName().startsWith("Delete")) {
            let action = createAssociation("Delete Entity Action", command.id, entity.id);
            let mapping = action.createMapping(command.id, entity.id);
            // Query Entity Mapping
            addFilterMapping(mapping, command, entity);
            command.clearMapping();
        }
        else if (command.isMapped()) {
            let action = createAssociation("Update Entity Action", command.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(command.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, command, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(command.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            if (target.id != entity.id) {
                updateMapping.addMappedEnd("Invocation Mapping", [command.id], [target.id]);
            }
            mapContract("Data Mapping", command, command, [command.id], [target.id], updateMapping);
        }
    }
    convertToAdvancedMapping.convertCommand = convertCommand;
    function addFilterMapping(mapping, command, entity) {
        var _a, _b;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key")) || (x.getName() == "Id" || x.getName() == `${entity.getName()}Id`));
            let entityPk = entity.getChildren("Attribute").find(x =&gt; x.hasStereotype("Primary Key"));
            if (idField &amp;&amp; (idField.isMapped() || entityPk)) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [entityPk.id]);
                idField.clearMapping();
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a, _b;
                let idField = command.getChildren("DTO-Field").find(x =&gt; (x.isMapped() &amp;&amp; x.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp; x.getMapping().getElement().getName() == pk.name) || (x.getName() == pk.name));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_b = (_a = idField.getMapping()) === null || _a === void 0 ? void 0 : _a.getPath().map(x =&gt; x.id)) !== null &amp;&amp; _b !== void 0 ? _b : [pk.id]);
                    idField.clearMapping();
                }
            });
        }
    }
    function convertQuery(query) {
        if (!query) {
            console.warn(`Could not convert null Query.`);
            return;
        }
        if (!query.getMapping()) {
            console.warn(`Could not convert Query '${query.getName()}' without it mapping to an Entity.`);
            return;
        }
        let entity = query.getMapping().getElement();
        let action = createAssociation("Query Entity Action", query.id, entity.id);
        if (query.typeReference.getIsCollection()) {
            action.typeReference.setIsCollection(true);
        }
        let mapping = action.createMapping(query.id, entity.id);
        mapContract("Filter Mapping", query, query, [query.id], [entity.id], mapping);
    }
    convertToAdvancedMapping.convertQuery = convertQuery;
    function mapContract(mappingType, root, dto, sourcePath, targetPathIds, mapping) {
        if (dto.isMapped() &amp;&amp; dto.getMapping().getElement().specialization == "Class Constructor") {
            if (targetPathIds[targetPathIds.length - 1] != dto.getMapping().getElement().id) {
                targetPathIds.push(dto.getMapping().getElement().id);
                console.warn("Invocation Mapping : " + root.id + "-&gt;" + dto.getMapping().getElement().id);
                mapping.addMappedEnd("Invocation Mapping", [root.id], targetPathIds);
            }
        }
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; !fieldsToSkip(dto, x)).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                console.warn("sourcePath : " + sourcePath);
                console.warn("targetPathIds : " + targetPathIds);
                console.warn("sourceAdd : " + field.id);
                console.warn("targetAdd : " + field.getMapping().getPath().map(x =&gt; x.id));
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, root, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
    function fieldsToSkip(dto, field) {
        return dto.specialization == "Command" &amp;&amp;
            field.getMapping().getElement().hasStereotype("Primary Key") &amp;&amp;
            (!field.getMapping().getElement().getStereotype("Primary Key").hasProperty("Data source") || field.getMapping().getElement().getStereotype("Primary Key").getProperty("Data source").value != "User supplied");
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
/// &lt;reference path="../_common/convertToAdvancedMapping.ts" /&gt;
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/convert-to-advanced-mapping/convert-to-advanced-mapping.ts
 */
convertToAdvancedMapping.execute();
</script>
        </option>
      </scriptOptions>
      <mappingOptions>
        <option type="open-advanced-mapping" mappingType="Map Return Type" mappingTypeId="b7ae8bf5-f2fd-4a5c-b57e-05410687bfc4">
          <text>Map Return Type</text>
          <shortcut>ctrl + shift + m</shortcut>
          <isOptionVisibleFunction>return false &amp;&amp; typeReference?.isTypeFound();</isOptionVisibleFunction>
        </option>
      </mappingOptions>
      <typeOrder>
        <type type="Query Entity Action Target End" typeId="93ef6675-cba4-4998-adff-cb22d5343ed4" />
        <type type="Perform Invocation Target End" typeId="093e5909-ffe4-4510-b3ea-532f30212f3c" />
      </typeOrder>
      <mappingSettings />
    </elementExtension>
    <elementExtension type="Service" typeId="b16578a5-27b1-4047-a8df-f0b783d706bd">
      <contextMenuOptions>
        <runScript group="2" type="run-script">
          <text>Convert to advanced mapping system</text>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return element.getChildren("Operation").every(x =&gt; x.getAssociations().length == 0);</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        var _a, _b, _c, _d, _e, _f;
        if (element.specialization == "Service") {
            let entity = (_c = (_b = (_a = element.getChildren("Operation").find(x =&gt; x.getName().startsWith("Find"))) === null || _a === void 0 ? void 0 : _a.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.getMapping()) === null || _c === void 0 ? void 0 : _c.getElement();
            element.getChildren("Operation").forEach(operation =&gt; {
                convertOperation(operation, entity);
            });
        }
        else if (element.specialization == "Operation") {
            let dtoParam = element.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
            let dto = (_d = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType()) !== null &amp;&amp; _d !== void 0 ? _d : (_e = element.typeReference) === null || _e === void 0 ? void 0 : _e.getType();
            let entity = (_f = dto === null || dto === void 0 ? void 0 : dto.getMapping().getElement()) !== null &amp;&amp; _f !== void 0 ? _f : lookupTypesOf("Class").find(x =&gt; x.getName() == element.getName().replace("Delete", ""));
            if (entity) {
                convertOperation(element, entity);
            }
            else {
                console.warn("Cannot execute conversion script on Operation " + element.getName());
            }
        }
        else {
            console.error("Cannot qualify this script. Please contact Intent Architect support.");
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertOperation(operation, entity) {
        var _a, _b;
        let target = entity;
        let dtoParam = operation.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
        let dto = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType();
        // CREATE OPERATION:
        if (operation.getName().startsWith("Create") &amp;&amp; ((_a = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType().getMapping()) === null || _a === void 0 ? void 0 : _a.getElement().id) == entity.id) {
            let action = createAssociation("Create Entity Action", operation.id, target.id);
            let mapping = action.createMapping(operation.id, entity.id);
            mapping.addMappedEnd("Invocation Mapping", [operation.id], [target.id]);
            mapContract("Data Mapping", dto, [operation.id, dtoParam.id], [target.id], mapping);
            // DELETE OPERATION:
        }
        else if (operation.getName().startsWith("Delete") &amp;&amp; operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Delete Entity Action", operation.id, entity.id);
            let mapping = action.createMapping(operation.id, entity.id);
            addFilterMapping(mapping, operation, entity);
            // UPDATE OPERATION:
        }
        else if (operation.getName().startsWith("Update") &amp;&amp; ((_b = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType().getMapping()) === null || _b === void 0 ? void 0 : _b.getElement().id) == entity.id) {
            let action = createAssociation("Update Entity Action", operation.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(operation.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            mapContract("Data Mapping", dto, [operation.id, dtoParam.id], [target.id], updateMapping);
            // FIND BY ID OPERATION:
        }
        else if (operation.getName().startsWith("Find" + entity.getName()) &amp;&amp; operation.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // FIND ALL OPERATION:
        }
        else if (operation.getName().startsWith("Find" + pluralize(entity.getName()))) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            action.typeReference.setIsCollection(true);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
        }
        else {
            console.warn(`Could not convert operation: ${operation.getName()} (For entity ${entity.getName()}. Has parameters: (${operation.getChildren("Parameter").map(x =&gt; x.getName())}))`);
        }
    }
    convertToAdvancedMapping.convertOperation = convertOperation;
    function addFilterMapping(mapping, operation, entity) {
        var _a;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id");
            let pk = pkFields[0];
            if (idField &amp;&amp; pk) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a;
                let idField = operation.getChildren("Parameter").find(x =&gt; (x.getName().toLowerCase() == pk.name.toLowerCase()));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
                }
            });
        }
    }
    function mapContract(mappingType, dto, sourcePath, targetPathIds, mapping, isNested = false) {
        console.log("mapContract: " + dto.getName());
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; (isNested || !x.getMapping().getElement().hasStereotype("Primary Key"))).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping, true);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
/// &lt;reference path="../_common/convertToAdvancedMapping.ts" /&gt;
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/convert-to-advanced-mapping/convert-to-advanced-mapping.ts
 */
convertToAdvancedMapping.execute();
</script>
        </runScript>
      </contextMenuOptions>
      <creationOptions />
      <scriptOptions>
        <option group="2" type="run-script">
          <text>Convert to advanced mapping system</text>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <isOptionVisibleFunction>return element.getChildren("Operation").every(x =&gt; x.getAssociations().length == 0);</isOptionVisibleFunction>
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
var convertToAdvancedMapping;
(function (convertToAdvancedMapping) {
    function execute() {
        var _a, _b, _c, _d, _e, _f;
        if (element.specialization == "Service") {
            let entity = (_c = (_b = (_a = element.getChildren("Operation").find(x =&gt; x.getName().startsWith("Find"))) === null || _a === void 0 ? void 0 : _a.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.getMapping()) === null || _c === void 0 ? void 0 : _c.getElement();
            element.getChildren("Operation").forEach(operation =&gt; {
                convertOperation(operation, entity);
            });
        }
        else if (element.specialization == "Operation") {
            let dtoParam = element.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
            let dto = (_d = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType()) !== null &amp;&amp; _d !== void 0 ? _d : (_e = element.typeReference) === null || _e === void 0 ? void 0 : _e.getType();
            let entity = (_f = dto === null || dto === void 0 ? void 0 : dto.getMapping().getElement()) !== null &amp;&amp; _f !== void 0 ? _f : lookupTypesOf("Class").find(x =&gt; x.getName() == element.getName().replace("Delete", ""));
            if (entity) {
                convertOperation(element, entity);
            }
            else {
                console.warn("Cannot execute conversion script on Operation " + element.getName());
            }
        }
        else {
            console.error("Cannot qualify this script. Please contact Intent Architect support.");
        }
    }
    convertToAdvancedMapping.execute = execute;
    function convertOperation(operation, entity) {
        var _a, _b;
        let target = entity;
        let dtoParam = operation.getChildren("Parameter").find(x =&gt; x.typeReference.getType().specialization == "DTO");
        let dto = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType();
        // CREATE OPERATION:
        if (operation.getName().startsWith("Create") &amp;&amp; ((_a = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType().getMapping()) === null || _a === void 0 ? void 0 : _a.getElement().id) == entity.id) {
            let action = createAssociation("Create Entity Action", operation.id, target.id);
            let mapping = action.createMapping(operation.id, entity.id);
            mapping.addMappedEnd("Invocation Mapping", [operation.id], [target.id]);
            mapContract("Data Mapping", dto, [operation.id, dtoParam.id], [target.id], mapping);
            // DELETE OPERATION:
        }
        else if (operation.getName().startsWith("Delete") &amp;&amp; operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Delete Entity Action", operation.id, entity.id);
            let mapping = action.createMapping(operation.id, entity.id);
            addFilterMapping(mapping, operation, entity);
            // UPDATE OPERATION:
        }
        else if (operation.getName().startsWith("Update") &amp;&amp; ((_b = dtoParam === null || dtoParam === void 0 ? void 0 : dtoParam.typeReference.getType().getMapping()) === null || _b === void 0 ? void 0 : _b.getElement().id) == entity.id) {
            let action = createAssociation("Update Entity Action", operation.id, target.id);
            // Query Entity Mapping
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // Update Entity Mapping
            let updateMapping = action.createMapping(operation.id, entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            mapContract("Data Mapping", dto, [operation.id, dtoParam.id], [target.id], updateMapping);
            // FIND BY ID OPERATION:
        }
        else if (operation.getName().startsWith("Find" + entity.getName()) &amp;&amp; operation.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() == "id")) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
            // FIND ALL OPERATION:
        }
        else if (operation.getName().startsWith("Find" + pluralize(entity.getName()))) {
            let action = createAssociation("Query Entity Action", operation.id, target.id);
            action.typeReference.setIsCollection(true);
            let queryMapping = action.createMapping(operation.id, entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            addFilterMapping(queryMapping, operation, entity);
        }
        else {
            console.warn(`Could not convert operation: ${operation.getName()} (For entity ${entity.getName()}. Has parameters: (${operation.getChildren("Parameter").map(x =&gt; x.getName())}))`);
        }
    }
    convertToAdvancedMapping.convertOperation = convertOperation;
    function addFilterMapping(mapping, operation, entity) {
        var _a;
        let pkFields = DomainHelper.getPrimaryKeys(entity);
        if (pkFields.length == 1) {
            let idField = operation.getChildren("Parameter").find(x =&gt; x.getName().toLowerCase() == "id");
            let pk = pkFields[0];
            if (idField &amp;&amp; pk) {
                mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
            }
        }
        else {
            pkFields.forEach(pk =&gt; {
                var _a;
                let idField = operation.getChildren("Parameter").find(x =&gt; (x.getName().toLowerCase() == pk.name.toLowerCase()));
                if (idField) {
                    mapping.addMappedEnd("Filter Mapping", [idField.id], (_a = pk.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : [pk.id]);
                }
            });
        }
    }
    function mapContract(mappingType, dto, sourcePath, targetPathIds, mapping, isNested = false) {
        console.log("mapContract: " + dto.getName());
        dto.getChildren("DTO-Field").filter(x =&gt; x.isMapped() &amp;&amp; (isNested || !x.getMapping().getElement().hasStereotype("Primary Key"))).forEach(field =&gt; {
            var _a, _b;
            if (((_a = field.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" || field.typeReference.getIsCollection()) {
                mapping.addMappedEnd(mappingType, sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)));
            }
            if (((_b = field.typeReference.getType()) === null || _b === void 0 ? void 0 : _b.specialization) == "DTO") {
                mapContract(mappingType, field.typeReference.getType(), sourcePath.concat([field.id]), targetPathIds.concat(field.getMapping().getPath().map(x =&gt; x.id)), mapping, true);
            }
            field.clearMapping();
        });
        dto.clearMapping();
    }
})(convertToAdvancedMapping || (convertToAdvancedMapping = {}));
/// &lt;reference path="../_common/convertToAdvancedMapping.ts" /&gt;
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/convert-to-advanced-mapping/convert-to-advanced-mapping.ts
 */
convertToAdvancedMapping.execute();
</script>
        </option>
      </scriptOptions>
      <mappingOptions />
      <typeOrder />
      <mappingSettings />
    </elementExtension>
  </elementExtensions>
  <associationSettings>
    <associationSetting type="Create Entity Action" typeId="7a3f0474-3cf8-4249-baac-8c07c49465e0">
      <sourceEnd type="Create Entity Action Source End" typeId="a3e7c59e-b0a1-47e1-ba29-66f2c7047b0a">
        <displayFunction>return `created by : ${typeReference.getType().getParent().getName()}.${typeReference.display}`</displayFunction>
        <nameAccessibilityMode>optional</nameAccessibilityMode>
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type type="Command" typeId="ccf14eb6-3a55-4d81-b5b9-d27311c70cb9" />
            <type type="Operation" typeId="e030c97a-e066-40a7-8188-808c275df3cb" />
            <type type="Domain Event Handler Association Target End" typeId="f45dfee9-f62b-45ac-bfce-a3878e04b73f" />
            <type type="[Processing Handler]" typeId="2b6729eb-e2ae-4b5f-86fe-4f611d1f912e" />
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>false</allowIsNullable>
          <allowIsCollection>false</allowIsCollection>
          <isNavigableDefault>true</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
      </sourceEnd>
      <targetEnd type="Create Entity Action Target End" typeId="328f54e5-7bad-4b5f-90ca-03ce3105d016">
        <implements>
          <trait id="d00a2ab0-9a23-4192-b8bb-166798fc7dba" name="[Processing Action]" />
        </implements>
        <displayFunction>return `[create] ${getName()}: ${typeReference.display}`</displayFunction>
        <nameAccessibilityMode>required</nameAccessibilityMode>
        <defaultNameFunction>let name = (typeReference.getType()?.getParent("Class") ?? typeReference.getType())?.getName() ?? "entity"
return typeReference.getIsCollection() 
    ? pluralize(toCamelCase(name))
    : toCamelCase(name);</defaultNameFunction>
        <nameMustBeUnique>true</nameMustBeUnique>
        <icon type="UrlImagePath" source="data:image/png;base64,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" />
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10" />
            <type type="Class Constructor" typeId="dec2bd12-4699-4f45-8ec9-3b62dc692d2b" />
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>false</allowIsNullable>
          <allowIsCollection>false</allowIsCollection>
          <isNavigableDefault>true</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
        <typeOrder />
        <contextMenuOptions>
          <openMapping type="open-advanced-mapping" mappingType="Create Entity Mapping" mappingTypeId="5f172141-fdba-426b-980e-163e782ff53e">
            <text>Map Entity Creation</text>
            <shortcut>ctrl + space</shortcut>
          </openMapping>
        </contextMenuOptions>
        <creationOptions />
        <scriptOptions />
        <mappingOptions>
          <option type="open-advanced-mapping" mappingType="Create Entity Mapping" mappingTypeId="5f172141-fdba-426b-980e-163e782ff53e">
            <text>Map Entity Creation</text>
            <shortcut>ctrl + space</shortcut>
          </option>
        </mappingOptions>
      </targetEnd>
      <visualSettings>
        <lineType>Curved</lineType>
        <lineDashArray>return "3,7";</lineDashArray>
        <sourceEnd>
          <pointIndicator>
            <fillColor>return 'limegreen'</fillColor>
            <lineWidth>return 3;</lineWidth>
            <path>return `a 4,4 0 1,0 4,4 
        a 4,4 0 1,0 -4,4`;</path>
          </pointIndicator>
        </sourceEnd>
        <targetEnd>
          <pointIndicator>
            <path>return `l 4 8 l -8 0 l 4 -8 Z`</path>
          </pointIndicator>
        </targetEnd>
      </visualSettings>
    </associationSetting>
    <associationSetting type="Delete Entity Action" typeId="bfc823fb-60ab-451d-ba62-12671fe7e28e">
      <sourceEnd type="Delete Entity Action Source End" typeId="8c2d9fed-bd14-44b2-9f98-8a801aaf157e">
        <displayFunction>return `deleted by : ${typeReference.getType().getParent().getName()}.${typeReference.display}`</displayFunction>
        <nameAccessibilityMode>optional</nameAccessibilityMode>
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type type="Command" typeId="ccf14eb6-3a55-4d81-b5b9-d27311c70cb9" />
            <type type="Operation" typeId="e030c97a-e066-40a7-8188-808c275df3cb" />
            <type type="Domain Event Handler Association Target End" typeId="f45dfee9-f62b-45ac-bfce-a3878e04b73f" />
            <type type="[Processing Handler]" typeId="2b6729eb-e2ae-4b5f-86fe-4f611d1f912e" />
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>false</allowIsNullable>
          <allowIsCollection>false</allowIsCollection>
          <isNavigableDefault>true</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
      </sourceEnd>
      <targetEnd type="Delete Entity Action Target End" typeId="4a04cfc2-5841-438c-9c16-fb58b784b365">
        <implements>
          <trait id="d00a2ab0-9a23-4192-b8bb-166798fc7dba" name="[Processing Action]" />
        </implements>
        <displayFunction>return `[delete] ${getName()}: ${typeReference.display}`</displayFunction>
        <nameAccessibilityMode>required</nameAccessibilityMode>
        <defaultNameFunction>let name = (typeReference.getType()?.getParent("Class") ?? typeReference.getType())?.getName() ?? "entity"
return typeReference.getIsCollection() 
    ? pluralize(toCamelCase(name))
    : toCamelCase(name);</defaultNameFunction>
        <nameMustBeUnique>true</nameMustBeUnique>
        <icon type="UrlImagePath" source="data:image/png;base64,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" />
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10" />
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>false</allowIsNullable>
          <allowIsCollection>true</allowIsCollection>
          <isNavigableDefault>true</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
        <typeOrder />
        <contextMenuOptions>
          <openMapping type="open-advanced-mapping" mappingType="Query Entity Mapping" mappingTypeId="25f25af9-c38b-4053-9474-b0fabe9d7ea7">
            <text>Map Entity Filter</text>
            <shortcut>ctrl + space</shortcut>
          </openMapping>
        </contextMenuOptions>
        <creationOptions />
        <scriptOptions />
        <mappingOptions>
          <option type="open-advanced-mapping" mappingType="Query Entity Mapping" mappingTypeId="25f25af9-c38b-4053-9474-b0fabe9d7ea7">
            <text>Map Entity Filter</text>
            <shortcut>ctrl + space</shortcut>
          </option>
        </mappingOptions>
      </targetEnd>
      <visualSettings>
        <lineType>Curved</lineType>
        <lineDashArray>return "3,7";</lineDashArray>
        <sourceEnd>
          <pointIndicator>
            <fillColor>return 'indianred'</fillColor>
            <lineWidth>return 3;</lineWidth>
            <path>return `a 4,4 0 1,0 4,4 
        a 4,4 0 1,0 -4,4`;</path>
          </pointIndicator>
        </sourceEnd>
        <targetEnd>
          <pointIndicator>
            <path>return `l 4 8 l -8 0 l 4 -8 Z`</path>
          </pointIndicator>
        </targetEnd>
      </visualSettings>
      <macros>
        <macro trigger="on-created">
          <script>let mapping = association.createMapping(association.getOtherEnd().typeReference.getTypeId(), association.typeReference.getTypeId(), "25f25af9-c38b-4053-9474-b0fabe9d7ea7") // Query Entity Mapping
association.typeReference.getType().getChildren("Attribute")
    .filter(x =&gt; x.hasStereotype("Primary Key"))
    .forEach(attr =&gt; {
        let handler = association.getOtherEnd().typeReference.getType();
        let childSpecialization = handler.specialization == "Command" ? "DTO-Field"
            : handler.specialization == "Operation" ? "Parameter"
            : null
        if (childSpecialization == null) {
            return;
        }
        let pkField = handler.getChildren(childSpecialization).find(x =&gt; x.getName().toLowerCase() == attr.getName().toLowerCase()
            &amp;&amp; x.typeReference.getTypeId() == attr.typeReference.getTypeId())
        if (!pkField) {
            let newField = createElement(childSpecialization, attr.getName(), handler.id);
            newField.typeReference.setType(attr.typeReference.getTypeId());
            newField.typeReference.setIsNullable(attr.typeReference.getIsNullable())
            newField.typeReference.setIsCollection(attr.typeReference.getIsCollection())
            pkField = newField;
        }
        mapping.addMappedEnd("Filter Mapping", [pkField.id], [attr.id]);
    })</script>
        </macro>
      </macros>
    </associationSetting>
    <associationSetting type="Query Entity Action" typeId="47ab5888-a258-4bec-a9fc-a83de69eb79d">
      <sourceEnd type="Query Entity Action Source End" typeId="32a65f26-2555-4616-8a2c-6a90805600bb">
        <nameAccessibilityMode>optional</nameAccessibilityMode>
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type type="Query" typeId="e71b0662-e29d-4db2-868b-8a12464b25d0" />
            <type type="Operation" typeId="e030c97a-e066-40a7-8188-808c275df3cb" />
            <type type="Command" typeId="ccf14eb6-3a55-4d81-b5b9-d27311c70cb9" />
            <type type="Domain Event Handler Association Target End" typeId="f45dfee9-f62b-45ac-bfce-a3878e04b73f" />
            <type type="[Processing Handler]" typeId="2b6729eb-e2ae-4b5f-86fe-4f611d1f912e" />
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>false</allowIsNullable>
          <allowIsCollection>false</allowIsCollection>
          <isNavigableDefault>false</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
      </sourceEnd>
      <targetEnd type="Query Entity Action Target End" typeId="93ef6675-cba4-4998-adff-cb22d5343ed4">
        <implements>
          <trait id="d00a2ab0-9a23-4192-b8bb-166798fc7dba" name="[Processing Action]" />
        </implements>
        <displayFunction>return `[query] ${getName()}: ${typeReference.display}`</displayFunction>
        <nameAccessibilityMode>required</nameAccessibilityMode>
        <defaultNameFunction>let name = (typeReference.getType()?.getParent("Class") ?? typeReference.getType())?.getName() ?? "entity"
return typeReference.getIsCollection() 
    ? pluralize(toCamelCase(name))
    : toCamelCase(name);</defaultNameFunction>
        <nameMustBeUnique>true</nameMustBeUnique>
        <validateFunction>if (!typeReference.getIsCollection() &amp;&amp; getAdvancedMapping() != null) {
    if (getAdvancedMapping().getMappedEnds().length == 0) {
        return "At least one mapping is required if this query will return a single result (i.e. Is Collection == false).";
    }
}

const hasConflict = element.getParent().getChildren().filter(x =&gt; x.id != element.id &amp;&amp; element.getName().toLowerCase() == x.getName().toLowerCase()).length &gt; 0;
if (hasConflict) {
    return "Name is conflicting with that of a sibling element";
}

return null;</validateFunction>
        <icon type="UrlImagePath" source="data:image/png;base64,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" />
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10" />
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>true</allowIsNullable>
          <allowIsCollection>true</allowIsCollection>
          <isNavigableDefault>true</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
        <typeOrder />
        <contextMenuOptions>
          <openMapping type="open-advanced-mapping" mappingType="Query Entity Mapping" mappingTypeId="25f25af9-c38b-4053-9474-b0fabe9d7ea7">
            <text>Map Entity Query</text>
            <shortcut>ctrl + space</shortcut>
          </openMapping>
        </contextMenuOptions>
        <creationOptions />
        <scriptOptions />
        <mappingOptions>
          <option type="open-advanced-mapping" mappingType="Query Entity Mapping" mappingTypeId="25f25af9-c38b-4053-9474-b0fabe9d7ea7">
            <text>Map Entity Query</text>
            <shortcut>ctrl + space</shortcut>
          </option>
        </mappingOptions>
      </targetEnd>
      <visualSettings>
        <lineType>Curved</lineType>
        <lineDashArray>return "3,7";</lineDashArray>
        <sourceEnd>
          <pointIndicator>
            <fillColor>return 'dodgerblue'</fillColor>
            <lineWidth>return 3;</lineWidth>
            <path>return `a 4,4 0 1,0 4,4 
        a 4,4 0 1,0 -4,4`;</path>
          </pointIndicator>
        </sourceEnd>
        <targetEnd>
          <pointIndicator>
            <path>return `l 4 8 l -8 0 l 4 -8 Z`</path>
          </pointIndicator>
        </targetEnd>
      </visualSettings>
      <macros />
    </associationSetting>
    <associationSetting type="Update Entity Action" typeId="9ea0382a-4617-412a-a8c8-af987bbce226">
      <sourceEnd type="Update Entity Action Source End" typeId="6bc95978-6def-4d0c-a4f5-25bdeda8a9f6">
        <displayFunction>return `updated by : ${typeReference.getType().getParent().getName()}.${typeReference.display}`</displayFunction>
        <nameAccessibilityMode>optional</nameAccessibilityMode>
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type type="Command" typeId="ccf14eb6-3a55-4d81-b5b9-d27311c70cb9" />
            <type type="Operation" typeId="e030c97a-e066-40a7-8188-808c275df3cb" />
            <type type="Domain Event Handler Association Target End" typeId="f45dfee9-f62b-45ac-bfce-a3878e04b73f" />
            <type type="[Processing Handler]" typeId="2b6729eb-e2ae-4b5f-86fe-4f611d1f912e" />
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>false</allowIsNullable>
          <allowIsCollection>false</allowIsCollection>
          <isNavigableDefault>true</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
      </sourceEnd>
      <targetEnd type="Update Entity Action Target End" typeId="516069f6-09cc-4de8-8e31-3c71ca823452">
        <implements>
          <trait id="d00a2ab0-9a23-4192-b8bb-166798fc7dba" name="[Processing Action]" />
        </implements>
        <displayFunction>return `[update] ${getName()}: ${typeReference.display}`</displayFunction>
        <nameAccessibilityMode>required</nameAccessibilityMode>
        <defaultNameFunction>let name = (typeReference.getType()?.getParent("Class") ?? typeReference.getType())?.getName() ?? "entity"
return typeReference.getIsCollection() 
    ? pluralize(toCamelCase(name))
    : toCamelCase(name);</defaultNameFunction>
        <nameMustBeUnique>true</nameMustBeUnique>
        <icon type="UrlImagePath" source="data:image/png;base64,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" />
        <allowSorting>true</allowSorting>
        <sortChildren p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
        <typeReferenceSetting>
          <isRequired>true</isRequired>
          <targetTypes>
            <type type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10" />
            <type type="Operation" typeId="e042bb67-a1df-480c-9935-b26210f78591" />
          </targetTypes>
          <allowIsNavigable>false</allowIsNavigable>
          <allowIsNullable>false</allowIsNullable>
          <allowIsCollection>true</allowIsCollection>
          <isNavigableDefault>true</isNavigableDefault>
          <isNullableDefault>false</isNullableDefault>
          <isCollectionDefault>false</isCollectionDefault>
        </typeReferenceSetting>
        <typeOrder />
        <contextMenuOptions>
          <openMapping type="open-advanced-mapping" mappingType="Query Entity Mapping" mappingTypeId="25f25af9-c38b-4053-9474-b0fabe9d7ea7">
            <text>Map Entity Query</text>
            <shortcut>ctrl + shift + q</shortcut>
          </openMapping>
          <openMapping type="open-advanced-mapping" mappingType="Update Entity Mapping" mappingTypeId="01721b1a-a85d-4320-a5cd-8bd39247196a">
            <text>Map Entity Update</text>
            <shortcut>ctrl + space</shortcut>
          </openMapping>
        </contextMenuOptions>
        <creationOptions />
        <scriptOptions />
        <mappingOptions>
          <option type="open-advanced-mapping" mappingType="Query Entity Mapping" mappingTypeId="25f25af9-c38b-4053-9474-b0fabe9d7ea7">
            <text>Map Entity Query</text>
            <shortcut>ctrl + shift + q</shortcut>
          </option>
          <option type="open-advanced-mapping" mappingType="Update Entity Mapping" mappingTypeId="01721b1a-a85d-4320-a5cd-8bd39247196a">
            <text>Map Entity Update</text>
            <shortcut>ctrl + space</shortcut>
          </option>
        </mappingOptions>
      </targetEnd>
      <visualSettings>
        <lineType>Curved</lineType>
        <lineDashArray>return "3,7";</lineDashArray>
        <sourceEnd>
          <pointIndicator>
            <fillColor>return 'orange'</fillColor>
            <lineWidth>return 3;</lineWidth>
            <path>return `a 4,4 0 1,0 4,4 
        a 4,4 0 1,0 -4,4`;</path>
          </pointIndicator>
        </sourceEnd>
        <targetEnd>
          <pointIndicator>
            <path>return `l 4 8 l -8 0 l 4 -8 Z`</path>
          </pointIndicator>
        </targetEnd>
      </visualSettings>
      <macros>
        <macro trigger="on-created">
          <script>if (association.getParent().specialization !== "Command") {
    return;
}
let mapping = association.createMapping(association.getOtherEnd().typeReference.getTypeId(), association.typeReference.getTypeId(), "25f25af9-c38b-4053-9474-b0fabe9d7ea7") // Query Entity Mapping
association.typeReference.getType().getChildren("Attribute")
    .filter(x =&gt; x.hasStereotype("Primary Key"))
    .forEach(attr =&gt; {
        let sourceType = association.getOtherEnd().typeReference.getType();
        let pkField = sourceType.specialization == "Command" 
            ? getOrCreatePkField(sourceType, attr, "DTO-Field")
            : getOrCreatePkField(sourceType, attr, "Parameter")
        mapping.addMappedEnd("Filter Mapping", [pkField.id], [attr.id]);
    })

function getOrCreatePkField(sourceType, attr, fieldType) {
    let pkField = sourceType.getChildren(fieldType).find(x =&gt; x.getName().toLowerCase() == attr.getName().toLowerCase()
    &amp;&amp; x.typeReference.getTypeId() == attr.typeReference.getTypeId())
    if (!pkField) {
        let newField = createElement(fieldType, attr.getName(), sourceType.id);
        newField.typeReference.setType(attr.typeReference.getTypeId());
        newField.typeReference.setIsNullable(attr.typeReference.getIsNullable())
        newField.typeReference.setIsCollection(attr.typeReference.getIsCollection())
        pkField = newField;
    }
    return pkField;
}</script>
        </macro>
      </macros>
    </associationSetting>
  </associationSettings>
  <associationExtensions>
    <associationExtension type="Domain Event Handler Association" typeId="90831494-f069-44eb-b488-ab2dba7518ea">
      <sourceEndExtension>
        <typeOrder />
        <typeReferenceExtension>
          <isRequired>true</isRequired>
          <targetTypes />
          <allowIsNavigable>inherit</allowIsNavigable>
          <allowIsNullable>inherit</allowIsNullable>
          <allowIsCollection>inherit</allowIsCollection>
        </typeReferenceExtension>
      </sourceEndExtension>
      <targetEndExtension>
        <typeOrder>
          <type type="Query Entity Action Target End" typeId="93ef6675-cba4-4998-adff-cb22d5343ed4" />
          <type type="Perform Invocation Target End" typeId="093e5909-ffe4-4510-b3ea-532f30212f3c" />
          <type type="Create Entity Action Target End" typeId="328f54e5-7bad-4b5f-90ca-03ce3105d016" />
          <type type="Update Entity Action Target End" typeId="516069f6-09cc-4de8-8e31-3c71ca823452" />
          <type type="Delete Entity Action Target End" typeId="4a04cfc2-5841-438c-9c16-fb58b784b365" />
          <type type="Processing Action" typeId="405a2857-b911-431f-8142-719a0e9f15f3" />
        </typeOrder>
        <contextMenuOptions>
          <createAssociation type="association">
            <text>Query Entity</text>
            <shortcut>ctrl + shift + q</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,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" />
            <specializationType>Query Entity Action Target End</specializationType>
            <specializationTypeId>93ef6675-cba4-4998-adff-cb22d5343ed4</specializationTypeId>
            <defaultName>NewQueryEntityAction</defaultName>
            <allowMultiple>true</allowMultiple>
          </createAssociation>
          <createAssociation type="association">
            <text>Invoke Service</text>
            <shortcut>ctrl + shift + o</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,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" />
            <specializationType>Perform Invocation Target End</specializationType>
            <specializationTypeId>093e5909-ffe4-4510-b3ea-532f30212f3c</specializationTypeId>
            <defaultName>NewPerformInvocation</defaultName>
            <allowMultiple>true</allowMultiple>
          </createAssociation>
          <createAssociation type="association">
            <text>Create Entity</text>
            <shortcut>ctrl + shift + c</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,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" />
            <specializationType>Create Entity Action Target End</specializationType>
            <specializationTypeId>328f54e5-7bad-4b5f-90ca-03ce3105d016</specializationTypeId>
            <defaultName>NewCreateEntityAction</defaultName>
            <allowMultiple>true</allowMultiple>
          </createAssociation>
          <createAssociation type="association">
            <text>Update Entity</text>
            <shortcut>ctrl + shift + u</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,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" />
            <specializationType>Update Entity Action Target End</specializationType>
            <specializationTypeId>516069f6-09cc-4de8-8e31-3c71ca823452</specializationTypeId>
            <defaultName>NewUpdateEntityAction</defaultName>
            <allowMultiple>true</allowMultiple>
          </createAssociation>
          <createAssociation type="association">
            <text>Delete Entity</text>
            <shortcut>ctrl + shift + d</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAEiZJREFUeF7tXHl4VFWWP+e9CNLirkirKBAgpBIqS6WyV1LZKyuyG3QcdRC153PU0th/tLa4zPdNo7baM9NurXb3KLIYMWQPIfteqSxVWYAQicq0W4OitkCSqjPffe8lLQ68m1dVpiMf9798de455/7e79533++eG4TzzSsE0Kve5zvDeQC9JMG0AvjFrfeYvcx3St2vfuvluikZ+sBo2gAcyrxv9mWXj530Qc5cF1eNHZ2Nu3aNcg19YPAPAJAATls5fP/3VWPHzj0A2cP+PH8zkYzXSQRo9wEBvu8ikf3B/F+z/dVpI8a0BWJT+JJLT01M4ZFrtr+6yJcAfnbzXSMAeCPz+VfXl7ODzsUpfPElJxQAcWT+jtd8CuCnGzaNAIAE4FH38XMXQDbFEGlk/o7XfQrgJxs2jSDAjcz/MTpHAbxo7ncnARiCMHLtzjd8CuBf1t2pTGGCL+Gbc5OBF8392+QaeO2uHwNAeQr/wwE8svbO2xDci325yBOQiCA8Kr+G4StEeNG3/vEBBLhU8o/4NAK5fOnfTXhoQeGbb/3Q5xnfwkfW3r4PCJJ9mcBP3RcCVF5X+EfLlAD8ePVt+wDwPICnoUWVC97789QAPLLqn28jJJ9O4Z86A8ENhxa8/+epTeGf/GCncQDT9iUyjWOa1lCaATyct/FeANjAskSAJxbu2VY7rRn7ONhIbn4yIf5adovbF+15+2UtIbQDuPKWJ4BICogEmxYWb3tdS8CZZjuyMn8TEb6m5PXEoj3btmjJUTOAH+TlPwQEz0rKB5DVv3j781oCzjTb4Zx8KyI8J42H4CH/knd+qyVH7QDmbtgMgK+w/aqA+Pii4nee1BJwptkO59z8OCJskfbfAJsXl2yfYOOUUtUM4HDW+nxC3KZ4f25J6Y6HpxRphhoN52x4jgis8hKINy8p2b5DS6raAcxel00glEiiAOCrS0p33K0l4EyzPZS14TVA2MTGgwjZ/iU7y7TkqBnAg1nrExCoXv6kxe3Lynfmawk402yHMtdtB4QNbDxEYAqo2NWkJUfNAA5lrgkjELpkWQpLl5XtyuEFPJCzIYRcrsnPoOXl7/6G1+egZV0BIglMEUCi0YCKQu7Lan/m2l9O+EVRrAgo2dHLizOUubaMADOlV6Iohk6lz/d9egDgTf5uEg/JawY0BJQXSmcRam04a8Oycff4gQmbgIpCbtz9ljUFCLBV6WOdCoAHLGukecGan+AO8C/bfZCX2wHL6kYAjJeGI5L/stL3PuD18QrAQ+mr5rkE4TPJCUFPQGVhGC/goOWmhQKIhz0BUFanQDOAbnAtCqx4n8n8qm2/ZU0vAuglowtGrw4oLv4rr49XAB42337hyVnHT0hPDGF4eeXuJbyAAxmrf45Ef5mwC6zazWXgQPqqSQYSgFVXtZs7hQfTV00ykBCv1VW+9wkvt8H01R8AkKSO+4knL1xaXn6K18crAFnnwfRVbGkSAOCLwKrd83gB+zPWXSHQ+NHpBNCNflcGVe46xsttMH0VY9yVAOAOrNot8ux/+DuXCWdyOJC2kiV2OQCc1O0tmsML2pv+TxddQF9/Kx+oE+j2FnHjDqTmFQAKW5m9m8AaXF3EZeBA2k3sXSqlM4Yn5oZUVf2Nl9tA2k0uABKA4Kiuuugqnr1vAExdOUIANyICBMaFibhli1stMJnNfgN+l44xeyIYDqou4k57Z2pegYi4VdpewNQA7E9dyV5u/iwX3fjxC7Cublwtr6HMzNmjY7OkcxoEOKyrLtKsgXKZcKYEnMm5TkQIlgL7jV4ZVFnJnSp9KbkyNQiPBNfsWcB70s7UnAIklN/CyAAs5jKwLyXvYwC6nnUJ3lfMHdsBc+5VYyJ8oeTiCN5XHMLLyycMdCbnNANgLGOU6BIXBdbx33bO5NzvEGEOEX2xoqaEu246k3IKUFAYSGDV1/IBdCbnfg4AVwPAiRU1xT/jgeFIyV6MJAyzcQBAU/C+YhOvj28ATMqpIKAM9hoGwa3XV5c5eYEdSTlfAsBlgPS1vqb0Up59b1JWAYK8BgKQVV9bxmWgMzn7OBFcAoBf6WtL2Bqt2vqSckLcQD3SBEYo19eUZPH6+ARAR3L2LiBYy5wJ4I4Pri1v5gV2JGV/CgDXAMApfW3phTx7GUBlCk8RQEdSNlvPZgPAZ/ra0vncGCnZJnRDg2K3U19bKgnFWhp3nTiTs57ETCai3oky9zND6soqeEF7EjM/QsQFQEQh9eVsC6TauhOzCgSErfI5MllD6yu4DOw1Z7mJiGX1cUh9+Q28GI4ES5YbsVQZxx9C6sru4vXxCQN7zZkvEMH9zBkBrQ+rr9jFC9yTmDkEANLb94J5c7mlF92JltMYyAOwf926WWOffzuxCT4UWl++lJdTr9lyMxG+I9vh86H1ZbKspaF5xMCuBMtTCPCoDCBsCm+o4Mr63YmWPiAIYn3muGZdsrx5zzdqeXabLAWA8rcw2wcaGtUZuD8u7+IT4ujXMhbQH1ZfIe0SVGMkZtwFhK8qNk+ENVRokvPlUB40eXAkbzEIHgxrrHyB56YrIcOOAOHMziXMujqiTv2b026yFAhKDDeR1dBYpTqFO825V4nuUWlLQgBd4Q2Vhink9BDCxPEEPBzeUClJ+1qaRwB2mdLuIcKXpGSRHo9o3MuV9btM6S1EEMP6iK7x60Nba/5XLVF7XLrCQElN4ALYE5N8nUv0OyKxAqE1vLEqlgeEPT59CwA9Lr+FcbOhsVKTnO8xAzvjUzci4NvydMFnDY1VBfxk01jlvCR9ucHtb2zapyobyQDKLHcTWo3N6gy0xacsFkAYVvKoNzTt5d4IsMel/xaQHpSHgfnhjVXbeeP44e8eMdAen55L5N4jMZDgVWNLNVfW74xNrQSEdClZF+gMbdWDasna4lJPU2OMzdWqU9genRpIIgwoPqsimqszeGB0xqW8BoCb5GmP2cbmvZrkfI8ZaItPNYObatnrnwjeMbZUb+Qla4tL2QOAuawDgRAW2bK3ZyoAKuVqVh6AHbFpoYjULVWZIxQbm/fl8XLqjEvdQUTrmZ2AkGBo3tfI6+MTBnZGJ4e7Eezyk6PSqNZarqxvi0neRSBvvhEgytha06GWbHtM0uQ2hoisUW21qgy0xSRHklL5jwDvGltr1vHA6IhJZozLlJcid1hkS53qQz2TP4+mcFtU2lJBGD/IoCCghqjWWq6s3x6d9DYibpQYJQoJUZynPQGgUpDJBbA9LsWEbmqQGQvbolprb+EDmNREBHFs542iwF2XfQZgh9E83y3AJ9KHCEFPVHsdV9Zvi0p6A5HukPBDSDO21VWrMjAysQAmxQSyxnTUqzMw2pzqBtirnBa+Gd1eeycPwLZoswMIVjC70VmueQmNjRPKDK/r5O8eMbDTYPjZuN/FkljJ9L2YjjquvtcebX6JCO6RlmsScqI6akvVsmyJTCwQkH0LE4vBBbA9MimbkKTzakR8OaqtjhVBqba2KPNhAFrIKHvsijkXZmmU8z1+ibCOrUaTCxAFAvg8tqOBiQSqrcWY8AIi3K+UUKyJsTW8pwpghGlSzkJkDGxUZWCrMWE1IBTKDIQXY20ND/Byao1MOEoEVyCAO8bWoFnO9wrAFmOCLE8BnYy1NXJl/ZZI01YgLJDPk2ljbEeT8g165mG2RJgKQGEgO5XjAdgSEZ8PKGxTrlE8E9vR+AgXQKPJJZX4AB6NsTVolvO9ArA5Iv4jAJCU5djOJpE9RbWEm43xTwHJ38+AeEecrfGPavZNEXF/fwsDWuM71RnYHG66HQR6U/YPT8fZmh5T819rNl8469tx6XQREEfibI0e3VvxaA1kMZsM8f2IoJPiX+C6Mra1VVXWbzbEPwoITylP7e7YzqaJj/gzjvN0AMka39msOoVbIuI3E8ArkjOCx+LsTU+rAdgQZrpaFIkp2GyNdcTbmzTL+V4xsDE8thUAopkTgWBhXHfLh6qMCo8rIJA/zQSEf4uzt/yn6gDDGQNlewK0JnSpA9hsiL3PTfA7eVD4SHxX8zOqM8IQ6+8mUCossNlkb5aqE7Q2jxnYGBZbBQhpLKAbSZ9ob1WV9esNMfcLhJJqg0gF8fZWqUjzbK0hPOa0KcwDsMkQ8zARyqAhPWCyt6pe5GkOjQ11C9Atx8cKU1ezvKHW2DwGsD4suhABV8vbDIxL7GltUQUkLPoeAKbgSGVkj5q62v5d1T405ntqDFgTutpUp3B9aPSvEPFp5Vz43oTuNtVa5/qwWKnKTNkm7UzsadMs58ts97A1hEa/CQi3S5WqAmaaulpVZf3GkKg7SMA35FoXfCqhu1Up7D5zAnWhMZIeqJSdWc296gDWhUU9KQA+JuVDdKept11+oZylNYRGZgMKJcoF8NcTu9skUUFr8xjAupDI3wHgfcq2Yb25p0NV1q8PjdxIxCQwaaO21dzbMVmKdqak6/SRk9sYALCaeztUGVgXEvkbAHxEYfgtiT0dE1W0Z8SkTh+ZD1KlrZTP8+beDs1yvlcMrNVHPo0Iv1I2rpuSHB2qsn6DPmqNG+ld2Z5eTHLYVDe6MoDsUEmuzuIBWKs3voCI0kZdBFyb4GgvVGNTfUjUZgKSar0R6Ulzr+1xrezzDsAVhl8CCv/BPt4R4cEkR6eqrL9Pb8wVAPYo8tRLyQ7bL9QSrtFHSC+RCTEh2dmpysAavfH3CHAvsyfEvBSHrVjNf63eyGq7n5HyF/DhpF6bZjnfKwBr9MZfANF/y0nir5OdNmmPd7a2L9iQjoiVyu9vJDs7/4UHINDfCyy5AK6IkI5aJX4TZaT02atU/a8wPMHyVmzuTnZ2qu5Lz+bL4zWwOjj8VgT8H5mB+GxKn11V1q9ZYUwkctcxewHx7eQ++61qA9wbHF4gKAxkxUVp/V2qDKwODn8LAW+R/AuiOdlpq1d9oEHhzwPiA8q5c35qf7dmOd8rBu7Vha5EFN6XCQivpPZ13aM+ZcKjXS5gm2/W4d3Ufruq4MkARIWBUwIwyLALgCTBVhQhJsnR1aaWT3WQ4Q8AJM0CQsxJ67OrqkO+Z2BQSBKRUCM5JngnbbBbVdavCNSHiyhKKjYCFKcOdKtK7pWBoYqcJe28uQys0oXtQYBc5t9FgsEyaO9SBVAXupMApYcoECSmDHZPlHiodft/v3k8hasCwiJQJJsCYEnaYI+U/NlahS4kSATsk9coqEof7FE99JEBnDhYJ2vGYK/qFK4KDK1E5dDKBRRsGejtV10idGHlACTdHCCAsPSBHs1yvldTuDxAHyAg7pdnJDVkDDpUZf2KoPAl6HKx8g6Wcn3GfofqsWNlgF7ZB8r1gTwAK5fr6wBQ/u9ForjU0t8lf+eepVUuD2EFUdLZscvPtSSrr2/iSHR6GFgRaPg50phUOE4A3Zb9Dqnq4KwJBwcvgHGBSWBSy9jvUGV/eYB+koGAjIFOVQZWLtdPFpiDn/uGjL6+j9UB1DsAZDnfNS7OyzrUrVnO94qBtTrd3FMuUa5vIRi2HHSqyvpFi4KvmT0LWYmb1CwHnBwAg793KgfWzIPqAFYErJgE8NQozV95uE++inGWVh4QPILKv4qafeqbOUkjIx79ZzmP10CWF0ta2sYAfm456FSV9XcvDL1szmzXl8pGGjKnCKDy38q4AJYvCyb5nJrg5Kjf5atGer7iAHgMAS8nInfmwT6P5HyvGMg6ly0NOg7AKkLhZNZQv6qsv/P6mDlz53z9qfztiZA11K9apVq6lDGQHlXUni3Zh/pVp3DZUt3xiVsA3564dP76I62y2nyWVrpU50JAVqd4LGuon11z8Kh5xcCypbojRHAde/IdQ/3iFo6s71GGP0In+WEe/04BfCRraMAjOd9rBpYu0Q0QUaB0fWHU74qcj5zsoGnGt0p//bwxGPtMuXbhzBkelK96edC8YmDJksB2IIiUnoQbFmYfHlSV9T3I70fpUuQftEQE98SWqiVneH+cp4G8ArB4cUA1EaRIpREorMgZHpQ2yjO9Fd2oCxNEl/SlQgQVeYcPeCTnez2F9yxeVggEq5VrAl1AoFq2O3OAJXYVQilHoR15hw/e7GluXjGwaOGyPwHQbZ4GnxH9EF9fefigR3K+1wwsWrTkv4DwX2cEEJ4n8cLKkSGpStWT5hUDC29YulgQiHsfw5PEpquPSOKHeR8emLwMrjWuVwBqDXYu2p8H0Muneh5ALwH8P/iQU7rBy/3YAAAAAElFTkSuQmCC" />
            <specializationType>Delete Entity Action Target End</specializationType>
            <specializationTypeId>4a04cfc2-5841-438c-9c16-fb58b784b365</specializationTypeId>
            <defaultName>NewDeleteEntityAction</defaultName>
            <allowMultiple>true</allowMultiple>
          </createAssociation>
          <createElement type="element">
            <text>Add Processing Action</text>
            <shortcut>ctrl + shift + p</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAAehJREFUeF7t3L1NA0EQhuE55DrYJijAEiVQAh0QEVl3XRGQQwWk/qGQRYewRGCB5G93dr6ZcT723nOv5GS0k+QHEpig6RyWBAQjSMAEBAXA8WYFll15lI18HHfHN/BMVOMwYFnKg1R5FpG79cknmZbDfJipFIDDXg24nbebvexfROT+wu+/y408RajxasAVrcyl/vXyItTYFfAH13WNGoDfjl5rVAP0WqM2oLsahwB6qnEkoIsahwOy12gFkLZGU4CMNVoEpKrRLCBLjdYBzddIAWi5RiZAkzXSAVqrkRXQTI3UgBZq9AA4tEY3gKNq9AaoXqNLQM0aPQOq1OgesHeNUQC71RgKsEeNEQGb1hgWcFWstX6eltMtsFuEbaj+txuDHExjNgFB5QRMQFAAHM8CAcBW22IR/4Wb7iuGAmxV3e/wowA2rS4UYI/qogB2q849YO/qPAOqVOcSULM6b4Dq1bkBHFWdB8Ch1VEDWqiOFdBMdXSA1qpjAjRZHQWg5eqsA5qvziwgS3UWAamqMwXIWJ0VQNrqhgOyVzcS0EV1QwA9VacN6K46NUCv1bUEfM27s4D9knU0b28DAc/jeX9gI8hoXwPtxkTDuvS8CQhWkIAJCAqA41lgAoIC4HgWmICgADieBYKAX0uidGAd9hNhAAAAAElFTkSuQmCC" />
            <specializationType>Processing Action</specializationType>
            <specializationTypeId>405a2857-b911-431f-8142-719a0e9f15f3</specializationTypeId>
            <defaultName>Action</defaultName>
            <allowMultiple>true</allowMultiple>
          </createElement>
        </contextMenuOptions>
        <creationOptions>
          <option type="association">
            <text>Query Entity</text>
            <shortcut>ctrl + shift + q</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,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" />
            <specializationType>Query Entity Action Target End</specializationType>
            <specializationTypeId>93ef6675-cba4-4998-adff-cb22d5343ed4</specializationTypeId>
            <defaultName>NewQueryEntityAction</defaultName>
            <allowMultiple>true</allowMultiple>
          </option>
          <option type="association">
            <text>Invoke Service</text>
            <shortcut>ctrl + shift + o</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,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" />
            <specializationType>Perform Invocation Target End</specializationType>
            <specializationTypeId>093e5909-ffe4-4510-b3ea-532f30212f3c</specializationTypeId>
            <defaultName>NewPerformInvocation</defaultName>
            <allowMultiple>true</allowMultiple>
          </option>
          <option type="association">
            <text>Create Entity</text>
            <shortcut>ctrl + shift + c</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAFFFJREFUeF7tnHt01dWVx7/fcwNC1UJ1WkrbUdC2alVIIAF5KAm17cysOmLHaleVmogGQR73CgQIj9ybF5AAN1FQQBEUp452pjJOZ7mmnZpQeRgDJoz4mmkRtGp9JhGQV3L2rHN+v5vcJDfJ7+ZeKK7F+Scrye+cs8/nt885++y9z484WxIiwIRqn62MswATVIKzAL/oAJ/Y9y8ZirxMgG+TuFSLXEzwQgBfATEYAoB4H4IGQj7R4EECfwTkj1DqjduuuGVPggwSqn7aNdACU7hZBONAjBRBPxopHFCdfooA3f0fwFEBdkNkO5TvyduvuOWVhIjEWfm0AHz61acvOI6WOwnJFuDKiIwRXtG/uxSPkGwCeNT5n/QXkQEAzxVL2imx6gvkZZIbj6ujW6ZcPuVQnDzifvyUAtzy2pbBEDUXwD0AvtRROlJ9BuH7BPoAGATyXG8jkCMAPgTkpIYMhsj5Mep9BmDNcfRZddeVt3zqrd34nzplAB/f98QKQPI6zkyC/ydQJxSNJhJGoxhr7rpz2uv/Bfo1CPpp6Es6rATHAJTecdXkovjx9Fwj6QAfe/WxURA+BuDySPcCOa7g20PFqyD4sjP52v7r/r6NkEYB6p35yXq0sLH1MaUz3b8PgWAIgAnu9O64eH4mgjcFLRkdhr9btfD2ycMnv9kzFu9PJBXg5n2PF0H04tbViYQCdwPqu4ABF11krxBblUb15KsnV3sXue3JLa9sydRAJslJAIa3a4PyGQQHtLQMi5ZHNObkDLtjdW/6i1UnKQA3vb5pCJr5JIlrxN02CfU2ya9A0LY+EU0ANmvVXJFzRc6BZA3CtGNkUDrFDyAbggFWie2mLoc1cASiB5nd3MhH8rfH+/S9beplP/84URkSBvjovkd/BMHTdmq6rSmo/QAvcUYgEPIgwAqcbNmck5bTNi0TlT5G/U11mwaijy8bED+Bi03/Lsq3NfVF0JFf5QMqdUPOVTm1iYiREMBNrzxypxZuIOEzYirhASp1gZjp6tpvIhJCMypONbiOECzIFBiNLLCGpMPxkNYtn5MY5GI9JoKfTBk25bneQuw1wIf3PryIRHGkY4L7SHVVlCDb2MzsnLTkTtV4B7qpbtMQSZHNbZuOncZvCvRlrbIL7pgy/O7H4207skzEXe+RVzbMhqAiUlHR94YAl0cZtqEpV08Jxt3wKayw8ZWNQQIFkQmtRd4G9EXOzg6tgRtzr879TbwixK2BD9evyxHi0S40rwnQ2XcNm7o1XkFOx/OP/M8jkyB6M0i7yQDYr6XlkraxyPfvHj7t+XhkiQvg+r3rRwC6hkCK6UQp3+sicoUxhEXQJCnIzL0y17HjztCyoW5DKn0wZtMAZ/Dyjhb9t64mfiYn1OVT06e+71V8zwBX71zd/9xzz6kXwXdJg0y9irZzbRO0ysxNO7PhRaAYiFDaQjR/09D7IXKJGZeI/O6e1Ht/mHSA6+vXPiDEDGsWkPsVlFV9AZqodWZu2r1ntOZ1BLKhbm0qlKoWVxM19ScQXGjGR4UZU4fNWOsFoicNfKjuAeN62u4Ca1RCBdKeLER01rS0mb06SXgR8FQ+s77uwUlCecadvoe01v1JSRHhUaL5e9PSAj0a+z0C3PTWpn7Hmg69LrDnTzN1XyFwtYVHCU0bPjOh3XZtfcWtBNd14Q7syk3oOrXknntT/U8lAnnd3gcqIJzt9r/fOCPc9qqmp86a2FPbPQJcW1dhzo0Bu2lQvSyCEe4Zadv0tFnOAT+BsqYu7CcY7k0TAgnMSAu0mlO9acPUeaju/noxZ2lDQ8tfhPJ1Z3/BXfeO8G/srt1uAa7fHR580oe3za4rwHFFdTziFKDooV5UvKdBOQDRCjCiiZF63f0uQJIAhocI1VvuEnUYos9z+3/3o8amIcGsYHNX4+gW4Jq6VWERexwyU/dlECPcTkIz0wIJTd2IQGvqyv0iqlcaSOrAjLR5CWugkeWBurA1tJ11HX8C9KXOMoWcWWlzzEkmZukSYLguPDBFWt4ToD+AZkKZM+SXATl4Eio1kBZIilPAAehO4Rg+ervpR0Tv8H/STOHkADTj7QMxlsTFAA6L0ULnCP3mzNQ5V5BsiyVEoewSYGVd2VwKy637B6wDmeasCxKYNTI5QpvmwnXlfiViNdAxyO2kDRnrDFDWSov8JFW2iFwcIeojkwbQauGe8qCQjhZCf0BwkOOek+tnj5j/+1gq2DXAPWWvg8arLKCoQ6D16zW1MGVIsrTPAVjqV5ISjg7HzR4xP6ZclS+XVQMyIeLp01SBQJI00JElPNAnzcZ0GQDI52LjOFbxtsweMf8XngGufnlFOkXXWo2AvEuobzoaIpWzRy6wa2KySri21E+lwpHYh/kZGLkwJsDwnmXG3pzgymV2zEAgIz8pa2BkPOE9yysIzna0UE4C0oeCY336H//qvVcGD3ccdxeClpYDNNE0M1v2AbRuKlEyNJC2sEfjMh64BiBUezOma4Cl1QDdWIg1OZIPsK4slVrXuQDfAWDPyRTc4k9f+CtPAFfvLjHRfrvj2pXJWUz33jcyPzUeOF6eDdcW+4XtAd6Xvijmi129p6QaEgkmmUEZgIuTqoFG5tV7SushGB4JAbjjWHdf+qJpPQIs31t+rq/5xCERMfXfBzjY3Y1Cc0YuSorpEi1EeW2x30eE7dZhYxbAnPTFXQIUkQmRzVgJTgnAVXtKWk0aJyRgFeiNOemLr+gZ4EuhG0g+6+penQBpFqAga17GEk9n3rKXlt7qUymDvGig1iaqhpuin52bsTQmwPLawmq2hjOtjfaMgnVN9VhadPMHeaMKPR37ymuLMglUmReqBR8R8lULsa8eNG948MPozjoJWr47tIRAoQOeb5Kwru+56bEHFUvylbtDDSIYGNGoeH/OyyjoAmDI2URcTY3nJ4DGuekFX+mRtPvAyt2FEdV7H5TBDg/5wbyM4H93C3BFbcGTBH7mauBhAcyxZlteRtDzubd8d7BBRAZ2zl6JNQE626d5GaGYAMtqg64ZE2mno+XddfskG+elBz0DNH052s6jAm0OE8YenZGXUdDOzdVJ0LLagr0AhrXZZWax5mPzRgWzvb698t1LrQbGTLfq1r/iAMnLKOwC4FKrgb1pl5TGeemF8QDcCsiNbWO2L/qBvIzCWd1r4EtLGgRm8NJEcIBd3IWh+aMLPW8gK2qXdNDAiKZ4+7lgVHFMgCteWlItUYZ0PCBJNM7PKPIMcEXN0iAoNgjlFHMiw2/mjyq+oVuAy19abFLK+oHyMYR/Y6sSoYUZxZ4BLq9d3ACrgU7H1gQXhBaO9t6GV22P9dyymsVB0nEMtM4konFBRrFngO3baO1l94JRxe1ybjq96dKafHGDLR+C/Jodv1JZCzOKPe12pqvS2kUN1DLQ3b0jR9fQwtGlnl9CYgDzTT8F0f2LYmN+RolngKU1CyeRfCY6SUyId/JHlTqhULe0AxisCqb0/dLxk+6IPwLwVZthoCRrYcbyOAAubICGBRhZ8kQYWnSaAJbU5AcJsQBbl1yiMT9jmWeAy2oXZIqwynV9m5yeASBO5I9adk63U7jkxfl2skPkU5AXmO1bhFlLxngHWFIz35nC0QOAAbj8tGhgSc2CIKQDQEjjotFlngEW7VqQqZRUmfEr4hMxASdCLxq9wtctwOIX84zn5TwIHA+MBajiBJjnbkRRGgiElowuOy0Ai2ryok4SzoGeQHwAa/ImEbBTmMQRAc4l0LRodJm7tjsYO62BRS/ONUHlr0PQDDoBdAhCS8as9Dz4opp5DbB2YFSJs41E1sCiXXODaN1EIi1J45JrVsWhgVFtuDlxAN5dcs3Kb3WrgUUvzv1fAN9x/WB2CTDrV0EcAAtr5jTQtQMdN1XbktsxZTfW/5desyqmGVNYM7ca9izctjZ4bV+IxqWjvQMM7ZobVK4ZExFGwNeWXrOyNUk+pgYW7gr8TsDrIwDdoT9WMCbs2ZAOvRhwzRhvdl9He65gTDgmwNCu+9o5VOOxA0FpLLgm7FkDQzsDW0G4hnTriee5gjHhf+hWA4O7AmsJTLfuROBzk11PYFvBmArPRzkHYPRRLj6QBWMqugAYSAAg4gO4y++cegjXHrb2bLhgTPi+bgEu3TVrpgLvdzI45C0RDDUVQmPvjzmoWGtV8MXZDaJ770wIja2M2Vdwl7/aurN640wQNAbHVnrWwIKdsxz3AXBQkRe7u3FuwZjKh7sFuGTnzAmKtDYfRf6kgUvNaEjJCo5Z48kWXLp99q1KcbCXjUDQMgFOkrhTpOuXFdw1q1qMQ7V1UZKthG+bl360lvcLx1d6cmcFd83I1ELrzhKByfW2xrPWHFU0rrJdSnCnNx2syu6nzznvkDjB9JMUMZdgjF86VDhujeed2MugzDOLdt7r94Em/tzqUC0atyamBi7dOcMCjGTs+iCB4Ni1SfdIL90xIyhthrgmqQQ4UjRmzfk2TBRVYgq6ZOeMVreRs4PbN1FfPO5BJ7SZxGIAqqjMBNN00VizDHcu0XJZjQACJacA4OId001MJNXe0WtT9/8sGvvgjztKFVPQxTvuKQBotU2ItyBi18EWhaHLx6xLalBp0fZcP+lrl5lQPO6hLuSa5rqz3NkuLYGS8RuSqoH5O6anEpGgEvYrc9vAWVvmFo9bt8oTwIV/mPo95eOrbvjwMCA2V0SAytJx65Ma1nQAmrBmm1FSMm5dbIA7pzmbiHvAAXWgZGyyAU41JoANawI4CdAsYdJHUr4VHL/mPU8AzUP523NrAaZbc0bkCGiPMo19T54cGszanJS0DrsGbs/1S+sUdtCUjt8QE2D+jtz2UTkzhZOogcGq7IHHU/q8BVpX3OeEcgLr5O9Lx62/Ptay0qVpsmB77gxFPOCkdsibGrjMfTiwbPwjSZs2edvv8qegfWCdZLAtoUNDQZk0XJPglA2RIZHAugKTCjD/hbuCmnADMnyX5DedPUBNLh23/om4AOZtv/N8BfWuuaplHYSiTVTeJNwcOH5Sp1UkSQsNQLuJdMywjEjbVealu4mUJell+quyB56TYlPcjPYdAZWZcUYBP+53QdM3g1f+6kRcAM3DC16YshzEfKcdfcC9JWlNmuXXPpoUk8YB6CQXxVs0GEgWwAUv3OmYLrbwPZLfcDfR+SvGbSzrSrZuTxdzd0z+mtK+dwD2tY2JNhed7aVoXwuHLs/anPCOnLc9249Ielu8BCmBsvGbE15OFlRlD2nxiU2wBOQo6bNROAKH+zf3HxzMerBTTkxE1B6PZ3kv5KwEZI7b+Ici8jXnzUj1ymu3ZMU75o7POwDbMlTjao9ICsB5L/yiDoJU18nzGalsAj1F5q+47rEutc+F3L3IgZ0/7Z/S3N/cCbG2oEAfFCcJ0STchFZOeCKhqTxve86t0HpdXOAiDyt1T/n4TZ6OZ121P2fb7RWgY7YQtKksrv1cX37t4z0eHHrUQNPwnG13XEdq58xJ0aLlqDFr3PXiplXXPXFGXu3q6aXM+cPtkwDnmoOAnyvQfteBJiNXMKxswpbXe2rDE0AH4m0mIj/dbfCQhnYuUgsaTcykIuuXX6iLNv6qn6dSoQpwPefC44q0ASMBFq+e8M8lPcHzNIUjjRgnwyHfiX0iuNT5kIt+T0TsTgWwUfQXB6IDr6UKoA07kPwUwgucq154+cvXfScj6JiiPRbPGmi18IWfj9RaXnKTls2ufFBgvjRk31ojRbIqsn51Rmuiv+qnqSCrTPaFM3h+RCqbfUXgmCheGb72l/t7JOc+EBdAUyew7WdTADwS6UCkxdxiiuTNNVKYU5H19Bm5JvqrbjFXuza5xrI52RwkaTdEC1DJDauvfSquO8NxAzQd+atvWShAaRvEdppojn7B+7N+HfL6Fk/HczOrbg4TYs7dtijyQ0BZk8xxOuG2isynn4xXll4BNJ3Mrr65BGB+K0ToP4tIa8hPwPoUtNxUkbU1YWM73kFFP++vmjSkGb5nCGlLT6ZqUGCUe5+5lZlPt3PVe+2z1wBNBzOr/2kaBMb76dxCoW7QWvqQOC/iYdZAsC9QWZG1NWkeHC+D81dNGtgMzBaBSTRyMnUFnyulFMF+jibyGAU/u3/iv/67lzZjPZMQQNPgrOqf3CSCXzvyOIKK6P2gOI5IxxlwQCCb+0KdcpAG3AlgtvnQGcwNU9cZQeGfqdS3Wh3yxEdK84bKif9W01t47pATqe7Unfb8P17mg3oKxPC22IYc0JQLoeX8tq+OGJsRm0X5KtcleWpPr5qUKrrlDhIG3MDWS4oiRwjfMZAXtkbzgN/6tP5F5fXPfpDo6BPWwGgBZjx/42pzgzL6cpvWLXVQ+HaML6zVm08/UVj90MT/8BRZ6zjYac/fMEFETJK6ieq1v4JBHqbgz4S6vC2RwUwRPWftxGfPrE8/tYNY9eNMLWoLAHdDcXRBS8t+wN7D7fQZPHcfrBZKI92PjwlRryB23dTgQJrDvrMipJIcCJEuAv38hGALGdlhW3VxtwC3PzTx2TP342MRkNOrfnoe5NhKAFM7+0PlI6H+WLR0unORyHQi+QaEF5HKZFJE+WfFfP6u8KGJv1mWSPtd1U3qFO7YSe7vfnyR8ul8CKfGFkDMrv0XEueI6K+D+FJ3F6wjexJA89GwIwpsBvkNgm4WfXQv0gTh/Sebmys2/t1/ffE+wBg9lNw//GgwT6i7oWi+rDa0vYa0TxHSxi9CHhIth0gcFoi2H8rRGECa6d/d5xptr3sA2XikueXxLT/6rXEAn9JySjUwluR3P//3EyhyIwTXgkhvF+dvjVe6Nb39foRArYjsINUv11//3GunlFiHxk87wI6Du/v3PxyrwMtE7GeQvy3O5nMBxH4GeRAEZg1rAPGpnbqCA6T5DDL+RM031v3gOXuz8q9V/uoA/1oDT1a/ZwEmSPIswLMAEySQYPX/B7HF0ckrQsvkAAAAAElFTkSuQmCC" />
            <specializationType>Create Entity Action Target End</specializationType>
            <specializationTypeId>328f54e5-7bad-4b5f-90ca-03ce3105d016</specializationTypeId>
            <defaultName>NewCreateEntityAction</defaultName>
            <allowMultiple>true</allowMultiple>
          </option>
          <option type="association">
            <text>Update Entity</text>
            <shortcut>ctrl + shift + u</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,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" />
            <specializationType>Update Entity Action Target End</specializationType>
            <specializationTypeId>516069f6-09cc-4de8-8e31-3c71ca823452</specializationTypeId>
            <defaultName>NewUpdateEntityAction</defaultName>
            <allowMultiple>true</allowMultiple>
          </option>
          <option type="association">
            <text>Delete Entity</text>
            <shortcut>ctrl + shift + d</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,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" />
            <specializationType>Delete Entity Action Target End</specializationType>
            <specializationTypeId>4a04cfc2-5841-438c-9c16-fb58b784b365</specializationTypeId>
            <defaultName>NewDeleteEntityAction</defaultName>
            <allowMultiple>true</allowMultiple>
          </option>
          <option type="element">
            <text>Add Processing Action</text>
            <shortcut>ctrl + shift + p</shortcut>
            <icon type="UrlImagePath" source="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAAehJREFUeF7t3L1NA0EQhuE55DrYJijAEiVQAh0QEVl3XRGQQwWk/qGQRYewRGCB5G93dr6ZcT723nOv5GS0k+QHEpig6RyWBAQjSMAEBAXA8WYFll15lI18HHfHN/BMVOMwYFnKg1R5FpG79cknmZbDfJipFIDDXg24nbebvexfROT+wu+/y408RajxasAVrcyl/vXyItTYFfAH13WNGoDfjl5rVAP0WqM2oLsahwB6qnEkoIsahwOy12gFkLZGU4CMNVoEpKrRLCBLjdYBzddIAWi5RiZAkzXSAVqrkRXQTI3UgBZq9AA4tEY3gKNq9AaoXqNLQM0aPQOq1OgesHeNUQC71RgKsEeNEQGb1hgWcFWstX6eltMtsFuEbaj+txuDHExjNgFB5QRMQFAAHM8CAcBW22IR/4Wb7iuGAmxV3e/wowA2rS4UYI/qogB2q849YO/qPAOqVOcSULM6b4Dq1bkBHFWdB8Ch1VEDWqiOFdBMdXSA1qpjAjRZHQWg5eqsA5qvziwgS3UWAamqMwXIWJ0VQNrqhgOyVzcS0EV1QwA9VacN6K46NUCv1bUEfM27s4D9knU0b28DAc/jeX9gI8hoXwPtxkTDuvS8CQhWkIAJCAqA41lgAoIC4HgWmICgADieBYKAX0uidGAd9hNhAAAAAElFTkSuQmCC" />
            <specializationType>Processing Action</specializationType>
            <specializationTypeId>405a2857-b911-431f-8142-719a0e9f15f3</specializationTypeId>
            <defaultName>Action</defaultName>
            <allowMultiple>true</allowMultiple>
          </option>
        </creationOptions>
        <scriptOptions />
        <mappingOptions />
        <typeReferenceExtension>
          <isRequired>true</isRequired>
          <targetTypes />
          <allowIsNavigable>inherit</allowIsNavigable>
          <allowIsNullable>inherit</allowIsNullable>
          <allowIsCollection>inherit</allowIsCollection>
        </typeReferenceExtension>
      </targetEndExtension>
      <macros />
    </associationExtension>
    <associationExtension type="Perform Invocation" typeId="3e69085c-fa2f-44bd-93eb-41075fd472f8">
      <sourceEndExtension>
        <typeOrder />
        <typeReferenceExtension>
          <isRequired>true</isRequired>
          <targetTypes />
          <allowIsNavigable>inherit</allowIsNavigable>
          <allowIsNullable>inherit</allowIsNullable>
          <allowIsCollection>inherit</allowIsCollection>
        </typeReferenceExtension>
      </sourceEndExtension>
      <targetEndExtension>
        <typeReferenceExtension>
          <isRequired>true</isRequired>
          <targetTypes>
            <type type="Operation" typeId="e042bb67-a1df-480c-9935-b26210f78591" />
          </targetTypes>
          <allowIsNavigable>inherit</allowIsNavigable>
          <allowIsNullable>inherit</allowIsNullable>
          <allowIsCollection>inherit</allowIsCollection>
        </typeReferenceExtension>
      </targetEndExtension>
      <macros />
    </associationExtension>
  </associationExtensions>
  <mappingSettings>
    <mappingSetting type="Create Entity Mapping" typeId="5f172141-fdba-426b-980e-163e782ff53e">
      <title>Create Entity Mapping</title>
      <isRequiredFunction>return true;</isRequiredFunction>
      <targetRootElementFunction>return element.getParent("Class")?.id ?? element.id;</targetRootElementFunction>
      <sourceMappings>
        <importSettings id="2b74b9ec-75bb-4eb2-8b3c-5b4fd755f019" name="Invocation Source Mappables" />
      </sourceMappings>
      <targetMappings>
        <importSettings id="d7aea784-eb96-472e-919d-a0e71315a0ed" name="Common Domain Mappables" />
        <mapping id="e04ab087-8c1a-42b9-aac7-d76ed674e319" name="Create Class" type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10" version="2.0.0">
          <isRequiredFunction>return element.id == mappingContext.targetElementId</isRequiredFunction>
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>function getAllChildrenInHierarchy(element, type) {
    let children = element.getChildren(type);
    element.getChildren("Generalization Target End").forEach(x =&gt; children.push(...getAllChildrenInHierarchy(x, type)))
    return children;
}

return element.id == mappingContext.targetElementId &amp;&amp; getAllChildrenInHierarchy(element, "Class Constructor").length == 0</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>invokable</represents>
          <childSettings>
            <childSetting id="53e8bc33-5930-4364-9526-7f8f181b14a1" name="Set Attribute" type="Attribute" typeId="0090fb93-483e-41af-a11d-5ad2dc796adf" version="2.0.0">
              <isRequiredFunction>let isPartOfAssociation = (element.getParent().specialization == "Association Target End" || element.getParent().specialization == "Association Source End");
let isPartOfAggregationSubEntity = (isPartOfAssociation 
    &amp;&amp; element.getParent().getOtherEnd().typeReference.getIsCollection() == false 
    &amp;&amp; element.getParent().getOtherEnd().typeReference.getIsNullable() == false);

return !element.typeReference.getIsNullable() &amp;&amp; !element.typeReference.getIsCollection()
    &amp;&amp; (element.getParent("Class").getIsMapped())
    &amp;&amp; !isPartOfAggregationSubEntity;</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>let fkAssociation = element.getStereotype("Foreign Key")?.getProperty("Association")?.getSelected();
let isFk = fkAssociation != null;
let isChildOfTargetClassOrCtor = element.getParent("Class").id == mappingContext.targetElementId || element.getParent("Class Constructor")?.id == mappingContext.targetElementId
let isAutoGeneratedPk = element.hasStereotype('Primary Key') &amp;&amp; element.getStereotype('Primary Key').getProperty('Data source')?.value !== "User supplied";

//let fkAssociation = element.getStereotype("Foreign Key")?.getProperty("Association")?.getSelected();  
return isChildOfTargetClassOrCtor
    &amp;&amp; !isAutoGeneratedPk
    // Entity Settings -&gt; Ensure Private Property Settings != true
    &amp;&amp; (application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")?.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")?.value != "true")
    // if is FK under root class, include if is for aggregational relationahip:
    &amp;&amp; (!isFk || element.getParent().specialization == "Class" || fkAssociation.getOtherEnd().typeReference.getIsCollection() || fkAssociation.getOtherEnd().typeReference.getIsNullable())
    &amp;&amp; (element.getMetadata("set-by-infrastructure") != "true");</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
            </childSetting>
            <childSetting id="a4a2572b-57d1-4782-8ace-dd22540211dc" name="Set Association Target End" type="Association Target End" typeId="0a66489f-30aa-417b-a75d-b945863366fd" version="2.0.0">
              <filterFunction>return element.typeReference.isNavigable 
    &amp;&amp; ((element.getOtherEnd().typeReference.getIsCollection() == false &amp;&amp; element.getOtherEnd().typeReference.getIsNullable() == false)
        || application.isModuleInstalled("Intent.EntityFrameworkCore"))</filterFunction>
              <isRequiredFunction>return !association.typeReference.getIsNullable() &amp;&amp; !association.typeReference.getIsCollection()
    &amp;&amp; !association.getOtherEnd().typeReference.getIsNullable() &amp;&amp; !association.getOtherEnd().typeReference.getIsCollection()
    &amp;&amp; association.getParent("Class").getIsMapped();</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>// Attribute is under mapped to Class or Constructor
let underClassOrCtor = element.getParent("Class").id == mappingContext.targetElementId || element.getParent("Class Constructor")?.id == mappingContext.targetElementId

return underClassOrCtor
    // Entity Settings -&gt; Ensure Private Property Settings != true
    &amp;&amp; (application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")?.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")?.value != "true")</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>e04ab087-8c1a-42b9-aac7-d76ed674e319</mappingId>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <useChildSettingsFrom>e04ab087-8c1a-42b9-aac7-d76ed674e319</useChildSettingsFrom>
              <represents>data</represents>
            </childSetting>
            <childSetting id="adb76398-4759-40ce-9b58-f98c1358f8e9" name="Set Association Source End" type="Association Source End" typeId="8d9d2e5b-bd55-4f36-9ae4-2b9e84fd4e58" version="2.0.0">
              <filterFunction>return element.typeReference.isNavigable &amp;&amp; application.isModuleInstalled("Intent.EntityFrameworkCore")</filterFunction>
              <isRequiredFunction>return false;</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>// anemic mapping
return element.getParent("Class")?.id == mappingContext.targetElementId</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>e04ab087-8c1a-42b9-aac7-d76ed674e319</mappingId>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <useChildSettingsFrom>e04ab087-8c1a-42b9-aac7-d76ed674e319</useChildSettingsFrom>
              <represents>data</represents>
            </childSetting>
            <childSetting id="1fba46e9-3cf7-4154-ad38-451c9696c413" name="Invoke Constructor" type="Class Constructor" typeId="dec2bd12-4699-4f45-8ec9-3b62dc692d2b" version="2.0.0">
              <isRequiredFunction>return element.id == mappingContext.targetElementId</isRequiredFunction>
              <allowMultipleMappings>false</allowMultipleMappings>
              <isMappableFunction>return element.id == mappingContext.targetElementId 
    || lookup(mappingContext.targetElementId).specialization != "Class Constructor" 
    || element.getParent("Class Constructor")?.getIsMapped();</isMappableFunction>
              <isTraversable>false</isTraversable>
              <traversableTypes />
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings>
                <childSetting id="8ec45776-c6cc-4174-84f8-efb5d4308ed4" name="Constructor Parameter" type="Parameter" typeId="c26d8d0a-a26b-4b5f-b449-e9bdb60b3a4b" version="2.0.0">
                  <isRequiredFunction>return (element.getValue() ?? "") == "";</isRequiredFunction>
                  <allowMultipleMappings>true</allowMultipleMappings>
                  <isMappableFunction>return element.getParent()?.getIsMapped() &amp;&amp; !element.typeReference.getType()?.hasTrait("20ce5b45-803a-4e2d-9f62-53b90f856529"); // [Injectable Service] trait</isMappableFunction>
                  <isTraversable>true</isTraversable>
                  <traversableTypes>
                    <mappingId>e04ab087-8c1a-42b9-aac7-d76ed674e319</mappingId>
                    <mappingId>15b84be5-c79b-41bf-881c-447fe70f5f5b</mappingId>
                    <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
                  </traversableTypes>
                  <canBeModified>false</canBeModified>
                  <represents>data</represents>
                </childSetting>
              </childSettings>
            </childSetting>
            <childSetting id="22a4b2cf-3791-42c3-846c-8ea4fd917289" name="Inheritance" type="Generalization Target End" typeId="4686cc1d-b4d8-4b99-b45b-f77bd5496946" version="2.0.0">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return false;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>e04ab087-8c1a-42b9-aac7-d76ed674e319</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
            </childSetting>
          </childSettings>
        </mapping>
      </targetMappings>
      <mappingTypes>
        <mappingType type="Invocation Mapping" typeId="47dc4a51-30a3-4ee8-8c7d-25a35bb965b9">
          <represents>invokable</represents>
          <sources>
            <source id="5a3018a8-38bc-450f-bf82-631e2d9475b3" name="Command" />
            <source id="8a986f57-e0bd-4b81-ac39-cbe0e5b44ac7" name="Service Operation" />
            <source id="5b5676ef-333f-4f52-859d-925ee8c43578" name="Domain Event Handler Association" />
          </sources>
          <sourceArrowFunction>return null</sourceArrowFunction>
          <targets>
            <target id="e04ab087-8c1a-42b9-aac7-d76ed674e319" name="Create Class" />
            <target id="1fba46e9-3cf7-4154-ad38-451c9696c413" name="Invoke Constructor" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
        <mappingType type="Data Mapping" typeId="50dccfb2-bd24-4135-adf6-ed31f28f8fe0">
          <represents>data</represents>
          <sources>
            <source id="98041049-0f91-4c21-99dc-50cd18fd1dae" name="Field" />
            <source id="7767267b-2e01-42cd-8a03-103d296a6306" name="Parameter" />
            <source id="daf3a2fa-0b35-4549-8b65-26b3a74dc7e0" name="Attribute" />
            <source id="c0682bc4-2b6a-4638-a35e-39188d253694" name="Association Target End" />
            <source id="cfe9c4d4-9c26-4f11-a585-f1e3863fb658" name="Invoke Domain Operation" />
            <source id="792374ff-6b97-45df-96de-01acd2488cc0" name="Property" />
            <source id="eb1478af-4b69-4d33-826f-3f195ebbed79" name="Collection Field" />
            <source id="ef61ebc7-f442-4b5f-bb5a-2ef68a1e4da8" name="Collection Parameter" />
          </sources>
          <sourceArrowFunction>return null</sourceArrowFunction>
          <targets>
            <target id="53e8bc33-5930-4364-9526-7f8f181b14a1" name="Set Attribute" />
            <target id="a4a2572b-57d1-4782-8ace-dd22540211dc" name="Set Association Target End" />
            <target id="8ec45776-c6cc-4174-84f8-efb5d4308ed4" name="Constructor Parameter" />
            <target id="e2ccdf82-ec44-4eb3-b32d-513ac3833d3b" name="Set Value Object Attribute" />
            <target id="82927c4e-1b48-4ab8-90ad-7c4d0b02067e" name="Set Data Contract Attribute" />
            <target id="adb76398-4759-40ce-9b58-f98c1358f8e9" name="Set Association Source End" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
      </mappingTypes>
    </mappingSetting>
    <mappingSetting type="Map Return Type" typeId="b7ae8bf5-f2fd-4a5c-b57e-05410687bfc4">
      <title>Map Return Type</title>
      <sourceMappings>
        <importSettings id="2b74b9ec-75bb-4eb2-8b3c-5b4fd755f019" name="Invocation Source Mappables" />
      </sourceMappings>
      <targetMappings>
        <mapping id="7e501670-11af-47fa-bf05-b0da94c85225" name="Return DTO" type="DTO" typeId="fee0edca-4aa0-4f77-a524-6bbd84e78734" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>true</canBeModified>
          <createNameFunction>return element.getParent('DTO').getName() + element.getName() + 'Dto'</createNameFunction>
          <represents>data</represents>
          <childSettings>
            <childSetting id="ee4038a2-7109-4ae2-b667-983ef574070b" name="Return DTO-Field" type="DTO-Field" typeId="7baed1fd-469b-4980-8fd9-4cefb8331eb2" version="2.0.0">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>7e501670-11af-47fa-bf05-b0da94c85225</mappingId>
              </traversableTypes>
              <canBeModified>true</canBeModified>
              <represents>data</represents>
            </childSetting>
          </childSettings>
        </mapping>
        <mapping id="e2e407d6-4f3e-41bb-8ec2-12f110b620a5" name="Type-Defintion" type="Type-Definition" typeId="d4e577cd-ad05-4180-9a2e-fff4ddea0e1e" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>data</represents>
        </mapping>
      </targetMappings>
      <mappingTypes />
    </mappingSetting>
    <mappingSetting type="Process Action Mapping" typeId="01bc7593-a6a2-45aa-8497-b4b6a269ab68">
      <title>Process Action Mapping</title>
      <isRequiredFunction>return true;</isRequiredFunction>
      <sourceRootElementFunction>return element.getParent().id;</sourceRootElementFunction>
      <targetRootElementFunction>return element.getParent().id;
</targetRootElementFunction>
      <sourceMappings>
        <importSettings id="2b74b9ec-75bb-4eb2-8b3c-5b4fd755f019" name="Invocation Source Mappables" />
      </sourceMappings>
      <targetMappings>
        <importSettings id="93c752a0-161d-4ef5-9c88-09995f59c263" name="Application Target Mappables" />
      </targetMappings>
      <mappingTypes>
        <mappingType type="Invocation Mapping" typeId="19c5ccad-f41f-4613-bd0b-b8e2adba6245">
          <represents>invokable</represents>
          <sources>
            <source id="5a3018a8-38bc-450f-bf82-631e2d9475b3" name="Command" />
            <source id="8a986f57-e0bd-4b81-ac39-cbe0e5b44ac7" name="Service Operation" />
            <source id="eb1478af-4b69-4d33-826f-3f195ebbed79" name="Collection Field" />
            <source id="ef61ebc7-f442-4b5f-bb5a-2ef68a1e4da8" name="Collection Parameter" />
          </sources>
          <sourceArrowFunction>return null</sourceArrowFunction>
          <targets>
            <target id="091c6b4d-5cf7-4561-9d4c-b025905152e3" name="Invoke Class Operation" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
        <mappingType type="Data Mapping" typeId="ac40ddfb-4d32-495d-928e-ddb991434a87">
          <represents>data</represents>
          <sources>
            <source id="98041049-0f91-4c21-99dc-50cd18fd1dae" name="Field" />
            <source id="7767267b-2e01-42cd-8a03-103d296a6306" name="Parameter" />
            <source id="eb1478af-4b69-4d33-826f-3f195ebbed79" name="Collection Field" />
            <source id="ef61ebc7-f442-4b5f-bb5a-2ef68a1e4da8" name="Collection Parameter" />
            <source id="daf3a2fa-0b35-4549-8b65-26b3a74dc7e0" name="Attribute" />
            <source id="cfe9c4d4-9c26-4f11-a585-f1e3863fb658" name="Invoke Domain Operation" />
          </sources>
          <sourceArrowFunction>return null</sourceArrowFunction>
          <targets>
            <target id="84e9dcc5-8765-48ef-b2a6-39744498a4af" name="Set Attribute" />
            <target id="e2ccdf82-ec44-4eb3-b32d-513ac3833d3b" name="Set Value Object Attribute" />
            <target id="82927c4e-1b48-4ab8-90ad-7c4d0b02067e" name="Set Data Contract Attribute" />
            <target id="8acf7530-30fd-49fc-b082-75e0060c249e" name="Set Association Target End" />
            <target id="95db9e8b-5db5-4a46-815c-53948a16fe7c" name="Set Operation Parameter" />
            <target id="49bfbdb3-9697-4d84-9194-df60ee7dfd9a" name="Set Association Source End" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
      </mappingTypes>
    </mappingSetting>
    <mappingSetting type="Query Entity Mapping" typeId="25f25af9-c38b-4053-9474-b0fabe9d7ea7">
      <title>Query Entity Mapping</title>
      <isRequiredFunction>return false;</isRequiredFunction>
      <targetRootElementFunction>return element.getParent("Class")?.id ?? element.id;</targetRootElementFunction>
      <sourceMappings>
        <importSettings id="2b74b9ec-75bb-4eb2-8b3c-5b4fd755f019" name="Invocation Source Mappables" />
      </sourceMappings>
      <targetMappings>
        <mapping id="0cd3919e-8d19-4b35-8c2b-dc8037efc3d5" name="Create Class" type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings>
            <childSetting id="a861cc4a-9aed-41f5-ad5d-fdc651497de4" name="Attribute" type="Attribute" typeId="0090fb93-483e-41af-a11d-5ad2dc796adf" version="2.0.0">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>c5a629db-c717-400b-9204-7cdb6acfa13e</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
            </childSetting>
            <childSetting id="4e6c69aa-dfdb-4f34-b9dd-80ad18cfe855" name="Association Target End" type="Association Target End" typeId="0a66489f-30aa-417b-a75d-b945863366fd" version="2.0.0">
              <filterFunction>return element.getOtherEnd().typeReference.getIsCollection() == false</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return false;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>0cd3919e-8d19-4b35-8c2b-dc8037efc3d5</mappingId>
                <mappingId>c5a629db-c717-400b-9204-7cdb6acfa13e</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <useChildSettingsFrom>0cd3919e-8d19-4b35-8c2b-dc8037efc3d5</useChildSettingsFrom>
              <represents>data</represents>
            </childSetting>
            <childSetting id="c15d409c-2707-419e-bb07-0c0df98b2aea" name="Inheritance" type="Generalization Target End" typeId="4686cc1d-b4d8-4b99-b45b-f77bd5496946" version="2.0.0">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return false;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>0cd3919e-8d19-4b35-8c2b-dc8037efc3d5</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
            </childSetting>
          </childSettings>
        </mapping>
        <mapping id="c5a629db-c717-400b-9204-7cdb6acfa13e" name="Create Value Object" type="Value Object" typeId="5fe6bb0a-7fc3-42ae-a351-d9188f5b8bc5" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <useChildSettingsFrom>0cd3919e-8d19-4b35-8c2b-dc8037efc3d5</useChildSettingsFrom>
          <represents>data</represents>
        </mapping>
      </targetMappings>
      <mappingTypes>
        <mappingType type="Filter Mapping" typeId="01d09a7f-0e7c-4670-b7bc-395d7e893ef2">
          <represents>data</represents>
          <sources>
            <source id="98041049-0f91-4c21-99dc-50cd18fd1dae" name="Field" />
            <source id="7767267b-2e01-42cd-8a03-103d296a6306" name="Parameter" />
            <source id="ef61ebc7-f442-4b5f-bb5a-2ef68a1e4da8" name="Collection Parameter" />
            <source id="daf3a2fa-0b35-4549-8b65-26b3a74dc7e0" name="Attribute" />
            <source id="c0682bc4-2b6a-4638-a35e-39188d253694" name="Association Target End" />
            <source id="cfe9c4d4-9c26-4f11-a585-f1e3863fb658" name="Invoke Domain Operation" />
            <source id="792374ff-6b97-45df-96de-01acd2488cc0" name="Property" />
            <source id="eb1478af-4b69-4d33-826f-3f195ebbed79" name="Collection Field" />
          </sources>
          <sourceArrowFunction>return null</sourceArrowFunction>
          <targets>
            <target id="a861cc4a-9aed-41f5-ad5d-fdc651497de4" name="Attribute" />
            <target id="4e6c69aa-dfdb-4f34-b9dd-80ad18cfe855" name="Association Target End" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <lineColor>lawngreen</lineColor>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
      </mappingTypes>
    </mappingSetting>
    <mappingSetting type="Update Entity Mapping" typeId="01721b1a-a85d-4320-a5cd-8bd39247196a">
      <title>Update Entity Mapping</title>
      <isRequiredFunction>return true;</isRequiredFunction>
      <targetRootElementFunction>return element.getParent("Class")?.id ?? element.id;</targetRootElementFunction>
      <sourceMappings>
        <importSettings id="2b74b9ec-75bb-4eb2-8b3c-5b4fd755f019" name="Invocation Source Mappables" />
      </sourceMappings>
      <targetMappings>
        <importSettings id="128a6e65-c165-400a-800d-71c7e67e7b01" name="Update Entity Mappables" />
      </targetMappings>
      <mappingTypes>
        <mappingType type="Invocation Mapping" typeId="d30bdba1-9c47-4917-b81d-29230fed5d6a">
          <represents>invokable</represents>
          <sources>
            <source id="5a3018a8-38bc-450f-bf82-631e2d9475b3" name="Command" />
            <source id="eb1478af-4b69-4d33-826f-3f195ebbed79" name="Collection Field" />
            <source id="8a986f57-e0bd-4b81-ac39-cbe0e5b44ac7" name="Service Operation" />
            <source id="ef61ebc7-f442-4b5f-bb5a-2ef68a1e4da8" name="Collection Parameter" />
            <source id="5b5676ef-333f-4f52-859d-925ee8c43578" name="Domain Event Handler Association" />
          </sources>
          <sourceArrowFunction>return null</sourceArrowFunction>
          <targets>
            <target id="091c6b4d-5cf7-4561-9d4c-b025905152e3" name="Invoke Class Operation" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
        <mappingType type="Data Mapping" typeId="ca88649b-f20b-44db-a9c0-017c26155ba8">
          <represents>data</represents>
          <sources>
            <source id="98041049-0f91-4c21-99dc-50cd18fd1dae" name="Field" />
            <source id="7767267b-2e01-42cd-8a03-103d296a6306" name="Parameter" />
            <source id="eb1478af-4b69-4d33-826f-3f195ebbed79" name="Collection Field" />
            <source id="ef61ebc7-f442-4b5f-bb5a-2ef68a1e4da8" name="Collection Parameter" />
            <source id="792374ff-6b97-45df-96de-01acd2488cc0" name="Property" />
            <source id="daf3a2fa-0b35-4549-8b65-26b3a74dc7e0" name="Attribute" />
            <source id="c0682bc4-2b6a-4638-a35e-39188d253694" name="Association Target End" />
            <source id="cfe9c4d4-9c26-4f11-a585-f1e3863fb658" name="Invoke Domain Operation" />
          </sources>
          <sourceArrowFunction>return null</sourceArrowFunction>
          <targets>
            <target id="84e9dcc5-8765-48ef-b2a6-39744498a4af" name="Set Attribute" />
            <target id="8acf7530-30fd-49fc-b082-75e0060c249e" name="Set Association Target End" />
            <target id="82927c4e-1b48-4ab8-90ad-7c4d0b02067e" name="Set Data Contract Attribute" />
            <target id="e2ccdf82-ec44-4eb3-b32d-513ac3833d3b" name="Set Value Object Attribute" />
            <target id="95db9e8b-5db5-4a46-815c-53948a16fe7c" name="Set Operation Parameter" />
            <target id="49bfbdb3-9697-4d84-9194-df60ee7dfd9a" name="Set Association Source End" />
          </targets>
          <targetArrowFunction>return `M ${x} ${y} l -10 5 l 0 -10 z`</targetArrowFunction>
          <allowAutoMap>true</allowAutoMap>
        </mappingType>
      </mappingTypes>
    </mappingSetting>
  </mappingSettings>
  <mappableElementPackages>
    <mappableElementPackage id="93c752a0-161d-4ef5-9c88-09995f59c263" name="Application Target Mappables">
      <imports>
        <import id="128a6e65-c165-400a-800d-71c7e67e7b01" name="Update Entity Mappables" />
      </imports>
      <mappableElementSettings>
        <mappableElement id="05cdd272-2140-4e9a-90ab-2395bfe28be0" name="Call Operation Action" type="Perform Invocation Target End" typeId="093e5909-ffe4-4510-b3ea-532f30212f3c" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <traversableTypes />
          <overrideTypeReferenceFunction>return {
    typeId: element.typeReference.getType().typeReference.getTypeId()
}</overrideTypeReferenceFunction>
          <canBeModified>false</canBeModified>
          <represents>invokable</represents>
        </mappableElement>
        <mappableElement id="0c6e161d-0f7d-41eb-997a-67279b5e7b18" name="Command" type="Command" typeId="ccf14eb6-3a55-4d81-b5b9-d27311c70cb9" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <useChildSettingsFrom>13b6c853-ef60-4dc9-8c6b-a0fe24fc80b8</useChildSettingsFrom>
          <represents>data</represents>
        </mappableElement>
        <mappableElement id="6dad8aff-d0f4-4630-9ca3-ae36943ef302" name="Create Entity Action" type="Create Entity Action Target End" typeId="328f54e5-7bad-4b5f-90ca-03ce3105d016" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <getTraversableTypeFunction>return element.typeReference.getType().getParent("Class")?.id ?? element.typeReference.getType().id;</getTraversableTypeFunction>
          <traversableTypes>
            <mappingId>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</mappingId>
          </traversableTypes>
          <overrideTypeReferenceFunction>return {
    typeId: element.typeReference.getType().getParent("Class")?.id ?? element.typeReference.getType().id,
    isCollection: false,
    isNullable: false
}</overrideTypeReferenceFunction>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
        </mappableElement>
        <mappableElement id="459be12d-ded5-40cb-9b5d-a57d2683375d" name="Delete Entity Action" type="Delete Entity Action Target End" typeId="4a04cfc2-5841-438c-9c16-fb58b784b365" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <traversableTypes>
            <mappingId>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</mappingId>
          </traversableTypes>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
        </mappableElement>
        <mappableElement id="13b6c853-ef60-4dc9-8c6b-a0fe24fc80b8" name="DTO" type="DTO" typeId="fee0edca-4aa0-4f77-a524-6bbd84e78734" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>true</canBeModified>
          <createNameFunction>return element.getParent('Command').getName() + element.getName() + 'Dto'</createNameFunction>
          <represents>data</represents>
          <childSettings>
            <childSetting id="643689ae-7903-447e-8ed3-1d492427b5ba" name="Field" type="DTO-Field" typeId="7baed1fd-469b-4980-8fd9-4cefb8331eb2" version="2.0.0">
              <filterFunction>return !element.typeReference.getIsCollection()</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>13b6c853-ef60-4dc9-8c6b-a0fe24fc80b8</mappingId>
              </traversableTypes>
              <canBeModified>true</canBeModified>
              <represents>data</represents>
            </childSetting>
            <childSetting id="9af8578c-b2fe-4f65-8014-6acfc258e6d5" name="Collection Field" type="DTO-Field" typeId="7baed1fd-469b-4980-8fd9-4cefb8331eb2" version="2.0.0">
              <filterFunction>return element.typeReference.getIsCollection()</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>13b6c853-ef60-4dc9-8c6b-a0fe24fc80b8</mappingId>
              </traversableTypes>
              <canBeModified>true</canBeModified>
              <represents>data</represents>
            </childSetting>
          </childSettings>
        </mappableElement>
        <mappableElement id="85f8d87f-3d9f-49a2-a882-eefae06a5e9a" name="Query Entity Action" type="Query Entity Action Target End" typeId="93ef6675-cba4-4998-adff-cb22d5343ed4" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <traversableTypes>
            <mappingId>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</mappingId>
          </traversableTypes>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
        </mappableElement>
        <mappableElement id="e65cd91b-d605-4341-9fdf-470a54c06d47" name="Service Operation" type="Operation" typeId="e030c97a-e066-40a7-8188-808c275df3cb" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>true</canBeModified>
          <represents>data</represents>
          <childSettings>
            <childSetting id="fffe6f4e-bcf6-4c7a-887e-6aca52d66806" name="Parameter" type="Parameter" typeId="00208d20-469d-41cb-8501-768fd5eb796b" version="2.0.0">
              <filterFunction>return !element.typeReference.getIsCollection()</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>13b6c853-ef60-4dc9-8c6b-a0fe24fc80b8</mappingId>
              </traversableTypes>
              <canBeModified>true</canBeModified>
              <represents>data</represents>
            </childSetting>
            <childSetting id="57def1e1-4cbe-497a-8f9c-c01f8bd14b7b" name="Collection Parameter" type="Parameter" typeId="00208d20-469d-41cb-8501-768fd5eb796b" version="2.0.0">
              <filterFunction>return element.typeReference.getIsCollection()</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>13b6c853-ef60-4dc9-8c6b-a0fe24fc80b8</mappingId>
              </traversableTypes>
              <canBeModified>true</canBeModified>
              <represents>data</represents>
            </childSetting>
          </childSettings>
        </mappableElement>
        <mappableElement id="95e12352-27ab-4d94-96a1-4d2cb0fb06be" name="Update Entity Action" type="Update Entity Action Target End" typeId="516069f6-09cc-4de8-8e31-3c71ca823452" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <traversableTypes>
            <mappingId>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</mappingId>
          </traversableTypes>
          <overrideTypeReferenceFunction>return {
    typeId: element.typeReference.getType().getParent("Class")?.id ?? element.typeReference.getType().id
}</overrideTypeReferenceFunction>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
        </mappableElement>
      </mappableElementSettings>
    </mappableElementPackage>
    <mappableElementPackage id="d7aea784-eb96-472e-919d-a0e71315a0ed" name="Common Domain Mappables">
      <imports />
      <mappableElementSettings>
        <mappableElement id="15b84be5-c79b-41bf-881c-447fe70f5f5b" name="Create Data Contract" type="Data Contract" typeId="4464fabe-c59e-4d90-81fc-c9245bdd1afd" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings>
            <childSetting id="82927c4e-1b48-4ab8-90ad-7c4d0b02067e" name="Set Data Contract Attribute" type="Attribute" typeId="0090fb93-483e-41af-a11d-5ad2dc796adf" version="2.0.0">
              <isRequiredFunction>return !element.typeReference.isNullable;</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
                <mappingId>15b84be5-c79b-41bf-881c-447fe70f5f5b</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
            </childSetting>
            <childSetting id="153c412a-5f90-48b1-9059-6ea19b76d70e" name="Inheritance" type="Data Contract Generalization Target End" typeId="4ea029c6-e963-46c7-8d2f-e4ea73e05a07" version="2.0.0">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return false;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>15b84be5-c79b-41bf-881c-447fe70f5f5b</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
            </childSetting>
          </childSettings>
        </mappableElement>
        <mappableElement id="32b2649c-7d86-42ba-807f-d9449ed15980" name="Create Value Object" type="Value Object" typeId="5fe6bb0a-7fc3-42ae-a351-d9188f5b8bc5" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings>
            <childSetting id="e2ccdf82-ec44-4eb3-b32d-513ac3833d3b" name="Set Value Object Attribute" type="Attribute" typeId="0090fb93-483e-41af-a11d-5ad2dc796adf" version="2.0.0">
              <isRequiredFunction>return true;</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
            </childSetting>
          </childSettings>
        </mappableElement>
      </mappableElementSettings>
    </mappableElementPackage>
    <mappableElementPackage id="128a6e65-c165-400a-800d-71c7e67e7b01" name="Update Entity Mappables">
      <imports>
        <import id="d7aea784-eb96-472e-919d-a0e71315a0ed" name="Common Domain Mappables" />
      </imports>
      <mappableElementSettings>
        <mappableElement id="72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8" name="Update Class" type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings>
            <childSetting id="84e9dcc5-8765-48ef-b2a6-39744498a4af" name="Set Attribute" type="Attribute" typeId="0090fb93-483e-41af-a11d-5ad2dc796adf" version="2.0.0">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>
let fkAssociation = element.getStereotype("Foreign Key")?.getProperty("Association")?.getSelected();
let isFk = fkAssociation != null;
let isAutoGeneratedPk = element.hasStereotype('Primary Key') &amp;&amp; element.getStereotype('Primary Key').getProperty('Data source')?.value !== "User supplied";
let isPartOfAssociation = (element.getParent().specialization == "Association Target End" || element.getParent().specialization == "Association Source End");


return (!isAutoGeneratedPk || isPartOfAssociation)
    // Entity Settings -&gt; Ensure Private Property Settings != true
    &amp;&amp; (application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")?.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")?.value != "true")
    // mapping association is not to an Operation:
    &amp;&amp; (lookup(mappingContext.targetElementId).specialization != "Operation")
    // if is FK under root class, include if is for aggregational relationahip:
    &amp;&amp; (!isFk || element.getParent().specialization == "Class" || fkAssociation.getOtherEnd().typeReference.getIsCollection() || fkAssociation.getOtherEnd().typeReference.getIsNullable())
    &amp;&amp; (element.getMetadata("set-by-infrastructure") != "true");</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
            </childSetting>
            <childSetting id="8acf7530-30fd-49fc-b082-75e0060c249e" name="Set Association Target End" type="Association Target End" typeId="0a66489f-30aa-417b-a75d-b945863366fd" version="2.0.0">
              <filterFunction>return element.typeReference.isNavigable 
    &amp;&amp; ((element.getOtherEnd().typeReference.getIsCollection() == false &amp;&amp; element.getOtherEnd().typeReference.getIsNullable() == false)
        || application.isModuleInstalled("Intent.EntityFrameworkCore"))</filterFunction>
              <isRequiredFunction>return false;</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>// anemic mapping
return element.getParent("Class")?.id == mappingContext.targetElementId</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</mappingId>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <useChildSettingsFrom>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</useChildSettingsFrom>
              <represents>data</represents>
            </childSetting>
            <childSetting id="49bfbdb3-9697-4d84-9194-df60ee7dfd9a" name="Set Association Source End" type="Association Source End" typeId="8d9d2e5b-bd55-4f36-9ae4-2b9e84fd4e58" version="2.0.0">
              <filterFunction>return element.typeReference.isNavigable &amp;&amp; application.isModuleInstalled("Intent.EntityFrameworkCore")</filterFunction>
              <isRequiredFunction>return false;</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>// anemic mapping
return element.getParent("Class")?.id == mappingContext.targetElementId</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</mappingId>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <useChildSettingsFrom>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</useChildSettingsFrom>
              <represents>data</represents>
            </childSetting>
            <childSetting id="091c6b4d-5cf7-4561-9d4c-b025905152e3" name="Invoke Class Operation" type="Operation" typeId="e042bb67-a1df-480c-9935-b26210f78591" version="2.0.0">
              <filterFunction>return !element.getIsStatic()</filterFunction>
              <isRequiredFunction>return element.id == mappingContext.targetElementId</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return element.id == mappingContext.targetElementId || lookup(mappingContext.targetElementId).specialization != "Operation"</isMappableFunction>
              <isTraversable>false</isTraversable>
              <traversableTypes />
              <canBeModified>false</canBeModified>
              <represents>data</represents>
              <childSettings>
                <childSetting id="95db9e8b-5db5-4a46-815c-53948a16fe7c" name="Set Operation Parameter" type="Parameter" typeId="c26d8d0a-a26b-4b5f-b449-e9bdb60b3a4b" version="2.0.0">
                  <isRequiredFunction>return true;</isRequiredFunction>
                  <allowMultipleMappings>true</allowMultipleMappings>
                  <isMappableFunction>return element.getParent()?.getIsMapped() &amp;&amp; !element.typeReference.getType()?.hasTrait("20ce5b45-803a-4e2d-9f62-53b90f856529"); // [Injectable Service] trait</isMappableFunction>
                  <isTraversable>true</isTraversable>
                  <traversableTypes>
                    <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
                    <mappingId>15b84be5-c79b-41bf-881c-447fe70f5f5b</mappingId>
                  </traversableTypes>
                  <canBeModified>false</canBeModified>
                  <represents>data</represents>
                </childSetting>
              </childSettings>
            </childSetting>
            <childSetting id="b705b26f-b317-4278-9458-0d2442d46182" name="Inheritance" type="Generalization Target End" typeId="4686cc1d-b4d8-4b99-b45b-f77bd5496946" version="2.0.0">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return false;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>72bbcbf9-96c1-483b-8ecd-ac7dd636fcc8</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
            </childSetting>
          </childSettings>
        </mappableElement>
      </mappableElementSettings>
    </mappableElementPackage>
  </mappableElementPackages>
  <mappableElementPackageExtensions>
    <mappableElementPackageExtension id="f7772228-e409-4998-92b7-d0ab6b7b338a" name="Application Source Action Extensions" extendPackageId="2b74b9ec-75bb-4eb2-8b3c-5b4fd755f019" extendPackage="Invocation Source Mappables">
      <mappableElementSettings>
        <mappableElement id="df404369-916e-4385-a29b-cbf86aa99846" name="Call Operation Action" type="Perform Invocation Target End" typeId="093e5909-ffe4-4510-b3ea-532f30212f3c" version="2.0.0">
          <filterFunction>return !isHost(element)</filterFunction>
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <getTraversableTypeFunction>return element.typeReference.getType().typeReference.getTypeId()</getTraversableTypeFunction>
          <traversableTypes />
          <overrideTypeReferenceFunction>return {
    typeId: element.typeReference.getType().typeReference.getTypeId()
}</overrideTypeReferenceFunction>
          <canBeModified>false</canBeModified>
          <represents>invokable</represents>
        </mappableElement>
        <mappableElement id="f11b799f-24a9-4a8c-ae3b-576c8571c771" name="Create Entity Action" type="Create Entity Action Target End" typeId="328f54e5-7bad-4b5f-90ca-03ce3105d016" version="2.0.0">
          <filterFunction>return !isHost(element)</filterFunction>
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return false;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <getTraversableTypeFunction>return element.typeReference.getType().getParent("Class")?.id ?? element.typeReference.getType().id;</getTraversableTypeFunction>
          <traversableTypes>
            <mappingId>5ef8e1c3-9626-4501-8968-6d9e432fb3b5</mappingId>
          </traversableTypes>
          <overrideTypeReferenceFunction>return {
    typeId: element.typeReference.getType().getParent("Class")?.id ?? element.typeReference.getType().id
}</overrideTypeReferenceFunction>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
        </mappableElement>
        <mappableElement id="a9b0bd2b-9b5a-45d5-992b-48430fc7579d" name="Delete Entity Action" type="Delete Entity Action Target End" typeId="4a04cfc2-5841-438c-9c16-fb58b784b365" version="2.0.0">
          <filterFunction>return !isHost(element)</filterFunction>
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <traversableTypes>
            <mappingId>5ef8e1c3-9626-4501-8968-6d9e432fb3b5</mappingId>
          </traversableTypes>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
        </mappableElement>
        <mappableElement id="049127ae-ee8f-40d0-bed8-a3c9a559d7e5" name="Query Entity Action" type="Query Entity Action Target End" typeId="93ef6675-cba4-4998-adff-cb22d5343ed4" version="2.0.0">
          <filterFunction>return !isHost(element)</filterFunction>
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <traversableTypes>
            <mappingId>5ef8e1c3-9626-4501-8968-6d9e432fb3b5</mappingId>
          </traversableTypes>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
        </mappableElement>
        <mappableElement id="f1c2f529-7818-4f89-a9b6-1b327e100470" name="Update Entity Action" type="Update Entity Action Target End" typeId="516069f6-09cc-4de8-8e31-3c71ca823452" version="2.0.0">
          <filterFunction>return !isHost(element)</filterFunction>
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <traversableTypes>
            <mappingId>5ef8e1c3-9626-4501-8968-6d9e432fb3b5</mappingId>
          </traversableTypes>
          <canBeModified>false</canBeModified>
          <represents>data</represents>
        </mappableElement>
      </mappableElementSettings>
    </mappableElementPackageExtension>
    <mappableElementPackageExtension id="b6d97897-19a6-475b-bd06-f51dd1a11bc6" name="Domain Event Mappable Extension" extendPackageId="93c752a0-161d-4ef5-9c88-09995f59c263" extendPackage="Application Target Mappables">
      <mappableElementSettings>
        <mappableElement id="0d7e67b8-f056-443d-906d-665c0da26895" name="Domain Event Handler Target" type="Domain Event Handler Association Target End" typeId="f45dfee9-f62b-45ac-bfce-a3878e04b73f" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>true</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>invokable</represents>
        </mappableElement>
      </mappableElementSettings>
    </mappableElementPackageExtension>
    <mappableElementPackageExtension id="dbfbbc5d-a427-41f3-961a-4eb2388582cf" name="Domain Interaction Invocation Target Extensions" extendPackageId="1b6bf8a4-7812-4f3c-8378-ef411edb59cf" extendPackage="Invocation Target Mappables">
      <imports>
        <import id="d7aea784-eb96-472e-919d-a0e71315a0ed" name="Common Domain Mappables" />
      </imports>
      <mappableElementSettings>
        <mappableElement id="842b0753-adfc-4215-a772-65f4a033aedd" name="Call Domain Service Operation" type="Operation" typeId="e042bb67-a1df-480c-9935-b26210f78591" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>data</represents>
          <childSettings>
            <childSetting id="bd766e67-6d4a-44d9-aadc-feef8882840f" name="Domain Service Operation Parameter" type="Parameter" typeId="c26d8d0a-a26b-4b5f-b449-e9bdb60b3a4b" version="2.0.0">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
                <mappingId>15b84be5-c79b-41bf-881c-447fe70f5f5b</mappingId>
                <mappingId>182b8204-5ba9-4bc8-b109-65545989e757</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
            </childSetting>
          </childSettings>
        </mappableElement>
        <mappableElement id="182b8204-5ba9-4bc8-b109-65545989e757" name="Create Class" type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10" version="2.0.0">
          <isRequiredFunction>return element.id == mappingContext.targetElementId</isRequiredFunction>
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>function getAllChildrenInHierarchy(element, type) {
    let children = element.getChildren(type);
    element.getChildren("Generalization Target End").forEach(x =&gt;
        children.push(...getAllChildrenInHierarchy(x, type))
    );
    return children;
}

return element.id == mappingContext.targetElementId &amp;&amp; 
       getAllChildrenInHierarchy(element, "Class Constructor").length == 0;
</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>invokable</represents>
          <childSettings>
            <childSetting id="0f3c0d59-6a6c-4d60-bef4-08afa9525acf" name="Set Attribute" type="Attribute" typeId="0090fb93-483e-41af-a11d-5ad2dc796adf" version="2.0.0">
              <isRequiredFunction>let isPartOfAssociation = (element.getParent().specialization == "Association Target End" || element.getParent().specialization == "Association Source End");
let isPartOfAggregationSubEntity = (isPartOfAssociation 
    &amp;&amp; element.getParent().getOtherEnd().typeReference.getIsCollection() == false 
    &amp;&amp; element.getParent().getOtherEnd().typeReference.getIsNullable() == false);

return !element.typeReference.getIsNullable() &amp;&amp; !element.typeReference.getIsCollection()
    &amp;&amp; (element.getParent("Class")?.getIsMapped())
    &amp;&amp; !isPartOfAggregationSubEntity;</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>let fkAssociation = element.getStereotype("Foreign Key")?.getProperty("Association")?.getSelected();
let isFk = fkAssociation != null;
let isChildOfTargetClassOrCtor = true;// = element.getParent("Class")?.id == mappingContext.targetElementId || element.getParent("Class Constructor")?.id == mappingContext.targetElementId
let isAutoGeneratedPk = element.hasStereotype('Primary Key') &amp;&amp; element.getStereotype('Primary Key').getProperty('Data source')?.value !== "User supplied";

//let fkAssociation = element.getStereotype("Foreign Key")?.getProperty("Association")?.getSelected();  
return isChildOfTargetClassOrCtor
    &amp;&amp; !isAutoGeneratedPk
    // Entity Settings -&gt; Ensure Private Property Settings != true
    &amp;&amp; (application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")?.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")?.value != "true")
    // if is FK under root class, include if is for aggregational relationahip:
    &amp;&amp; (!isFk || element.getParent().specialization == "Class" || fkAssociation.getOtherEnd().typeReference.getIsCollection() || fkAssociation.getOtherEnd().typeReference.getIsNullable())
    ;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
            </childSetting>
            <childSetting id="c509a64d-6271-492a-94d6-b318307f0cf4" name="Set Association Target End" type="Association Target End" typeId="0a66489f-30aa-417b-a75d-b945863366fd" version="2.0.0">
              <filterFunction>return element.typeReference.isNavigable 
    &amp;&amp; ((element.getOtherEnd().typeReference.getIsCollection() == false &amp;&amp; element.getOtherEnd().typeReference.getIsNullable() == false)
        || application.isModuleInstalled("Intent.EntityFrameworkCore"))</filterFunction>
              <isRequiredFunction>return !association.typeReference.getIsNullable() &amp;&amp; !association.typeReference.getIsCollection()
    &amp;&amp; !association.getOtherEnd().typeReference.getIsNullable() &amp;&amp; !association.getOtherEnd().typeReference.getIsCollection()
    &amp;&amp; association.getParent("Class").getIsMapped();</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>const DomainSettings = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
const EnsurePrivatePropertySettings = "0cf704e1-9a61-499a-bb91-b20717e334f5";
const hasPrivateSettersEnabled = application.getSettings(DomainSettings)?.getField(EnsurePrivatePropertySettings)?.value == "true";

return !hasPrivateSettersEnabled;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>182b8204-5ba9-4bc8-b109-65545989e757</mappingId>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
                <mappingId>15b84be5-c79b-41bf-881c-447fe70f5f5b</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <useChildSettingsFrom>182b8204-5ba9-4bc8-b109-65545989e757</useChildSettingsFrom>
              <represents>data</represents>
            </childSetting>
            <childSetting id="1f0bc2d1-41e4-4738-9de8-d499bba3bb9a" name="Set Association Source End" type="Association Source End" typeId="8d9d2e5b-bd55-4f36-9ae4-2b9e84fd4e58" version="2.0.0">
              <filterFunction>return element.typeReference.isNavigable &amp;&amp; application.isModuleInstalled("Intent.EntityFrameworkCore")</filterFunction>
              <isRequiredFunction>return false;</isRequiredFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>// anemic mapping
return element.getParent("Class")?.id == mappingContext.targetElementId</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>182b8204-5ba9-4bc8-b109-65545989e757</mappingId>
                <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <useChildSettingsFrom>182b8204-5ba9-4bc8-b109-65545989e757</useChildSettingsFrom>
              <represents>data</represents>
            </childSetting>
            <childSetting id="00294673-7016-42a2-a9d9-b41d0e6271eb" name="Invoke Constructor" type="Class Constructor" typeId="dec2bd12-4699-4f45-8ec9-3b62dc692d2b" version="2.0.0">
              <isRequiredFunction>return element.id == mappingContext.targetElementId</isRequiredFunction>
              <allowMultipleMappings>false</allowMultipleMappings>
              <isMappableFunction>return element.id == mappingContext.targetElementId || lookup(mappingContext.targetElementId).specialization != "Class Constructor"</isMappableFunction>
              <isTraversable>false</isTraversable>
              <traversableTypes />
              <canBeModified>false</canBeModified>
              <represents>invokable</represents>
              <childSettings>
                <childSetting id="1971bf3d-ced6-4587-8db4-1c7f2eeca169" name="Constructor Parameter" type="Parameter" typeId="c26d8d0a-a26b-4b5f-b449-e9bdb60b3a4b" version="2.0.0">
                  <isRequiredFunction>return true;</isRequiredFunction>
                  <allowMultipleMappings>true</allowMultipleMappings>
                  <isMappableFunction>return element.getParent()?.getIsMapped();</isMappableFunction>
                  <isTraversable>true</isTraversable>
                  <traversableTypes>
                    <mappingId>182b8204-5ba9-4bc8-b109-65545989e757</mappingId>
                    <mappingId>15b84be5-c79b-41bf-881c-447fe70f5f5b</mappingId>
                    <mappingId>32b2649c-7d86-42ba-807f-d9449ed15980</mappingId>
                  </traversableTypes>
                  <canBeModified>false</canBeModified>
                  <represents>data</represents>
                </childSetting>
              </childSettings>
            </childSetting>
            <childSetting id="f0a076a1-1b31-430f-ab7b-ae3e6f467f6d" name="Inheritance" type="Generalization Target End" typeId="4686cc1d-b4d8-4b99-b45b-f77bd5496946" version="2.0.0">
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return false;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>182b8204-5ba9-4bc8-b109-65545989e757</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
            </childSetting>
          </childSettings>
        </mappableElement>
        <mappableElement id="809a0d2b-fbb6-4f09-9302-5d13a19d1607" name="Stored Procedure" type="Stored Procedure" typeId="575edd35-9438-406d-b0a7-b99d6f29b560" version="2.0.0">
          <allowMultipleMappings>true</allowMultipleMappings>
          <isMappableFunction>return true;</isMappableFunction>
          <isTraversable>false</isTraversable>
          <traversableTypes />
          <canBeModified>false</canBeModified>
          <represents>invokable</represents>
          <childSettings>
            <childSetting id="dba64983-a232-4042-89f6-fe70e966fa32" name="Stored Procedure Parameter" type="Stored Procedure Parameter" typeId="5823b192-eb03-47c8-90d8-5501c922e9a5" version="2.0.0">
              <filterFunction>return !element.typeReference.getIsCollection()</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>false</isTraversable>
              <traversableTypes />
              <canBeModified>false</canBeModified>
              <represents>data</represents>
            </childSetting>
            <childSetting id="5cf85beb-5228-4f1a-969c-bc72b0c14a0c" name="Collection Stored Procedure Parameter" type="Stored Procedure Parameter" typeId="5823b192-eb03-47c8-90d8-5501c922e9a5" version="2.0.0">
              <filterFunction>return element.typeReference.getIsCollection()</filterFunction>
              <allowMultipleMappings>true</allowMultipleMappings>
              <isMappableFunction>return true;</isMappableFunction>
              <isTraversable>true</isTraversable>
              <traversableTypes>
                <mappingId>15b84be5-c79b-41bf-881c-447fe70f5f5b</mappingId>
              </traversableTypes>
              <canBeModified>false</canBeModified>
              <represents>data</represents>
            </childSetting>
          </childSettings>
        </mappableElement>
      </mappableElementSettings>
    </mappableElementPackageExtension>
  </mappableElementPackageExtensions>
  <suggestionSettings>
    <suggestionSetting type="Operation" typeId="e042bb67-a1df-480c-9935-b26210f78591" locations="diagram, model">
      <name>Create CQRS Operation</name>
      <filterFunction>const callServiceOperationTargetEnd = "093e5909-ffe4-4510-b3ea-532f30212f3c";
let notMapped = lookupTypesOf(callServiceOperationTargetEnd).every(x =&gt; x.typeReference.getTypeId() != element.id)

return application.isModuleInstalled("Intent.Modelers.Services.CQRS") &amp;&amp;
    application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "advanced"
    &amp;&amp; element.getParent() &amp;&amp; element.getParent().specializationId == "96ffceb2-a70a-4b69-869b-0df436c470c3" // is a Repository
    &amp;&amp; notMapped; // not already mapped</filterFunction>
      <dependencies />
      <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getPackageSelectItemOptions(packages, packageTypeName) {
    return {
        items: packages,
        getId(item) {
            return item.id;
        },
        getDisplayName(item) {
            return item.getName();
        },
        getItemNotFoundMessage(itemId) {
            return `No ${packageTypeName} found with id "${itemId}".`;
        },
        getNoItemsFoundMessage() {
            return `No packages of type ${packageTypeName} could be found.`;
        },
    };
}
function getElementSelectItemOptions(elements, elementTypeName, relevantPackageTypeName) {
    return {
        items: elements,
        getId(item) {
            return item.id;
        },
        getDisplayName(item) {
            return item.getName();
        },
        getItemNotFoundMessage(itemId) {
            return `No "${elementTypeName}" found with id "${itemId}".`;
        },
        getNoItemsFoundMessage() {
            return `No Elements of type "${elementTypeName}" could be found. Please ensure that you have a reference to the ${relevantPackageTypeName} package and that at least one ${elementTypeName} exists in it.`;
        },
    };
}
/**
 * Dialog selection.
 * @param options For simplicity, use getPackageSelectItemOptions() or getElementSelectItemOptions()
 * @returns Selected item.
 */
async function openSelectItemDialog(options) {
    if (!options) {
        throw new Error("Options are required for 'openSelectItemDialog'.");
    }
    let items = options.items;
    if (items.length == 0) {
        await dialogService.info(options.getNoItemsFoundMessage());
        return null;
    }
    let itemId = await dialogService.lookupFromOptions(items.map(item =&gt; ({
        id: options.getId(item),
        name: options.getDisplayName(item)
    })));
    if (itemId == null) {
        await dialogService.error(options.getItemNotFoundMessage(itemId));
        return null;
    }
    let foundItem = items.filter(item =&gt; options.getId(item) === itemId)[0];
    return foundItem;
}
;
/// &lt;reference path="attributeWithMapPath.ts" /&gt;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
ServicesConstants.dtoToDomainOperation = "8d1f6a8a-77c8-43a2-8e60-421559725419";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if ((key.mapPath ?? []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
/**
 * Helper class to build up source and target mapping paths for
 * advanced mapping scenarios.
 *
 * @remarks
 *
 * Source Path and Target Path is maintained separately since not all mapping scenarios are
 * straightforward.
 *
 * @example
 *
 * When to Push/Pop the Paths
 *
    let leftField = createField(...);

    mappingStore.pushSourcePath(leftField.id);
    mappingStore.pushTargetPath(rightField.id);

    let leftFieldDto = replicateDto(rightField.typeReference.getType(), folder, mappingStore);

    mappingStore.popSourcePath();
    mappingStore.popTargetPath();

    leftField.typeReference.setType(leftFieldDto.id);
 *
 * Adding mappings
 *
    function replicateDto(existingDto: MacroApi.Context.IElementApi, ...) {
        let newDto = createElement("DTO", existingDto.getName(), folder.id);
        existingDto.getChildren("DTO-Field").forEach(existingField =&gt; {
            let newField = createElement("DTO-Field", existingField.getName(), newDto.id);
            // ...
            mappingStore.addMapping(newField.id, existingField.id);
            // ...
        }
    }
 */
class MappingStore {
    constructor() {
        this.mappings = [];
        this.sourcePath = [];
        this.targetPath = [];
    }
    /**
     * Get all the recorded mapping entries
     */
    getMappings() {
        return this.mappings;
    }
    /**
     * Keep track of this element id on the source end
     * when navigating inside it's type hierarchy.
     */
    pushSourcePath(id) {
        this.sourcePath.push(id);
    }
    /**
     * Remove the last tracked element on the source path stack
     * when done navigating down its type hierarchy.
     */
    popSourcePath() {
        this.sourcePath.pop();
    }
    /**
     * Keep track of this element id on the target end
     * when navigating inside it's type hierarchy.
     */
    pushTargetPath(id) {
        this.targetPath.push(id);
    }
    /**
     * Remove the last tracked element on the target path stack
     * when done navigating down its type hierarchy.
     */
    popTargetPath() {
        this.targetPath.pop();
    }
    /**
     * Record a mapping between a source element id and target element id.
     * Target and Source path stack will be used to build up the whole path.
     */
    addMapping(sourceId, targetId) {
        this.mappings.push({
            sourcePath: this.sourcePath.concat([sourceId]),
            targetPath: this.targetPath.concat([targetId])
        });
    }
}
class ElementManager {
    constructor(innerElement, settings) {
        this.innerElement = innerElement;
        this.settings = settings;
        this.mappedElement = innerElement.getMapping()?.getElement();
    }
    get id() { return this.innerElement.id; }
    ;
    setReturnType(typeId, isCollection, isNullable) {
        this.innerElement.typeReference.setType(typeId);
        if (isCollection != null) {
            this.innerElement.typeReference.setIsCollection(isCollection);
        }
        if (isNullable != null) {
            this.innerElement.typeReference.setIsNullable(isNullable);
        }
        return this;
    }
    addChild(name, type) {
        let existingField = this.innerElement.getChildren(this.settings.childSpecialization)
            .find(c =&gt; c.getName().toLowerCase() == ServicesHelper.formatName(name, this.settings.childType ?? "property").toLowerCase());
        let field = existingField ?? createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, this.settings.childType ?? "property"), this.innerElement.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {
                    return;
                }
            }
            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options?.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.innerElement.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.innerElement;
    }
    collapse() {
        this.innerElement.collapse();
    }
}
/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")?.getField("Key Type")?.value ?? "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return element?.specialization === "Data Contract" ||
            element?.specialization === "Value Object" ||
            element?.specialization === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]?.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = attr.getStereotype("Foreign Key").getProperty("Association")?.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    /**
     * Returns true if the attribute is a foreign key on a compositional one-to-many relationship (i.e. is managed by the DB and should not be set).
     * @param attribute
     * @returns
     */
    static isManagedForeignKey(attribute) {
        let fkAssociation = attribute.getStereotype("Foreign Key")?.getProperty("Association")?.getSelected();
        return fkAssociation != null &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsCollection() &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsNullable();
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp;
            !DomainHelper.legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || x.getMetadata("set-by-infrastructure")?.toLocaleLowerCase() != "true")));
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return application.getSettings(domainSettingsId)
            ?.getField("Attribute Naming Convention")?.value ?? "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="../../common/attributeWithMapPath.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto) {
    let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
    childrenToAdd.forEach(e =&gt; {
        if (e.mapPath != null) {
            if (dto.getChildren("Parameter").some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {
                return;
            }
        }
        else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
            return;
        }
        let field = createElement("DTO-Field", e.name, dto.id);
        field.typeReference.setType(e.typeId);
        field.typeReference.setIsCollection(e.isCollection);
        field.typeReference.setIsNullable(e.isNullable);
        if (this.mappedElement != null &amp;&amp; e.mapPath) {
            field.setMapping(e.mapPath);
        }
    });
    dto.collapse();
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = dto.getMetadata("originalVerb")?.toLowerCase()?.startsWith("create") == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", toPascalCase(entry.name), dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp;
        !legacyPartitionKey(x) &amp;&amp;
        (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || x.getMetadata("set-by-infrastructure")?.toLocaleLowerCase() != "true")));
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return application.getSettings(domainSettingsId)
        ?.getField("Attribute Naming Convention")?.value ?? "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
class CrudConstants {
}
CrudConstants.mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
CrudConstants.mapToDomainConstructorForDtosSettingId = "8d1f6a8a-77c8-43a2-8e60-421559725419";
CrudConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class CrudHelper {
    // Super basic selection dialog.
    static async openBasicSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; CrudHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: getFriendlyDisplayNameForClassSelection(x),
            additionalInfo: `(${x.getParents().map(item =&gt; item.getName()).join("/")})`
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
        function getFriendlyDisplayNameForClassSelection(element) {
            let aggregateEntity = DomainHelper.getOwningAggregate(element);
            return !aggregateEntity ? element.getName() : `${element.getName()} (${aggregateEntity.getName()})`;
        }
    }
    static async openCrudCreationDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; CrudHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let dialogResult = await dialogService.openForm({
            title: "CRUD Creation Options",
            fields: [
                {
                    id: "entityId",
                    fieldType: "select",
                    label: "Entity for CRUD operations",
                    selectOptions: classes.map(x =&gt; {
                        return {
                            id: x.id,
                            description: x.getName(),
                            additionalInfo: getClassAdditionalInfo(x)
                        };
                    }),
                    isRequired: true
                },
                {
                    id: "create",
                    fieldType: "checkbox",
                    label: "Create",
                    value: "true",
                    hint: "Generate the \"Create\" operation"
                },
                {
                    id: "update",
                    fieldType: "checkbox",
                    label: "Update",
                    value: "true",
                    hint: "Generate the \"Update\" operation"
                },
                {
                    id: "queryById",
                    fieldType: "checkbox",
                    label: "Query By Id",
                    value: "true",
                    hint: "Generate the \"Query By Id\" operation"
                },
                {
                    id: "queryAll",
                    fieldType: "checkbox",
                    label: "Query All",
                    value: "true",
                    hint: "Generate the \"Query All\" operation"
                },
                {
                    id: "delete",
                    fieldType: "checkbox",
                    label: "Delete",
                    value: "true",
                    hint: "Generate the \"Delete\" operation"
                },
                {
                    id: "domain",
                    fieldType: "checkbox",
                    label: "Domain Operations",
                    value: "true",
                    hint: "Generate operations for Domain Entity operations"
                }
            ]
        });
        let foundEntity = lookup(dialogResult.entityId);
        var result = {
            selectedEntity: foundEntity,
            canCreate: dialogResult.create == "true",
            canUpdate: dialogResult.update == "true",
            canQueryById: dialogResult.queryById == "true",
            canQueryAll: dialogResult.queryAll == "true",
            canDelete: dialogResult.delete == "true",
            canDomain: dialogResult.domain == "true",
            selectedDomainOperationIds: []
        };
        if (result.canDomain &amp;&amp; foundEntity.getChildren("Operation").length &gt; 0) {
            dialogResult = await dialogService.openForm({
                title: "Select Domain Operations",
                fields: [
                    {
                        id: "tree",
                        fieldType: "tree-view",
                        label: "Domain Operations",
                        hint: "Generate operations from selected domain entity operations",
                        treeViewOptions: {
                            rootId: foundEntity.id,
                            submitFormTriggers: ["double-click", "enter"],
                            isMultiSelect: true,
                            selectableTypes: [
                                {
                                    specializationId: "Class",
                                    autoExpand: true,
                                    autoSelectChildren: false,
                                    isSelectable: (x) =&gt; false
                                },
                                {
                                    specializationId: "Operation",
                                    isSelectable: (x) =&gt; true
                                }
                            ]
                        }
                    }
                ]
            });
            result.selectedDomainOperationIds = dialogResult.tree?.filter((x) =&gt; x != "0") ?? [];
        }
        return result;
        function getClassAdditionalInfo(element) {
            let aggregateEntity = DomainHelper.getOwningAggregate(element);
            let prefix = aggregateEntity ? `: ${aggregateEntity.getName()}  ` : "";
            return `${prefix}(${element.getParents().map(item =&gt; item.getName()).join("/")})`;
        }
    }
    static filterClassSelection(element, options) {
        if (!(options?.allowAbstract ?? false) &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if (options?.includeOwnedRelationships != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return CrudHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false, allowAbstract: true });
        }
        return false;
    }
    static getName(command, mappedElement, dtoPrefix = null) {
        if (mappedElement.typeReference != null)
            mappedElement = mappedElement.typeReference.getType();
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        if (dtoPrefix)
            dtoName = `${dtoPrefix}${dtoName}`;
        return dtoName;
    }
    static getOrCreateCrudDto(dtoName, mappedElement, autoAddPrimaryKey, mappingTypeSettingId, folder, inbound = false) {
        let dto = CrudHelper.getOrCreateDto(dtoName, folder);
        //dtoField.typeReference.setType(dto.id);
        const entityCtor = mappedElement
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (inbound &amp;&amp; entityCtor != null) {
            dto.setMapping([mappedElement.id, entityCtor.id], CrudConstants.mapToDomainConstructorForDtosSettingId);
            CrudHelper.addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto, folder);
        }
        else {
            dto.setMapping(mappedElement.id, mappingTypeSettingId);
            CrudHelper.addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder);
        }
        return dto;
    }
    static getOrCreateDto(elementName, parentElement) {
        const expectedDtoName = elementName.replace(/Dto$/, "") + "Dto";
        let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
        if (existingDto) {
            return existingDto;
        }
        let dto = createElement("DTO", expectedDtoName, parentElement.id);
        return dto;
    }
    static addDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto, folder) {
        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        childrenToAdd.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (dto.getChildren("Parameter").some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {
                    return;
                }
            }
            else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
            field.setMapping(e.mapPath);
            if (DomainHelper.isComplexTypeById(e.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(e.typeId);
            }
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
        });
        dto.collapse();
    }
    static addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder) {
        let dtoUpdated = false;
        let domainElement = mappedElement;
        let attributesWithMapPaths = CrudHelper.getAttributesWithMapPath(domainElement);
        let isCreateMode = dto.getMetadata("originalVerb")?.toLowerCase()?.startsWith("create") == true;
        for (var keyName of Object.keys(attributesWithMapPaths)) {
            let entry = attributesWithMapPaths[keyName];
            if (isCreateMode &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {
                continue;
            }
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                continue;
            }
            let field = createElement("DTO-Field", entry.name, dto.id);
            field.setMapping(entry.mapPath);
            if (DomainHelper.isComplexTypeById(entry.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(entry.typeId);
            }
            field.typeReference.setIsNullable(entry.isNullable);
            field.typeReference.setIsCollection(entry.isCollection);
            dtoUpdated = true;
        }
        if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
            CrudHelper.addPrimaryKeys(dto, domainElement, true);
        }
        if (dtoUpdated) {
            dto.collapse();
        }
    }
    static isOwnerForeignKey(attributeName, domainElement) {
        for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
            if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
                return true;
            }
        }
        return false;
    }
    static addPrimaryKeys(dto, entity, map) {
        const primaryKeys = CrudHelper.getPrimaryKeysWithMapPath(entity);
        for (const primaryKey of primaryKeys) {
            const name = CrudHelper.getDomainAttributeNameFormat(primaryKey.name);
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
                continue;
            }
            const dtoField = createElement("DTO-Field", CrudHelper.getFieldFormat(name), dto.id);
            dtoField.typeReference.setType(primaryKey.typeId);
            if (map &amp;&amp; primaryKey.mapPath != null) {
                console.log(`Doing mapping for ${dtoField.id}`);
                dtoField.setMapping(primaryKey.mapPath);
            }
        }
    }
    static getPrimaryKeysWithMapPath(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return Object.values(keydict);
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren("Attribute")
            .filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp;
            !DomainHelper.isManagedForeignKey(x) &amp;&amp; // essentially also an attribute set by infrastructure
            !CrudHelper.legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || x.getMetadata("set-by-infrastructure")?.toLocaleLowerCase() != "true")));
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return attrDict;
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !CrudHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static getDomainAttributeNameFormat(str) {
        let convention = CrudHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
            default:
                return str;
        }
    }
    static getDomainAttributeNamingConvention() {
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return application.getSettings(domainSettingsId)
            ?.getField("Attribute Naming Convention")?.value ?? "pascal-case";
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
function onMapDto(element, folder, autoAddPrimaryKey = true, dtoPrefix = null, inbound = false) {
    if (element.isMapped) {
        let mappedFields = element.getChildren("DTO-Field").filter(x =&gt; x.getMapping());
        let unmappedFields = element.getChildren("DTO-Field").filter(x =&gt; !x.getMapping());
        for (let mappedField of mappedFields) {
            // Unfortunately have to take into account Intent's ability to disambiguate newly created fields... (the "1")
            let matchedUnmappedField = unmappedFields
                .filter(x =&gt; `${x.getName()}1` === mappedField.getName() ||
                x.getName() === mappedField.getName())[0];
            if (!matchedUnmappedField) {
                continue;
            }
            matchedUnmappedField.setMapping(mappedField.getMapping().getElement().id, mappedField.getMapping().mappingSettingsId);
            mappedField.delete();
        }
    }
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; x.typeReference.getType()?.specialization != "DTO" &amp;&amp; x.getMapping()?.getElement()?.specialization.startsWith("Association"));
    fields.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement().typeReference.getType(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; x.typeReference.getType()?.specialization != "DTO"
        &amp;&amp; (DomainHelper.isComplexType(x.getMapping()?.getElement()?.typeReference?.getType())));
    complexAttributes.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), false, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
}
/// &lt;reference path="servicesHelper.ts" /&gt;
/// &lt;reference path="mappingStore.ts" /&gt;
/// &lt;reference path="elementManager.ts" /&gt;
/// &lt;reference path="../services-cqrs-crud/_common/onMapDto.ts" /&gt;
var RepositoryCrudType;
(function (RepositoryCrudType) {
    RepositoryCrudType[RepositoryCrudType["Create"] = 0] = "Create";
    RepositoryCrudType[RepositoryCrudType["Read"] = 1] = "Read";
    RepositoryCrudType[RepositoryCrudType["Update"] = 2] = "Update";
    RepositoryCrudType[RepositoryCrudType["Delete"] = 3] = "Delete";
})(RepositoryCrudType || (RepositoryCrudType = {}));
const mapToDomainOperationSettingId = "7c31c459-6229-4f10-bf13-507348cd8828";
class RepositoryServiceHelper {
    static _createService(repository, folder) {
        let serviceName = repository.getName();
        serviceName = RepositoryServiceHelper.sanitizeServiceName(serviceName);
        const existing = folder.getPackage().getChildren("Service").find(x =&gt; x.getName() == serviceName);
        if (existing) {
            return existing;
        }
        let serviceElement = createElement("Service", serviceName, folder.getPackage().id);
        return serviceElement;
    }
    static sanitizeServiceName(name) {
        name = removeSuffix(name, "Repository");
        name += "Service";
        name = toPascalCase(name);
        return name;
    }
    static createAppServiceOperationAction(operation, folder, service, syncElement = false) {
        let operationName = operation.getName();
        operationName = removeSuffix(operationName, "Async");
        operationName = toPascalCase(operationName);
        if (!service) {
            service = RepositoryServiceHelper._createService(operation.getParent(), folder);
        }
        // look up if there is an existing operation with the same name
        const existing = service.getChildren().find(x =&gt; x.getName() == operationName);
        // and return the existing one if the sync is disable (which is is by default)
        if (existing &amp;&amp; !syncElement) {
            return existing;
        }
        let operationElement = existing ?? createElement("Operation", operationName, service.id);
        let mappingStore = new MappingStore();
        RepositoryServiceHelper.createAction(operation.getChildren("Parameter"), operationElement, false, folder, mappingStore, existing != null);
        // only add the association if not an existing operation
        if (!existing) {
            let callOp = createAssociation("Call Service Operation", operationElement.id, operation.id);
            let mapping = callOp.createAdvancedMapping(operationElement.id, operation.id);
            mapping.addMappedEnd("Invocation Mapping", [operationElement.id], [operation.id]);
            for (let entry of mappingStore.getMappings().reverse()) {
                mapping.addMappedEnd("Data Mapping", entry.sourcePath, entry.targetPath);
            }
        }
        if (!DomainHelper.isComplexType(operation.typeReference?.getType())) {
            operationElement.typeReference.setType(operation.typeReference.getTypeId());
            operationElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());
            operationElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());
        }
        else {
            var resultDto = RepositoryServiceHelper.createRepositoryClassTypeDto(operation, operation.typeReference?.getType(), folder);
            operationElement.typeReference.setType(resultDto.id);
            operationElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());
            operationElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());
        }
        return operationElement;
    }
    static createCqrsAction(operation, folder, syncElement = false) {
        let operationName = operation.getName();
        operationName = removeSuffix(operationName, "Async", "Command", "Query");
        operationName = toPascalCase(operationName);
        let metadata = RepositoryServiceHelper.getRepositoryOperationMetadata(operation);
        let actionTypeName;
        switch (metadata.crudType) {
            default:
                actionTypeName = "Command";
                break;
            case RepositoryCrudType.Read:
                actionTypeName = "Query";
                break;
        }
        const actionName = `${operationName}${actionTypeName}`;
        // if sync is set to true, then don't return right away
        const existing = folder.getChildren().find(x =&gt; x.getName() == actionName);
        if (existing &amp;&amp; !syncElement) {
            return existing;
        }
        const actionElement = existing ?? createElement(actionTypeName, actionName, folder.id);
        let mappingStore = new MappingStore();
        RepositoryServiceHelper.createAction(operation.getChildren("Parameter"), actionElement, true, folder, mappingStore, existing != null);
        // don't recreate the association if it the entity exists exists
        if (!existing) {
            let callOp = createAssociation("Call Service Operation", actionElement.id, operation.id);
            let mapping = callOp.createAdvancedMapping(actionElement.id, operation.id);
            mapping.addMappedEnd("Invocation Mapping", [actionElement.id], [operation.id]);
            for (let entry of mappingStore.getMappings().reverse()) {
                mapping.addMappedEnd("Data Mapping", entry.sourcePath, entry.targetPath);
            }
        }
        if (!DomainHelper.isComplexType(operation.typeReference?.getType())) {
            actionElement.typeReference.setType(operation.typeReference.getTypeId());
            actionElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());
            actionElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());
        }
        else {
            var resultDto = RepositoryServiceHelper.createRepositoryClassTypeDto(operation, operation.typeReference?.getType(), folder);
            actionElement.typeReference.setType(resultDto.id);
            actionElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());
            actionElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());
        }
        return actionElement;
    }
    static getRepositoryOperationMetadata(operation) {
        let mappedElement = operation.getMapping()?.getElement();
        mappedElement;
        let crudType;
        let httpSettings = mappedElement?.getStereotype("Http Settings");
        let httpVerb = httpSettings?.getProperty("Verb")?.getValue();
        let httpRoute = httpSettings?.getProperty("Route")?.getValue();
        const routeParamRegex = /\{([a-zA-Z0-9_\-]+)\}/g;
        let httpRouteParams = httpRoute ? [...httpRoute.matchAll(routeParamRegex)].map(match =&gt; match[1]) : [];
        if (httpVerb) {
            switch (httpVerb.toUpperCase()) {
                case "POST":
                    crudType = RepositoryCrudType.Create;
                    break;
                case "PUT":
                    crudType = RepositoryCrudType.Update;
                    break;
                case "DELETE":
                    crudType = RepositoryCrudType.Delete;
                    break;
                case "GET":
                    crudType = RepositoryCrudType.Read;
                    break;
            }
        }
        else if (mappedElement &amp;&amp; (mappedElement.specialization === "Command" ||
            mappedElement.specialization === "Query" ||
            mappedElement.specialization === "Operation")) {
            for (let association of mappedElement.getAssociations()) {
                switch (association.specialization) {
                    case "Create Entity Action":
                        crudType = RepositoryCrudType.Create;
                        break;
                    case "Update Entity Action":
                        crudType = RepositoryCrudType.Update;
                        break;
                    case "Delete Entity Action":
                        crudType = RepositoryCrudType.Delete;
                        break;
                    case "Query Entity Action":
                        crudType = RepositoryCrudType.Read;
                        break;
                }
            }
        }
        else if (!crudType) {
            let mappedElementNameLower = (mappedElement ? mappedElement.getName() : operation.getName()).toLocaleLowerCase();
            if (mappedElementNameLower.indexOf("create") &gt; -1) {
                crudType = RepositoryCrudType.Create;
            }
            else if (mappedElementNameLower.indexOf("update") &gt; -1) {
                crudType = RepositoryCrudType.Update;
            }
            else if (mappedElementNameLower.indexOf("delete") &gt; -1) {
                crudType = RepositoryCrudType.Delete;
            }
            else if (mappedElementNameLower.indexOf("get") &gt; -1 || mappedElementNameLower.indexOf("find") &gt; -1) {
                crudType = RepositoryCrudType.Read;
            }
        }
        return {
            crudType: crudType,
            httpVerb: httpVerb,
            httpRoute: httpRoute,
            httpRouteParams: httpRouteParams
        };
    }
    static createAction(repositoryFields, actionElement, flattenFieldsFromComplexTypes, folder, mappingStore, isExistingElement = false) {
        const childSpecialization = actionElement.specialization == "Operation" ? "Parameter" : "DTO-Field";
        let elementManager = new ElementManager(actionElement, { childSpecialization: childSpecialization });
        for (let repositoryField of repositoryFields) {
            let paramRefType = repositoryField.typeReference?.getType()?.specialization;
            switch (paramRefType) {
                case "Class":
                case "Data Contract":
                case "Value Object":
                    let repositoryRefType = repositoryField.typeReference.getType();
                    if (flattenFieldsFromComplexTypes &amp;&amp; !repositoryField.typeReference?.isCollection) {
                        mappingStore.pushTargetPath(repositoryField.id);
                        RepositoryServiceHelper.createAction(repositoryRefType.getChildren("Attribute"), elementManager.getElement(), false, folder, mappingStore, isExistingElement);
                        mappingStore.popTargetPath();
                    }
                    else {
                        let actionField = elementManager.addChild(repositoryField.getName(), null);
                        mappingStore.pushSourcePath(actionField.id);
                        mappingStore.pushTargetPath(repositoryField.id);
                        let actionDto = RepositoryServiceHelper.replicateDto(repositoryRefType, folder, mappingStore, isExistingElement);
                        mappingStore.popSourcePath();
                        mappingStore.popTargetPath();
                        actionField.typeReference.setType(actionDto.id);
                        actionField.typeReference.setIsCollection(repositoryField.typeReference.isCollection);
                        actionField.typeReference.setIsNullable(repositoryField.typeReference.isNullable);
                        if (repositoryField.hasMetadata("endpoint-input-id") &amp;&amp; !actionField.hasMetadata("endpoint-input-id")) {
                            actionField.addMetadata("endpoint-input-id", repositoryField.getMetadata("endpoint-input-id"));
                        }
                        if (repositoryField.typeReference?.isCollection) {
                            actionField.setValue(actionDto.getValue());
                            if (!isExistingElement) {
                                mappingStore.addMapping(actionField.id, repositoryField.id);
                            }
                        }
                    }
                    break;
                default:
                    // Non-Complex type
                    // if mapping directly to a class, skip over the primary keys 
                    if (repositoryField.hasStereotype("Primary Key")) {
                        continue;
                    }
                    let fieldName = repositoryField.getName();
                    if (elementManager.getElement().getChildren().some(x =&gt; x.getName() === fieldName) &amp;&amp; !isExistingElement) {
                        let parentName = repositoryField.getParent().getName();
                        fieldName = parentName + fieldName;
                    }
                    let actionField = elementManager.addChild(fieldName, repositoryField.typeReference);
                    actionField.setValue(repositoryField.getValue());
                    if (!isExistingElement) {
                        mappingStore.addMapping(actionField.id, repositoryField.id);
                    }
                    if (repositoryField.hasMetadata("endpoint-input-id") &amp;&amp; !actionField.hasMetadata("endpoint-input-id")) {
                        actionField.addMetadata("endpoint-input-id", repositoryField.getMetadata("endpoint-input-id"));
                    }
                    break;
            }
        }
        elementManager.collapse();
    }
    static getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        // Keeping 'owningAggregate' in case we still need to use it as part of the name one day
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return entityName;
    }
    static createRepositoryClassTypeDto(operation, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = this.getBaseNameForElement(owningAggregate, entity, false);
        let expectedDtoName = `${operation.getName()}${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedDtoName);
        if (existing) {
            return existing;
        }
        let dto = createElement("DTO", expectedDtoName, folder.id);
        dto.setMetadata("baseName", baseName);
        dto.setMapping(entity.id);
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), dto.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        ServicesHelper.addDtoFieldsFromDomain(dto, primaryKeys);
        let attributesWithMapPaths = DomainHelper.getAttributesWithMapPath(entity);
        for (var attr of attributesWithMapPaths) {
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getMapping()?.getElement()?.id == attr.id)) {
                continue;
            }
            let field = createElement("DTO-Field", attr.name, dto.id);
            field.typeReference.setType(attr.typeId);
            field.setMapping(attr.mapPath);
        }
        onMapDto(dto, folder);
        dto.collapse();
        return dto;
    }
    static replicateDto(repositoryDto, folder, mappingStore, isExistingElement = false) {
        var expectedName = `${repositoryDto.getName()}Dto`;
        // check to see if there is a DTO with the same name, and only if there is and we are working with an existing element do we update
        // this is to preserve backwards compatibility
        let existingDto = folder.getChildren().find(x =&gt; x.getName() == expectedName);
        let newDto = (existingDto &amp;&amp; isExistingElement) ? existingDto : createElement("DTO", expectedName, folder.id);
        let elementManager = new ElementManager(newDto, { childSpecialization: "DTO-Field" });
        repositoryDto.getChildren("Attribute").forEach(repositoryField =&gt; {
            let existingField = newDto.getChildren().find(c =&gt; c.getName() == repositoryField.getName());
            //let actionField =  (existingField &amp;&amp; isExistingElement) ? existingField :  createElement("DTO-Field", repositoryField.getName(), newDto.id);
            let actionField = (existingField &amp;&amp; isExistingElement) ? existingField : elementManager.addChild(repositoryField.getName(), null);
            let fieldRefType = repositoryField.typeReference?.getType()?.specialization;
            switch (fieldRefType) {
                case "Class":
                case "Data Contract":
                case "Value Object":
                    ``;
                    // Complex type
                    mappingStore.pushSourcePath(actionField.id);
                    mappingStore.pushTargetPath(repositoryField.id);
                    let nestedDto = RepositoryServiceHelper.replicateDto(repositoryField.typeReference.getType(), folder, mappingStore, isExistingElement);
                    mappingStore.popSourcePath();
                    mappingStore.popTargetPath();
                    actionField.typeReference.setType(nestedDto.id);
                    if (repositoryField.typeReference?.isCollection) {
                        actionField.setValue(nestedDto.getValue());
                        mappingStore.addMapping(actionField.id, repositoryField.id);
                    }
                    break;
                default:
                    // Non-Complex type
                    // if mapping directly to a class, skip over the primary keys 
                    if (repositoryField.hasStereotype("Primary Key")) {
                        break;
                    }
                    actionField.typeReference.setType(repositoryField.typeReference.getTypeId());
                    actionField.setValue(repositoryField.getValue());
                    mappingStore.addMapping(actionField.id, repositoryField.id);
                    break;
            }
            actionField.typeReference.setIsCollection(repositoryField.typeReference.isCollection);
            actionField.typeReference.setIsNullable(repositoryField.typeReference.isNullable);
        });
        return newDto;
    }
}
/// &lt;reference path="../../common/openSelectItemDialog.ts" /&gt;
/// &lt;reference path="../../common/repositoryServiceHelper.ts" /&gt;
async function execute(repositoryOperation) {
    let servicePackages = getPackages().filter(pkg =&gt; pkg.specialization === "Services Package");
    let selectedPackage;
    if (servicePackages.length == 1) {
        selectedPackage = servicePackages[0];
    }
    else {
        selectedPackage = await openSelectItemDialog(getPackageSelectItemOptions(servicePackages, "Service Package"));
    }
    const repository = repositoryOperation.getParent();
    const folderName = pluralize(repository.getName().replace("Repository", ""));
    const folder = selectedPackage.getChildren("Folder").find(x =&gt; x.getName() == pluralize(folderName)) ?? createElement("Folder", pluralize(folderName), selectedPackage.id);
    RepositoryServiceHelper.createCqrsAction(repositoryOperation, folder, true);
    // this can only be triggered from the diagram, so there will always be one.
    const diagram = getCurrentDiagram();
    //Since we're adding a single new element on the diagram, it may not be positioned below the last created one.
    let lastActionVisual = null;
    for (let action of folder.getChildren("Command").concat(folder.getChildren("Query"))) {
        if (diagram.isVisual(action.id)) {
            var actionElement = diagram.getVisual(action.id);
            if (!lastActionVisual || actionElement.getPosition().y &gt; lastActionVisual.getPosition().y) {
                lastActionVisual = actionElement;
            }
        }
    }
    let newPosition = null;
    let repoElement = diagram.getVisual(repository.id);
    // This is an attempt to reposition the newly created elements due to the lack of
    // directly manipulating the visuals on the diagram but it ends up skewing diagonally.
    if (lastActionVisual) {
        newPosition = {
            x: repoElement.getPosition().x - (repoElement.getSize().width / 1.5),
            y: lastActionVisual.getPosition().y + (lastActionVisual.getSize().height * 1.5)
        };
    }
    else {
        if (diagram.isVisual(repository.id)) {
            newPosition = {
                x: repoElement.getPosition().x - (repoElement.getSize().width / 1.5),
                y: repoElement.getPosition().y
            };
        }
    }
    diagram.layoutVisuals(folder, newPosition, true);
}
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/create-cqrs-repository-operation-macro-advanced-mapping/create-cqrs-repository-operation-macro-advanced-mapping.ts
 */
await execute(element);
</script>
    </suggestionSetting>
    <suggestionSetting type="Operation" typeId="e042bb67-a1df-480c-9935-b26210f78591" locations="diagram, model">
      <name>Create Service Operation</name>
      <filterFunction>const callServiceOperationTargetEnd = "093e5909-ffe4-4510-b3ea-532f30212f3c";
let notMapped = lookupTypesOf(callServiceOperationTargetEnd).every(x =&gt; x.typeReference.getTypeId() != element.id)

return application.getSettings("0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad").getField("14bc1e98-930b-494c-97a9-5da4e1f3a5fa").value == "advanced"
    &amp;&amp; element.getParent() &amp;&amp; element.getParent().specializationId == "96ffceb2-a70a-4b69-869b-0df436c470c3" // is a Repository
    &amp;&amp; notMapped;</filterFunction>
      <dependencies />
      <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getPackageSelectItemOptions(packages, packageTypeName) {
    return {
        items: packages,
        getId(item) {
            return item.id;
        },
        getDisplayName(item) {
            return item.getName();
        },
        getItemNotFoundMessage(itemId) {
            return `No ${packageTypeName} found with id "${itemId}".`;
        },
        getNoItemsFoundMessage() {
            return `No packages of type ${packageTypeName} could be found.`;
        },
    };
}
function getElementSelectItemOptions(elements, elementTypeName, relevantPackageTypeName) {
    return {
        items: elements,
        getId(item) {
            return item.id;
        },
        getDisplayName(item) {
            return item.getName();
        },
        getItemNotFoundMessage(itemId) {
            return `No "${elementTypeName}" found with id "${itemId}".`;
        },
        getNoItemsFoundMessage() {
            return `No Elements of type "${elementTypeName}" could be found. Please ensure that you have a reference to the ${relevantPackageTypeName} package and that at least one ${elementTypeName} exists in it.`;
        },
    };
}
/**
 * Dialog selection.
 * @param options For simplicity, use getPackageSelectItemOptions() or getElementSelectItemOptions()
 * @returns Selected item.
 */
async function openSelectItemDialog(options) {
    if (!options) {
        throw new Error("Options are required for 'openSelectItemDialog'.");
    }
    let items = options.items;
    if (items.length == 0) {
        await dialogService.info(options.getNoItemsFoundMessage());
        return null;
    }
    let itemId = await dialogService.lookupFromOptions(items.map(item =&gt; ({
        id: options.getId(item),
        name: options.getDisplayName(item)
    })));
    if (itemId == null) {
        await dialogService.error(options.getItemNotFoundMessage(itemId));
        return null;
    }
    let foundItem = items.filter(item =&gt; options.getId(item) === itemId)[0];
    return foundItem;
}
;
/// &lt;reference path="attributeWithMapPath.ts" /&gt;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
ServicesConstants.dtoToDomainOperation = "8d1f6a8a-77c8-43a2-8e60-421559725419";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if ((key.mapPath ?? []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
/**
 * Helper class to build up source and target mapping paths for
 * advanced mapping scenarios.
 *
 * @remarks
 *
 * Source Path and Target Path is maintained separately since not all mapping scenarios are
 * straightforward.
 *
 * @example
 *
 * When to Push/Pop the Paths
 *
    let leftField = createField(...);

    mappingStore.pushSourcePath(leftField.id);
    mappingStore.pushTargetPath(rightField.id);

    let leftFieldDto = replicateDto(rightField.typeReference.getType(), folder, mappingStore);

    mappingStore.popSourcePath();
    mappingStore.popTargetPath();

    leftField.typeReference.setType(leftFieldDto.id);
 *
 * Adding mappings
 *
    function replicateDto(existingDto: MacroApi.Context.IElementApi, ...) {
        let newDto = createElement("DTO", existingDto.getName(), folder.id);
        existingDto.getChildren("DTO-Field").forEach(existingField =&gt; {
            let newField = createElement("DTO-Field", existingField.getName(), newDto.id);
            // ...
            mappingStore.addMapping(newField.id, existingField.id);
            // ...
        }
    }
 */
class MappingStore {
    constructor() {
        this.mappings = [];
        this.sourcePath = [];
        this.targetPath = [];
    }
    /**
     * Get all the recorded mapping entries
     */
    getMappings() {
        return this.mappings;
    }
    /**
     * Keep track of this element id on the source end
     * when navigating inside it's type hierarchy.
     */
    pushSourcePath(id) {
        this.sourcePath.push(id);
    }
    /**
     * Remove the last tracked element on the source path stack
     * when done navigating down its type hierarchy.
     */
    popSourcePath() {
        this.sourcePath.pop();
    }
    /**
     * Keep track of this element id on the target end
     * when navigating inside it's type hierarchy.
     */
    pushTargetPath(id) {
        this.targetPath.push(id);
    }
    /**
     * Remove the last tracked element on the target path stack
     * when done navigating down its type hierarchy.
     */
    popTargetPath() {
        this.targetPath.pop();
    }
    /**
     * Record a mapping between a source element id and target element id.
     * Target and Source path stack will be used to build up the whole path.
     */
    addMapping(sourceId, targetId) {
        this.mappings.push({
            sourcePath: this.sourcePath.concat([sourceId]),
            targetPath: this.targetPath.concat([targetId])
        });
    }
}
class ElementManager {
    constructor(innerElement, settings) {
        this.innerElement = innerElement;
        this.settings = settings;
        this.mappedElement = innerElement.getMapping()?.getElement();
    }
    get id() { return this.innerElement.id; }
    ;
    setReturnType(typeId, isCollection, isNullable) {
        this.innerElement.typeReference.setType(typeId);
        if (isCollection != null) {
            this.innerElement.typeReference.setIsCollection(isCollection);
        }
        if (isNullable != null) {
            this.innerElement.typeReference.setIsNullable(isNullable);
        }
        return this;
    }
    addChild(name, type) {
        let existingField = this.innerElement.getChildren(this.settings.childSpecialization)
            .find(c =&gt; c.getName().toLowerCase() == ServicesHelper.formatName(name, this.settings.childType ?? "property").toLowerCase());
        let field = existingField ?? createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, this.settings.childType ?? "property"), this.innerElement.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {
                    return;
                }
            }
            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options?.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.innerElement.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.innerElement;
    }
    collapse() {
        this.innerElement.collapse();
    }
}
/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")?.getField("Key Type")?.value ?? "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return element?.specialization === "Data Contract" ||
            element?.specialization === "Value Object" ||
            element?.specialization === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]?.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = attr.getStereotype("Foreign Key").getProperty("Association")?.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    /**
     * Returns true if the attribute is a foreign key on a compositional one-to-many relationship (i.e. is managed by the DB and should not be set).
     * @param attribute
     * @returns
     */
    static isManagedForeignKey(attribute) {
        let fkAssociation = attribute.getStereotype("Foreign Key")?.getProperty("Association")?.getSelected();
        return fkAssociation != null &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsCollection() &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsNullable();
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp;
            !DomainHelper.legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || x.getMetadata("set-by-infrastructure")?.toLocaleLowerCase() != "true")));
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return application.getSettings(domainSettingsId)
            ?.getField("Attribute Naming Convention")?.value ?? "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="../../common/attributeWithMapPath.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto) {
    let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
    childrenToAdd.forEach(e =&gt; {
        if (e.mapPath != null) {
            if (dto.getChildren("Parameter").some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {
                return;
            }
        }
        else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
            return;
        }
        let field = createElement("DTO-Field", e.name, dto.id);
        field.typeReference.setType(e.typeId);
        field.typeReference.setIsCollection(e.isCollection);
        field.typeReference.setIsNullable(e.isNullable);
        if (this.mappedElement != null &amp;&amp; e.mapPath) {
            field.setMapping(e.mapPath);
        }
    });
    dto.collapse();
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = dto.getMetadata("originalVerb")?.toLowerCase()?.startsWith("create") == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", toPascalCase(entry.name), dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp;
        !legacyPartitionKey(x) &amp;&amp;
        (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || x.getMetadata("set-by-infrastructure")?.toLocaleLowerCase() != "true")));
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return application.getSettings(domainSettingsId)
        ?.getField("Attribute Naming Convention")?.value ?? "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
class CrudConstants {
}
CrudConstants.mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
CrudConstants.mapToDomainConstructorForDtosSettingId = "8d1f6a8a-77c8-43a2-8e60-421559725419";
CrudConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class CrudHelper {
    // Super basic selection dialog.
    static async openBasicSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; CrudHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: getFriendlyDisplayNameForClassSelection(x),
            additionalInfo: `(${x.getParents().map(item =&gt; item.getName()).join("/")})`
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
        function getFriendlyDisplayNameForClassSelection(element) {
            let aggregateEntity = DomainHelper.getOwningAggregate(element);
            return !aggregateEntity ? element.getName() : `${element.getName()} (${aggregateEntity.getName()})`;
        }
    }
    static async openCrudCreationDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; CrudHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let dialogResult = await dialogService.openForm({
            title: "CRUD Creation Options",
            fields: [
                {
                    id: "entityId",
                    fieldType: "select",
                    label: "Entity for CRUD operations",
                    selectOptions: classes.map(x =&gt; {
                        return {
                            id: x.id,
                            description: x.getName(),
                            additionalInfo: getClassAdditionalInfo(x)
                        };
                    }),
                    isRequired: true
                },
                {
                    id: "create",
                    fieldType: "checkbox",
                    label: "Create",
                    value: "true",
                    hint: "Generate the \"Create\" operation"
                },
                {
                    id: "update",
                    fieldType: "checkbox",
                    label: "Update",
                    value: "true",
                    hint: "Generate the \"Update\" operation"
                },
                {
                    id: "queryById",
                    fieldType: "checkbox",
                    label: "Query By Id",
                    value: "true",
                    hint: "Generate the \"Query By Id\" operation"
                },
                {
                    id: "queryAll",
                    fieldType: "checkbox",
                    label: "Query All",
                    value: "true",
                    hint: "Generate the \"Query All\" operation"
                },
                {
                    id: "delete",
                    fieldType: "checkbox",
                    label: "Delete",
                    value: "true",
                    hint: "Generate the \"Delete\" operation"
                },
                {
                    id: "domain",
                    fieldType: "checkbox",
                    label: "Domain Operations",
                    value: "true",
                    hint: "Generate operations for Domain Entity operations"
                }
            ]
        });
        let foundEntity = lookup(dialogResult.entityId);
        var result = {
            selectedEntity: foundEntity,
            canCreate: dialogResult.create == "true",
            canUpdate: dialogResult.update == "true",
            canQueryById: dialogResult.queryById == "true",
            canQueryAll: dialogResult.queryAll == "true",
            canDelete: dialogResult.delete == "true",
            canDomain: dialogResult.domain == "true",
            selectedDomainOperationIds: []
        };
        if (result.canDomain &amp;&amp; foundEntity.getChildren("Operation").length &gt; 0) {
            dialogResult = await dialogService.openForm({
                title: "Select Domain Operations",
                fields: [
                    {
                        id: "tree",
                        fieldType: "tree-view",
                        label: "Domain Operations",
                        hint: "Generate operations from selected domain entity operations",
                        treeViewOptions: {
                            rootId: foundEntity.id,
                            submitFormTriggers: ["double-click", "enter"],
                            isMultiSelect: true,
                            selectableTypes: [
                                {
                                    specializationId: "Class",
                                    autoExpand: true,
                                    autoSelectChildren: false,
                                    isSelectable: (x) =&gt; false
                                },
                                {
                                    specializationId: "Operation",
                                    isSelectable: (x) =&gt; true
                                }
                            ]
                        }
                    }
                ]
            });
            result.selectedDomainOperationIds = dialogResult.tree?.filter((x) =&gt; x != "0") ?? [];
        }
        return result;
        function getClassAdditionalInfo(element) {
            let aggregateEntity = DomainHelper.getOwningAggregate(element);
            let prefix = aggregateEntity ? `: ${aggregateEntity.getName()}  ` : "";
            return `${prefix}(${element.getParents().map(item =&gt; item.getName()).join("/")})`;
        }
    }
    static filterClassSelection(element, options) {
        if (!(options?.allowAbstract ?? false) &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if (options?.includeOwnedRelationships != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return CrudHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false, allowAbstract: true });
        }
        return false;
    }
    static getName(command, mappedElement, dtoPrefix = null) {
        if (mappedElement.typeReference != null)
            mappedElement = mappedElement.typeReference.getType();
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        if (dtoPrefix)
            dtoName = `${dtoPrefix}${dtoName}`;
        return dtoName;
    }
    static getOrCreateCrudDto(dtoName, mappedElement, autoAddPrimaryKey, mappingTypeSettingId, folder, inbound = false) {
        let dto = CrudHelper.getOrCreateDto(dtoName, folder);
        //dtoField.typeReference.setType(dto.id);
        const entityCtor = mappedElement
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (inbound &amp;&amp; entityCtor != null) {
            dto.setMapping([mappedElement.id, entityCtor.id], CrudConstants.mapToDomainConstructorForDtosSettingId);
            CrudHelper.addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto, folder);
        }
        else {
            dto.setMapping(mappedElement.id, mappingTypeSettingId);
            CrudHelper.addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder);
        }
        return dto;
    }
    static getOrCreateDto(elementName, parentElement) {
        const expectedDtoName = elementName.replace(/Dto$/, "") + "Dto";
        let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
        if (existingDto) {
            return existingDto;
        }
        let dto = createElement("DTO", expectedDtoName, parentElement.id);
        return dto;
    }
    static addDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto, folder) {
        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        childrenToAdd.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (dto.getChildren("Parameter").some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {
                    return;
                }
            }
            else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
            field.setMapping(e.mapPath);
            if (DomainHelper.isComplexTypeById(e.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(e.typeId);
            }
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
        });
        dto.collapse();
    }
    static addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder) {
        let dtoUpdated = false;
        let domainElement = mappedElement;
        let attributesWithMapPaths = CrudHelper.getAttributesWithMapPath(domainElement);
        let isCreateMode = dto.getMetadata("originalVerb")?.toLowerCase()?.startsWith("create") == true;
        for (var keyName of Object.keys(attributesWithMapPaths)) {
            let entry = attributesWithMapPaths[keyName];
            if (isCreateMode &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {
                continue;
            }
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                continue;
            }
            let field = createElement("DTO-Field", entry.name, dto.id);
            field.setMapping(entry.mapPath);
            if (DomainHelper.isComplexTypeById(entry.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(entry.typeId);
            }
            field.typeReference.setIsNullable(entry.isNullable);
            field.typeReference.setIsCollection(entry.isCollection);
            dtoUpdated = true;
        }
        if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
            CrudHelper.addPrimaryKeys(dto, domainElement, true);
        }
        if (dtoUpdated) {
            dto.collapse();
        }
    }
    static isOwnerForeignKey(attributeName, domainElement) {
        for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
            if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
                return true;
            }
        }
        return false;
    }
    static addPrimaryKeys(dto, entity, map) {
        const primaryKeys = CrudHelper.getPrimaryKeysWithMapPath(entity);
        for (const primaryKey of primaryKeys) {
            const name = CrudHelper.getDomainAttributeNameFormat(primaryKey.name);
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
                continue;
            }
            const dtoField = createElement("DTO-Field", CrudHelper.getFieldFormat(name), dto.id);
            dtoField.typeReference.setType(primaryKey.typeId);
            if (map &amp;&amp; primaryKey.mapPath != null) {
                console.log(`Doing mapping for ${dtoField.id}`);
                dtoField.setMapping(primaryKey.mapPath);
            }
        }
    }
    static getPrimaryKeysWithMapPath(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return Object.values(keydict);
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren("Attribute")
            .filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp;
            !DomainHelper.isManagedForeignKey(x) &amp;&amp; // essentially also an attribute set by infrastructure
            !CrudHelper.legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || x.getMetadata("set-by-infrastructure")?.toLocaleLowerCase() != "true")));
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return attrDict;
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !CrudHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static getDomainAttributeNameFormat(str) {
        let convention = CrudHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
            default:
                return str;
        }
    }
    static getDomainAttributeNamingConvention() {
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return application.getSettings(domainSettingsId)
            ?.getField("Attribute Naming Convention")?.value ?? "pascal-case";
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/crudHelper.ts" /&gt;
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
function onMapDto(element, folder, autoAddPrimaryKey = true, dtoPrefix = null, inbound = false) {
    if (element.isMapped) {
        let mappedFields = element.getChildren("DTO-Field").filter(x =&gt; x.getMapping());
        let unmappedFields = element.getChildren("DTO-Field").filter(x =&gt; !x.getMapping());
        for (let mappedField of mappedFields) {
            // Unfortunately have to take into account Intent's ability to disambiguate newly created fields... (the "1")
            let matchedUnmappedField = unmappedFields
                .filter(x =&gt; `${x.getName()}1` === mappedField.getName() ||
                x.getName() === mappedField.getName())[0];
            if (!matchedUnmappedField) {
                continue;
            }
            matchedUnmappedField.setMapping(mappedField.getMapping().getElement().id, mappedField.getMapping().mappingSettingsId);
            mappedField.delete();
        }
    }
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; x.typeReference.getType()?.specialization != "DTO" &amp;&amp; x.getMapping()?.getElement()?.specialization.startsWith("Association"));
    fields.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement().typeReference.getType(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; x.typeReference.getType()?.specialization != "DTO"
        &amp;&amp; (DomainHelper.isComplexType(x.getMapping()?.getElement()?.typeReference?.getType())));
    complexAttributes.forEach(f =&gt; {
        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;
        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), false, targetMappingSettingId, folder, inbound);
        f.typeReference.setType(newDto.id);
    });
}
/// &lt;reference path="servicesHelper.ts" /&gt;
/// &lt;reference path="mappingStore.ts" /&gt;
/// &lt;reference path="elementManager.ts" /&gt;
/// &lt;reference path="../services-cqrs-crud/_common/onMapDto.ts" /&gt;
var RepositoryCrudType;
(function (RepositoryCrudType) {
    RepositoryCrudType[RepositoryCrudType["Create"] = 0] = "Create";
    RepositoryCrudType[RepositoryCrudType["Read"] = 1] = "Read";
    RepositoryCrudType[RepositoryCrudType["Update"] = 2] = "Update";
    RepositoryCrudType[RepositoryCrudType["Delete"] = 3] = "Delete";
})(RepositoryCrudType || (RepositoryCrudType = {}));
const mapToDomainOperationSettingId = "7c31c459-6229-4f10-bf13-507348cd8828";
class RepositoryServiceHelper {
    static _createService(repository, folder) {
        let serviceName = repository.getName();
        serviceName = RepositoryServiceHelper.sanitizeServiceName(serviceName);
        const existing = folder.getPackage().getChildren("Service").find(x =&gt; x.getName() == serviceName);
        if (existing) {
            return existing;
        }
        let serviceElement = createElement("Service", serviceName, folder.getPackage().id);
        return serviceElement;
    }
    static sanitizeServiceName(name) {
        name = removeSuffix(name, "Repository");
        name += "Service";
        name = toPascalCase(name);
        return name;
    }
    static createAppServiceOperationAction(operation, folder, service, syncElement = false) {
        let operationName = operation.getName();
        operationName = removeSuffix(operationName, "Async");
        operationName = toPascalCase(operationName);
        if (!service) {
            service = RepositoryServiceHelper._createService(operation.getParent(), folder);
        }
        // look up if there is an existing operation with the same name
        const existing = service.getChildren().find(x =&gt; x.getName() == operationName);
        // and return the existing one if the sync is disable (which is is by default)
        if (existing &amp;&amp; !syncElement) {
            return existing;
        }
        let operationElement = existing ?? createElement("Operation", operationName, service.id);
        let mappingStore = new MappingStore();
        RepositoryServiceHelper.createAction(operation.getChildren("Parameter"), operationElement, false, folder, mappingStore, existing != null);
        // only add the association if not an existing operation
        if (!existing) {
            let callOp = createAssociation("Call Service Operation", operationElement.id, operation.id);
            let mapping = callOp.createAdvancedMapping(operationElement.id, operation.id);
            mapping.addMappedEnd("Invocation Mapping", [operationElement.id], [operation.id]);
            for (let entry of mappingStore.getMappings().reverse()) {
                mapping.addMappedEnd("Data Mapping", entry.sourcePath, entry.targetPath);
            }
        }
        if (!DomainHelper.isComplexType(operation.typeReference?.getType())) {
            operationElement.typeReference.setType(operation.typeReference.getTypeId());
            operationElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());
            operationElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());
        }
        else {
            var resultDto = RepositoryServiceHelper.createRepositoryClassTypeDto(operation, operation.typeReference?.getType(), folder);
            operationElement.typeReference.setType(resultDto.id);
            operationElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());
            operationElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());
        }
        return operationElement;
    }
    static createCqrsAction(operation, folder, syncElement = false) {
        let operationName = operation.getName();
        operationName = removeSuffix(operationName, "Async", "Command", "Query");
        operationName = toPascalCase(operationName);
        let metadata = RepositoryServiceHelper.getRepositoryOperationMetadata(operation);
        let actionTypeName;
        switch (metadata.crudType) {
            default:
                actionTypeName = "Command";
                break;
            case RepositoryCrudType.Read:
                actionTypeName = "Query";
                break;
        }
        const actionName = `${operationName}${actionTypeName}`;
        // if sync is set to true, then don't return right away
        const existing = folder.getChildren().find(x =&gt; x.getName() == actionName);
        if (existing &amp;&amp; !syncElement) {
            return existing;
        }
        const actionElement = existing ?? createElement(actionTypeName, actionName, folder.id);
        let mappingStore = new MappingStore();
        RepositoryServiceHelper.createAction(operation.getChildren("Parameter"), actionElement, true, folder, mappingStore, existing != null);
        // don't recreate the association if it the entity exists exists
        if (!existing) {
            let callOp = createAssociation("Call Service Operation", actionElement.id, operation.id);
            let mapping = callOp.createAdvancedMapping(actionElement.id, operation.id);
            mapping.addMappedEnd("Invocation Mapping", [actionElement.id], [operation.id]);
            for (let entry of mappingStore.getMappings().reverse()) {
                mapping.addMappedEnd("Data Mapping", entry.sourcePath, entry.targetPath);
            }
        }
        if (!DomainHelper.isComplexType(operation.typeReference?.getType())) {
            actionElement.typeReference.setType(operation.typeReference.getTypeId());
            actionElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());
            actionElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());
        }
        else {
            var resultDto = RepositoryServiceHelper.createRepositoryClassTypeDto(operation, operation.typeReference?.getType(), folder);
            actionElement.typeReference.setType(resultDto.id);
            actionElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());
            actionElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());
        }
        return actionElement;
    }
    static getRepositoryOperationMetadata(operation) {
        let mappedElement = operation.getMapping()?.getElement();
        mappedElement;
        let crudType;
        let httpSettings = mappedElement?.getStereotype("Http Settings");
        let httpVerb = httpSettings?.getProperty("Verb")?.getValue();
        let httpRoute = httpSettings?.getProperty("Route")?.getValue();
        const routeParamRegex = /\{([a-zA-Z0-9_\-]+)\}/g;
        let httpRouteParams = httpRoute ? [...httpRoute.matchAll(routeParamRegex)].map(match =&gt; match[1]) : [];
        if (httpVerb) {
            switch (httpVerb.toUpperCase()) {
                case "POST":
                    crudType = RepositoryCrudType.Create;
                    break;
                case "PUT":
                    crudType = RepositoryCrudType.Update;
                    break;
                case "DELETE":
                    crudType = RepositoryCrudType.Delete;
                    break;
                case "GET":
                    crudType = RepositoryCrudType.Read;
                    break;
            }
        }
        else if (mappedElement &amp;&amp; (mappedElement.specialization === "Command" ||
            mappedElement.specialization === "Query" ||
            mappedElement.specialization === "Operation")) {
            for (let association of mappedElement.getAssociations()) {
                switch (association.specialization) {
                    case "Create Entity Action":
                        crudType = RepositoryCrudType.Create;
                        break;
                    case "Update Entity Action":
                        crudType = RepositoryCrudType.Update;
                        break;
                    case "Delete Entity Action":
                        crudType = RepositoryCrudType.Delete;
                        break;
                    case "Query Entity Action":
                        crudType = RepositoryCrudType.Read;
                        break;
                }
            }
        }
        else if (!crudType) {
            let mappedElementNameLower = (mappedElement ? mappedElement.getName() : operation.getName()).toLocaleLowerCase();
            if (mappedElementNameLower.indexOf("create") &gt; -1) {
                crudType = RepositoryCrudType.Create;
            }
            else if (mappedElementNameLower.indexOf("update") &gt; -1) {
                crudType = RepositoryCrudType.Update;
            }
            else if (mappedElementNameLower.indexOf("delete") &gt; -1) {
                crudType = RepositoryCrudType.Delete;
            }
            else if (mappedElementNameLower.indexOf("get") &gt; -1 || mappedElementNameLower.indexOf("find") &gt; -1) {
                crudType = RepositoryCrudType.Read;
            }
        }
        return {
            crudType: crudType,
            httpVerb: httpVerb,
            httpRoute: httpRoute,
            httpRouteParams: httpRouteParams
        };
    }
    static createAction(repositoryFields, actionElement, flattenFieldsFromComplexTypes, folder, mappingStore, isExistingElement = false) {
        const childSpecialization = actionElement.specialization == "Operation" ? "Parameter" : "DTO-Field";
        let elementManager = new ElementManager(actionElement, { childSpecialization: childSpecialization });
        for (let repositoryField of repositoryFields) {
            let paramRefType = repositoryField.typeReference?.getType()?.specialization;
            switch (paramRefType) {
                case "Class":
                case "Data Contract":
                case "Value Object":
                    let repositoryRefType = repositoryField.typeReference.getType();
                    if (flattenFieldsFromComplexTypes &amp;&amp; !repositoryField.typeReference?.isCollection) {
                        mappingStore.pushTargetPath(repositoryField.id);
                        RepositoryServiceHelper.createAction(repositoryRefType.getChildren("Attribute"), elementManager.getElement(), false, folder, mappingStore, isExistingElement);
                        mappingStore.popTargetPath();
                    }
                    else {
                        let actionField = elementManager.addChild(repositoryField.getName(), null);
                        mappingStore.pushSourcePath(actionField.id);
                        mappingStore.pushTargetPath(repositoryField.id);
                        let actionDto = RepositoryServiceHelper.replicateDto(repositoryRefType, folder, mappingStore, isExistingElement);
                        mappingStore.popSourcePath();
                        mappingStore.popTargetPath();
                        actionField.typeReference.setType(actionDto.id);
                        actionField.typeReference.setIsCollection(repositoryField.typeReference.isCollection);
                        actionField.typeReference.setIsNullable(repositoryField.typeReference.isNullable);
                        if (repositoryField.hasMetadata("endpoint-input-id") &amp;&amp; !actionField.hasMetadata("endpoint-input-id")) {
                            actionField.addMetadata("endpoint-input-id", repositoryField.getMetadata("endpoint-input-id"));
                        }
                        if (repositoryField.typeReference?.isCollection) {
                            actionField.setValue(actionDto.getValue());
                            if (!isExistingElement) {
                                mappingStore.addMapping(actionField.id, repositoryField.id);
                            }
                        }
                    }
                    break;
                default:
                    // Non-Complex type
                    // if mapping directly to a class, skip over the primary keys 
                    if (repositoryField.hasStereotype("Primary Key")) {
                        continue;
                    }
                    let fieldName = repositoryField.getName();
                    if (elementManager.getElement().getChildren().some(x =&gt; x.getName() === fieldName) &amp;&amp; !isExistingElement) {
                        let parentName = repositoryField.getParent().getName();
                        fieldName = parentName + fieldName;
                    }
                    let actionField = elementManager.addChild(fieldName, repositoryField.typeReference);
                    actionField.setValue(repositoryField.getValue());
                    if (!isExistingElement) {
                        mappingStore.addMapping(actionField.id, repositoryField.id);
                    }
                    if (repositoryField.hasMetadata("endpoint-input-id") &amp;&amp; !actionField.hasMetadata("endpoint-input-id")) {
                        actionField.addMetadata("endpoint-input-id", repositoryField.getMetadata("endpoint-input-id"));
                    }
                    break;
            }
        }
        elementManager.collapse();
    }
    static getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        // Keeping 'owningAggregate' in case we still need to use it as part of the name one day
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return entityName;
    }
    static createRepositoryClassTypeDto(operation, entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = this.getBaseNameForElement(owningAggregate, entity, false);
        let expectedDtoName = `${operation.getName()}${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedDtoName);
        if (existing) {
            return existing;
        }
        let dto = createElement("DTO", expectedDtoName, folder.id);
        dto.setMetadata("baseName", baseName);
        dto.setMapping(entity.id);
        let primaryKeys = DomainHelper.getPrimaryKeys(entity);
        if (owningAggregate) {
            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
            foreignKeys.forEach(fk =&gt; {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), dto.id);
                field.typeReference.setType(fk.typeId);
                if (fk.mapPath) {
                    field.setMapping(fk.mapPath);
                }
            });
        }
        ServicesHelper.addDtoFieldsFromDomain(dto, primaryKeys);
        let attributesWithMapPaths = DomainHelper.getAttributesWithMapPath(entity);
        for (var attr of attributesWithMapPaths) {
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getMapping()?.getElement()?.id == attr.id)) {
                continue;
            }
            let field = createElement("DTO-Field", attr.name, dto.id);
            field.typeReference.setType(attr.typeId);
            field.setMapping(attr.mapPath);
        }
        onMapDto(dto, folder);
        dto.collapse();
        return dto;
    }
    static replicateDto(repositoryDto, folder, mappingStore, isExistingElement = false) {
        var expectedName = `${repositoryDto.getName()}Dto`;
        // check to see if there is a DTO with the same name, and only if there is and we are working with an existing element do we update
        // this is to preserve backwards compatibility
        let existingDto = folder.getChildren().find(x =&gt; x.getName() == expectedName);
        let newDto = (existingDto &amp;&amp; isExistingElement) ? existingDto : createElement("DTO", expectedName, folder.id);
        let elementManager = new ElementManager(newDto, { childSpecialization: "DTO-Field" });
        repositoryDto.getChildren("Attribute").forEach(repositoryField =&gt; {
            let existingField = newDto.getChildren().find(c =&gt; c.getName() == repositoryField.getName());
            //let actionField =  (existingField &amp;&amp; isExistingElement) ? existingField :  createElement("DTO-Field", repositoryField.getName(), newDto.id);
            let actionField = (existingField &amp;&amp; isExistingElement) ? existingField : elementManager.addChild(repositoryField.getName(), null);
            let fieldRefType = repositoryField.typeReference?.getType()?.specialization;
            switch (fieldRefType) {
                case "Class":
                case "Data Contract":
                case "Value Object":
                    ``;
                    // Complex type
                    mappingStore.pushSourcePath(actionField.id);
                    mappingStore.pushTargetPath(repositoryField.id);
                    let nestedDto = RepositoryServiceHelper.replicateDto(repositoryField.typeReference.getType(), folder, mappingStore, isExistingElement);
                    mappingStore.popSourcePath();
                    mappingStore.popTargetPath();
                    actionField.typeReference.setType(nestedDto.id);
                    if (repositoryField.typeReference?.isCollection) {
                        actionField.setValue(nestedDto.getValue());
                        mappingStore.addMapping(actionField.id, repositoryField.id);
                    }
                    break;
                default:
                    // Non-Complex type
                    // if mapping directly to a class, skip over the primary keys 
                    if (repositoryField.hasStereotype("Primary Key")) {
                        break;
                    }
                    actionField.typeReference.setType(repositoryField.typeReference.getTypeId());
                    actionField.setValue(repositoryField.getValue());
                    mappingStore.addMapping(actionField.id, repositoryField.id);
                    break;
            }
            actionField.typeReference.setIsCollection(repositoryField.typeReference.isCollection);
            actionField.typeReference.setIsNullable(repositoryField.typeReference.isNullable);
        });
        return newDto;
    }
}
/// &lt;reference path="../../common/openSelectItemDialog.ts" /&gt;
/// &lt;reference path="../../common/repositoryServiceHelper.ts" /&gt;
async function execute(repositoryOperation) {
    let servicePackages = getPackages().filter(pkg =&gt; pkg.specialization === "Services Package");
    let selectedPackage;
    if (servicePackages.length == 1) {
        selectedPackage = servicePackages[0];
    }
    else {
        selectedPackage = await openSelectItemDialog(getPackageSelectItemOptions(servicePackages, "Service Package"));
    }
    const repository = repositoryOperation.getParent();
    const folderName = pluralize(repository.getName().replace("Repository", ""));
    const folder = selectedPackage.getChildren("Folder").find(x =&gt; x.getName() == pluralize(folderName)) ?? createElement("Folder", pluralize(folderName), selectedPackage.id);
    let newOperation = RepositoryServiceHelper.createAppServiceOperationAction(repositoryOperation, folder, null, true);
    // this can only be triggered from the diagram, so there will always be one.
    const diagram = getCurrentDiagram();
    let newPosition = null;
    let repoElement = diagram.getVisual(repository.id);
    // This is an attempt to reposition the newly created elements due to the lack of
    // directly manipulating the visuals on the diagram but it ends up skewing diagonally.
    if (repoElement) {
        newPosition = {
            x: repoElement.getPosition().x - (repoElement.getSize().width / 1.5),
            y: repoElement.getPosition().y + (repoElement.getSize().height / 2)
        };
    }
    diagram.layoutVisuals(newOperation.getParent(), newPosition, true);
}
/**
 * Used by Intent.Modelers.Services.DomainInteractions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/create-appservice-repository-operation-macro-advanced-mapping/create-appservice-repository-operation-macro-advanced-mapping.ts
 */
await execute(element);
</script>
    </suggestionSetting>
  </suggestionSettings>
  <scripts>
    <script name="Crud Api" id="61a8411f-b5bc-4a00-9a37-a967e0893d9d">
      <script>/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
var _a, _b;
const privateSettersOnly = ((_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")) === null || _b === void 0 ? void 0 : _b.value) == "true";
async function notifyUserOfLimitations(entity, dialogOptions) {
    if ((privateSettersOnly &amp;&amp; !hasConstructor(entity)) &amp;&amp; dialogOptions.canCreate) {
        await dialogService.warn(`Partial CQRS Operation Creation.
Some CQRS operations were created successfully, but was limited due to private setters being enabled, and no constructor is present for entity '${entity.getName()}'.

To avoid this limitation in the future, either disable private setters or add a constructor element to the entity.`);
    }
    else if (!entityHasPrimaryKey(entity) &amp;&amp; (dialogOptions.canDelete || dialogOptions.canQueryById || dialogOptions.canUpdate || dialogOptions.selectedDomainOperationIds.length &gt; 0)) {
        await dialogService.warn(`Partial CQRS Operation Creation.
Some CQRS operations were created successfully, but was limited due to no Primary Key on entity '${entity.getName()}'.

To avoid this limitation in the future, model a Primary Key on the entity.`);
    }
}
function hasConstructor(entity) {
    return entity.getChildren("Class Constructor").length &gt; 0;
}
function entityHasPrimaryKey(entity) {
    const primaryKeys = DomainHelper.getPrimaryKeys(entity);
    return primaryKeys.length &gt; 0;
}
/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
;
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    /**
     * Returns true if the attribute is a foreign key on a compositional one-to-many relationship (i.e. is managed by the DB and should not be set).
     * @param attribute
     * @returns
     */
    static isManagedForeignKey(attribute) {
        var _a, _b;
        let fkAssociation = (_b = (_a = attribute.getStereotype("Foreign Key")) === null || _a === void 0 ? void 0 : _a.getProperty("Association")) === null || _b === void 0 ? void 0 : _b.getSelected();
        return fkAssociation != null &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsCollection() &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsNullable();
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
    static getOwningAggregateRecursive(entity) {
        let owners = DomainHelper.getOwnersRecursive(entity);
        if (owners.length == 0)
            return null;
        const uniqueIds = new Set(owners.map(item =&gt; item.id));
        if (uniqueIds.size !== 1) {
            throw new Error(`Entity : '${entity.getName()}' has more than 1 owner.`);
        }
        return owners[0];
    }
    static getOwnersRecursive(entity) {
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let results = entity.getAssociations("Association").filter(x =&gt; DomainHelper.isOwnedByAssociation(x));
        let result = [];
        for (let i = 0; i &lt; results.length; i++) {
            let owner = results[i].typeReference.getType();
            if (DomainHelper.isAggregateRoot(owner)) {
                result.push(owner);
            }
            else {
                result.push(...DomainHelper.getOwnersRecursive(owner));
            }
        }
        return result;
    }
    static isOwnedByAssociation(association) {
        return association.isSourceEnd() &amp;&amp;
            !association.typeReference.isNullable &amp;&amp;
            !association.typeReference.isCollection;
    }
    static getOwningAggregateKeyChain(entity) {
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let results = entity.getAssociations("Association").filter(x =&gt; DomainHelper.isOwnedByAssociation(x));
        let result = [];
        if (results.length == 0)
            return result;
        let owner = results[0].typeReference.getType();
        let pks = DomainHelper.getPrimaryKeys(owner);
        pks.forEach(pk =&gt; {
            let attribute = lookup(pk.id);
            //expectedName would typically be CountryId if you have a Agg: Country with a Pk: Id
            let expectedName = attribute.getParent().getName();
            if (!attribute.getName().startsWith(expectedName)) {
                expectedName += attribute.getName();
            }
            else {
                expectedName = attribute.getName();
            }
            result.push({ attribute: attribute, expectedName: expectedName });
        });
        if (!DomainHelper.isAggregateRoot(owner)) {
            result.unshift(...DomainHelper.getOwningAggregateKeyChain(owner));
        }
        return result;
    }
}
/// &lt;reference path="common.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
class CrudCreationContext {
    constructor(element, dialogOptions, primaryKeys) {
        this.element = element;
        this.dialogOptions = dialogOptions;
        this.primaryKeys = primaryKeys;
    }
    hasPrimaryKey() {
        return this.primaryKeys.length &gt; 0;
    }
}
async function presentCrudOptionsDialog(preselectedClass) {
    let dialogResult = null;
    if (!preselectedClass) {
        dialogResult = await openCrudCreationDialog();
        if (!dialogResult) {
            return null;
        }
    }
    else {
        dialogResult = {
            selectedEntity: preselectedClass,
            canCreate: true,
            canUpdate: true,
            canQueryById: true,
            canQueryAll: true,
            canDelete: true,
            canDomain: true,
            selectedDomainOperationIds: []
        };
    }
    return dialogResult;
}
async function openCrudCreationDialog() {
    var _a, _b;
    let classes = lookupTypesOf("Class");
    if (classes.length == 0) {
        await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
        return null;
    }
    let dialogResult = await dialogService.openForm({
        title: "CRUD Creation Options",
        fields: [
            {
                id: "entityId",
                fieldType: "select",
                label: "Entity for CRUD operations",
                selectOptions: classes.map(x =&gt; {
                    return {
                        id: x.id,
                        description: x.getName(),
                        additionalInfo: getClassAdditionalInfo(x)
                    };
                }),
                isRequired: true
            },
            {
                id: "create",
                fieldType: "checkbox",
                label: "Create",
                value: "true",
                hint: "Generate the \"Create\" operation"
            },
            {
                id: "update",
                fieldType: "checkbox",
                label: "Update",
                value: "true",
                hint: "Generate the \"Update\" operation"
            },
            {
                id: "queryById",
                fieldType: "checkbox",
                label: "Query By Id",
                value: "true",
                hint: "Generate the \"Query By Id\" operation"
            },
            {
                id: "queryAll",
                fieldType: "checkbox",
                label: "Query All",
                value: "true",
                hint: "Generate the \"Query All\" operation"
            },
            {
                id: "delete",
                fieldType: "checkbox",
                label: "Delete",
                value: "true",
                hint: "Generate the \"Delete\" operation"
            },
            {
                id: "domain",
                fieldType: "checkbox",
                label: "Domain Operations",
                value: "true",
                hint: "Generate operations for Domain Entity operations"
            }
        ]
    });
    let foundEntity = lookup(dialogResult.entityId);
    var result = {
        selectedEntity: foundEntity,
        canCreate: dialogResult.create == "true",
        canUpdate: dialogResult.update == "true",
        canQueryById: dialogResult.queryById == "true",
        canQueryAll: dialogResult.queryAll == "true",
        canDelete: dialogResult.delete == "true",
        canDomain: dialogResult.domain == "true",
        selectedDomainOperationIds: []
    };
    if (result.canDomain &amp;&amp; foundEntity.getChildren("Operation").length &gt; 0) {
        dialogResult = await dialogService.openForm({
            title: "Select Domain Operations",
            fields: [
                {
                    id: "tree",
                    fieldType: "tree-view",
                    label: "Domain Operations",
                    hint: "Generate operations from selected domain entity operations",
                    treeViewOptions: {
                        rootId: foundEntity.id,
                        submitFormTriggers: ["double-click", "enter"],
                        isMultiSelect: true,
                        selectableTypes: [
                            {
                                specializationId: "Class",
                                autoExpand: true,
                                autoSelectChildren: false,
                                isSelectable: (x) =&gt; false
                            },
                            {
                                specializationId: "Operation",
                                isSelectable: (x) =&gt; true
                            }
                        ]
                    }
                }
            ]
        });
        result.selectedDomainOperationIds = (_b = (_a = dialogResult.tree) === null || _a === void 0 ? void 0 : _a.filter((x) =&gt; x != "0")) !== null &amp;&amp; _b !== void 0 ? _b : [];
    }
    return result;
    function getClassAdditionalInfo(element) {
        let aggregateEntity = DomainHelper.getOwningAggregate(element);
        let prefix = aggregateEntity ? `: ${aggregateEntity.getName()}  ` : "";
        return `${prefix}(${element.getParents().map(item =&gt; item.getName()).join("/")})`;
    }
}
/// &lt;reference path="attributeWithMapPath.ts" /&gt;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
ServicesConstants.dtoToDomainOperation = "8d1f6a8a-77c8-43a2-8e60-421559725419";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
class CrudConstants {
}
CrudConstants.mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
CrudConstants.mapToDomainConstructorForDtosSettingId = "8d1f6a8a-77c8-43a2-8e60-421559725419";
CrudConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class CrudHelper {
    // Super basic selection dialog.
    static async openBasicSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; CrudHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: getFriendlyDisplayNameForClassSelection(x),
            additionalInfo: `(${x.getParents().map(item =&gt; item.getName()).join("/")})`
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
        function getFriendlyDisplayNameForClassSelection(element) {
            let aggregateEntity = DomainHelper.getOwningAggregate(element);
            return !aggregateEntity ? element.getName() : `${element.getName()} (${aggregateEntity.getName()})`;
        }
    }
    static async openCrudCreationDialog(options) {
        var _a, _b;
        let classes = lookupTypesOf("Class").filter(x =&gt; CrudHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let dialogResult = await dialogService.openForm({
            title: "CRUD Creation Options",
            fields: [
                {
                    id: "entityId",
                    fieldType: "select",
                    label: "Entity for CRUD operations",
                    selectOptions: classes.map(x =&gt; {
                        return {
                            id: x.id,
                            description: x.getName(),
                            additionalInfo: getClassAdditionalInfo(x)
                        };
                    }),
                    isRequired: true
                },
                {
                    id: "create",
                    fieldType: "checkbox",
                    label: "Create",
                    value: "true",
                    hint: "Generate the \"Create\" operation"
                },
                {
                    id: "update",
                    fieldType: "checkbox",
                    label: "Update",
                    value: "true",
                    hint: "Generate the \"Update\" operation"
                },
                {
                    id: "queryById",
                    fieldType: "checkbox",
                    label: "Query By Id",
                    value: "true",
                    hint: "Generate the \"Query By Id\" operation"
                },
                {
                    id: "queryAll",
                    fieldType: "checkbox",
                    label: "Query All",
                    value: "true",
                    hint: "Generate the \"Query All\" operation"
                },
                {
                    id: "delete",
                    fieldType: "checkbox",
                    label: "Delete",
                    value: "true",
                    hint: "Generate the \"Delete\" operation"
                },
                {
                    id: "domain",
                    fieldType: "checkbox",
                    label: "Domain Operations",
                    value: "true",
                    hint: "Generate operations for Domain Entity operations"
                }
            ]
        });
        let foundEntity = lookup(dialogResult.entityId);
        var result = {
            selectedEntity: foundEntity,
            canCreate: dialogResult.create == "true",
            canUpdate: dialogResult.update == "true",
            canQueryById: dialogResult.queryById == "true",
            canQueryAll: dialogResult.queryAll == "true",
            canDelete: dialogResult.delete == "true",
            canDomain: dialogResult.domain == "true",
            selectedDomainOperationIds: []
        };
        if (result.canDomain &amp;&amp; foundEntity.getChildren("Operation").length &gt; 0) {
            dialogResult = await dialogService.openForm({
                title: "Select Domain Operations",
                fields: [
                    {
                        id: "tree",
                        fieldType: "tree-view",
                        label: "Domain Operations",
                        hint: "Generate operations from selected domain entity operations",
                        treeViewOptions: {
                            rootId: foundEntity.id,
                            submitFormTriggers: ["double-click", "enter"],
                            isMultiSelect: true,
                            selectableTypes: [
                                {
                                    specializationId: "Class",
                                    autoExpand: true,
                                    autoSelectChildren: false,
                                    isSelectable: (x) =&gt; false
                                },
                                {
                                    specializationId: "Operation",
                                    isSelectable: (x) =&gt; true
                                }
                            ]
                        }
                    }
                ]
            });
            result.selectedDomainOperationIds = (_b = (_a = dialogResult.tree) === null || _a === void 0 ? void 0 : _a.filter((x) =&gt; x != "0")) !== null &amp;&amp; _b !== void 0 ? _b : [];
        }
        return result;
        function getClassAdditionalInfo(element) {
            let aggregateEntity = DomainHelper.getOwningAggregate(element);
            let prefix = aggregateEntity ? `: ${aggregateEntity.getName()}  ` : "";
            return `${prefix}(${element.getParents().map(item =&gt; item.getName()).join("/")})`;
        }
    }
    static filterClassSelection(element, options) {
        var _a;
        if (!((_a = options === null || options === void 0 ? void 0 : options.allowAbstract) !== null &amp;&amp; _a !== void 0 ? _a : false) &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return CrudHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false, allowAbstract: true });
        }
        return false;
    }
    static getName(command, mappedElement, dtoPrefix = null) {
        if (mappedElement.typeReference != null)
            mappedElement = mappedElement.typeReference.getType();
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        if (dtoPrefix)
            dtoName = `${dtoPrefix}${dtoName}`;
        return dtoName;
    }
    static getOrCreateCrudDto(dtoName, mappedElement, autoAddPrimaryKey, mappingTypeSettingId, folder, inbound = false) {
        let dto = CrudHelper.getOrCreateDto(dtoName, folder);
        //dtoField.typeReference.setType(dto.id);
        const entityCtor = mappedElement
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (inbound &amp;&amp; entityCtor != null) {
            dto.setMapping([mappedElement.id, entityCtor.id], CrudConstants.mapToDomainConstructorForDtosSettingId);
            CrudHelper.addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto, folder);
        }
        else {
            dto.setMapping(mappedElement.id, mappingTypeSettingId);
            CrudHelper.addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder);
        }
        return dto;
    }
    static getOrCreateDto(elementName, parentElement) {
        const expectedDtoName = elementName.replace(/Dto$/, "") + "Dto";
        let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
        if (existingDto) {
            return existingDto;
        }
        let dto = createElement("DTO", expectedDtoName, parentElement.id);
        return dto;
    }
    static addDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto, folder) {
        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        childrenToAdd.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
            field.setMapping(e.mapPath);
            if (DomainHelper.isComplexTypeById(e.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(e.typeId);
            }
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
        });
        dto.collapse();
    }
    static addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder) {
        var _a, _b;
        let dtoUpdated = false;
        let domainElement = mappedElement;
        let attributesWithMapPaths = CrudHelper.getAttributesWithMapPath(domainElement);
        let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
        for (var keyName of Object.keys(attributesWithMapPaths)) {
            let entry = attributesWithMapPaths[keyName];
            if (isCreateMode &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {
                continue;
            }
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                continue;
            }
            let field = createElement("DTO-Field", entry.name, dto.id);
            field.setMapping(entry.mapPath);
            if (DomainHelper.isComplexTypeById(entry.typeId)) {
                let dtoName = dto.getName().replace(/Dto$/, "") + field.getName() + "Dto";
                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(entry.typeId);
            }
            field.typeReference.setIsNullable(entry.isNullable);
            field.typeReference.setIsCollection(entry.isCollection);
            dtoUpdated = true;
        }
        if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
            CrudHelper.addPrimaryKeys(dto, domainElement, true);
        }
        if (dtoUpdated) {
            dto.collapse();
        }
    }
    static isOwnerForeignKey(attributeName, domainElement) {
        for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
            if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
                return true;
            }
        }
        return false;
    }
    static addPrimaryKeys(dto, entity, map) {
        const primaryKeys = CrudHelper.getPrimaryKeysWithMapPath(entity);
        for (const primaryKey of primaryKeys) {
            const name = CrudHelper.getDomainAttributeNameFormat(primaryKey.name);
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
                continue;
            }
            const dtoField = createElement("DTO-Field", CrudHelper.getFieldFormat(name), dto.id);
            dtoField.typeReference.setType(primaryKey.typeId);
            if (map &amp;&amp; primaryKey.mapPath != null) {
                console.log(`Doing mapping for ${dtoField.id}`);
                dtoField.setMapping(primaryKey.mapPath);
            }
        }
    }
    static getPrimaryKeysWithMapPath(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return Object.values(keydict);
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.isManagedForeignKey(x) &amp;&amp; // essentially also an attribute set by infrastructure
                !CrudHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return attrDict;
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !CrudHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static getDomainAttributeNameFormat(str) {
        let convention = CrudHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
            default:
                return str;
        }
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
}
class ElementManager {
    constructor(innerElement, settings) {
        var _a;
        this.innerElement = innerElement;
        this.settings = settings;
        this.mappedElement = (_a = innerElement.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.innerElement.id; }
    ;
    setReturnType(typeId, isCollection, isNullable) {
        this.innerElement.typeReference.setType(typeId);
        if (isCollection != null) {
            this.innerElement.typeReference.setIsCollection(isCollection);
        }
        if (isNullable != null) {
            this.innerElement.typeReference.setIsNullable(isNullable);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let existingField = this.innerElement.getChildren(this.settings.childSpecialization)
            .find(c =&gt; { var _a; return c.getName().toLowerCase() == ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property").toLowerCase(); });
        let field = existingField !== null &amp;&amp; existingField !== void 0 ? existingField : createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.innerElement.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.innerElement.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.innerElement;
    }
    collapse() {
        this.innerElement.collapse();
    }
}
/// &lt;reference path="common.ts" /&gt;
var MappingType;
(function (MappingType) {
    MappingType[MappingType["Navigation"] = 1] = "Navigation";
    MappingType[MappingType["TypeMap"] = 2] = "TypeMap";
})(MappingType || (MappingType = {}));
class EntityProjector {
    addMapping(type, sourceRelative, targetRelative, changeCurrent = false) {
        let result = { targetPops: 0, sourcePops: 0 };
        this.mappings.push({ type: type, sourcePath: this.sourcePath.concat(sourceRelative), targetPath: this.targetPath.concat(targetRelative), targetPropertyStart: targetRelative[0] });
        if (type == MappingType.Navigation &amp;&amp; changeCurrent) {
            this.sourcePath.push(...sourceRelative);
            this.targetPath.push(...targetRelative);
            result.sourcePops = sourceRelative.length;
            result.targetPops = targetRelative.length;
        }
        return result;
    }
    popMapping(pops) {
        for (let i = 0; i &lt; pops.sourcePops; i++) {
            this.sourcePath.pop();
        }
        for (let i = 0; i &lt; pops.targetPops; i++) {
            this.targetPath.pop();
        }
    }
    constructor() {
        this.mappings = [];
        this.sourcePath = []; //Dto
        this.targetPath = []; //Entity
        this.isChild = false;
        this.addMandatoryRelationships = false;
    }
    getMappings() {
        return this.mappings;
    }
    getTarget() {
        return this.target;
    }
    getEntityConstructor(entity) {
        return entity
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
    }
    createOrGetCreateCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = this.getBaseNameForElement(owningAggregate, entity, false);
        const commandName = `Create${baseName}Command`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == commandName);
        if (existing) {
            return existing;
        }
        this.addMandatoryRelationships = true;
        let dto = this.getOrCreateElement(commandName, "Command", folder);
        this.sourcePath.push(dto.id);
        this.targetPath.push(entity.id);
        const entityCtor = this.getEntityConstructor(entity);
        if (entityCtor != null) {
            entity = entityCtor;
            this.targetPath.push(entityCtor.id);
        }
        //Not this is the entity or the ctor depending
        this.target = entity;
        let result = this.populateContract(dto, entity, true, folder);
        return result;
    }
    createOrGetCallOperation(operation, entity, folder) {
        let operationName = operation.getName();
        operationName = removeSuffix(operationName, "Async");
        operationName = toPascalCase(operationName);
        const commandName = `${operationName}${entity.getName()}Command`;
        const existing = folder.getChildren().find(x =&gt; x.getName() == commandName);
        if (existing) {
            return existing;
        }
        let dto = this.getOrCreateElement(commandName, "Command", folder);
        this.sourcePath.push(dto.id);
        this.targetPath.push(entity.id);
        this.targetPath.push(operation.id);
        //Not this is the entity or the ctor depending
        this.target = operation;
        let result = this.populateContract(dto, operation, false, folder);
        return result;
    }
    createOrGetUpdateCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = this.getBaseNameForElement(owningAggregate, entity, false);
        const commandName = `Update${baseName}Command`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == commandName);
        if (existing) {
            return existing;
        }
        let dto = this.getOrCreateElement(commandName, "Command", folder);
        this.addMandatoryRelationships = true;
        this.sourcePath.push(dto.id);
        this.targetPath.push(entity.id);
        this.target = entity;
        let result = this.populateContract(dto, entity, false, folder);
        return result;
    }
    createOrGetDeleteCommand(entity, folder) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = this.getBaseNameForElement(owningAggregate, entity, false);
        const commandName = `Delete${baseName}Command`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == commandName);
        if (existing) {
            return existing;
        }
        let dto = this.getOrCreateElement(commandName, "Command", folder);
        let attributes = this.getAttributesWithMapPath(entity, (x) =&gt; x.hasStereotype("Primary Key"));
        this.addDtoFieldsInternal(attributes, false, entity, dto, folder, true);
        dto.collapse();
        return dto;
    }
    createOrGetFindByIdQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = this.getBaseNameForElement(owningAggregate, entity, false);
        let expectedQueryName = `Get${baseName}ByIdQuery`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        if (existing) {
            return existing;
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        let attributes = this.getAttributesWithMapPath(entity, (x) =&gt; x.hasStereotype("Primary Key"));
        this.addDtoFieldsInternal(attributes, false, entity, query, folder, true);
        query.collapse();
        return query;
    }
    createOrGetFindAllQuery(entity, folder, resultDto) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = this.getBaseNameForElement(owningAggregate, entity, true);
        let expectedQueryName = `Get${baseName}Query`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);
        if (existing) {
            return existing;
        }
        let query = createElement("Query", expectedQueryName, folder.id);
        query.typeReference.setType(resultDto.id);
        query.typeReference.setIsCollection(true);
        query.collapse();
        return query;
    }
    createOrGetOperationDto(operationManager, entity, folder, createMode, inbound = false, addMandatoryRelationships = false) {
        let operation = operationManager.getElement();
        let dtoName = `${operation.getName()}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == dtoName);
        if (existing) {
            return existing;
        }
        this.addMandatoryRelationships = addMandatoryRelationships;
        let dto = this.getOrCreateElement(dtoName, "DTO", folder);
        let dtoParam = operationManager.addChild("dto", dto.id);
        this.sourcePath.push(operation.id);
        this.sourcePath.push(dtoParam.id);
        this.targetPath.push(entity.id);
        if (inbound) {
            const entityCtor = this.getEntityConstructor(entity);
            if (entityCtor != null) {
                entity = entityCtor;
                this.targetPath.push(entityCtor.id);
            }
        }
        //Not this is the entity or the ctor depending
        this.target = entity;
        let result = this.populateContract(dto, entity, createMode, folder);
        return result;
    }
    createOrGetDto(entity, folder, inbound = false) {
        let owningAggregate = DomainHelper.getOwningAggregate(entity);
        let baseName = this.getBaseNameForElement(owningAggregate, entity, false);
        let dtoName = `${baseName}Dto`;
        let existing = folder.getChildren().find(x =&gt; x.getName() == dtoName);
        if (existing) {
            return existing;
        }
        let dto = this.getOrCreateElement(dtoName, "DTO", folder);
        this.sourcePath.push(dto.id);
        this.targetPath.push(entity.id);
        if (inbound) {
            const entityCtor = this.getEntityConstructor(entity);
            if (entityCtor != null) {
                entity = entityCtor;
                this.targetPath.push(entityCtor.id);
            }
        }
        //Not this is the entity or the ctor depending
        this.target = entity;
        let result = this.populateContract(dto, entity, false, folder);
        return result;
    }
    populateContract(contract, entity, createMode, folder) {
        if (entity.specialization == "Class Constructor" || entity.specialization == "Operation") {
            this.addMapping(MappingType.TypeMap, [contract.id], [entity.id]);
            this.addDtoFieldsForCtor(createMode, entity, contract, folder);
        }
        else {
            this.addMapping(MappingType.TypeMap, [contract.id], [entity.id]);
            this.addDtoFields(createMode, entity, contract, folder, false);
        }
        return contract;
    }
    getOrCreateContract(elementName, elementType, entity, createMode, folder, inbound = false) {
        let dto = this.getOrCreateElement(elementName, elementType, folder);
        const entityCtor = entity
            .getChildren("Class Constructor")
            .sort((a, b) =&gt; {
            // In descending order:
            return b.getChildren("Parameter").length - a.getChildren("Parameter").length;
        })[0];
        if (inbound &amp;&amp; entityCtor != null) {
            this.addMapping(MappingType.TypeMap, [dto.id], [entity.id, entityCtor.id]);
            this.addDtoFieldsForCtor(createMode, entityCtor, dto, folder);
        }
        else {
            this.addMapping(MappingType.TypeMap, [dto.id], [entity.id]);
            this.addDtoFields(createMode, entity, dto, folder, inbound);
        }
        return dto;
    }
    addDtoFields(createMode, entity, dto, folder, inbound = false) {
        let dtoUpdated = false;
        let domainElement = entity;
        let attributesWithMapPaths = createMode ?
            this.getAttributesWithMapPath(domainElement, (x) =&gt; this.standardAttributeFilter(x) &amp;&amp; !this.generatedPKFilter(x)) :
            this.getAttributesWithMapPath(domainElement, this.standardAttributeFilter);
        this.addDtoFieldsInternal(attributesWithMapPaths, createMode, entity, dto, folder, inbound);
    }
    addDtoFieldsInternal(attributes, createMode, entity, dto, folder, inbound = false) {
        let dtoUpdated = false;
        let domainElement = entity;
        for (let keyName of Object.keys(attributes)) {
            let entry = attributes[keyName];
            if (createMode &amp;&amp; this.isChild == true &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {
                continue;
            }
            if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
                continue;
            }
            let field = createElement("DTO-Field", entry.name, dto.id);
            console.warn("Field : " + entry.name + " , mappath =" + entry.mapPath);
            let pops = this.addMapping(MappingType.Navigation, [field.id], entry.mapPath, DomainHelper.isComplexTypeById(entry.typeId));
            if (DomainHelper.isComplexTypeById(entry.typeId)) {
                let dtoName = dto.getName().replace(/(?:Dto|Command|Query)$/, "") + field.getName() + "Dto";
                let entityField = lookup(entry.id);
                let newDto = this.getOrCreateContract(dtoName, "DTO", entityField.typeReference.getType(), createMode, folder, inbound);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(entry.typeId);
            }
            this.popMapping(pops);
            field.typeReference.setIsNullable(entry.isNullable);
            field.typeReference.setIsCollection(entry.isCollection);
            dtoUpdated = true;
        }
        if (this.addMandatoryRelationships) {
            this.isChild = true;
            let requiredAssociations = DomainHelper.getMandatoryAssociationsWithMapPath(entity);
            for (let entry of requiredAssociations) {
                let field = createElement("DTO-Field", entry.name, dto.id);
                let pops = this.addMapping(MappingType.Navigation, [field.id], entry.mapPath, true);
                let dtoName = dto.getName().replace(/(?:Dto|Command|Query)$/, "") + field.getName() + "Dto";
                let entityField = lookup(entry.id);
                let newDto = this.getOrCreateContract(dtoName, "DTO", entityField.typeReference.getType(), createMode, folder, inbound);
                field.typeReference.setType(newDto.id);
                this.popMapping(pops);
                field.typeReference.setIsNullable(entry.isNullable);
                field.typeReference.setIsCollection(entry.isCollection);
                dtoUpdated = true;
            }
        }
        if (dtoUpdated) {
            dto.collapse();
        }
    }
    addDtoFieldsForCtor(createMode, ctor, dto, folder) {
        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, "Parameter").filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== "Domain Service");
        childrenToAdd.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (dto.getChildren("Parameter").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (ctor.getChildren("Parameter").some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = createElement("DTO-Field", toPascalCase(e.name), dto.id);
            let pops = this.addMapping(MappingType.Navigation, [field.id], e.mapPath, DomainHelper.isComplexTypeById(e.typeId));
            if (DomainHelper.isComplexTypeById(e.typeId)) {
                let dtoName = dto.getName().replace(/(?:Dto|Command|Query)$/, "") + field.getName() + "Dto";
                let entityField = lookup(e.id);
                let newDto = this.getOrCreateContract(dtoName, "DTO", entityField.typeReference.getType(), createMode, folder, false);
                field.typeReference.setType(newDto.id);
            }
            else {
                field.typeReference.setType(e.typeId);
            }
            this.popMapping(pops);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
        });
        dto.collapse();
    }
    getBaseNameForElement(owningAggregate, entity, entityIsMany) {
        // Keeping 'owningAggregate' in case we still need to use it as part of the name one day
        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());
        return entityName;
    }
    getOrCreateElement(elementName, elementType, parentElement) {
        let existingDto = parentElement.getChildren(elementType).filter(x =&gt; x.getName() === elementName)[0];
        if (existingDto) {
            return existingDto;
        }
        let dto = createElement(elementType, elementName, parentElement.id);
        return dto;
    }
    standardAttributeFilter(x) {
        var _a;
        return !CrudHelper.legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) !== "true"));
    }
    generatedPKFilter(x) {
        return x.hasStereotype("Primary Key") &amp;&amp; (!x.getStereotype("Primary Key").hasProperty("Data source") || x.getStereotype("Primary Key").getProperty("Data source").value != "User supplied");
    }
    getAttributesWithMapPath(entity, attributeFilter) {
        if (attributeFilter == null) {
            attributeFilter = (x) =&gt; this.standardAttributeFilter(x) &amp;&amp; !x.hasStereotype("Primary Key");
        }
        let attrDict = Object.create(null);
        let attributes = entity.getChildren("Attribute")
            .filter(attributeFilter);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return attrDict;
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute")
                .filter(attributeFilter);
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
}
/// &lt;reference path="common.ts" /&gt;
/// &lt;reference path="crud-dialog.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../../common/CrudHelper.ts" /&gt;
/// &lt;reference path="../../common/elementManager.ts" /&gt;
/// &lt;reference path="project-from-entity.ts" /&gt;
class CrudStrategy {
    constructor() {
        this.resultDto = null;
        this.owningAggregate = null;
        this.entity = null;
        this.context = null;
        this.targetFolder = null;
        this.primaryKeys = null;
    }
    async askUser(element, preselectedClass) {
        let dialogOptions = await presentCrudOptionsDialog(preselectedClass);
        if (dialogOptions == null || dialogOptions.selectedEntity == null)
            return null;
        const primaryKeys = DomainHelper.getPrimaryKeys(dialogOptions.selectedEntity);
        let context = new CrudCreationContext(element, dialogOptions, primaryKeys);
        return context;
    }
    getOrCreateEntityFolder(folderOrPackage, entity) {
        var _a;
        if (folderOrPackage.specialization == "Folder") {
            return element;
        }
        const folderName = this.getAggregateRootFolderName(entity);
        const folder = (_a = element.getChildren().find(x =&gt; x.getName() == pluralize(folderName))) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Folder", pluralize(folderName), element.id);
        return folder;
    }
    getAggregateRootFolderName(entity) {
        return pluralize(this.owningAggregate != null ? this.owningAggregate.getName() : entity.getName());
    }
    async execute(element, preselectedClass) {
        var _a;
        this.context = await this.askUser(element, preselectedClass);
        if (this.context == null)
            return;
        let dialogOptions = this.context.dialogOptions;
        this.entity = dialogOptions.selectedEntity;
        this.primaryKeys = this.context.primaryKeys;
        let hasPrimaryKey = this.context.hasPrimaryKey();
        if (!await this.validate()) {
            return;
        }
        this.owningAggregate = DomainHelper.getOwningAggregateRecursive(this.entity);
        this.targetFolder = this.getOrCreateEntityFolder(this.context.element, this.entity);
        this.initialize(this.context);
        if (dialogOptions.canQueryById || dialogOptions.canQueryAll) {
            let projector = new EntityProjector();
            this.resultDto = projector.createOrGetDto(this.entity, this.targetFolder);
            if (projector.getMappings().length &gt; 0) {
                this.addBasicMapping(projector.getMappings());
            }
            this.resultDto.collapse();
        }
        if ((!privateSettersOnly || hasConstructor(this.entity)) &amp;&amp; dialogOptions.canCreate) {
            let x = this.doCreate();
            if (this.owningAggregate != null) {
                this.AddAggregateKeys(x);
            }
            x.collapse();
        }
        if ((hasPrimaryKey &amp;&amp; !privateSettersOnly) &amp;&amp; dialogOptions.canUpdate) {
            let x = this.doUpdate();
            if (this.owningAggregate != null) {
                this.AddAggregateKeys(x);
            }
            x.collapse();
        }
        if (hasPrimaryKey &amp;&amp; dialogOptions.canQueryById) {
            let x = this.doGetById();
            if (this.owningAggregate != null) {
                this.AddAggregateKeys(x);
            }
            x.collapse();
        }
        if (dialogOptions.canQueryAll) {
            let x = this.doGetAll();
            if (this.owningAggregate != null) {
                this.AddAggregateKeys(x);
            }
            x.collapse();
        }
        if (hasPrimaryKey &amp;&amp; dialogOptions.canDelete) {
            let x = this.doDelete();
            if (this.owningAggregate != null) {
                this.AddAggregateKeys(x);
            }
            x.collapse();
        }
        if (dialogOptions.canDomain) {
            const operations = DomainHelper.getCommandOperations(this.entity);
            for (const operation of operations) {
                if (!this.context.dialogOptions.selectedDomainOperationIds.some(x =&gt; x == operation.id)) {
                    continue;
                }
                let operationResultDto = null;
                if (operation.typeReference != null) {
                    if (DomainHelper.isComplexType((_a = operation.typeReference) === null || _a === void 0 ? void 0 : _a.getType())) {
                        let projector2 = new EntityProjector();
                        let from = lookup(operation.typeReference.getTypeId());
                        operationResultDto = projector2.createOrGetDto(from, this.targetFolder);
                        if (projector2.getMappings().length &gt; 0) {
                            this.addBasicMapping(projector2.getMappings());
                        }
                    }
                }
                let x = this.doOperation(operation, operationResultDto);
                if (this.owningAggregate != null) {
                    this.AddAggregateKeys(x);
                }
                x.collapse();
            }
        }
        this.doAddDiagram();
        await notifyUserOfLimitations(dialogOptions.selectedEntity, dialogOptions);
    }
    async validate() {
        if (DomainHelper.getOwnersRecursive(this.entity).length &gt; 1) {
            const owners = DomainHelper.getOwnersRecursive(this.entity).map(item =&gt; item.getName()).join(", ");
            await dialogService.warn(`Entity has multiple owners.
The entity '${this.entity.getName()}' has multiple Aggregate owning it [${owners}].

Compositional Entities (black diamond) must have 1 owner. Please adjust the associations accordingly.`);
            return false;
        }
        return true;
    }
    doAdvancedMappingCreate(projector, source) {
        if (projector.getMappings().length &gt; 0) {
            let target = projector.getTarget();
            let action = createAssociation("Create Entity Action", source.id, target.id);
            let mapping = action.createAdvancedMapping(source.id, this.entity.id);
            mapping.addMappedEnd("Invocation Mapping", [source.id], [target.id]);
            this.addAdvancedMappingEnds("Data Mapping", source, mapping, projector.getMappings());
        }
    }
    doAdvancedMappingDelete(mappings, source) {
        if (mappings.length &gt; 0) {
            let action = createAssociation("Delete Entity Action", source.id, this.entity.id);
            let mapping = action.createAdvancedMapping(source.id, this.entity.id);
            this.addAdvancedMappingEnds("Filter Mapping", source, mapping, mappings);
        }
    }
    doAdvancedMappingGetById(mappings, source) {
        if (mappings.length &gt; 0) {
            let action = createAssociation("Query Entity Action", source.id, this.entity.id);
            let queryMapping = action.createAdvancedMapping(source.id, this.entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            this.addAdvancedMappingEnds("Filter Mapping", source, queryMapping, mappings);
        }
    }
    doAdvancedMappingUpdate(projector, source) {
        if (projector.getMappings().length &gt; 0) {
            let action = createAssociation("Update Entity Action", source.id, this.entity.id);
            //remove PKs from Update
            let updateMappingEnds = projector.getMappings().filter(x =&gt; {
                const last = x.targetPath[x.targetPath.length - 1];
                return !this.primaryKeys.some(pk =&gt; pk.id == last);
            });
            let queryMappingEnds = this.createQueryMappingEnds(source);
            // Query Entity Mapping
            let queryMapping = action.createAdvancedMapping(source.id, this.entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            this.addAdvancedMappingEnds("Filter Mapping", source, queryMapping, queryMappingEnds);
            // Update Entity Mapping
            let updateMapping = action.createAdvancedMapping(source.id, this.entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            this.addAdvancedMappingEnds("Data Mapping", source, updateMapping, updateMappingEnds);
        }
    }
    doAdvancedMappingGetAll(source) {
        let action = createAssociation("Query Entity Action", source.id, this.entity.id);
        action.typeReference.setIsCollection(true);
        action.createAdvancedMapping(source.id, this.entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
    }
    doAdvancedMappingCallOperation(projector, source) {
        if (projector.getMappings().length &gt; 0) {
            let target = projector.getTarget();
            let action = createAssociation("Update Entity Action", source.id, this.entity.id);
            //remove PKs from Update
            let updateMappingEnds = projector.getMappings().filter(x =&gt; {
                const last = x.targetPath[x.targetPath.length - 1];
                return !this.primaryKeys.some(pk =&gt; pk.id == last);
            });
            let queryMappingEnds = this.createQueryMappingEnds(source);
            // Query Entity Mapping
            let queryMapping = action.createAdvancedMapping(source.id, this.entity.id, "25f25af9-c38b-4053-9474-b0fabe9d7ea7");
            this.addAdvancedMappingEnds("Filter Mapping", source, queryMapping, queryMappingEnds);
            // Update Entity Mapping
            let updateMapping = action.createAdvancedMapping(source.id, this.entity.id, "01721b1a-a85d-4320-a5cd-8bd39247196a");
            updateMapping.addMappedEnd("Invocation Mapping", [source.id], [target.id]);
            this.addAdvancedMappingEnds("Data Mapping", source, updateMapping, updateMappingEnds);
        }
    }
    createQueryMappingEnds(source) {
        let queryMappingEnds = [];
        for (const pk of Object.values(this.primaryKeys)) {
            var dtoField = source.getChildren().find(x =&gt; x.getName() == pk.name);
            queryMappingEnds.push({ type: MappingType.Navigation, sourcePath: [dtoField.id], targetPath: pk.mapPath, targetPropertyStart: pk.mapPath[0] });
        }
        return queryMappingEnds;
    }
    addDiagram(whatToAdd, diagramFolder) {
        var _a;
        if (diagramFolder == null) {
            diagramFolder = this.targetFolder;
        }
        let entity = this.entity;
        if (DomainHelper.isAggregateRoot(entity)) {
            const aggregateRootFolderName = this.getAggregateRootFolderName(entity);
            const diagramElement = (_a = diagramFolder.getChildren("Diagram").find(x =&gt; x.getName() == aggregateRootFolderName)) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Diagram", aggregateRootFolderName, diagramFolder.id);
            diagramElement.loadDiagram();
            const diagram = getCurrentDiagram();
            diagram.layoutVisuals(whatToAdd, null, true);
        }
    }
    addBasicMapping(mappings) {
        mappings.forEach(m =&gt; {
            var _a;
            let dtoPart = lookup(m.sourcePath.slice(-1)[0]);
            //Work around for SetMapping clearing type in some scenarios.
            let previousType = (_a = dtoPart.typeReference) === null || _a === void 0 ? void 0 : _a.getTypeId();
            //Some property paths are multiple entries like "base.id"
            if (m.type == MappingType.Navigation) {
                //console.warn(m.type + ":" + m.sourcePath.map(x =&gt; lookup(x).getName()).join('.') + "-&gt;" + m.targetPath.map(x =&gt; lookup(x).getName()).join('.'));
                const index = m.targetPath.indexOf(m.targetPropertyStart);
                if (index === -1)
                    return; // value not found
                dtoPart.setMapping(m.targetPath.slice(index));
            }
            else {
                dtoPart.setMapping(m.targetPath.slice(-1)[0]);
            }
            if (previousType != null) {
                dtoPart.typeReference.setType(previousType);
            }
        });
    }
    addAdvancedMappingEnds(mappingType, element, mapping, mappings) {
        mappings.forEach(m =&gt; {
            var _a, _b, _c;
            if (m.type == MappingType.Navigation) {
                //console.warn(m.type + ":" + m.sourcePath.map(x =&gt; lookup(x).getName()).join('.') + "-&gt;" + m.targetPath.map(x =&gt; lookup(x).getName()).join('.'));
                let dtoPart = lookup(m.sourcePath.slice(-1)[0]);
                let mappedElementId = m.targetPath.slice(-1)[0];
                let element = lookup(mappedElementId);
                if (element.specialization == "Class Constructor") {
                    mapping.addMappedEnd("Invocation Mapping", [element.id], m.targetPath);
                }
                else {
                    if ((((_b = (_a = dtoPart.typeReference) === null || _a === void 0 ? void 0 : _a.getType()) === null || _b === void 0 ? void 0 : _b.specialization) != "DTO" || ((_c = dtoPart.typeReference) === null || _c === void 0 ? void 0 : _c.getIsCollection()))) {
                        mapping.addMappedEnd(mappingType, m.sourcePath, m.targetPath);
                    }
                }
            }
        });
    }
    AddAggregateKeys(element) {
        //Have to do the reverse so setOrder works
        let keys = DomainHelper.getOwningAggregateKeyChain(this.entity).reverse();
        keys.forEach((pk) =&gt; {
            if (!element.getChildren().some(x =&gt; x.getName().toLowerCase() == pk.expectedName.toLowerCase())) {
                let field = this.addMissingAggregateKey(element, pk.expectedName);
                field.typeReference.setType(pk.attribute.typeReference.getTypeId());
                field.setOrder(0);
            }
            else {
                let field = element.getChildren().find(x =&gt; x.getName().toLowerCase() == pk.expectedName.toLowerCase());
                field.setOrder(0);
            }
        });
    }
}
/// &lt;reference path="strategy-base.ts" /&gt;
class CQRSCrudStrategy extends CrudStrategy {
    initialize(context) {
    }
    doCreate() {
        let projector = new EntityProjector();
        let command = projector.createOrGetCreateCommand(this.entity, this.targetFolder);
        const surrogateKey = this.primaryKeys.length === 1;
        if (surrogateKey) {
            command.typeReference.setType(this.primaryKeys[0].typeId);
        }
        this.doAdvancedMappingCreate(projector, command);
        return command;
    }
    doUpdate() {
        let projector = new EntityProjector();
        let command = projector.createOrGetUpdateCommand(this.entity, this.targetFolder);
        this.doAdvancedMappingUpdate(projector, command);
        return command;
    }
    doDelete() {
        let projector = new EntityProjector();
        let command = projector.createOrGetDeleteCommand(this.entity, this.targetFolder);
        this.doAdvancedMappingDelete(projector.getMappings(), command);
        return command;
    }
    doGetById() {
        let projector = new EntityProjector();
        let query = projector.createOrGetFindByIdQuery(this.entity, this.targetFolder, this.resultDto);
        this.doAdvancedMappingGetById(projector.getMappings(), query);
        return query;
    }
    doGetAll() {
        let projector = new EntityProjector();
        let query = projector.createOrGetFindAllQuery(this.entity, this.targetFolder, this.resultDto);
        this.doAdvancedMappingGetAll(query);
        return query;
    }
    doOperation(operation, operationResultDto) {
        let projector = new EntityProjector();
        let command = projector.createOrGetCallOperation(operation, this.entity, this.targetFolder);
        if (operationResultDto) {
            command.typeReference.setType(operationResultDto.id);
        }
        this.doAdvancedMappingCallOperation(projector, command);
        return command;
    }
    doAddDiagram() {
        this.addDiagram(this.targetFolder);
    }
    addMissingAggregateKey(element, name) {
        return createElement("DTO-Field", name, element.id);
    }
}
/// &lt;reference path="strategy-base.ts" /&gt;
class TraditionalServicesStrategy extends CrudStrategy {
    initialize(context) {
        const intentPackage = element.getPackage();
        let entity = context.dialogOptions.selectedEntity;
        const serviceName = `${toPascalCase(pluralize(this.owningAggregate != null ? this.owningAggregate.getName() : entity.getName()))}Service`;
        const existingService = element.specialization == "Service" ? element : intentPackage.getChildren("Service").find(x =&gt; x.getName() == serviceName);
        this.service = existingService !== null &amp;&amp; existingService !== void 0 ? existingService : createElement("Service", serviceName, intentPackage.id);
    }
    doCreate() {
        let operationName = `Create${this.entity.getName()}`;
        const existing = this.operationExists(operationName);
        if (existing) {
            existing.typeReference.setType(this.primaryKeys[0].typeId);
            return existing;
        }
        let operationManager = new ElementManager(createElement("Operation", operationName, this.service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        let projector = new EntityProjector();
        projector.createOrGetOperationDto(operationManager, this.entity, this.targetFolder, true, true, true);
        if (this.primaryKeys.length == 1) {
            operationManager.setReturnType(this.primaryKeys[0].typeId);
        }
        this.doAdvancedMappingCreate(projector, operationManager.getElement());
        return operationManager.getElement();
    }
    doUpdate() {
        let operationName = `Update${this.entity.getName()}`;
        const existing = this.operationExists(operationName);
        if (existing)
            return existing;
        let operationManager = new ElementManager(createElement("Operation", operationName, this.service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        let operation = operationManager.getElement();
        for (const pk of Object.values(this.primaryKeys)) {
            var param = createElement("Parameter", pk.name, operation.id);
            param.typeReference.setType(pk.typeId);
        }
        let projector = new EntityProjector();
        projector.createOrGetOperationDto(operationManager, this.entity, this.targetFolder, true, true, true);
        this.doAdvancedMappingUpdate(projector, operationManager.getElement());
        return operationManager.getElement();
    }
    doDelete() {
        let operationName = `Delete${this.entity.getName()}`;
        const existing = this.operationExists(operationName);
        if (existing)
            return existing;
        let operation = createElement("Operation", operationName, this.service.id);
        let mappings = this.addPkParameters(operation);
        this.doAdvancedMappingDelete(mappings, operation);
        return operation;
    }
    doGetById() {
        let operationName = `Find${this.entity.getName()}ById`;
        const existing = this.operationExists(operationName);
        if (existing)
            return existing;
        let operation = createElement("Operation", operationName, this.service.id);
        let mappings = this.addPkParameters(operation);
        operation.typeReference.setType(this.resultDto.id);
        this.doAdvancedMappingGetById(mappings, operation);
        return operation;
    }
    doGetAll() {
        let operationName = `Find${pluralize(this.entity.getName())}`;
        const existing = this.operationExists(operationName);
        if (existing)
            return existing;
        let operation = createElement("Operation", operationName, this.service.id);
        operation.typeReference.setType(this.resultDto.id);
        operation.typeReference.setIsCollection(true);
        this.doAdvancedMappingGetAll(operation);
        return operation;
    }
    doOperation(domainOperation, operationResultDto) {
        let operationName = domainOperation.getName();
        const existing = this.operationExists(operationName);
        if (existing)
            return existing;
        let operationManager = new ElementManager(createElement("Operation", operationName, this.service.id), {
            childSpecialization: "Parameter",
            childType: "parameter"
        });
        let operation = operationManager.getElement();
        for (const pk of Object.values(this.primaryKeys)) {
            var param = createElement("Parameter", pk.name, operation.id);
            param.typeReference.setType(pk.typeId);
        }
        let projector = new EntityProjector();
        projector.createOrGetOperationDto(operationManager, domainOperation, this.targetFolder, false, true);
        if (operationResultDto) {
            operationManager.setReturnType(operationResultDto.id);
        }
        this.doAdvancedMappingCallOperation(projector, operationManager.getElement());
        return operation;
    }
    addPkParameters(operation) {
        let mappings = [];
        for (const pk of Object.values(this.primaryKeys)) {
            var param = createElement("Parameter", pk.name, operation.id);
            param.typeReference.setType(pk.typeId);
            mappings.push({ type: MappingType.Navigation, sourcePath: [param.id], targetPath: pk.mapPath, targetPropertyStart: pk.mapPath[0] });
        }
        return mappings;
    }
    operationExists(operationName) {
        return this.service.getChildren().find(x =&gt; x.getName() === operationName);
    }
    doAddDiagram() {
        this.addDiagram(this.service);
    }
    addMissingAggregateKey(element, name) {
        return createElement("Parameter", toCamelCase(name), element.id);
    }
}
/// &lt;reference path="strategy-cqrs.ts" /&gt;
/// &lt;reference path="strategy-traditional.ts" /&gt;
let CrudApi = {
    createCQRSService,
    createTraditionalService
};
async function createCQRSService(element, preselectedClass) {
    let strategy = new CQRSCrudStrategy();
    await strategy.execute(element, preselectedClass);
}
async function createTraditionalService(element, preselectedClass) {
    let strategy = new TraditionalServicesStrategy();
    await strategy.execute(element, preselectedClass);
}
</script>
    </script>
  </scripts>
</settings>