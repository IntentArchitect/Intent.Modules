<?xml version="1.0" encoding="utf-8"?>
<class id="d29e55e2-d02e-4866-a44b-0443c4086e8a" type="Suggestions Settings" typeId="f68b5446-19f2-402d-a940-f62b3a592906">
  <name>Suggestions</name>
  <display>Suggestions</display>
  <isAbstract>false</isAbstract>
  <sort-children>by-type-then-by-name</sort-children>
  <genericTypes />
  <isMapped>false</isMapped>
  <parentFolderId>f36cb21a-faf9-46ff-85e7-41f38345253d</parentFolderId>
  <packageId>bff48d8d-9246-4ad7-9dda-9703b7139b86</packageId>
  <packageName>Intent.Modelers.Services.DomainInteractions</packageName>
  <stereotypes />
  <metadata />
  <childElements>
    <childElement id="37ec0e16-56fb-41d1-8fa3-0bd70ecd084a" type="Suggestion" typeId="0c21ab10-e87b-4e88-ab44-38ea7adf514a">
      <name>Create CQRS Operation</name>
      <display>Create CQRS Operation: Operation</display>
      <isAbstract>false</isAbstract>
      <genericTypes />
      <typeReference id="944fd18c-86b6-48f0-b555-2b7a05254e90">
        <typeId>e042bb67-a1df-480c-9935-b26210f78591</typeId>
        <isNavigable>true</isNavigable>
        <isNullable>false</isNullable>
        <isCollection>false</isCollection>
        <isRequired>true</isRequired>
        <typePackageName>Intent.Modelers.Domain</typePackageName>
        <typePackageId>6572b98d-5e13-4d4b-9ffc-820057da974e</typePackageId>
        <stereotypes />
        <genericTypeParameters />
      </typeReference>
      <isMapped>false</isMapped>
      <parentFolderId>d29e55e2-d02e-4866-a44b-0443c4086e8a</parentFolderId>
      <packageId>bff48d8d-9246-4ad7-9dda-9703b7139b86</packageId>
      <packageName>Intent.Modelers.Services.DomainInteractions</packageName>
      <stereotypes>
        <stereotype stereotypeDefinitionId="daf7d9b3-9c10-4286-b30e-7edb2e62f10e" name="Settings">
          <addedByDefault>true</addedByDefault>
          <definitionPackageName>Intent.ModuleBuilder</definitionPackageName>
          <definitionPackageId>9972b2a9-b749-4bba-b5c8-824bf694c6ef</definitionPackageId>
          <properties>
            <property name="bd242929-b399-4d13-88c0-d046b7161d41" display="Locations" value="[&quot;Diagram&quot;,&quot;Model&quot;]" isActive="true" />
            <property name="8d51eb08-f4a9-4703-ba70-de87c9417d46" display="Filter Function" value="const callServiceOperationTargetEnd = &quot;093e5909-ffe4-4510-b3ea-532f30212f3c&quot;;&#xD;&#xA;let notMapped = lookupTypesOf(callServiceOperationTargetEnd).every(x =&gt; x.typeReference.getTypeId() != element.id)&#xD;&#xA;&#xD;&#xA;return application.isModuleInstalled(&quot;Intent.Modelers.Services.CQRS&quot;) &amp;&amp;&#xD;&#xA;    application.getSettings(&quot;0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad&quot;).getField(&quot;14bc1e98-930b-494c-97a9-5da4e1f3a5fa&quot;).value == &quot;advanced&quot;&#xD;&#xA;    &amp;&amp; element.getParent() &amp;&amp; element.getParent().specializationId == &quot;96ffceb2-a70a-4b69-869b-0df436c470c3&quot; // is a Repository&#xD;&#xA;    &amp;&amp; notMapped; // not already mapped" isActive="true" />
            <property name="ecb7abbb-0297-486e-bd99-cded3226d2a4" display="Display Function" value="" isActive="true" />
            <property name="bfd10a66-2f93-4ffd-bf35-633ff96e7e6c" display="Script" value="/// &lt;reference path=&quot;../../typings/elementmacro.context.api.d.ts&quot; /&gt;&#xD;&#xA;function getPackageSelectItemOptions(packages, packageTypeName) {&#xD;&#xA;    return {&#xD;&#xA;        items: packages,&#xD;&#xA;        getId(item) {&#xD;&#xA;            return item.id;&#xD;&#xA;        },&#xD;&#xA;        getDisplayName(item) {&#xD;&#xA;            return item.getName();&#xD;&#xA;        },&#xD;&#xA;        getItemNotFoundMessage(itemId) {&#xD;&#xA;            return `No ${packageTypeName} found with id &quot;${itemId}&quot;.`;&#xD;&#xA;        },&#xD;&#xA;        getNoItemsFoundMessage() {&#xD;&#xA;            return `No packages of type ${packageTypeName} could be found.`;&#xD;&#xA;        },&#xD;&#xA;    };&#xD;&#xA;}&#xD;&#xA;function getElementSelectItemOptions(elements, elementTypeName, relevantPackageTypeName) {&#xD;&#xA;    return {&#xD;&#xA;        items: elements,&#xD;&#xA;        getId(item) {&#xD;&#xA;            return item.id;&#xD;&#xA;        },&#xD;&#xA;        getDisplayName(item) {&#xD;&#xA;            return item.getName();&#xD;&#xA;        },&#xD;&#xA;        getItemNotFoundMessage(itemId) {&#xD;&#xA;            return `No &quot;${elementTypeName}&quot; found with id &quot;${itemId}&quot;.`;&#xD;&#xA;        },&#xD;&#xA;        getNoItemsFoundMessage() {&#xD;&#xA;            return `No Elements of type &quot;${elementTypeName}&quot; could be found. Please ensure that you have a reference to the ${relevantPackageTypeName} package and that at least one ${elementTypeName} exists in it.`;&#xD;&#xA;        },&#xD;&#xA;    };&#xD;&#xA;}&#xD;&#xA;/**&#xD;&#xA; * Dialog selection.&#xD;&#xA; * @param options For simplicity, use getPackageSelectItemOptions() or getElementSelectItemOptions()&#xD;&#xA; * @returns Selected item.&#xD;&#xA; */&#xD;&#xA;async function openSelectItemDialog(options) {&#xD;&#xA;    if (!options) {&#xD;&#xA;        throw new Error(&quot;Options are required for 'openSelectItemDialog'.&quot;);&#xD;&#xA;    }&#xD;&#xA;    let items = options.items;&#xD;&#xA;    if (items.length == 0) {&#xD;&#xA;        await dialogService.info(options.getNoItemsFoundMessage());&#xD;&#xA;        return null;&#xD;&#xA;    }&#xD;&#xA;    let itemId = await dialogService.lookupFromOptions(items.map(item =&gt; ({&#xD;&#xA;        id: options.getId(item),&#xD;&#xA;        name: options.getDisplayName(item)&#xD;&#xA;    })));&#xD;&#xA;    if (itemId == null) {&#xD;&#xA;        await dialogService.error(options.getItemNotFoundMessage(itemId));&#xD;&#xA;        return null;&#xD;&#xA;    }&#xD;&#xA;    let foundItem = items.filter(item =&gt; options.getId(item) === itemId)[0];&#xD;&#xA;    return foundItem;&#xD;&#xA;}&#xD;&#xA;;&#xD;&#xA;/// &lt;reference path=&quot;attributeWithMapPath.ts&quot; /&gt;&#xD;&#xA;class ServicesConstants {&#xD;&#xA;}&#xD;&#xA;ServicesConstants.dtoToEntityMappingId = &quot;942eae46-49f1-450e-9274-a92d40ac35fa&quot;; //&quot;01d74d4f-e478-4fde-a2f0-9ea92255f3c5&quot;;&#xD;&#xA;ServicesConstants.dtoFromEntityMappingId = &quot;1f747d14-681c-4a20-8c68-34223f41b825&quot;;&#xD;&#xA;ServicesConstants.dtoToDomainOperation = &quot;8d1f6a8a-77c8-43a2-8e60-421559725419&quot;;&#xD;&#xA;class ServicesHelper {&#xD;&#xA;    static addDtoFieldsFromDomain(dto, attributes) {&#xD;&#xA;        for (let key of attributes) {&#xD;&#xA;            if (dto &amp;&amp; !dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {&#xD;&#xA;                let field = createElement(&quot;DTO-Field&quot;, ServicesHelper.getFieldFormat(key.name), dto.id);&#xD;&#xA;                field.typeReference.setType(key.typeId);&#xD;&#xA;                if ((key.mapPath ?? []).length &gt; 0) {&#xD;&#xA;                    field.setMapping(key.mapPath);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getParameterFormat(str) {&#xD;&#xA;        return toCamelCase(str);&#xD;&#xA;    }&#xD;&#xA;    static getRoutingFormat(str) {&#xD;&#xA;        return pluralize(str);&#xD;&#xA;    }&#xD;&#xA;    static getFieldFormat(str) {&#xD;&#xA;        return toPascalCase(str);&#xD;&#xA;    }&#xD;&#xA;    static formatName(str, type) {&#xD;&#xA;        switch (type) {&#xD;&#xA;            case &quot;property&quot;:&#xD;&#xA;            case &quot;class&quot;:&#xD;&#xA;                return toPascalCase(str);&#xD;&#xA;            case &quot;parameter&quot;:&#xD;&#xA;                return toCamelCase(str);&#xD;&#xA;            default:&#xD;&#xA;                return str;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/**&#xD;&#xA; * Helper class to build up source and target mapping paths for&#xD;&#xA; * advanced mapping scenarios.&#xD;&#xA; *&#xD;&#xA; * @remarks&#xD;&#xA; *&#xD;&#xA; * Source Path and Target Path is maintained separately since not all mapping scenarios are&#xD;&#xA; * straightforward.&#xD;&#xA; *&#xD;&#xA; * @example&#xD;&#xA; *&#xD;&#xA; * When to Push/Pop the Paths&#xD;&#xA; *&#xD;&#xA;    let leftField = createField(...);&#xD;&#xA;&#xD;&#xA;    mappingStore.pushSourcePath(leftField.id);&#xD;&#xA;    mappingStore.pushTargetPath(rightField.id);&#xD;&#xA;&#xD;&#xA;    let leftFieldDto = replicateDto(rightField.typeReference.getType(), folder, mappingStore);&#xD;&#xA;&#xD;&#xA;    mappingStore.popSourcePath();&#xD;&#xA;    mappingStore.popTargetPath();&#xD;&#xA;&#xD;&#xA;    leftField.typeReference.setType(leftFieldDto.id);&#xD;&#xA; *&#xD;&#xA; * Adding mappings&#xD;&#xA; *&#xD;&#xA;    function replicateDto(existingDto: MacroApi.Context.IElementApi, ...) {&#xD;&#xA;        let newDto = createElement(&quot;DTO&quot;, existingDto.getName(), folder.id);&#xD;&#xA;        existingDto.getChildren(&quot;DTO-Field&quot;).forEach(existingField =&gt; {&#xD;&#xA;            let newField = createElement(&quot;DTO-Field&quot;, existingField.getName(), newDto.id);&#xD;&#xA;            // ...&#xD;&#xA;            mappingStore.addMapping(newField.id, existingField.id);&#xD;&#xA;            // ...&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA; */&#xD;&#xA;class MappingStore {&#xD;&#xA;    constructor() {&#xD;&#xA;        this.mappings = [];&#xD;&#xA;        this.sourcePath = [];&#xD;&#xA;        this.targetPath = [];&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Get all the recorded mapping entries&#xD;&#xA;     */&#xD;&#xA;    getMappings() {&#xD;&#xA;        return this.mappings;&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Keep track of this element id on the source end&#xD;&#xA;     * when navigating inside it's type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    pushSourcePath(id) {&#xD;&#xA;        this.sourcePath.push(id);&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Remove the last tracked element on the source path stack&#xD;&#xA;     * when done navigating down its type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    popSourcePath() {&#xD;&#xA;        this.sourcePath.pop();&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Keep track of this element id on the target end&#xD;&#xA;     * when navigating inside it's type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    pushTargetPath(id) {&#xD;&#xA;        this.targetPath.push(id);&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Remove the last tracked element on the target path stack&#xD;&#xA;     * when done navigating down its type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    popTargetPath() {&#xD;&#xA;        this.targetPath.pop();&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Record a mapping between a source element id and target element id.&#xD;&#xA;     * Target and Source path stack will be used to build up the whole path.&#xD;&#xA;     */&#xD;&#xA;    addMapping(sourceId, targetId) {&#xD;&#xA;        this.mappings.push({&#xD;&#xA;            sourcePath: this.sourcePath.concat([sourceId]),&#xD;&#xA;            targetPath: this.targetPath.concat([targetId])&#xD;&#xA;        });&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;class ElementManager {&#xD;&#xA;    constructor(innerElement, settings) {&#xD;&#xA;        this.innerElement = innerElement;&#xD;&#xA;        this.settings = settings;&#xD;&#xA;        this.mappedElement = innerElement.getMapping()?.getElement();&#xD;&#xA;    }&#xD;&#xA;    get id() { return this.innerElement.id; }&#xD;&#xA;    ;&#xD;&#xA;    setReturnType(typeId, isCollection, isNullable) {&#xD;&#xA;        this.innerElement.typeReference.setType(typeId);&#xD;&#xA;        if (isCollection != null) {&#xD;&#xA;            this.innerElement.typeReference.setIsCollection(isCollection);&#xD;&#xA;        }&#xD;&#xA;        if (isNullable != null) {&#xD;&#xA;            this.innerElement.typeReference.setIsNullable(isNullable);&#xD;&#xA;        }&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;    addChild(name, type) {&#xD;&#xA;        let existingField = this.innerElement.getChildren(this.settings.childSpecialization)&#xD;&#xA;            .find(c =&gt; c.getName().toLowerCase() == ServicesHelper.formatName(name, this.settings.childType ?? &quot;property&quot;).toLowerCase());&#xD;&#xA;        let field = existingField ?? createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, this.settings.childType ?? &quot;property&quot;), this.innerElement.id);&#xD;&#xA;        const typeReferenceDetails = type == null&#xD;&#xA;            ? null&#xD;&#xA;            : typeof (type) === &quot;string&quot;&#xD;&#xA;                ? { id: type, isNullable: false, isCollection: false }&#xD;&#xA;                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };&#xD;&#xA;        if (typeReferenceDetails != null) {&#xD;&#xA;            field.typeReference.setType(typeReferenceDetails.id);&#xD;&#xA;            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);&#xD;&#xA;            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);&#xD;&#xA;        }&#xD;&#xA;        return field;&#xD;&#xA;    }&#xD;&#xA;    addChildrenFrom(elements, options) {&#xD;&#xA;        let order = 0;&#xD;&#xA;        elements.forEach(e =&gt; {&#xD;&#xA;            if (e.mapPath != null) {&#xD;&#xA;                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let field = this.addChild(e.name, e.typeId);&#xD;&#xA;            field.typeReference.setIsCollection(e.isCollection);&#xD;&#xA;            field.typeReference.setIsNullable(e.isNullable);&#xD;&#xA;            if (options?.addToTop) {&#xD;&#xA;                field.setOrder(order++);&#xD;&#xA;            }&#xD;&#xA;            if (this.mappedElement != null &amp;&amp; e.mapPath) {&#xD;&#xA;                field.setMapping(e.mapPath);&#xD;&#xA;            }&#xD;&#xA;        });&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;    mapToElement(param1, mappingSettingsId) {&#xD;&#xA;        let elementIds;&#xD;&#xA;        let element;&#xD;&#xA;        if (Array.isArray(param1)) {&#xD;&#xA;            elementIds = param1;&#xD;&#xA;            element = lookup(elementIds[elementIds.length - 1]);&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            elementIds = [param1.id];&#xD;&#xA;            element = param1;&#xD;&#xA;        }&#xD;&#xA;        this.mappedElement = element;&#xD;&#xA;        this.innerElement.setMapping(elementIds, mappingSettingsId);&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;    getElement() {&#xD;&#xA;        return this.innerElement;&#xD;&#xA;    }&#xD;&#xA;    collapse() {&#xD;&#xA;        this.innerElement.collapse();&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;../../typings/elementmacro.context.api.d.ts&quot; /&gt;&#xD;&#xA;function getSurrogateKeyType() {&#xD;&#xA;    const commonTypes = {&#xD;&#xA;        guid: &quot;6b649125-18ea-48fd-a6ba-0bfff0d8f488&quot;,&#xD;&#xA;        long: &quot;33013006-E404-48C2-AC46-24EF5A5774FD&quot;,&#xD;&#xA;        int: &quot;fb0a362d-e9e2-40de-b6ff-5ce8167cbe74&quot;&#xD;&#xA;    };&#xD;&#xA;    const javaTypes = {&#xD;&#xA;        long: &quot;e9e575eb-f8de-4ce4-9838-2d09665a752d&quot;,&#xD;&#xA;        int: &quot;b3e5cb3b-8a26-4346-810b-9789afa25a82&quot;&#xD;&#xA;    };&#xD;&#xA;    const typeNameToIdMap = new Map();&#xD;&#xA;    typeNameToIdMap.set(&quot;guid&quot;, commonTypes.guid);&#xD;&#xA;    typeNameToIdMap.set(&quot;int&quot;, lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);&#xD;&#xA;    typeNameToIdMap.set(&quot;long&quot;, lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);&#xD;&#xA;    let typeName = application.getSettings(&quot;ac0a788e-d8b3-4eea-b56d-538608f1ded9&quot;)?.getField(&quot;Key Type&quot;)?.value ?? &quot;int&quot;;&#xD;&#xA;    if (typeNameToIdMap.has(typeName)) {&#xD;&#xA;        return typeNameToIdMap.get(typeName);&#xD;&#xA;    }&#xD;&#xA;    return typeNameToIdMap.get(&quot;guid&quot;);&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;getSurrogateKeyType.ts&quot;/&gt;&#xD;&#xA;/// &lt;reference path=&quot;attributeWithMapPath.ts&quot;/&gt;&#xD;&#xA;class DomainHelper {&#xD;&#xA;    static isAggregateRoot(element) {&#xD;&#xA;        let result = !element.getAssociations(&quot;Association&quot;)&#xD;&#xA;            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    static getCommandOperations(entity) {&#xD;&#xA;        const queryOperationNames = [&quot;Get&quot;, &quot;Find&quot;, &quot;Filter&quot;, &quot;Query&quot;, &quot;Is&quot;, &quot;Must&quot;, &quot;Can&quot;];&#xD;&#xA;        const operations = entity.getChildren(&quot;Operation&quot;).filter(operation =&gt; operation.typeReference.getType() == null ||&#xD;&#xA;            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));&#xD;&#xA;        return operations;&#xD;&#xA;    }&#xD;&#xA;    static isComplexType(element) {&#xD;&#xA;        return element?.specialization === &quot;Data Contract&quot; ||&#xD;&#xA;            element?.specialization === &quot;Value Object&quot; ||&#xD;&#xA;            element?.specialization === &quot;Class&quot;;&#xD;&#xA;    }&#xD;&#xA;    static isComplexTypeById(typeId) {&#xD;&#xA;        let element = lookup(typeId);&#xD;&#xA;        return DomainHelper.isComplexType(element);&#xD;&#xA;    }&#xD;&#xA;    static getOwningAggregate(entity) {&#xD;&#xA;        if (!entity || entity.specialization != &quot;Class&quot;) {&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;        let invalidAssociations = entity.getAssociations(&quot;Association&quot;).filter(x =&gt; x.typeReference.getType() == null);&#xD;&#xA;        if (invalidAssociations.length &gt; 0) {&#xD;&#xA;            console.warn(&quot;Invalid associations found:&quot;);&#xD;&#xA;            invalidAssociations.forEach(x =&gt; {&#xD;&#xA;                console.warn(&quot;Invalid associations: &quot; + x.getName());&#xD;&#xA;            });&#xD;&#xA;        }&#xD;&#xA;        let result = entity.getAssociations(&quot;Association&quot;)&#xD;&#xA;            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;&#xD;&#xA;            // Let's only target collections for now as part of the nested compositional crud support&#xD;&#xA;            // as one-to-one relationships are more expensive to address and possibly not going to&#xD;&#xA;            // be needed.&#xD;&#xA;            x.getOtherEnd().typeReference.isCollection)[0]?.typeReference.getType();&#xD;&#xA;        return result;&#xD;&#xA;        function isOwnedBy(association) {&#xD;&#xA;            return association.isSourceEnd() &amp;&amp;&#xD;&#xA;                !association.typeReference.isNullable &amp;&amp;&#xD;&#xA;                !association.typeReference.isCollection;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static ownerIsAggregateRoot(entity) {&#xD;&#xA;        let result = DomainHelper.getOwningAggregate(entity);&#xD;&#xA;        return result ? true : false;&#xD;&#xA;    }&#xD;&#xA;    static hasPrimaryKey(entity) {&#xD;&#xA;        let keys = entity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;        return keys.length &gt; 0;&#xD;&#xA;    }&#xD;&#xA;    static getPrimaryKeys(entity) {&#xD;&#xA;        if (!entity) {&#xD;&#xA;            throw new Error(&quot;entity not specified&quot;);&#xD;&#xA;        }&#xD;&#xA;        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);&#xD;&#xA;        return Object.values(primaryKeys);&#xD;&#xA;    }&#xD;&#xA;    static isUserSuppliedPrimaryKey(pk) {&#xD;&#xA;        if (pk == null)&#xD;&#xA;            return false;&#xD;&#xA;        if (!pk.hasStereotype(&quot;Primary Key&quot;))&#xD;&#xA;            return false;&#xD;&#xA;        var pkStereotype = pk.getStereotype(&quot;Primary Key&quot;);&#xD;&#xA;        if (!pkStereotype.hasProperty(&quot;Data source&quot;)) {&#xD;&#xA;            return false;&#xD;&#xA;        }&#xD;&#xA;        return pkStereotype.getProperty(&quot;Data source&quot;).value == &quot;User supplied&quot;;&#xD;&#xA;    }&#xD;&#xA;    static getPrimaryKeysMap(entity) {&#xD;&#xA;        let keydict = Object.create(null);&#xD;&#xA;        let keys = entity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;        keys.forEach(key =&gt; keydict[key.id] = {&#xD;&#xA;            id: key.id,&#xD;&#xA;            name: key.getName(),&#xD;&#xA;            typeId: key.typeReference.typeId,&#xD;&#xA;            mapPath: [key.id],&#xD;&#xA;            isNullable: false,&#xD;&#xA;            isCollection: false&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);&#xD;&#xA;        return keydict;&#xD;&#xA;        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {&#xD;&#xA;            if (!curEntity) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            let nextEntity = generalization.typeReference.getType();&#xD;&#xA;            let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;            baseKeys.forEach(key =&gt; {&#xD;&#xA;                keydict[key.id] = {&#xD;&#xA;                    id: key.id,&#xD;&#xA;                    name: key.getName(),&#xD;&#xA;                    typeId: key.typeReference.typeId,&#xD;&#xA;                    mapPath: generalizationStack.concat([key.id]),&#xD;&#xA;                    isNullable: key.typeReference.isNullable,&#xD;&#xA;                    isCollection: key.typeReference.isCollection&#xD;&#xA;                };&#xD;&#xA;            });&#xD;&#xA;            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getForeignKeys(entity, owningAggregate) {&#xD;&#xA;        if (!entity) {&#xD;&#xA;            throw new Error(&quot;entity not specified&quot;);&#xD;&#xA;        }&#xD;&#xA;        if (!owningAggregate) {&#xD;&#xA;            throw new Error(&quot;nestedCompOwner not specified&quot;);&#xD;&#xA;        }&#xD;&#xA;        // Use the new Associated property on the FK stereotype method for FK Attribute lookup&#xD;&#xA;        let foreignKeys = [];&#xD;&#xA;        for (let attr of entity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Foreign Key&quot;))) {&#xD;&#xA;            let associationId = attr.getStereotype(&quot;Foreign Key&quot;).getProperty(&quot;Association&quot;)?.getValue();&#xD;&#xA;            if (owningAggregate.getAssociations(&quot;Association&quot;).some(x =&gt; x.id == associationId)) {&#xD;&#xA;                foreignKeys.push(attr);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        // Backward compatible lookup method&#xD;&#xA;        if (foreignKeys.length == 0) {&#xD;&#xA;            let foundFk = entity.getChildren(&quot;Attribute&quot;)&#xD;&#xA;                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype(&quot;Foreign Key&quot;))[0];&#xD;&#xA;            if (foundFk) {&#xD;&#xA;                foreignKeys.push(foundFk);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return foreignKeys.map(x =&gt; ({&#xD;&#xA;            name: DomainHelper.getAttributeNameFormat(x.getName()),&#xD;&#xA;            typeId: x.typeReference.typeId,&#xD;&#xA;            id: x.id,&#xD;&#xA;            mapPath: [x.id],&#xD;&#xA;            isCollection: x.typeReference.isCollection,&#xD;&#xA;            isNullable: x.typeReference.isNullable,&#xD;&#xA;            element: x&#xD;&#xA;        }));&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Returns true if the attribute is a foreign key on a compositional one-to-many relationship (i.e. is managed by the DB and should not be set).&#xD;&#xA;     * @param attribute&#xD;&#xA;     * @returns&#xD;&#xA;     */&#xD;&#xA;    static isManagedForeignKey(attribute) {&#xD;&#xA;        let fkAssociation = attribute.getStereotype(&quot;Foreign Key&quot;)?.getProperty(&quot;Association&quot;)?.getSelected();&#xD;&#xA;        return fkAssociation != null &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsCollection() &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsNullable();&#xD;&#xA;    }&#xD;&#xA;    static getChildrenOfType(entity, type) {&#xD;&#xA;        let attrDict = Object.create(null);&#xD;&#xA;        let attributes = entity.getChildren(type);&#xD;&#xA;        attributes.forEach(attr =&gt; attrDict[attr.id] = {&#xD;&#xA;            id: attr.id,&#xD;&#xA;            name: attr.getName(),&#xD;&#xA;            typeId: attr.typeReference.typeId,&#xD;&#xA;            mapPath: [attr.id],&#xD;&#xA;            isNullable: attr.typeReference.isNullable,&#xD;&#xA;            isCollection: attr.typeReference.isCollection&#xD;&#xA;        });&#xD;&#xA;        return Object.values(attrDict);&#xD;&#xA;    }&#xD;&#xA;    static getAttributesWithMapPath(entity) {&#xD;&#xA;        let attrDict = Object.create(null);&#xD;&#xA;        let attributes = entity&#xD;&#xA;            .getChildren(&quot;Attribute&quot;)&#xD;&#xA;            .filter(x =&gt; !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp;&#xD;&#xA;            !DomainHelper.legacyPartitionKey(x) &amp;&amp;&#xD;&#xA;            (x[&quot;hasMetadata&quot;] &amp;&amp; (!x.hasMetadata(&quot;set-by-infrastructure&quot;) || x.getMetadata(&quot;set-by-infrastructure&quot;)?.toLocaleLowerCase() != &quot;true&quot;)));&#xD;&#xA;        attributes.forEach(attr =&gt; attrDict[attr.id] = {&#xD;&#xA;            id: attr.id,&#xD;&#xA;            name: attr.getName(),&#xD;&#xA;            typeId: attr.typeReference.typeId,&#xD;&#xA;            mapPath: [attr.id],&#xD;&#xA;            isNullable: false,&#xD;&#xA;            isCollection: false&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);&#xD;&#xA;        return Object.values(attrDict);&#xD;&#xA;        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {&#xD;&#xA;            if (!curEntity) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            let nextEntity = generalization.typeReference.getType();&#xD;&#xA;            let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp; !DomainHelper.legacyPartitionKey(x));&#xD;&#xA;            baseKeys.forEach(attr =&gt; {&#xD;&#xA;                attrDict[attr.id] = {&#xD;&#xA;                    id: attr.id,&#xD;&#xA;                    name: attr.getName(),&#xD;&#xA;                    typeId: attr.typeReference.typeId,&#xD;&#xA;                    mapPath: generalizationStack.concat([attr.id]),&#xD;&#xA;                    isNullable: attr.typeReference.isNullable,&#xD;&#xA;                    isCollection: attr.typeReference.isCollection&#xD;&#xA;                };&#xD;&#xA;            });&#xD;&#xA;            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getMandatoryAssociationsWithMapPath(entity) {&#xD;&#xA;        return traverseInheritanceHierarchy(entity, [], []);&#xD;&#xA;        function traverseInheritanceHierarchy(entity, results, generalizationStack) {&#xD;&#xA;            entity&#xD;&#xA;                .getAssociations(&quot;Association&quot;)&#xD;&#xA;                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;&#xD;&#xA;                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)&#xD;&#xA;                .forEach(association =&gt; {&#xD;&#xA;                return results.push({&#xD;&#xA;                    id: association.id,&#xD;&#xA;                    name: association.getName(),&#xD;&#xA;                    typeId: null,&#xD;&#xA;                    mapPath: generalizationStack.concat([association.id]),&#xD;&#xA;                    isNullable: false,&#xD;&#xA;                    isCollection: false&#xD;&#xA;                });&#xD;&#xA;            });&#xD;&#xA;            let generalizations = entity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return results;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getAttributeNameFormat(str) {&#xD;&#xA;        let convention = DomainHelper.getDomainAttributeNamingConvention();&#xD;&#xA;        switch (convention) {&#xD;&#xA;            case &quot;pascal-case&quot;:&#xD;&#xA;                return toPascalCase(str);&#xD;&#xA;            case &quot;camel-case&quot;:&#xD;&#xA;                return toCamelCase(str);&#xD;&#xA;        }&#xD;&#xA;        return str;&#xD;&#xA;    }&#xD;&#xA;    static getDomainAttributeNamingConvention() {&#xD;&#xA;        const domainSettingsId = &quot;c4d1e35c-7c0d-4926-afe0-18f17563ce17&quot;;&#xD;&#xA;        return application.getSettings(domainSettingsId)&#xD;&#xA;            ?.getField(&quot;Attribute Naming Convention&quot;)?.value ?? &quot;pascal-case&quot;;&#xD;&#xA;    }&#xD;&#xA;    static getSurrogateKeyType() {&#xD;&#xA;        return getSurrogateKeyType();&#xD;&#xA;    }&#xD;&#xA;    // Just in case someone still uses this convention. Used to filter out those attributes when mapping&#xD;&#xA;    // to domain entities that are within a Cosmos DB paradigm.&#xD;&#xA;    static legacyPartitionKey(attribute) {&#xD;&#xA;        return attribute.hasStereotype(&quot;Partition Key&quot;) &amp;&amp; attribute.getName() === &quot;PartitionKey&quot;;&#xD;&#xA;    }&#xD;&#xA;    static requiresForeignKey(associationEnd) {&#xD;&#xA;        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);&#xD;&#xA;    }&#xD;&#xA;    static isManyToVariantsOfOne(associationEnd) {&#xD;&#xA;        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;&#xD;&#xA;    }&#xD;&#xA;    static isSelfReferencingZeroToOne(associationEnd) {&#xD;&#xA;        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;&#xD;&#xA;            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;../../../typings/elementmacro.context.api.d.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/getSurrogateKeyType.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/attributeWithMapPath.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/domainHelper.ts&quot; /&gt;&#xD;&#xA;function getFieldFormat(str) {&#xD;&#xA;    return toPascalCase(str);&#xD;&#xA;}&#xD;&#xA;function getDomainAttributeNameFormat(str) {&#xD;&#xA;    let convention = getDomainAttributeNamingConvention();&#xD;&#xA;    switch (convention) {&#xD;&#xA;        case &quot;pascal-case&quot;:&#xD;&#xA;            return toPascalCase(str);&#xD;&#xA;        case &quot;camel-case&quot;:&#xD;&#xA;            return toCamelCase(str);&#xD;&#xA;        default:&#xD;&#xA;            return str;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;function getOrCreateDto(elementName, parentElement) {&#xD;&#xA;    const expectedDtoName = `${elementName}Dto`;&#xD;&#xA;    let existingDto = parentElement.getChildren(&quot;DTO&quot;).filter(x =&gt; x.getName() === expectedDtoName)[0];&#xD;&#xA;    if (existingDto) {&#xD;&#xA;        return existingDto;&#xD;&#xA;    }&#xD;&#xA;    let dto = createElement(&quot;DTO&quot;, expectedDtoName, parentElement.id);&#xD;&#xA;    return dto;&#xD;&#xA;}&#xD;&#xA;function ensureDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto) {&#xD;&#xA;    let childrenToAdd = DomainHelper.getChildrenOfType(ctor, &quot;Parameter&quot;).filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== &quot;Domain Service&quot;);&#xD;&#xA;    childrenToAdd.forEach(e =&gt; {&#xD;&#xA;        if (e.mapPath != null) {&#xD;&#xA;            if (dto.getChildren(&quot;Parameter&quot;).some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        else if (ctor.getChildren(&quot;Parameter&quot;).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;        let field = createElement(&quot;DTO-Field&quot;, e.name, dto.id);&#xD;&#xA;        field.typeReference.setType(e.typeId);&#xD;&#xA;        field.typeReference.setIsCollection(e.isCollection);&#xD;&#xA;        field.typeReference.setIsNullable(e.isNullable);&#xD;&#xA;        if (this.mappedElement != null &amp;&amp; e.mapPath) {&#xD;&#xA;            field.setMapping(e.mapPath);&#xD;&#xA;        }&#xD;&#xA;    });&#xD;&#xA;    dto.collapse();&#xD;&#xA;}&#xD;&#xA;function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {&#xD;&#xA;    let dtoUpdated = false;&#xD;&#xA;    let domainElement = mappedElement&#xD;&#xA;        .typeReference&#xD;&#xA;        .getType();&#xD;&#xA;    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);&#xD;&#xA;    let isCreateMode = dto.getMetadata(&quot;originalVerb&quot;)?.toLowerCase()?.startsWith(&quot;create&quot;) == true;&#xD;&#xA;    for (var keyName of Object.keys(attributesWithMapPaths)) {&#xD;&#xA;        let entry = attributesWithMapPaths[keyName];&#xD;&#xA;        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {&#xD;&#xA;            continue;&#xD;&#xA;        }&#xD;&#xA;        if (dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName() == entry.name)) {&#xD;&#xA;            continue;&#xD;&#xA;        }&#xD;&#xA;        let field = createElement(&quot;DTO-Field&quot;, toPascalCase(entry.name), dto.id);&#xD;&#xA;        field.typeReference.setType(entry.typeId);&#xD;&#xA;        field.typeReference.setIsNullable(entry.isNullable);&#xD;&#xA;        field.typeReference.setIsCollection(entry.isCollection);&#xD;&#xA;        field.setMapping(entry.mapPath);&#xD;&#xA;        dtoUpdated = true;&#xD;&#xA;    }&#xD;&#xA;    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {&#xD;&#xA;        addPrimaryKeys(dto, domainElement, true);&#xD;&#xA;    }&#xD;&#xA;    if (dtoUpdated) {&#xD;&#xA;        dto.collapse();&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;function isOwnerForeignKey(attributeName, domainElement) {&#xD;&#xA;    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {&#xD;&#xA;        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {&#xD;&#xA;            return true;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    return false;&#xD;&#xA;}&#xD;&#xA;function addPrimaryKeys(dto, entity, map) {&#xD;&#xA;    const primaryKeys = getPrimaryKeysWithMapPath(entity);&#xD;&#xA;    for (const primaryKey of primaryKeys) {&#xD;&#xA;        const name = getDomainAttributeNameFormat(primaryKey.name);&#xD;&#xA;        if (dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {&#xD;&#xA;            continue;&#xD;&#xA;        }&#xD;&#xA;        const dtoField = createElement(&quot;DTO-Field&quot;, getFieldFormat(name), dto.id);&#xD;&#xA;        dtoField.typeReference.setType(primaryKey.typeId);&#xD;&#xA;        if (map &amp;&amp; primaryKey.mapPath != null) {&#xD;&#xA;            console.log(`Doing mapping for ${dtoField.id}`);&#xD;&#xA;            dtoField.setMapping(primaryKey.mapPath);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;function getPrimaryKeysWithMapPath(entity) {&#xD;&#xA;    let keydict = Object.create(null);&#xD;&#xA;    let keys = entity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;    keys.forEach(key =&gt; keydict[key.id] = {&#xD;&#xA;        id: key.id,&#xD;&#xA;        name: key.getName(),&#xD;&#xA;        typeId: key.typeReference.typeId,&#xD;&#xA;        mapPath: [key.id],&#xD;&#xA;        isNullable: false,&#xD;&#xA;        isCollection: false&#xD;&#xA;    });&#xD;&#xA;    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);&#xD;&#xA;    return Object.values(keydict);&#xD;&#xA;    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {&#xD;&#xA;        if (!curEntity) {&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;        let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;        if (generalizations.length == 0) {&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;        let generalization = generalizations[0];&#xD;&#xA;        generalizationStack.push(generalization.id);&#xD;&#xA;        let nextEntity = generalization.typeReference.getType();&#xD;&#xA;        let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;        baseKeys.forEach(key =&gt; {&#xD;&#xA;            keydict[key.id] = {&#xD;&#xA;                id: key.id,&#xD;&#xA;                name: key.getName(),&#xD;&#xA;                typeId: key.typeReference.typeId,&#xD;&#xA;                mapPath: generalizationStack.concat([key.id]),&#xD;&#xA;                isNullable: key.typeReference.isNullable,&#xD;&#xA;                isCollection: key.typeReference.isCollection&#xD;&#xA;            };&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;function getAttributesWithMapPath(entity) {&#xD;&#xA;    let attrDict = Object.create(null);&#xD;&#xA;    let attributes = entity.getChildren(&quot;Attribute&quot;)&#xD;&#xA;        .filter(x =&gt; !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp;&#xD;&#xA;        !legacyPartitionKey(x) &amp;&amp;&#xD;&#xA;        (x[&quot;hasMetadata&quot;] &amp;&amp; (!x.hasMetadata(&quot;set-by-infrastructure&quot;) || x.getMetadata(&quot;set-by-infrastructure&quot;)?.toLocaleLowerCase() != &quot;true&quot;)));&#xD;&#xA;    attributes.forEach(attr =&gt; attrDict[attr.id] = {&#xD;&#xA;        id: attr.id,&#xD;&#xA;        name: attr.getName(),&#xD;&#xA;        typeId: attr.typeReference.typeId,&#xD;&#xA;        mapPath: [attr.id],&#xD;&#xA;        isNullable: false,&#xD;&#xA;        isCollection: false&#xD;&#xA;    });&#xD;&#xA;    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);&#xD;&#xA;    return attrDict;&#xD;&#xA;    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {&#xD;&#xA;        if (!curEntity) {&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;        let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;        if (generalizations.length == 0) {&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;        let generalization = generalizations[0];&#xD;&#xA;        generalizationStack.push(generalization.id);&#xD;&#xA;        let nextEntity = generalization.typeReference.getType();&#xD;&#xA;        let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp; !legacyPartitionKey(x));&#xD;&#xA;        baseKeys.forEach(attr =&gt; {&#xD;&#xA;            attrDict[attr.id] = {&#xD;&#xA;                id: attr.id,&#xD;&#xA;                name: attr.getName(),&#xD;&#xA;                typeId: attr.typeReference.typeId,&#xD;&#xA;                mapPath: generalizationStack.concat([attr.id]),&#xD;&#xA;                isNullable: attr.typeReference.isNullable,&#xD;&#xA;                isCollection: attr.typeReference.isCollection&#xD;&#xA;            };&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;function getDomainAttributeNamingConvention() {&#xD;&#xA;    const domainSettingsId = &quot;c4d1e35c-7c0d-4926-afe0-18f17563ce17&quot;;&#xD;&#xA;    return application.getSettings(domainSettingsId)&#xD;&#xA;        ?.getField(&quot;Attribute Naming Convention&quot;)?.value ?? &quot;pascal-case&quot;;&#xD;&#xA;}&#xD;&#xA;// Just in case someone still uses this convention. Used to filter out those attributes when mapping&#xD;&#xA;// to domain entities that are within a Cosmos DB paradigm.&#xD;&#xA;function legacyPartitionKey(attribute) {&#xD;&#xA;    return attribute.hasStereotype(&quot;Partition Key&quot;) &amp;&amp; attribute.getName() === &quot;PartitionKey&quot;;&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;../common/domainHelper.ts&quot; /&gt;&#xD;&#xA;class CrudConstants {&#xD;&#xA;}&#xD;&#xA;CrudConstants.mapFromDomainMappingSettingId = &quot;1f747d14-681c-4a20-8c68-34223f41b825&quot;;&#xD;&#xA;CrudConstants.mapToDomainConstructorForDtosSettingId = &quot;8d1f6a8a-77c8-43a2-8e60-421559725419&quot;;&#xD;&#xA;CrudConstants.dtoFromEntityMappingId = &quot;1f747d14-681c-4a20-8c68-34223f41b825&quot;;&#xD;&#xA;class CrudHelper {&#xD;&#xA;    // Super basic selection dialog.&#xD;&#xA;    static async openBasicSelectEntityDialog(options) {&#xD;&#xA;        let classes = lookupTypesOf(&quot;Class&quot;).filter(x =&gt; CrudHelper.filterClassSelection(x, options));&#xD;&#xA;        if (classes.length == 0) {&#xD;&#xA;            await dialogService.info(&quot;No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.&quot;);&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({&#xD;&#xA;            id: x.id,&#xD;&#xA;            name: getFriendlyDisplayNameForClassSelection(x),&#xD;&#xA;            additionalInfo: `(${x.getParents().map(item =&gt; item.getName()).join(&quot;/&quot;)})`&#xD;&#xA;        })));&#xD;&#xA;        if (classId == null) {&#xD;&#xA;            await dialogService.error(`No class found with id &quot;${classId}&quot;.`);&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;        let foundEntity = lookup(classId);&#xD;&#xA;        return foundEntity;&#xD;&#xA;        function getFriendlyDisplayNameForClassSelection(element) {&#xD;&#xA;            let aggregateEntity = DomainHelper.getOwningAggregate(element);&#xD;&#xA;            return !aggregateEntity ? element.getName() : `${element.getName()} (${aggregateEntity.getName()})`;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static async openCrudCreationDialog(options) {&#xD;&#xA;        let classes = lookupTypesOf(&quot;Class&quot;).filter(x =&gt; CrudHelper.filterClassSelection(x, options));&#xD;&#xA;        if (classes.length == 0) {&#xD;&#xA;            await dialogService.info(&quot;No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.&quot;);&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;        let dialogResult = await dialogService.openForm({&#xD;&#xA;            title: &quot;CRUD Creation Options&quot;,&#xD;&#xA;            fields: [&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;entityId&quot;,&#xD;&#xA;                    fieldType: &quot;select&quot;,&#xD;&#xA;                    label: &quot;Entity for CRUD operations&quot;,&#xD;&#xA;                    selectOptions: classes.map(x =&gt; {&#xD;&#xA;                        return {&#xD;&#xA;                            id: x.id,&#xD;&#xA;                            description: x.getName(),&#xD;&#xA;                            additionalInfo: getClassAdditionalInfo(x)&#xD;&#xA;                        };&#xD;&#xA;                    }),&#xD;&#xA;                    isRequired: true&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;create&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Create&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate the \&quot;Create\&quot; operation&quot;&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;update&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Update&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate the \&quot;Update\&quot; operation&quot;&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;queryById&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Query By Id&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate the \&quot;Query By Id\&quot; operation&quot;&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;queryAll&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Query All&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate the \&quot;Query All\&quot; operation&quot;&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;delete&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Delete&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate the \&quot;Delete\&quot; operation&quot;&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;domain&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Domain Operations&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate operations for Domain Entity operations&quot;&#xD;&#xA;                }&#xD;&#xA;            ]&#xD;&#xA;        });&#xD;&#xA;        let foundEntity = lookup(dialogResult.entityId);&#xD;&#xA;        var result = {&#xD;&#xA;            selectedEntity: foundEntity,&#xD;&#xA;            canCreate: dialogResult.create == &quot;true&quot;,&#xD;&#xA;            canUpdate: dialogResult.update == &quot;true&quot;,&#xD;&#xA;            canQueryById: dialogResult.queryById == &quot;true&quot;,&#xD;&#xA;            canQueryAll: dialogResult.queryAll == &quot;true&quot;,&#xD;&#xA;            canDelete: dialogResult.delete == &quot;true&quot;,&#xD;&#xA;            canDomain: dialogResult.domain == &quot;true&quot;,&#xD;&#xA;            selectedDomainOperationIds: []&#xD;&#xA;        };&#xD;&#xA;        if (result.canDomain &amp;&amp; foundEntity.getChildren(&quot;Operation&quot;).length &gt; 0) {&#xD;&#xA;            dialogResult = await dialogService.openForm({&#xD;&#xA;                title: &quot;Select Domain Operations&quot;,&#xD;&#xA;                fields: [&#xD;&#xA;                    {&#xD;&#xA;                        id: &quot;tree&quot;,&#xD;&#xA;                        fieldType: &quot;tree-view&quot;,&#xD;&#xA;                        label: &quot;Domain Operations&quot;,&#xD;&#xA;                        hint: &quot;Generate operations from selected domain entity operations&quot;,&#xD;&#xA;                        treeViewOptions: {&#xD;&#xA;                            rootId: foundEntity.id,&#xD;&#xA;                            submitFormTriggers: [&quot;double-click&quot;, &quot;enter&quot;],&#xD;&#xA;                            isMultiSelect: true,&#xD;&#xA;                            selectableTypes: [&#xD;&#xA;                                {&#xD;&#xA;                                    specializationId: &quot;Class&quot;,&#xD;&#xA;                                    autoExpand: true,&#xD;&#xA;                                    autoSelectChildren: false,&#xD;&#xA;                                    isSelectable: (x) =&gt; false&#xD;&#xA;                                },&#xD;&#xA;                                {&#xD;&#xA;                                    specializationId: &quot;Operation&quot;,&#xD;&#xA;                                    isSelectable: (x) =&gt; true&#xD;&#xA;                                }&#xD;&#xA;                            ]&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                ]&#xD;&#xA;            });&#xD;&#xA;            result.selectedDomainOperationIds = dialogResult.tree?.filter((x) =&gt; x != &quot;0&quot;) ?? [];&#xD;&#xA;        }&#xD;&#xA;        return result;&#xD;&#xA;        function getClassAdditionalInfo(element) {&#xD;&#xA;            let aggregateEntity = DomainHelper.getOwningAggregate(element);&#xD;&#xA;            let prefix = aggregateEntity ? `: ${aggregateEntity.getName()}  ` : &quot;&quot;;&#xD;&#xA;            return `${prefix}(${element.getParents().map(item =&gt; item.getName()).join(&quot;/&quot;)})`;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static filterClassSelection(element, options) {&#xD;&#xA;        if (!(options?.allowAbstract ?? false) &amp;&amp; element.getIsAbstract()) {&#xD;&#xA;            return false;&#xD;&#xA;        }&#xD;&#xA;        if (element.hasStereotype(&quot;Repository&quot;)) {&#xD;&#xA;            return true;&#xD;&#xA;        }&#xD;&#xA;        if (options?.includeOwnedRelationships != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {&#xD;&#xA;            return DomainHelper.hasPrimaryKey(element);&#xD;&#xA;        }&#xD;&#xA;        if (DomainHelper.isAggregateRoot(element)) {&#xD;&#xA;            let generalizations = element.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return true;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            let parentEntity = generalization.typeReference.getType();&#xD;&#xA;            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack&#xD;&#xA;            return CrudHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false, allowAbstract: true });&#xD;&#xA;        }&#xD;&#xA;        return false;&#xD;&#xA;    }&#xD;&#xA;    static getName(command, mappedElement, dtoPrefix = null) {&#xD;&#xA;        if (mappedElement.typeReference != null)&#xD;&#xA;            mappedElement = mappedElement.typeReference.getType();&#xD;&#xA;        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];&#xD;&#xA;        let domainName = mappedElement.getName();&#xD;&#xA;        let baseName = command.getMetadata(&quot;baseName&quot;)&#xD;&#xA;            ? `${command.getMetadata(&quot;baseName&quot;)}${domainName}`&#xD;&#xA;            : domainName;&#xD;&#xA;        let dtoName = `${originalVerb}${baseName}`;&#xD;&#xA;        if (dtoPrefix)&#xD;&#xA;            dtoName = `${dtoPrefix}${dtoName}`;&#xD;&#xA;        return dtoName;&#xD;&#xA;    }&#xD;&#xA;    static getOrCreateCrudDto(dtoName, mappedElement, autoAddPrimaryKey, mappingTypeSettingId, folder, inbound = false) {&#xD;&#xA;        let dto = CrudHelper.getOrCreateDto(dtoName, folder);&#xD;&#xA;        //dtoField.typeReference.setType(dto.id);&#xD;&#xA;        const entityCtor = mappedElement&#xD;&#xA;            .getChildren(&quot;Class Constructor&quot;)&#xD;&#xA;            .sort((a, b) =&gt; {&#xD;&#xA;            // In descending order:&#xD;&#xA;            return b.getChildren(&quot;Parameter&quot;).length - a.getChildren(&quot;Parameter&quot;).length;&#xD;&#xA;        })[0];&#xD;&#xA;        if (inbound &amp;&amp; entityCtor != null) {&#xD;&#xA;            dto.setMapping([mappedElement.id, entityCtor.id], CrudConstants.mapToDomainConstructorForDtosSettingId);&#xD;&#xA;            CrudHelper.addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto, folder);&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            dto.setMapping(mappedElement.id, mappingTypeSettingId);&#xD;&#xA;            CrudHelper.addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder);&#xD;&#xA;        }&#xD;&#xA;        return dto;&#xD;&#xA;    }&#xD;&#xA;    static getOrCreateDto(elementName, parentElement) {&#xD;&#xA;        const expectedDtoName = elementName.replace(/Dto$/, &quot;&quot;) + &quot;Dto&quot;;&#xD;&#xA;        let existingDto = parentElement.getChildren(&quot;DTO&quot;).filter(x =&gt; x.getName() === expectedDtoName)[0];&#xD;&#xA;        if (existingDto) {&#xD;&#xA;            return existingDto;&#xD;&#xA;        }&#xD;&#xA;        let dto = createElement(&quot;DTO&quot;, expectedDtoName, parentElement.id);&#xD;&#xA;        return dto;&#xD;&#xA;    }&#xD;&#xA;    static addDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto, folder) {&#xD;&#xA;        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, &quot;Parameter&quot;).filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== &quot;Domain Service&quot;);&#xD;&#xA;        childrenToAdd.forEach(e =&gt; {&#xD;&#xA;            if (e.mapPath != null) {&#xD;&#xA;                if (dto.getChildren(&quot;Parameter&quot;).some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            else if (ctor.getChildren(&quot;Parameter&quot;).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let field = createElement(&quot;DTO-Field&quot;, toPascalCase(e.name), dto.id);&#xD;&#xA;            field.setMapping(e.mapPath);&#xD;&#xA;            if (DomainHelper.isComplexTypeById(e.typeId)) {&#xD;&#xA;                let dtoName = dto.getName().replace(/Dto$/, &quot;&quot;) + field.getName() + &quot;Dto&quot;;&#xD;&#xA;                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);&#xD;&#xA;                field.typeReference.setType(newDto.id);&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                field.typeReference.setType(e.typeId);&#xD;&#xA;            }&#xD;&#xA;            field.typeReference.setIsCollection(e.isCollection);&#xD;&#xA;            field.typeReference.setIsNullable(e.isNullable);&#xD;&#xA;        });&#xD;&#xA;        dto.collapse();&#xD;&#xA;    }&#xD;&#xA;    static addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder) {&#xD;&#xA;        let dtoUpdated = false;&#xD;&#xA;        let domainElement = mappedElement;&#xD;&#xA;        let attributesWithMapPaths = CrudHelper.getAttributesWithMapPath(domainElement);&#xD;&#xA;        let isCreateMode = dto.getMetadata(&quot;originalVerb&quot;)?.toLowerCase()?.startsWith(&quot;create&quot;) == true;&#xD;&#xA;        for (var keyName of Object.keys(attributesWithMapPaths)) {&#xD;&#xA;            let entry = attributesWithMapPaths[keyName];&#xD;&#xA;            if (isCreateMode &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            if (dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName() == entry.name)) {&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            let field = createElement(&quot;DTO-Field&quot;, entry.name, dto.id);&#xD;&#xA;            field.setMapping(entry.mapPath);&#xD;&#xA;            if (DomainHelper.isComplexTypeById(entry.typeId)) {&#xD;&#xA;                let dtoName = dto.getName().replace(/Dto$/, &quot;&quot;) + field.getName() + &quot;Dto&quot;;&#xD;&#xA;                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);&#xD;&#xA;                field.typeReference.setType(newDto.id);&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                field.typeReference.setType(entry.typeId);&#xD;&#xA;            }&#xD;&#xA;            field.typeReference.setIsNullable(entry.isNullable);&#xD;&#xA;            field.typeReference.setIsCollection(entry.isCollection);&#xD;&#xA;            dtoUpdated = true;&#xD;&#xA;        }&#xD;&#xA;        if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {&#xD;&#xA;            CrudHelper.addPrimaryKeys(dto, domainElement, true);&#xD;&#xA;        }&#xD;&#xA;        if (dtoUpdated) {&#xD;&#xA;            dto.collapse();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static isOwnerForeignKey(attributeName, domainElement) {&#xD;&#xA;        for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {&#xD;&#xA;            if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {&#xD;&#xA;                return true;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return false;&#xD;&#xA;    }&#xD;&#xA;    static addPrimaryKeys(dto, entity, map) {&#xD;&#xA;        const primaryKeys = CrudHelper.getPrimaryKeysWithMapPath(entity);&#xD;&#xA;        for (const primaryKey of primaryKeys) {&#xD;&#xA;            const name = CrudHelper.getDomainAttributeNameFormat(primaryKey.name);&#xD;&#xA;            if (dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            const dtoField = createElement(&quot;DTO-Field&quot;, CrudHelper.getFieldFormat(name), dto.id);&#xD;&#xA;            dtoField.typeReference.setType(primaryKey.typeId);&#xD;&#xA;            if (map &amp;&amp; primaryKey.mapPath != null) {&#xD;&#xA;                console.log(`Doing mapping for ${dtoField.id}`);&#xD;&#xA;                dtoField.setMapping(primaryKey.mapPath);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getPrimaryKeysWithMapPath(entity) {&#xD;&#xA;        let keydict = Object.create(null);&#xD;&#xA;        let keys = entity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;        keys.forEach(key =&gt; keydict[key.id] = {&#xD;&#xA;            id: key.id,&#xD;&#xA;            name: key.getName(),&#xD;&#xA;            typeId: key.typeReference.typeId,&#xD;&#xA;            mapPath: [key.id],&#xD;&#xA;            isNullable: false,&#xD;&#xA;            isCollection: false&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);&#xD;&#xA;        return Object.values(keydict);&#xD;&#xA;        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {&#xD;&#xA;            if (!curEntity) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            let nextEntity = generalization.typeReference.getType();&#xD;&#xA;            let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;            baseKeys.forEach(key =&gt; {&#xD;&#xA;                keydict[key.id] = {&#xD;&#xA;                    id: key.id,&#xD;&#xA;                    name: key.getName(),&#xD;&#xA;                    typeId: key.typeReference.typeId,&#xD;&#xA;                    mapPath: generalizationStack.concat([key.id]),&#xD;&#xA;                    isNullable: key.typeReference.isNullable,&#xD;&#xA;                    isCollection: key.typeReference.isCollection&#xD;&#xA;                };&#xD;&#xA;            });&#xD;&#xA;            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getAttributesWithMapPath(entity) {&#xD;&#xA;        let attrDict = Object.create(null);&#xD;&#xA;        let attributes = entity.getChildren(&quot;Attribute&quot;)&#xD;&#xA;            .filter(x =&gt; !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp;&#xD;&#xA;            !DomainHelper.isManagedForeignKey(x) &amp;&amp; // essentially also an attribute set by infrastructure&#xD;&#xA;            !CrudHelper.legacyPartitionKey(x) &amp;&amp;&#xD;&#xA;            (x[&quot;hasMetadata&quot;] &amp;&amp; (!x.hasMetadata(&quot;set-by-infrastructure&quot;) || x.getMetadata(&quot;set-by-infrastructure&quot;)?.toLocaleLowerCase() != &quot;true&quot;)));&#xD;&#xA;        attributes.forEach(attr =&gt; attrDict[attr.id] = {&#xD;&#xA;            id: attr.id,&#xD;&#xA;            name: attr.getName(),&#xD;&#xA;            typeId: attr.typeReference.typeId,&#xD;&#xA;            mapPath: [attr.id],&#xD;&#xA;            isNullable: false,&#xD;&#xA;            isCollection: false&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);&#xD;&#xA;        return attrDict;&#xD;&#xA;        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {&#xD;&#xA;            if (!curEntity) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            let nextEntity = generalization.typeReference.getType();&#xD;&#xA;            let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp; !CrudHelper.legacyPartitionKey(x));&#xD;&#xA;            baseKeys.forEach(attr =&gt; {&#xD;&#xA;                attrDict[attr.id] = {&#xD;&#xA;                    id: attr.id,&#xD;&#xA;                    name: attr.getName(),&#xD;&#xA;                    typeId: attr.typeReference.typeId,&#xD;&#xA;                    mapPath: generalizationStack.concat([attr.id]),&#xD;&#xA;                    isNullable: attr.typeReference.isNullable,&#xD;&#xA;                    isCollection: attr.typeReference.isCollection&#xD;&#xA;                };&#xD;&#xA;            });&#xD;&#xA;            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getFieldFormat(str) {&#xD;&#xA;        return toPascalCase(str);&#xD;&#xA;    }&#xD;&#xA;    static getDomainAttributeNameFormat(str) {&#xD;&#xA;        let convention = CrudHelper.getDomainAttributeNamingConvention();&#xD;&#xA;        switch (convention) {&#xD;&#xA;            case &quot;pascal-case&quot;:&#xD;&#xA;                return toPascalCase(str);&#xD;&#xA;            case &quot;camel-case&quot;:&#xD;&#xA;                return toCamelCase(str);&#xD;&#xA;            default:&#xD;&#xA;                return str;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getDomainAttributeNamingConvention() {&#xD;&#xA;        const domainSettingsId = &quot;c4d1e35c-7c0d-4926-afe0-18f17563ce17&quot;;&#xD;&#xA;        return application.getSettings(domainSettingsId)&#xD;&#xA;            ?.getField(&quot;Attribute Naming Convention&quot;)?.value ?? &quot;pascal-case&quot;;&#xD;&#xA;    }&#xD;&#xA;    // Just in case someone still uses this convention. Used to filter out those attributes when mapping&#xD;&#xA;    // to domain entities that are within a Cosmos DB paradigm.&#xD;&#xA;    static legacyPartitionKey(attribute) {&#xD;&#xA;        return attribute.hasStereotype(&quot;Partition Key&quot;) &amp;&amp; attribute.getName() === &quot;PartitionKey&quot;;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;./onMapFunctions.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/crudHelper.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../../typings/elementmacro.context.api.d.ts&quot; /&gt;&#xD;&#xA;const stringTypeId = &quot;d384db9c-a279-45e1-801e-e4e8099625f2&quot;;&#xD;&#xA;function onMapDto(element, folder, autoAddPrimaryKey = true, dtoPrefix = null, inbound = false) {&#xD;&#xA;    if (element.isMapped) {&#xD;&#xA;        let mappedFields = element.getChildren(&quot;DTO-Field&quot;).filter(x =&gt; x.getMapping());&#xD;&#xA;        let unmappedFields = element.getChildren(&quot;DTO-Field&quot;).filter(x =&gt; !x.getMapping());&#xD;&#xA;        for (let mappedField of mappedFields) {&#xD;&#xA;            // Unfortunately have to take into account Intent's ability to disambiguate newly created fields... (the &quot;1&quot;)&#xD;&#xA;            let matchedUnmappedField = unmappedFields&#xD;&#xA;                .filter(x =&gt; `${x.getName()}1` === mappedField.getName() ||&#xD;&#xA;                x.getName() === mappedField.getName())[0];&#xD;&#xA;            if (!matchedUnmappedField) {&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            matchedUnmappedField.setMapping(mappedField.getMapping().getElement().id, mappedField.getMapping().mappingSettingsId);&#xD;&#xA;            mappedField.delete();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    let fields = element.getChildren(&quot;DTO-Field&quot;)&#xD;&#xA;        .filter(x =&gt; x.typeReference.getType()?.specialization != &quot;DTO&quot; &amp;&amp; x.getMapping()?.getElement()?.specialization.startsWith(&quot;Association&quot;));&#xD;&#xA;    fields.forEach(f =&gt; {&#xD;&#xA;        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;&#xD;&#xA;        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement().typeReference.getType(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, targetMappingSettingId, folder, inbound);&#xD;&#xA;        f.typeReference.setType(newDto.id);&#xD;&#xA;    });&#xD;&#xA;    let complexAttributes = element.getChildren(&quot;DTO-Field&quot;)&#xD;&#xA;        .filter(x =&gt; x.typeReference.getType()?.specialization != &quot;DTO&quot;&#xD;&#xA;        &amp;&amp; (DomainHelper.isComplexType(x.getMapping()?.getElement()?.typeReference?.getType())));&#xD;&#xA;    complexAttributes.forEach(f =&gt; {&#xD;&#xA;        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;&#xD;&#xA;        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), false, targetMappingSettingId, folder, inbound);&#xD;&#xA;        f.typeReference.setType(newDto.id);&#xD;&#xA;    });&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;servicesHelper.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;mappingStore.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;elementManager.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../services-cqrs-crud/_common/onMapDto.ts&quot; /&gt;&#xD;&#xA;var RepositoryCrudType;&#xD;&#xA;(function (RepositoryCrudType) {&#xD;&#xA;    RepositoryCrudType[RepositoryCrudType[&quot;Create&quot;] = 0] = &quot;Create&quot;;&#xD;&#xA;    RepositoryCrudType[RepositoryCrudType[&quot;Read&quot;] = 1] = &quot;Read&quot;;&#xD;&#xA;    RepositoryCrudType[RepositoryCrudType[&quot;Update&quot;] = 2] = &quot;Update&quot;;&#xD;&#xA;    RepositoryCrudType[RepositoryCrudType[&quot;Delete&quot;] = 3] = &quot;Delete&quot;;&#xD;&#xA;})(RepositoryCrudType || (RepositoryCrudType = {}));&#xD;&#xA;const mapToDomainOperationSettingId = &quot;7c31c459-6229-4f10-bf13-507348cd8828&quot;;&#xD;&#xA;class RepositoryServiceHelper {&#xD;&#xA;    static _createService(repository, folder) {&#xD;&#xA;        let serviceName = repository.getName();&#xD;&#xA;        serviceName = RepositoryServiceHelper.sanitizeServiceName(serviceName);&#xD;&#xA;        const existing = folder.getPackage().getChildren(&quot;Service&quot;).find(x =&gt; x.getName() == serviceName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        let serviceElement = createElement(&quot;Service&quot;, serviceName, folder.getPackage().id);&#xD;&#xA;        //const httpServiceSettingsStereotypeId = &quot;c29224ec-d473-4b95-ad4a-ec55c676c4fd&quot;;&#xD;&#xA;        // let httpServiceSettings = serviceElement.getStereotype(httpServiceSettingsStereotypeId) ?? serviceElement.addStereotype(httpServiceSettingsStereotypeId);&#xD;&#xA;        // httpServiceSettings.getProperty(&quot;Route&quot;).setValue(`api/${toKebabCase(serviceName)}`);&#xD;&#xA;        return serviceElement;&#xD;&#xA;    }&#xD;&#xA;    static sanitizeServiceName(name) {&#xD;&#xA;        name = removeSuffix(name, &quot;Repository&quot;);&#xD;&#xA;        name += &quot;Service&quot;;&#xD;&#xA;        name = toPascalCase(name);&#xD;&#xA;        return name;&#xD;&#xA;    }&#xD;&#xA;    static createAppServiceOperationAction(operation, folder, service, syncElement = false) {&#xD;&#xA;        let operationName = operation.getName();&#xD;&#xA;        operationName = removeSuffix(operationName, &quot;Async&quot;);&#xD;&#xA;        operationName = toPascalCase(operationName);&#xD;&#xA;        if (!service) {&#xD;&#xA;            service = RepositoryServiceHelper._createService(operation.getParent(), folder);&#xD;&#xA;        }&#xD;&#xA;        // look up if there is an existing operation with the same name&#xD;&#xA;        const existing = service.getChildren().find(x =&gt; x.getName() == operationName);&#xD;&#xA;        // and return the existing one if the sync is disable (which is is by default)&#xD;&#xA;        if (existing &amp;&amp; !syncElement) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        let operationElement = existing ?? createElement(&quot;Operation&quot;, operationName, service.id);&#xD;&#xA;        let mappingStore = new MappingStore();&#xD;&#xA;        RepositoryServiceHelper.createAction(operation.getChildren(&quot;Parameter&quot;), operationElement, false, folder, mappingStore, existing != null);&#xD;&#xA;        // only add the association if not an existing operation&#xD;&#xA;        if (!existing) {&#xD;&#xA;            let callOp = createAssociation(&quot;Call Service Operation&quot;, operationElement.id, operation.id);&#xD;&#xA;            let mapping = callOp.createAdvancedMapping(operationElement.id, operation.id);&#xD;&#xA;            mapping.addMappedEnd(&quot;Invocation Mapping&quot;, [operationElement.id], [operation.id]);&#xD;&#xA;            for (let entry of mappingStore.getMappings().reverse()) {&#xD;&#xA;                //console.warn(&quot;source: &quot; + entry.sourcePath + &quot; to target: &quot; + entry.targetPath);&#xD;&#xA;                mapping.addMappedEnd(&quot;Data Mapping&quot;, entry.sourcePath, entry.targetPath);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        if (!DomainHelper.isComplexType(operation.typeReference?.getType())) {&#xD;&#xA;            operationElement.typeReference.setType(operation.typeReference.getTypeId());&#xD;&#xA;            operationElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());&#xD;&#xA;            operationElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            var resultDto = RepositoryServiceHelper.createRepositoryClassTypeDto(operation, operation.typeReference?.getType(), folder);&#xD;&#xA;            operationElement.typeReference.setType(resultDto.id);&#xD;&#xA;            operationElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());&#xD;&#xA;            operationElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());&#xD;&#xA;        }&#xD;&#xA;        return operationElement;&#xD;&#xA;    }&#xD;&#xA;    static createCqrsAction(operation, folder, syncElement = false) {&#xD;&#xA;        let operationName = operation.getName();&#xD;&#xA;        operationName = removeSuffix(operationName, &quot;Async&quot;, &quot;Command&quot;, &quot;Query&quot;);&#xD;&#xA;        operationName = toPascalCase(operationName);&#xD;&#xA;        let metadata = RepositoryServiceHelper.getRepositoryOperationMetadata(operation);&#xD;&#xA;        let actionTypeName;&#xD;&#xA;        switch (metadata.crudType) {&#xD;&#xA;            default:&#xD;&#xA;                actionTypeName = &quot;Command&quot;;&#xD;&#xA;                break;&#xD;&#xA;            case RepositoryCrudType.Read:&#xD;&#xA;                actionTypeName = &quot;Query&quot;;&#xD;&#xA;                break;&#xD;&#xA;        }&#xD;&#xA;        const actionName = `${operationName}${actionTypeName}`;&#xD;&#xA;        // if sync is set to true, then don't return right away&#xD;&#xA;        const existing = folder.getChildren().find(x =&gt; x.getName() == actionName);&#xD;&#xA;        if (existing &amp;&amp; !syncElement) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        const actionElement = existing ?? createElement(actionTypeName, actionName, folder.id);&#xD;&#xA;        let mappingStore = new MappingStore();&#xD;&#xA;        RepositoryServiceHelper.createAction(operation.getChildren(&quot;Parameter&quot;), actionElement, true, folder, mappingStore, existing != null);&#xD;&#xA;        // don't recreate the association if it the entity exists exists&#xD;&#xA;        if (!existing) {&#xD;&#xA;            let callOp = createAssociation(&quot;Call Service Operation&quot;, actionElement.id, operation.id);&#xD;&#xA;            let mapping = callOp.createAdvancedMapping(actionElement.id, operation.id);&#xD;&#xA;            mapping.addMappedEnd(&quot;Invocation Mapping&quot;, [actionElement.id], [operation.id]);&#xD;&#xA;            for (let entry of mappingStore.getMappings().reverse()) {&#xD;&#xA;                //console.warn(&quot;source: &quot; + entry.sourcePath + &quot; to target: &quot; + entry.targetPath);&#xD;&#xA;                mapping.addMappedEnd(&quot;Data Mapping&quot;, entry.sourcePath, entry.targetPath);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        if (!DomainHelper.isComplexType(operation.typeReference?.getType())) {&#xD;&#xA;            actionElement.typeReference.setType(operation.typeReference.getTypeId());&#xD;&#xA;            actionElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());&#xD;&#xA;            actionElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            var resultDto = RepositoryServiceHelper.createRepositoryClassTypeDto(operation, operation.typeReference?.getType(), folder);&#xD;&#xA;            actionElement.typeReference.setType(resultDto.id);&#xD;&#xA;            actionElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());&#xD;&#xA;            actionElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());&#xD;&#xA;        }&#xD;&#xA;        return actionElement;&#xD;&#xA;    }&#xD;&#xA;    static getRepositoryOperationMetadata(operation) {&#xD;&#xA;        let mappedElement = operation.getMapping()?.getElement();&#xD;&#xA;        mappedElement;&#xD;&#xA;        let crudType;&#xD;&#xA;        let httpSettings = mappedElement?.getStereotype(&quot;Http Settings&quot;);&#xD;&#xA;        let httpVerb = httpSettings?.getProperty(&quot;Verb&quot;)?.getValue();&#xD;&#xA;        let httpRoute = httpSettings?.getProperty(&quot;Route&quot;)?.getValue();&#xD;&#xA;        const routeParamRegex = /\{([a-zA-Z0-9_\-]+)\}/g;&#xD;&#xA;        let httpRouteParams = httpRoute ? [...httpRoute.matchAll(routeParamRegex)].map(match =&gt; match[1]) : [];&#xD;&#xA;        if (httpVerb) {&#xD;&#xA;            switch (httpVerb.toUpperCase()) {&#xD;&#xA;                case &quot;POST&quot;:&#xD;&#xA;                    crudType = RepositoryCrudType.Create;&#xD;&#xA;                    break;&#xD;&#xA;                case &quot;PUT&quot;:&#xD;&#xA;                    crudType = RepositoryCrudType.Update;&#xD;&#xA;                    break;&#xD;&#xA;                case &quot;DELETE&quot;:&#xD;&#xA;                    crudType = RepositoryCrudType.Delete;&#xD;&#xA;                    break;&#xD;&#xA;                case &quot;GET&quot;:&#xD;&#xA;                    crudType = RepositoryCrudType.Read;&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        else if (mappedElement &amp;&amp; (mappedElement.specialization === &quot;Command&quot; ||&#xD;&#xA;            mappedElement.specialization === &quot;Query&quot; ||&#xD;&#xA;            mappedElement.specialization === &quot;Operation&quot;)) {&#xD;&#xA;            for (let association of mappedElement.getAssociations()) {&#xD;&#xA;                switch (association.specialization) {&#xD;&#xA;                    case &quot;Create Entity Action&quot;:&#xD;&#xA;                        crudType = RepositoryCrudType.Create;&#xD;&#xA;                        break;&#xD;&#xA;                    case &quot;Update Entity Action&quot;:&#xD;&#xA;                        crudType = RepositoryCrudType.Update;&#xD;&#xA;                        break;&#xD;&#xA;                    case &quot;Delete Entity Action&quot;:&#xD;&#xA;                        crudType = RepositoryCrudType.Delete;&#xD;&#xA;                        break;&#xD;&#xA;                    case &quot;Query Entity Action&quot;:&#xD;&#xA;                        crudType = RepositoryCrudType.Read;&#xD;&#xA;                        break;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        else if (!crudType) {&#xD;&#xA;            let mappedElementNameLower = (mappedElement ? mappedElement.getName() : operation.getName()).toLocaleLowerCase();&#xD;&#xA;            if (mappedElementNameLower.indexOf(&quot;create&quot;) &gt; -1) {&#xD;&#xA;                crudType = RepositoryCrudType.Create;&#xD;&#xA;            }&#xD;&#xA;            else if (mappedElementNameLower.indexOf(&quot;update&quot;) &gt; -1) {&#xD;&#xA;                crudType = RepositoryCrudType.Update;&#xD;&#xA;            }&#xD;&#xA;            else if (mappedElementNameLower.indexOf(&quot;delete&quot;) &gt; -1) {&#xD;&#xA;                crudType = RepositoryCrudType.Delete;&#xD;&#xA;            }&#xD;&#xA;            else if (mappedElementNameLower.indexOf(&quot;get&quot;) &gt; -1 || mappedElementNameLower.indexOf(&quot;find&quot;) &gt; -1) {&#xD;&#xA;                crudType = RepositoryCrudType.Read;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return {&#xD;&#xA;            crudType: crudType,&#xD;&#xA;            httpVerb: httpVerb,&#xD;&#xA;            httpRoute: httpRoute,&#xD;&#xA;            httpRouteParams: httpRouteParams&#xD;&#xA;        };&#xD;&#xA;    }&#xD;&#xA;    static createAction(repositoryFields, actionElement, flattenFieldsFromComplexTypes, folder, mappingStore, isExistingElement = false) {&#xD;&#xA;        // console.warn(&quot;recreateAction called with actionElement: &quot; + actionElement.getName());&#xD;&#xA;        // console.warn(&quot;repositoryFields.length: &quot; + repositoryFields.length);&#xD;&#xA;        // console.warn(&quot;actionElement specializationId:&quot; + actionElement.specialization);&#xD;&#xA;        const childSpecialization = actionElement.specialization == &quot;Operation&quot; ? &quot;Parameter&quot; : &quot;DTO-Field&quot;;&#xD;&#xA;        //console.warn(&quot;childSpecialization: &quot; + childSpecialization);&#xD;&#xA;        let elementManager = new ElementManager(actionElement, { childSpecialization: childSpecialization });&#xD;&#xA;        for (let repositoryField of repositoryFields) {&#xD;&#xA;            let paramRefType = repositoryField.typeReference?.getType()?.specialization;&#xD;&#xA;            //console.warn(&quot;Field specialization: &quot; + childSpecialization);&#xD;&#xA;            //console.warn(&quot;paramRefType: &quot; + paramRefType);&#xD;&#xA;            switch (paramRefType) {&#xD;&#xA;                case &quot;Class&quot;:&#xD;&#xA;                case &quot;Data Contract&quot;:&#xD;&#xA;                case &quot;Value Object&quot;:&#xD;&#xA;                    let repositoryRefType = repositoryField.typeReference.getType();&#xD;&#xA;                    if (flattenFieldsFromComplexTypes &amp;&amp; !repositoryField.typeReference?.isCollection) {&#xD;&#xA;                        mappingStore.pushTargetPath(repositoryField.id);&#xD;&#xA;                        RepositoryServiceHelper.createAction(repositoryRefType.getChildren(&quot;Attribute&quot;), elementManager.getElement(), false, folder, mappingStore, isExistingElement);&#xD;&#xA;                        mappingStore.popTargetPath();&#xD;&#xA;                    }&#xD;&#xA;                    else {&#xD;&#xA;                        //console.warn(&quot;in the else:&quot;);&#xD;&#xA;                        let actionField = elementManager.addChild(repositoryField.getName(), null);&#xD;&#xA;                        //console.warn(&quot;Pushing source: &quot; + actionField.getName());&#xD;&#xA;                        //console.warn(&quot;Pushing target: &quot; + repositoryField.getName());&#xD;&#xA;                        mappingStore.pushSourcePath(actionField.id);&#xD;&#xA;                        mappingStore.pushTargetPath(repositoryField.id);&#xD;&#xA;                        let actionDto = RepositoryServiceHelper.replicateDto(repositoryRefType, folder, mappingStore, isExistingElement);&#xD;&#xA;                        mappingStore.popSourcePath();&#xD;&#xA;                        mappingStore.popTargetPath();&#xD;&#xA;                        actionField.typeReference.setType(actionDto.id);&#xD;&#xA;                        actionField.typeReference.setIsCollection(repositoryField.typeReference.isCollection);&#xD;&#xA;                        actionField.typeReference.setIsNullable(repositoryField.typeReference.isNullable);&#xD;&#xA;                        if (repositoryField.hasMetadata(&quot;endpoint-input-id&quot;) &amp;&amp; !actionField.hasMetadata(&quot;endpoint-input-id&quot;)) {&#xD;&#xA;                            actionField.addMetadata(&quot;endpoint-input-id&quot;, repositoryField.getMetadata(&quot;endpoint-input-id&quot;));&#xD;&#xA;                        }&#xD;&#xA;                        if (repositoryField.typeReference?.isCollection) {&#xD;&#xA;                            //console.warn(&quot;setting values and stuff&quot;);&#xD;&#xA;                            //console.warn(&quot;actionDto.getValue: &quot; + actionDto.getValue());&#xD;&#xA;                            actionField.setValue(actionDto.getValue());&#xD;&#xA;                            if (!isExistingElement) {&#xD;&#xA;                                //console.warn(&quot;Adding mapping&quot;);&#xD;&#xA;                                mappingStore.addMapping(actionField.id, repositoryField.id);&#xD;&#xA;                            }&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;                default:&#xD;&#xA;                    // Non-Complex type&#xD;&#xA;                    // if mapping directly to a class, skip over the primary keys &#xD;&#xA;                    if (repositoryField.hasStereotype(&quot;Primary Key&quot;)) {&#xD;&#xA;                        continue;&#xD;&#xA;                    }&#xD;&#xA;                    let fieldName = repositoryField.getName();&#xD;&#xA;                    if (elementManager.getElement().getChildren().some(x =&gt; x.getName() === fieldName) &amp;&amp; !isExistingElement) {&#xD;&#xA;                        let parentName = repositoryField.getParent().getName();&#xD;&#xA;                        fieldName = parentName + fieldName;&#xD;&#xA;                    }&#xD;&#xA;                    // console.warn(&quot;Adding simple field: &quot; + fieldName);&#xD;&#xA;                    // console.warn(&quot;repositoryField.typeReference: &quot; + repositoryField.typeReference.getType().getName());&#xD;&#xA;                    let actionField = elementManager.addChild(fieldName, repositoryField.typeReference);&#xD;&#xA;                    actionField.setValue(repositoryField.getValue());&#xD;&#xA;                    //console.warn(&quot;isExistingElement: &quot; + isExistingElement);&#xD;&#xA;                    if (!isExistingElement) {&#xD;&#xA;                        //console.warn(&quot;adding child mapping for action:&quot; + actionField.getName());&#xD;&#xA;                        //console.warn(&quot;adding child mapping for repo:&quot; + repositoryField.getName());&#xD;&#xA;                        mappingStore.addMapping(actionField.id, repositoryField.id);&#xD;&#xA;                    }&#xD;&#xA;                    if (repositoryField.hasMetadata(&quot;endpoint-input-id&quot;) &amp;&amp; !actionField.hasMetadata(&quot;endpoint-input-id&quot;)) {&#xD;&#xA;                        actionField.addMetadata(&quot;endpoint-input-id&quot;, repositoryField.getMetadata(&quot;endpoint-input-id&quot;));&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        elementManager.collapse();&#xD;&#xA;    }&#xD;&#xA;    static getBaseNameForElement(owningAggregate, entity, entityIsMany) {&#xD;&#xA;        // Keeping 'owningAggregate' in case we still need to use it as part of the name one day&#xD;&#xA;        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());&#xD;&#xA;        return entityName;&#xD;&#xA;    }&#xD;&#xA;    static createRepositoryClassTypeDto(operation, entity, folder) {&#xD;&#xA;        let owningAggregate = DomainHelper.getOwningAggregate(entity);&#xD;&#xA;        let baseName = this.getBaseNameForElement(owningAggregate, entity, false);&#xD;&#xA;        let expectedDtoName = `${operation.getName()}${baseName}Dto`;&#xD;&#xA;        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedDtoName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        let dto = createElement(&quot;DTO&quot;, expectedDtoName, folder.id);&#xD;&#xA;        dto.setMetadata(&quot;baseName&quot;, baseName);&#xD;&#xA;        dto.setMapping(entity.id);&#xD;&#xA;        let primaryKeys = DomainHelper.getPrimaryKeys(entity);&#xD;&#xA;        if (owningAggregate) {&#xD;&#xA;            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);&#xD;&#xA;            foreignKeys.forEach(fk =&gt; {&#xD;&#xA;                let field = createElement(&quot;DTO-Field&quot;, ServicesHelper.getFieldFormat(fk.name), dto.id);&#xD;&#xA;                field.typeReference.setType(fk.typeId);&#xD;&#xA;                if (fk.mapPath) {&#xD;&#xA;                    field.setMapping(fk.mapPath);&#xD;&#xA;                }&#xD;&#xA;            });&#xD;&#xA;        }&#xD;&#xA;        ServicesHelper.addDtoFieldsFromDomain(dto, primaryKeys);&#xD;&#xA;        let attributesWithMapPaths = DomainHelper.getAttributesWithMapPath(entity);&#xD;&#xA;        for (var attr of attributesWithMapPaths) {&#xD;&#xA;            if (dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getMapping()?.getElement()?.id == attr.id)) {&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            let field = createElement(&quot;DTO-Field&quot;, attr.name, dto.id);&#xD;&#xA;            field.typeReference.setType(attr.typeId);&#xD;&#xA;            field.setMapping(attr.mapPath);&#xD;&#xA;        }&#xD;&#xA;        onMapDto(dto, folder);&#xD;&#xA;        dto.collapse();&#xD;&#xA;        return dto;&#xD;&#xA;    }&#xD;&#xA;    static replicateDto(repositoryDto, folder, mappingStore, isExistingElement = false) {&#xD;&#xA;        console.warn(&quot;replicateDto:&quot; + repositoryDto.getName());&#xD;&#xA;        var expectedName = `${repositoryDto.getName()}Dto`;&#xD;&#xA;        // check to see if there is a DTO with the same name, and only if there is and we are working with an existing element do we update&#xD;&#xA;        // this is to preserve backwards compatibility&#xD;&#xA;        let existingDto = folder.getChildren().find(x =&gt; x.getName() == expectedName);&#xD;&#xA;        let newDto = (existingDto &amp;&amp; isExistingElement) ? existingDto : createElement(&quot;DTO&quot;, expectedName, folder.id);&#xD;&#xA;        let elementManager = new ElementManager(newDto, { childSpecialization: &quot;DTO-Field&quot; });&#xD;&#xA;        repositoryDto.getChildren(&quot;Attribute&quot;).forEach(repositoryField =&gt; {&#xD;&#xA;            let existingField = newDto.getChildren().find(c =&gt; c.getName() == repositoryField.getName());&#xD;&#xA;            //let actionField =  (existingField &amp;&amp; isExistingElement) ? existingField :  createElement(&quot;DTO-Field&quot;, repositoryField.getName(), newDto.id);&#xD;&#xA;            let actionField = (existingField &amp;&amp; isExistingElement) ? existingField : elementManager.addChild(repositoryField.getName(), null);&#xD;&#xA;            let fieldRefType = repositoryField.typeReference?.getType()?.specialization;&#xD;&#xA;            console.warn(&quot;actionField: &quot; + actionField.getName());&#xD;&#xA;            console.warn(&quot;repositoryField: &quot; + repositoryField.getName());&#xD;&#xA;            switch (fieldRefType) {&#xD;&#xA;                case &quot;Class&quot;:&#xD;&#xA;                case &quot;Data Contract&quot;:&#xD;&#xA;                case &quot;Value Object&quot;:&#xD;&#xA;                    ``;&#xD;&#xA;                    // Complex type&#xD;&#xA;                    mappingStore.pushSourcePath(actionField.id);&#xD;&#xA;                    mappingStore.pushTargetPath(repositoryField.id);&#xD;&#xA;                    let nestedDto = RepositoryServiceHelper.replicateDto(repositoryField.typeReference.getType(), folder, mappingStore, isExistingElement);&#xD;&#xA;                    mappingStore.popSourcePath();&#xD;&#xA;                    mappingStore.popTargetPath();&#xD;&#xA;                    actionField.typeReference.setType(nestedDto.id);&#xD;&#xA;                    if (repositoryField.typeReference?.isCollection) {&#xD;&#xA;                        actionField.setValue(nestedDto.getValue());&#xD;&#xA;                        mappingStore.addMapping(actionField.id, repositoryField.id);&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;                default:&#xD;&#xA;                    // Non-Complex type&#xD;&#xA;                    // if mapping directly to a class, skip over the primary keys &#xD;&#xA;                    if (repositoryField.hasStereotype(&quot;Primary Key&quot;)) {&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                    actionField.typeReference.setType(repositoryField.typeReference.getTypeId());&#xD;&#xA;                    actionField.setValue(repositoryField.getValue());&#xD;&#xA;                    mappingStore.addMapping(actionField.id, repositoryField.id);&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;            actionField.typeReference.setIsCollection(repositoryField.typeReference.isCollection);&#xD;&#xA;            actionField.typeReference.setIsNullable(repositoryField.typeReference.isNullable);&#xD;&#xA;        });&#xD;&#xA;        console.warn(&quot;Returning dto:&quot; + newDto.getName());&#xD;&#xA;        return newDto;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;../../common/openSelectItemDialog.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/repositoryServiceHelper.ts&quot; /&gt;&#xD;&#xA;async function execute(repositoryOperation) {&#xD;&#xA;    let servicePackages = getPackages().filter(pkg =&gt; pkg.specialization === &quot;Services Package&quot;);&#xD;&#xA;    let selectedPackage;&#xD;&#xA;    if (servicePackages.length == 1) {&#xD;&#xA;        selectedPackage = servicePackages[0];&#xD;&#xA;    }&#xD;&#xA;    else {&#xD;&#xA;        selectedPackage = await openSelectItemDialog(getPackageSelectItemOptions(servicePackages, &quot;Service Package&quot;));&#xD;&#xA;    }&#xD;&#xA;    const repository = repositoryOperation.getParent();&#xD;&#xA;    const folderName = pluralize(repository.getName().replace(&quot;Repository&quot;, &quot;&quot;));&#xD;&#xA;    const folder = selectedPackage.getChildren(&quot;Folder&quot;).find(x =&gt; x.getName() == pluralize(folderName)) ?? createElement(&quot;Folder&quot;, pluralize(folderName), selectedPackage.id);&#xD;&#xA;    RepositoryServiceHelper.createCqrsAction(repositoryOperation, folder, true);&#xD;&#xA;    const diagramElement = folder.getChildren(&quot;Diagram&quot;).find(x =&gt; x.getName() == folderName) ?? createElement(&quot;Diagram&quot;, folderName, folder.id);&#xD;&#xA;    diagramElement.loadDiagram();&#xD;&#xA;    const diagram = getCurrentDiagram();&#xD;&#xA;    //Since we're adding a single new element on the diagram, it may not be positioned below the last created one.&#xD;&#xA;    let lastActionVisual = null;&#xD;&#xA;    for (let action of folder.getChildren(&quot;Command&quot;).concat(folder.getChildren(&quot;Query&quot;))) {&#xD;&#xA;        if (diagram.isVisual(action.id)) {&#xD;&#xA;            var actionElement = diagram.getVisual(action.id);&#xD;&#xA;            if (!lastActionVisual || actionElement.getPosition().y &gt; lastActionVisual.getPosition().y) {&#xD;&#xA;                lastActionVisual = actionElement;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    let newPosition = null;&#xD;&#xA;    let repoElement = diagram.getVisual(repository.id);&#xD;&#xA;    // This is an attempt to reposition the newly created elements due to the lack of&#xD;&#xA;    // directly manipulating the visuals on the diagram but it ends up skewing diagonally.&#xD;&#xA;    if (lastActionVisual) {&#xD;&#xA;        newPosition = {&#xD;&#xA;            x: repoElement.getPosition().x - (repoElement.getSize().width / 1.5),&#xD;&#xA;            y: lastActionVisual.getPosition().y + (lastActionVisual.getSize().height * 1.5)&#xD;&#xA;        };&#xD;&#xA;    }&#xD;&#xA;    else {&#xD;&#xA;        if (diagram.isVisual(repository.id)) {&#xD;&#xA;            newPosition = {&#xD;&#xA;                x: repoElement.getPosition().x - (repoElement.getSize().width / 1.5),&#xD;&#xA;                y: repoElement.getPosition().y&#xD;&#xA;            };&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    diagram.layoutVisuals(folder, newPosition, true);&#xD;&#xA;}&#xD;&#xA;/**&#xD;&#xA; * Used by Intent.Modelers.Services.DomainInteractions&#xD;&#xA; *&#xD;&#xA; * Source code here:&#xD;&#xA; * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/create-cqrs-repository-operation-macro-advanced-mapping/create-cqrs-repository-operation-macro-advanced-mapping.ts&#xD;&#xA; */&#xD;&#xA;await execute(element);&#xD;&#xA;" isActive="true" />
            <property name="1d9dd994-46c3-4fdc-a24b-c69f689ca283" display="Dependencies" isActive="true" />
          </properties>
        </stereotype>
      </stereotypes>
      <metadata />
      <childElements />
    </childElement>
    <childElement id="cfd895b2-e635-4cdc-b652-496f17612f02" type="Suggestion" typeId="0c21ab10-e87b-4e88-ab44-38ea7adf514a">
      <name>Create Service Operation</name>
      <display>Create Service Operation: Operation</display>
      <isAbstract>false</isAbstract>
      <genericTypes />
      <typeReference id="5a9cc9bb-de58-493e-a7b5-40ebe7b08805">
        <typeId>e042bb67-a1df-480c-9935-b26210f78591</typeId>
        <isNavigable>true</isNavigable>
        <isNullable>false</isNullable>
        <isCollection>false</isCollection>
        <isRequired>true</isRequired>
        <typePackageName>Intent.Modelers.Domain</typePackageName>
        <typePackageId>6572b98d-5e13-4d4b-9ffc-820057da974e</typePackageId>
        <stereotypes />
        <genericTypeParameters />
      </typeReference>
      <isMapped>false</isMapped>
      <parentFolderId>d29e55e2-d02e-4866-a44b-0443c4086e8a</parentFolderId>
      <packageId>bff48d8d-9246-4ad7-9dda-9703b7139b86</packageId>
      <packageName>Intent.Modelers.Services.DomainInteractions</packageName>
      <stereotypes>
        <stereotype stereotypeDefinitionId="daf7d9b3-9c10-4286-b30e-7edb2e62f10e" name="Settings">
          <addedByDefault>true</addedByDefault>
          <definitionPackageName>Intent.ModuleBuilder</definitionPackageName>
          <definitionPackageId>9972b2a9-b749-4bba-b5c8-824bf694c6ef</definitionPackageId>
          <properties>
            <property name="bd242929-b399-4d13-88c0-d046b7161d41" display="Locations" value="[&quot;Diagram&quot;,&quot;Model&quot;]" isActive="true" />
            <property name="8d51eb08-f4a9-4703-ba70-de87c9417d46" display="Filter Function" value="const callServiceOperationTargetEnd = &quot;093e5909-ffe4-4510-b3ea-532f30212f3c&quot;;&#xD;&#xA;let notMapped = lookupTypesOf(callServiceOperationTargetEnd).every(x =&gt; x.typeReference.getTypeId() != element.id)&#xD;&#xA;&#xD;&#xA;return application.getSettings(&quot;0ecca7c5-96f7-449a-96b9-f65ba0a4e3ad&quot;).getField(&quot;14bc1e98-930b-494c-97a9-5da4e1f3a5fa&quot;).value == &quot;advanced&quot;&#xD;&#xA;    &amp;&amp; element.getParent() &amp;&amp; element.getParent().specializationId == &quot;96ffceb2-a70a-4b69-869b-0df436c470c3&quot; // is a Repository&#xD;&#xA;    &amp;&amp; notMapped;" isActive="true" />
            <property name="ecb7abbb-0297-486e-bd99-cded3226d2a4" display="Display Function" value="" isActive="true" />
            <property name="bfd10a66-2f93-4ffd-bf35-633ff96e7e6c" display="Script" value="/// &lt;reference path=&quot;../../typings/elementmacro.context.api.d.ts&quot; /&gt;&#xD;&#xA;function getPackageSelectItemOptions(packages, packageTypeName) {&#xD;&#xA;    return {&#xD;&#xA;        items: packages,&#xD;&#xA;        getId(item) {&#xD;&#xA;            return item.id;&#xD;&#xA;        },&#xD;&#xA;        getDisplayName(item) {&#xD;&#xA;            return item.getName();&#xD;&#xA;        },&#xD;&#xA;        getItemNotFoundMessage(itemId) {&#xD;&#xA;            return `No ${packageTypeName} found with id &quot;${itemId}&quot;.`;&#xD;&#xA;        },&#xD;&#xA;        getNoItemsFoundMessage() {&#xD;&#xA;            return `No packages of type ${packageTypeName} could be found.`;&#xD;&#xA;        },&#xD;&#xA;    };&#xD;&#xA;}&#xD;&#xA;function getElementSelectItemOptions(elements, elementTypeName, relevantPackageTypeName) {&#xD;&#xA;    return {&#xD;&#xA;        items: elements,&#xD;&#xA;        getId(item) {&#xD;&#xA;            return item.id;&#xD;&#xA;        },&#xD;&#xA;        getDisplayName(item) {&#xD;&#xA;            return item.getName();&#xD;&#xA;        },&#xD;&#xA;        getItemNotFoundMessage(itemId) {&#xD;&#xA;            return `No &quot;${elementTypeName}&quot; found with id &quot;${itemId}&quot;.`;&#xD;&#xA;        },&#xD;&#xA;        getNoItemsFoundMessage() {&#xD;&#xA;            return `No Elements of type &quot;${elementTypeName}&quot; could be found. Please ensure that you have a reference to the ${relevantPackageTypeName} package and that at least one ${elementTypeName} exists in it.`;&#xD;&#xA;        },&#xD;&#xA;    };&#xD;&#xA;}&#xD;&#xA;/**&#xD;&#xA; * Dialog selection.&#xD;&#xA; * @param options For simplicity, use getPackageSelectItemOptions() or getElementSelectItemOptions()&#xD;&#xA; * @returns Selected item.&#xD;&#xA; */&#xD;&#xA;async function openSelectItemDialog(options) {&#xD;&#xA;    if (!options) {&#xD;&#xA;        throw new Error(&quot;Options are required for 'openSelectItemDialog'.&quot;);&#xD;&#xA;    }&#xD;&#xA;    let items = options.items;&#xD;&#xA;    if (items.length == 0) {&#xD;&#xA;        await dialogService.info(options.getNoItemsFoundMessage());&#xD;&#xA;        return null;&#xD;&#xA;    }&#xD;&#xA;    let itemId = await dialogService.lookupFromOptions(items.map(item =&gt; ({&#xD;&#xA;        id: options.getId(item),&#xD;&#xA;        name: options.getDisplayName(item)&#xD;&#xA;    })));&#xD;&#xA;    if (itemId == null) {&#xD;&#xA;        await dialogService.error(options.getItemNotFoundMessage(itemId));&#xD;&#xA;        return null;&#xD;&#xA;    }&#xD;&#xA;    let foundItem = items.filter(item =&gt; options.getId(item) === itemId)[0];&#xD;&#xA;    return foundItem;&#xD;&#xA;}&#xD;&#xA;;&#xD;&#xA;/// &lt;reference path=&quot;attributeWithMapPath.ts&quot; /&gt;&#xD;&#xA;class ServicesConstants {&#xD;&#xA;}&#xD;&#xA;ServicesConstants.dtoToEntityMappingId = &quot;942eae46-49f1-450e-9274-a92d40ac35fa&quot;; //&quot;01d74d4f-e478-4fde-a2f0-9ea92255f3c5&quot;;&#xD;&#xA;ServicesConstants.dtoFromEntityMappingId = &quot;1f747d14-681c-4a20-8c68-34223f41b825&quot;;&#xD;&#xA;ServicesConstants.dtoToDomainOperation = &quot;8d1f6a8a-77c8-43a2-8e60-421559725419&quot;;&#xD;&#xA;class ServicesHelper {&#xD;&#xA;    static addDtoFieldsFromDomain(dto, attributes) {&#xD;&#xA;        for (let key of attributes) {&#xD;&#xA;            if (dto &amp;&amp; !dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {&#xD;&#xA;                let field = createElement(&quot;DTO-Field&quot;, ServicesHelper.getFieldFormat(key.name), dto.id);&#xD;&#xA;                field.typeReference.setType(key.typeId);&#xD;&#xA;                if ((key.mapPath ?? []).length &gt; 0) {&#xD;&#xA;                    field.setMapping(key.mapPath);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getParameterFormat(str) {&#xD;&#xA;        return toCamelCase(str);&#xD;&#xA;    }&#xD;&#xA;    static getRoutingFormat(str) {&#xD;&#xA;        return pluralize(str);&#xD;&#xA;    }&#xD;&#xA;    static getFieldFormat(str) {&#xD;&#xA;        return toPascalCase(str);&#xD;&#xA;    }&#xD;&#xA;    static formatName(str, type) {&#xD;&#xA;        switch (type) {&#xD;&#xA;            case &quot;property&quot;:&#xD;&#xA;            case &quot;class&quot;:&#xD;&#xA;                return toPascalCase(str);&#xD;&#xA;            case &quot;parameter&quot;:&#xD;&#xA;                return toCamelCase(str);&#xD;&#xA;            default:&#xD;&#xA;                return str;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/**&#xD;&#xA; * Helper class to build up source and target mapping paths for&#xD;&#xA; * advanced mapping scenarios.&#xD;&#xA; *&#xD;&#xA; * @remarks&#xD;&#xA; *&#xD;&#xA; * Source Path and Target Path is maintained separately since not all mapping scenarios are&#xD;&#xA; * straightforward.&#xD;&#xA; *&#xD;&#xA; * @example&#xD;&#xA; *&#xD;&#xA; * When to Push/Pop the Paths&#xD;&#xA; *&#xD;&#xA;    let leftField = createField(...);&#xD;&#xA;&#xD;&#xA;    mappingStore.pushSourcePath(leftField.id);&#xD;&#xA;    mappingStore.pushTargetPath(rightField.id);&#xD;&#xA;&#xD;&#xA;    let leftFieldDto = replicateDto(rightField.typeReference.getType(), folder, mappingStore);&#xD;&#xA;&#xD;&#xA;    mappingStore.popSourcePath();&#xD;&#xA;    mappingStore.popTargetPath();&#xD;&#xA;&#xD;&#xA;    leftField.typeReference.setType(leftFieldDto.id);&#xD;&#xA; *&#xD;&#xA; * Adding mappings&#xD;&#xA; *&#xD;&#xA;    function replicateDto(existingDto: MacroApi.Context.IElementApi, ...) {&#xD;&#xA;        let newDto = createElement(&quot;DTO&quot;, existingDto.getName(), folder.id);&#xD;&#xA;        existingDto.getChildren(&quot;DTO-Field&quot;).forEach(existingField =&gt; {&#xD;&#xA;            let newField = createElement(&quot;DTO-Field&quot;, existingField.getName(), newDto.id);&#xD;&#xA;            // ...&#xD;&#xA;            mappingStore.addMapping(newField.id, existingField.id);&#xD;&#xA;            // ...&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA; */&#xD;&#xA;class MappingStore {&#xD;&#xA;    constructor() {&#xD;&#xA;        this.mappings = [];&#xD;&#xA;        this.sourcePath = [];&#xD;&#xA;        this.targetPath = [];&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Get all the recorded mapping entries&#xD;&#xA;     */&#xD;&#xA;    getMappings() {&#xD;&#xA;        return this.mappings;&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Keep track of this element id on the source end&#xD;&#xA;     * when navigating inside it's type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    pushSourcePath(id) {&#xD;&#xA;        this.sourcePath.push(id);&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Remove the last tracked element on the source path stack&#xD;&#xA;     * when done navigating down its type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    popSourcePath() {&#xD;&#xA;        this.sourcePath.pop();&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Keep track of this element id on the target end&#xD;&#xA;     * when navigating inside it's type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    pushTargetPath(id) {&#xD;&#xA;        this.targetPath.push(id);&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Remove the last tracked element on the target path stack&#xD;&#xA;     * when done navigating down its type hierarchy.&#xD;&#xA;     */&#xD;&#xA;    popTargetPath() {&#xD;&#xA;        this.targetPath.pop();&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Record a mapping between a source element id and target element id.&#xD;&#xA;     * Target and Source path stack will be used to build up the whole path.&#xD;&#xA;     */&#xD;&#xA;    addMapping(sourceId, targetId) {&#xD;&#xA;        this.mappings.push({&#xD;&#xA;            sourcePath: this.sourcePath.concat([sourceId]),&#xD;&#xA;            targetPath: this.targetPath.concat([targetId])&#xD;&#xA;        });&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;class ElementManager {&#xD;&#xA;    constructor(innerElement, settings) {&#xD;&#xA;        this.innerElement = innerElement;&#xD;&#xA;        this.settings = settings;&#xD;&#xA;        this.mappedElement = innerElement.getMapping()?.getElement();&#xD;&#xA;    }&#xD;&#xA;    get id() { return this.innerElement.id; }&#xD;&#xA;    ;&#xD;&#xA;    setReturnType(typeId, isCollection, isNullable) {&#xD;&#xA;        this.innerElement.typeReference.setType(typeId);&#xD;&#xA;        if (isCollection != null) {&#xD;&#xA;            this.innerElement.typeReference.setIsCollection(isCollection);&#xD;&#xA;        }&#xD;&#xA;        if (isNullable != null) {&#xD;&#xA;            this.innerElement.typeReference.setIsNullable(isNullable);&#xD;&#xA;        }&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;    addChild(name, type) {&#xD;&#xA;        let existingField = this.innerElement.getChildren(this.settings.childSpecialization)&#xD;&#xA;            .find(c =&gt; c.getName().toLowerCase() == ServicesHelper.formatName(name, this.settings.childType ?? &quot;property&quot;).toLowerCase());&#xD;&#xA;        let field = existingField ?? createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, this.settings.childType ?? &quot;property&quot;), this.innerElement.id);&#xD;&#xA;        const typeReferenceDetails = type == null&#xD;&#xA;            ? null&#xD;&#xA;            : typeof (type) === &quot;string&quot;&#xD;&#xA;                ? { id: type, isNullable: false, isCollection: false }&#xD;&#xA;                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };&#xD;&#xA;        if (typeReferenceDetails != null) {&#xD;&#xA;            field.typeReference.setType(typeReferenceDetails.id);&#xD;&#xA;            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);&#xD;&#xA;            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);&#xD;&#xA;        }&#xD;&#xA;        return field;&#xD;&#xA;    }&#xD;&#xA;    addChildrenFrom(elements, options) {&#xD;&#xA;        let order = 0;&#xD;&#xA;        elements.forEach(e =&gt; {&#xD;&#xA;            if (e.mapPath != null) {&#xD;&#xA;                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let field = this.addChild(e.name, e.typeId);&#xD;&#xA;            field.typeReference.setIsCollection(e.isCollection);&#xD;&#xA;            field.typeReference.setIsNullable(e.isNullable);&#xD;&#xA;            if (options?.addToTop) {&#xD;&#xA;                field.setOrder(order++);&#xD;&#xA;            }&#xD;&#xA;            if (this.mappedElement != null &amp;&amp; e.mapPath) {&#xD;&#xA;                field.setMapping(e.mapPath);&#xD;&#xA;            }&#xD;&#xA;        });&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;    mapToElement(param1, mappingSettingsId) {&#xD;&#xA;        let elementIds;&#xD;&#xA;        let element;&#xD;&#xA;        if (Array.isArray(param1)) {&#xD;&#xA;            elementIds = param1;&#xD;&#xA;            element = lookup(elementIds[elementIds.length - 1]);&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            elementIds = [param1.id];&#xD;&#xA;            element = param1;&#xD;&#xA;        }&#xD;&#xA;        this.mappedElement = element;&#xD;&#xA;        this.innerElement.setMapping(elementIds, mappingSettingsId);&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;    getElement() {&#xD;&#xA;        return this.innerElement;&#xD;&#xA;    }&#xD;&#xA;    collapse() {&#xD;&#xA;        this.innerElement.collapse();&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;../../typings/elementmacro.context.api.d.ts&quot; /&gt;&#xD;&#xA;function getSurrogateKeyType() {&#xD;&#xA;    const commonTypes = {&#xD;&#xA;        guid: &quot;6b649125-18ea-48fd-a6ba-0bfff0d8f488&quot;,&#xD;&#xA;        long: &quot;33013006-E404-48C2-AC46-24EF5A5774FD&quot;,&#xD;&#xA;        int: &quot;fb0a362d-e9e2-40de-b6ff-5ce8167cbe74&quot;&#xD;&#xA;    };&#xD;&#xA;    const javaTypes = {&#xD;&#xA;        long: &quot;e9e575eb-f8de-4ce4-9838-2d09665a752d&quot;,&#xD;&#xA;        int: &quot;b3e5cb3b-8a26-4346-810b-9789afa25a82&quot;&#xD;&#xA;    };&#xD;&#xA;    const typeNameToIdMap = new Map();&#xD;&#xA;    typeNameToIdMap.set(&quot;guid&quot;, commonTypes.guid);&#xD;&#xA;    typeNameToIdMap.set(&quot;int&quot;, lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);&#xD;&#xA;    typeNameToIdMap.set(&quot;long&quot;, lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);&#xD;&#xA;    let typeName = application.getSettings(&quot;ac0a788e-d8b3-4eea-b56d-538608f1ded9&quot;)?.getField(&quot;Key Type&quot;)?.value ?? &quot;int&quot;;&#xD;&#xA;    if (typeNameToIdMap.has(typeName)) {&#xD;&#xA;        return typeNameToIdMap.get(typeName);&#xD;&#xA;    }&#xD;&#xA;    return typeNameToIdMap.get(&quot;guid&quot;);&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;getSurrogateKeyType.ts&quot;/&gt;&#xD;&#xA;/// &lt;reference path=&quot;attributeWithMapPath.ts&quot;/&gt;&#xD;&#xA;class DomainHelper {&#xD;&#xA;    static isAggregateRoot(element) {&#xD;&#xA;        let result = !element.getAssociations(&quot;Association&quot;)&#xD;&#xA;            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    static getCommandOperations(entity) {&#xD;&#xA;        const queryOperationNames = [&quot;Get&quot;, &quot;Find&quot;, &quot;Filter&quot;, &quot;Query&quot;, &quot;Is&quot;, &quot;Must&quot;, &quot;Can&quot;];&#xD;&#xA;        const operations = entity.getChildren(&quot;Operation&quot;).filter(operation =&gt; operation.typeReference.getType() == null ||&#xD;&#xA;            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));&#xD;&#xA;        return operations;&#xD;&#xA;    }&#xD;&#xA;    static isComplexType(element) {&#xD;&#xA;        return element?.specialization === &quot;Data Contract&quot; ||&#xD;&#xA;            element?.specialization === &quot;Value Object&quot; ||&#xD;&#xA;            element?.specialization === &quot;Class&quot;;&#xD;&#xA;    }&#xD;&#xA;    static isComplexTypeById(typeId) {&#xD;&#xA;        let element = lookup(typeId);&#xD;&#xA;        return DomainHelper.isComplexType(element);&#xD;&#xA;    }&#xD;&#xA;    static getOwningAggregate(entity) {&#xD;&#xA;        if (!entity || entity.specialization != &quot;Class&quot;) {&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;        let invalidAssociations = entity.getAssociations(&quot;Association&quot;).filter(x =&gt; x.typeReference.getType() == null);&#xD;&#xA;        if (invalidAssociations.length &gt; 0) {&#xD;&#xA;            console.warn(&quot;Invalid associations found:&quot;);&#xD;&#xA;            invalidAssociations.forEach(x =&gt; {&#xD;&#xA;                console.warn(&quot;Invalid associations: &quot; + x.getName());&#xD;&#xA;            });&#xD;&#xA;        }&#xD;&#xA;        let result = entity.getAssociations(&quot;Association&quot;)&#xD;&#xA;            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;&#xD;&#xA;            // Let's only target collections for now as part of the nested compositional crud support&#xD;&#xA;            // as one-to-one relationships are more expensive to address and possibly not going to&#xD;&#xA;            // be needed.&#xD;&#xA;            x.getOtherEnd().typeReference.isCollection)[0]?.typeReference.getType();&#xD;&#xA;        return result;&#xD;&#xA;        function isOwnedBy(association) {&#xD;&#xA;            return association.isSourceEnd() &amp;&amp;&#xD;&#xA;                !association.typeReference.isNullable &amp;&amp;&#xD;&#xA;                !association.typeReference.isCollection;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static ownerIsAggregateRoot(entity) {&#xD;&#xA;        let result = DomainHelper.getOwningAggregate(entity);&#xD;&#xA;        return result ? true : false;&#xD;&#xA;    }&#xD;&#xA;    static hasPrimaryKey(entity) {&#xD;&#xA;        let keys = entity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;        return keys.length &gt; 0;&#xD;&#xA;    }&#xD;&#xA;    static getPrimaryKeys(entity) {&#xD;&#xA;        if (!entity) {&#xD;&#xA;            throw new Error(&quot;entity not specified&quot;);&#xD;&#xA;        }&#xD;&#xA;        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);&#xD;&#xA;        return Object.values(primaryKeys);&#xD;&#xA;    }&#xD;&#xA;    static isUserSuppliedPrimaryKey(pk) {&#xD;&#xA;        if (pk == null)&#xD;&#xA;            return false;&#xD;&#xA;        if (!pk.hasStereotype(&quot;Primary Key&quot;))&#xD;&#xA;            return false;&#xD;&#xA;        var pkStereotype = pk.getStereotype(&quot;Primary Key&quot;);&#xD;&#xA;        if (!pkStereotype.hasProperty(&quot;Data source&quot;)) {&#xD;&#xA;            return false;&#xD;&#xA;        }&#xD;&#xA;        return pkStereotype.getProperty(&quot;Data source&quot;).value == &quot;User supplied&quot;;&#xD;&#xA;    }&#xD;&#xA;    static getPrimaryKeysMap(entity) {&#xD;&#xA;        let keydict = Object.create(null);&#xD;&#xA;        let keys = entity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;        keys.forEach(key =&gt; keydict[key.id] = {&#xD;&#xA;            id: key.id,&#xD;&#xA;            name: key.getName(),&#xD;&#xA;            typeId: key.typeReference.typeId,&#xD;&#xA;            mapPath: [key.id],&#xD;&#xA;            isNullable: false,&#xD;&#xA;            isCollection: false&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);&#xD;&#xA;        return keydict;&#xD;&#xA;        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {&#xD;&#xA;            if (!curEntity) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            let nextEntity = generalization.typeReference.getType();&#xD;&#xA;            let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;            baseKeys.forEach(key =&gt; {&#xD;&#xA;                keydict[key.id] = {&#xD;&#xA;                    id: key.id,&#xD;&#xA;                    name: key.getName(),&#xD;&#xA;                    typeId: key.typeReference.typeId,&#xD;&#xA;                    mapPath: generalizationStack.concat([key.id]),&#xD;&#xA;                    isNullable: key.typeReference.isNullable,&#xD;&#xA;                    isCollection: key.typeReference.isCollection&#xD;&#xA;                };&#xD;&#xA;            });&#xD;&#xA;            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getForeignKeys(entity, owningAggregate) {&#xD;&#xA;        if (!entity) {&#xD;&#xA;            throw new Error(&quot;entity not specified&quot;);&#xD;&#xA;        }&#xD;&#xA;        if (!owningAggregate) {&#xD;&#xA;            throw new Error(&quot;nestedCompOwner not specified&quot;);&#xD;&#xA;        }&#xD;&#xA;        // Use the new Associated property on the FK stereotype method for FK Attribute lookup&#xD;&#xA;        let foreignKeys = [];&#xD;&#xA;        for (let attr of entity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Foreign Key&quot;))) {&#xD;&#xA;            let associationId = attr.getStereotype(&quot;Foreign Key&quot;).getProperty(&quot;Association&quot;)?.getValue();&#xD;&#xA;            if (owningAggregate.getAssociations(&quot;Association&quot;).some(x =&gt; x.id == associationId)) {&#xD;&#xA;                foreignKeys.push(attr);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        // Backward compatible lookup method&#xD;&#xA;        if (foreignKeys.length == 0) {&#xD;&#xA;            let foundFk = entity.getChildren(&quot;Attribute&quot;)&#xD;&#xA;                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype(&quot;Foreign Key&quot;))[0];&#xD;&#xA;            if (foundFk) {&#xD;&#xA;                foreignKeys.push(foundFk);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return foreignKeys.map(x =&gt; ({&#xD;&#xA;            name: DomainHelper.getAttributeNameFormat(x.getName()),&#xD;&#xA;            typeId: x.typeReference.typeId,&#xD;&#xA;            id: x.id,&#xD;&#xA;            mapPath: [x.id],&#xD;&#xA;            isCollection: x.typeReference.isCollection,&#xD;&#xA;            isNullable: x.typeReference.isNullable,&#xD;&#xA;            element: x&#xD;&#xA;        }));&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Returns true if the attribute is a foreign key on a compositional one-to-many relationship (i.e. is managed by the DB and should not be set).&#xD;&#xA;     * @param attribute&#xD;&#xA;     * @returns&#xD;&#xA;     */&#xD;&#xA;    static isManagedForeignKey(attribute) {&#xD;&#xA;        let fkAssociation = attribute.getStereotype(&quot;Foreign Key&quot;)?.getProperty(&quot;Association&quot;)?.getSelected();&#xD;&#xA;        return fkAssociation != null &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsCollection() &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsNullable();&#xD;&#xA;    }&#xD;&#xA;    static getChildrenOfType(entity, type) {&#xD;&#xA;        let attrDict = Object.create(null);&#xD;&#xA;        let attributes = entity.getChildren(type);&#xD;&#xA;        attributes.forEach(attr =&gt; attrDict[attr.id] = {&#xD;&#xA;            id: attr.id,&#xD;&#xA;            name: attr.getName(),&#xD;&#xA;            typeId: attr.typeReference.typeId,&#xD;&#xA;            mapPath: [attr.id],&#xD;&#xA;            isNullable: attr.typeReference.isNullable,&#xD;&#xA;            isCollection: attr.typeReference.isCollection&#xD;&#xA;        });&#xD;&#xA;        return Object.values(attrDict);&#xD;&#xA;    }&#xD;&#xA;    static getAttributesWithMapPath(entity) {&#xD;&#xA;        let attrDict = Object.create(null);&#xD;&#xA;        let attributes = entity&#xD;&#xA;            .getChildren(&quot;Attribute&quot;)&#xD;&#xA;            .filter(x =&gt; !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp;&#xD;&#xA;            !DomainHelper.legacyPartitionKey(x) &amp;&amp;&#xD;&#xA;            (x[&quot;hasMetadata&quot;] &amp;&amp; (!x.hasMetadata(&quot;set-by-infrastructure&quot;) || x.getMetadata(&quot;set-by-infrastructure&quot;)?.toLocaleLowerCase() != &quot;true&quot;)));&#xD;&#xA;        attributes.forEach(attr =&gt; attrDict[attr.id] = {&#xD;&#xA;            id: attr.id,&#xD;&#xA;            name: attr.getName(),&#xD;&#xA;            typeId: attr.typeReference.typeId,&#xD;&#xA;            mapPath: [attr.id],&#xD;&#xA;            isNullable: false,&#xD;&#xA;            isCollection: false&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);&#xD;&#xA;        return Object.values(attrDict);&#xD;&#xA;        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {&#xD;&#xA;            if (!curEntity) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            let nextEntity = generalization.typeReference.getType();&#xD;&#xA;            let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp; !DomainHelper.legacyPartitionKey(x));&#xD;&#xA;            baseKeys.forEach(attr =&gt; {&#xD;&#xA;                attrDict[attr.id] = {&#xD;&#xA;                    id: attr.id,&#xD;&#xA;                    name: attr.getName(),&#xD;&#xA;                    typeId: attr.typeReference.typeId,&#xD;&#xA;                    mapPath: generalizationStack.concat([attr.id]),&#xD;&#xA;                    isNullable: attr.typeReference.isNullable,&#xD;&#xA;                    isCollection: attr.typeReference.isCollection&#xD;&#xA;                };&#xD;&#xA;            });&#xD;&#xA;            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getMandatoryAssociationsWithMapPath(entity) {&#xD;&#xA;        return traverseInheritanceHierarchy(entity, [], []);&#xD;&#xA;        function traverseInheritanceHierarchy(entity, results, generalizationStack) {&#xD;&#xA;            entity&#xD;&#xA;                .getAssociations(&quot;Association&quot;)&#xD;&#xA;                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;&#xD;&#xA;                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)&#xD;&#xA;                .forEach(association =&gt; {&#xD;&#xA;                return results.push({&#xD;&#xA;                    id: association.id,&#xD;&#xA;                    name: association.getName(),&#xD;&#xA;                    typeId: null,&#xD;&#xA;                    mapPath: generalizationStack.concat([association.id]),&#xD;&#xA;                    isNullable: false,&#xD;&#xA;                    isCollection: false&#xD;&#xA;                });&#xD;&#xA;            });&#xD;&#xA;            let generalizations = entity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return results;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getAttributeNameFormat(str) {&#xD;&#xA;        let convention = DomainHelper.getDomainAttributeNamingConvention();&#xD;&#xA;        switch (convention) {&#xD;&#xA;            case &quot;pascal-case&quot;:&#xD;&#xA;                return toPascalCase(str);&#xD;&#xA;            case &quot;camel-case&quot;:&#xD;&#xA;                return toCamelCase(str);&#xD;&#xA;        }&#xD;&#xA;        return str;&#xD;&#xA;    }&#xD;&#xA;    static getDomainAttributeNamingConvention() {&#xD;&#xA;        const domainSettingsId = &quot;c4d1e35c-7c0d-4926-afe0-18f17563ce17&quot;;&#xD;&#xA;        return application.getSettings(domainSettingsId)&#xD;&#xA;            ?.getField(&quot;Attribute Naming Convention&quot;)?.value ?? &quot;pascal-case&quot;;&#xD;&#xA;    }&#xD;&#xA;    static getSurrogateKeyType() {&#xD;&#xA;        return getSurrogateKeyType();&#xD;&#xA;    }&#xD;&#xA;    // Just in case someone still uses this convention. Used to filter out those attributes when mapping&#xD;&#xA;    // to domain entities that are within a Cosmos DB paradigm.&#xD;&#xA;    static legacyPartitionKey(attribute) {&#xD;&#xA;        return attribute.hasStereotype(&quot;Partition Key&quot;) &amp;&amp; attribute.getName() === &quot;PartitionKey&quot;;&#xD;&#xA;    }&#xD;&#xA;    static requiresForeignKey(associationEnd) {&#xD;&#xA;        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);&#xD;&#xA;    }&#xD;&#xA;    static isManyToVariantsOfOne(associationEnd) {&#xD;&#xA;        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;&#xD;&#xA;    }&#xD;&#xA;    static isSelfReferencingZeroToOne(associationEnd) {&#xD;&#xA;        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;&#xD;&#xA;            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;../../../typings/elementmacro.context.api.d.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/getSurrogateKeyType.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/attributeWithMapPath.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/domainHelper.ts&quot; /&gt;&#xD;&#xA;function getFieldFormat(str) {&#xD;&#xA;    return toPascalCase(str);&#xD;&#xA;}&#xD;&#xA;function getDomainAttributeNameFormat(str) {&#xD;&#xA;    let convention = getDomainAttributeNamingConvention();&#xD;&#xA;    switch (convention) {&#xD;&#xA;        case &quot;pascal-case&quot;:&#xD;&#xA;            return toPascalCase(str);&#xD;&#xA;        case &quot;camel-case&quot;:&#xD;&#xA;            return toCamelCase(str);&#xD;&#xA;        default:&#xD;&#xA;            return str;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;function getOrCreateDto(elementName, parentElement) {&#xD;&#xA;    const expectedDtoName = `${elementName}Dto`;&#xD;&#xA;    let existingDto = parentElement.getChildren(&quot;DTO&quot;).filter(x =&gt; x.getName() === expectedDtoName)[0];&#xD;&#xA;    if (existingDto) {&#xD;&#xA;        return existingDto;&#xD;&#xA;    }&#xD;&#xA;    let dto = createElement(&quot;DTO&quot;, expectedDtoName, parentElement.id);&#xD;&#xA;    return dto;&#xD;&#xA;}&#xD;&#xA;function ensureDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto) {&#xD;&#xA;    let childrenToAdd = DomainHelper.getChildrenOfType(ctor, &quot;Parameter&quot;).filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== &quot;Domain Service&quot;);&#xD;&#xA;    childrenToAdd.forEach(e =&gt; {&#xD;&#xA;        if (e.mapPath != null) {&#xD;&#xA;            if (dto.getChildren(&quot;Parameter&quot;).some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        else if (ctor.getChildren(&quot;Parameter&quot;).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;        let field = createElement(&quot;DTO-Field&quot;, e.name, dto.id);&#xD;&#xA;        field.typeReference.setType(e.typeId);&#xD;&#xA;        field.typeReference.setIsCollection(e.isCollection);&#xD;&#xA;        field.typeReference.setIsNullable(e.isNullable);&#xD;&#xA;        if (this.mappedElement != null &amp;&amp; e.mapPath) {&#xD;&#xA;            field.setMapping(e.mapPath);&#xD;&#xA;        }&#xD;&#xA;    });&#xD;&#xA;    dto.collapse();&#xD;&#xA;}&#xD;&#xA;function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {&#xD;&#xA;    let dtoUpdated = false;&#xD;&#xA;    let domainElement = mappedElement&#xD;&#xA;        .typeReference&#xD;&#xA;        .getType();&#xD;&#xA;    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);&#xD;&#xA;    let isCreateMode = dto.getMetadata(&quot;originalVerb&quot;)?.toLowerCase()?.startsWith(&quot;create&quot;) == true;&#xD;&#xA;    for (var keyName of Object.keys(attributesWithMapPaths)) {&#xD;&#xA;        let entry = attributesWithMapPaths[keyName];&#xD;&#xA;        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {&#xD;&#xA;            continue;&#xD;&#xA;        }&#xD;&#xA;        if (dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName() == entry.name)) {&#xD;&#xA;            continue;&#xD;&#xA;        }&#xD;&#xA;        let field = createElement(&quot;DTO-Field&quot;, toPascalCase(entry.name), dto.id);&#xD;&#xA;        field.typeReference.setType(entry.typeId);&#xD;&#xA;        field.typeReference.setIsNullable(entry.isNullable);&#xD;&#xA;        field.typeReference.setIsCollection(entry.isCollection);&#xD;&#xA;        field.setMapping(entry.mapPath);&#xD;&#xA;        dtoUpdated = true;&#xD;&#xA;    }&#xD;&#xA;    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {&#xD;&#xA;        addPrimaryKeys(dto, domainElement, true);&#xD;&#xA;    }&#xD;&#xA;    if (dtoUpdated) {&#xD;&#xA;        dto.collapse();&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;function isOwnerForeignKey(attributeName, domainElement) {&#xD;&#xA;    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {&#xD;&#xA;        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {&#xD;&#xA;            return true;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    return false;&#xD;&#xA;}&#xD;&#xA;function addPrimaryKeys(dto, entity, map) {&#xD;&#xA;    const primaryKeys = getPrimaryKeysWithMapPath(entity);&#xD;&#xA;    for (const primaryKey of primaryKeys) {&#xD;&#xA;        const name = getDomainAttributeNameFormat(primaryKey.name);&#xD;&#xA;        if (dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {&#xD;&#xA;            continue;&#xD;&#xA;        }&#xD;&#xA;        const dtoField = createElement(&quot;DTO-Field&quot;, getFieldFormat(name), dto.id);&#xD;&#xA;        dtoField.typeReference.setType(primaryKey.typeId);&#xD;&#xA;        if (map &amp;&amp; primaryKey.mapPath != null) {&#xD;&#xA;            console.log(`Doing mapping for ${dtoField.id}`);&#xD;&#xA;            dtoField.setMapping(primaryKey.mapPath);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;function getPrimaryKeysWithMapPath(entity) {&#xD;&#xA;    let keydict = Object.create(null);&#xD;&#xA;    let keys = entity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;    keys.forEach(key =&gt; keydict[key.id] = {&#xD;&#xA;        id: key.id,&#xD;&#xA;        name: key.getName(),&#xD;&#xA;        typeId: key.typeReference.typeId,&#xD;&#xA;        mapPath: [key.id],&#xD;&#xA;        isNullable: false,&#xD;&#xA;        isCollection: false&#xD;&#xA;    });&#xD;&#xA;    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);&#xD;&#xA;    return Object.values(keydict);&#xD;&#xA;    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {&#xD;&#xA;        if (!curEntity) {&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;        let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;        if (generalizations.length == 0) {&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;        let generalization = generalizations[0];&#xD;&#xA;        generalizationStack.push(generalization.id);&#xD;&#xA;        let nextEntity = generalization.typeReference.getType();&#xD;&#xA;        let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;        baseKeys.forEach(key =&gt; {&#xD;&#xA;            keydict[key.id] = {&#xD;&#xA;                id: key.id,&#xD;&#xA;                name: key.getName(),&#xD;&#xA;                typeId: key.typeReference.typeId,&#xD;&#xA;                mapPath: generalizationStack.concat([key.id]),&#xD;&#xA;                isNullable: key.typeReference.isNullable,&#xD;&#xA;                isCollection: key.typeReference.isCollection&#xD;&#xA;            };&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;function getAttributesWithMapPath(entity) {&#xD;&#xA;    let attrDict = Object.create(null);&#xD;&#xA;    let attributes = entity.getChildren(&quot;Attribute&quot;)&#xD;&#xA;        .filter(x =&gt; !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp;&#xD;&#xA;        !legacyPartitionKey(x) &amp;&amp;&#xD;&#xA;        (x[&quot;hasMetadata&quot;] &amp;&amp; (!x.hasMetadata(&quot;set-by-infrastructure&quot;) || x.getMetadata(&quot;set-by-infrastructure&quot;)?.toLocaleLowerCase() != &quot;true&quot;)));&#xD;&#xA;    attributes.forEach(attr =&gt; attrDict[attr.id] = {&#xD;&#xA;        id: attr.id,&#xD;&#xA;        name: attr.getName(),&#xD;&#xA;        typeId: attr.typeReference.typeId,&#xD;&#xA;        mapPath: [attr.id],&#xD;&#xA;        isNullable: false,&#xD;&#xA;        isCollection: false&#xD;&#xA;    });&#xD;&#xA;    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);&#xD;&#xA;    return attrDict;&#xD;&#xA;    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {&#xD;&#xA;        if (!curEntity) {&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;        let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;        if (generalizations.length == 0) {&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;        let generalization = generalizations[0];&#xD;&#xA;        generalizationStack.push(generalization.id);&#xD;&#xA;        let nextEntity = generalization.typeReference.getType();&#xD;&#xA;        let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp; !legacyPartitionKey(x));&#xD;&#xA;        baseKeys.forEach(attr =&gt; {&#xD;&#xA;            attrDict[attr.id] = {&#xD;&#xA;                id: attr.id,&#xD;&#xA;                name: attr.getName(),&#xD;&#xA;                typeId: attr.typeReference.typeId,&#xD;&#xA;                mapPath: generalizationStack.concat([attr.id]),&#xD;&#xA;                isNullable: attr.typeReference.isNullable,&#xD;&#xA;                isCollection: attr.typeReference.isCollection&#xD;&#xA;            };&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;function getDomainAttributeNamingConvention() {&#xD;&#xA;    const domainSettingsId = &quot;c4d1e35c-7c0d-4926-afe0-18f17563ce17&quot;;&#xD;&#xA;    return application.getSettings(domainSettingsId)&#xD;&#xA;        ?.getField(&quot;Attribute Naming Convention&quot;)?.value ?? &quot;pascal-case&quot;;&#xD;&#xA;}&#xD;&#xA;// Just in case someone still uses this convention. Used to filter out those attributes when mapping&#xD;&#xA;// to domain entities that are within a Cosmos DB paradigm.&#xD;&#xA;function legacyPartitionKey(attribute) {&#xD;&#xA;    return attribute.hasStereotype(&quot;Partition Key&quot;) &amp;&amp; attribute.getName() === &quot;PartitionKey&quot;;&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;../common/domainHelper.ts&quot; /&gt;&#xD;&#xA;class CrudConstants {&#xD;&#xA;}&#xD;&#xA;CrudConstants.mapFromDomainMappingSettingId = &quot;1f747d14-681c-4a20-8c68-34223f41b825&quot;;&#xD;&#xA;CrudConstants.mapToDomainConstructorForDtosSettingId = &quot;8d1f6a8a-77c8-43a2-8e60-421559725419&quot;;&#xD;&#xA;CrudConstants.dtoFromEntityMappingId = &quot;1f747d14-681c-4a20-8c68-34223f41b825&quot;;&#xD;&#xA;class CrudHelper {&#xD;&#xA;    // Super basic selection dialog.&#xD;&#xA;    static async openBasicSelectEntityDialog(options) {&#xD;&#xA;        let classes = lookupTypesOf(&quot;Class&quot;).filter(x =&gt; CrudHelper.filterClassSelection(x, options));&#xD;&#xA;        if (classes.length == 0) {&#xD;&#xA;            await dialogService.info(&quot;No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.&quot;);&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({&#xD;&#xA;            id: x.id,&#xD;&#xA;            name: getFriendlyDisplayNameForClassSelection(x),&#xD;&#xA;            additionalInfo: `(${x.getParents().map(item =&gt; item.getName()).join(&quot;/&quot;)})`&#xD;&#xA;        })));&#xD;&#xA;        if (classId == null) {&#xD;&#xA;            await dialogService.error(`No class found with id &quot;${classId}&quot;.`);&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;        let foundEntity = lookup(classId);&#xD;&#xA;        return foundEntity;&#xD;&#xA;        function getFriendlyDisplayNameForClassSelection(element) {&#xD;&#xA;            let aggregateEntity = DomainHelper.getOwningAggregate(element);&#xD;&#xA;            return !aggregateEntity ? element.getName() : `${element.getName()} (${aggregateEntity.getName()})`;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static async openCrudCreationDialog(options) {&#xD;&#xA;        let classes = lookupTypesOf(&quot;Class&quot;).filter(x =&gt; CrudHelper.filterClassSelection(x, options));&#xD;&#xA;        if (classes.length == 0) {&#xD;&#xA;            await dialogService.info(&quot;No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.&quot;);&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;        let dialogResult = await dialogService.openForm({&#xD;&#xA;            title: &quot;CRUD Creation Options&quot;,&#xD;&#xA;            fields: [&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;entityId&quot;,&#xD;&#xA;                    fieldType: &quot;select&quot;,&#xD;&#xA;                    label: &quot;Entity for CRUD operations&quot;,&#xD;&#xA;                    selectOptions: classes.map(x =&gt; {&#xD;&#xA;                        return {&#xD;&#xA;                            id: x.id,&#xD;&#xA;                            description: x.getName(),&#xD;&#xA;                            additionalInfo: getClassAdditionalInfo(x)&#xD;&#xA;                        };&#xD;&#xA;                    }),&#xD;&#xA;                    isRequired: true&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;create&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Create&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate the \&quot;Create\&quot; operation&quot;&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;update&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Update&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate the \&quot;Update\&quot; operation&quot;&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;queryById&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Query By Id&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate the \&quot;Query By Id\&quot; operation&quot;&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;queryAll&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Query All&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate the \&quot;Query All\&quot; operation&quot;&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;delete&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Delete&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate the \&quot;Delete\&quot; operation&quot;&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;domain&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Domain Operations&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate operations for Domain Entity operations&quot;&#xD;&#xA;                }&#xD;&#xA;            ]&#xD;&#xA;        });&#xD;&#xA;        let foundEntity = lookup(dialogResult.entityId);&#xD;&#xA;        var result = {&#xD;&#xA;            selectedEntity: foundEntity,&#xD;&#xA;            canCreate: dialogResult.create == &quot;true&quot;,&#xD;&#xA;            canUpdate: dialogResult.update == &quot;true&quot;,&#xD;&#xA;            canQueryById: dialogResult.queryById == &quot;true&quot;,&#xD;&#xA;            canQueryAll: dialogResult.queryAll == &quot;true&quot;,&#xD;&#xA;            canDelete: dialogResult.delete == &quot;true&quot;,&#xD;&#xA;            canDomain: dialogResult.domain == &quot;true&quot;,&#xD;&#xA;            selectedDomainOperationIds: []&#xD;&#xA;        };&#xD;&#xA;        if (result.canDomain &amp;&amp; foundEntity.getChildren(&quot;Operation&quot;).length &gt; 0) {&#xD;&#xA;            dialogResult = await dialogService.openForm({&#xD;&#xA;                title: &quot;Select Domain Operations&quot;,&#xD;&#xA;                fields: [&#xD;&#xA;                    {&#xD;&#xA;                        id: &quot;tree&quot;,&#xD;&#xA;                        fieldType: &quot;tree-view&quot;,&#xD;&#xA;                        label: &quot;Domain Operations&quot;,&#xD;&#xA;                        hint: &quot;Generate operations from selected domain entity operations&quot;,&#xD;&#xA;                        treeViewOptions: {&#xD;&#xA;                            rootId: foundEntity.id,&#xD;&#xA;                            submitFormTriggers: [&quot;double-click&quot;, &quot;enter&quot;],&#xD;&#xA;                            isMultiSelect: true,&#xD;&#xA;                            selectableTypes: [&#xD;&#xA;                                {&#xD;&#xA;                                    specializationId: &quot;Class&quot;,&#xD;&#xA;                                    autoExpand: true,&#xD;&#xA;                                    autoSelectChildren: false,&#xD;&#xA;                                    isSelectable: (x) =&gt; false&#xD;&#xA;                                },&#xD;&#xA;                                {&#xD;&#xA;                                    specializationId: &quot;Operation&quot;,&#xD;&#xA;                                    isSelectable: (x) =&gt; true&#xD;&#xA;                                }&#xD;&#xA;                            ]&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                ]&#xD;&#xA;            });&#xD;&#xA;            result.selectedDomainOperationIds = dialogResult.tree?.filter((x) =&gt; x != &quot;0&quot;) ?? [];&#xD;&#xA;        }&#xD;&#xA;        return result;&#xD;&#xA;        function getClassAdditionalInfo(element) {&#xD;&#xA;            let aggregateEntity = DomainHelper.getOwningAggregate(element);&#xD;&#xA;            let prefix = aggregateEntity ? `: ${aggregateEntity.getName()}  ` : &quot;&quot;;&#xD;&#xA;            return `${prefix}(${element.getParents().map(item =&gt; item.getName()).join(&quot;/&quot;)})`;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static filterClassSelection(element, options) {&#xD;&#xA;        if (!(options?.allowAbstract ?? false) &amp;&amp; element.getIsAbstract()) {&#xD;&#xA;            return false;&#xD;&#xA;        }&#xD;&#xA;        if (element.hasStereotype(&quot;Repository&quot;)) {&#xD;&#xA;            return true;&#xD;&#xA;        }&#xD;&#xA;        if (options?.includeOwnedRelationships != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {&#xD;&#xA;            return DomainHelper.hasPrimaryKey(element);&#xD;&#xA;        }&#xD;&#xA;        if (DomainHelper.isAggregateRoot(element)) {&#xD;&#xA;            let generalizations = element.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return true;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            let parentEntity = generalization.typeReference.getType();&#xD;&#xA;            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack&#xD;&#xA;            return CrudHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false, allowAbstract: true });&#xD;&#xA;        }&#xD;&#xA;        return false;&#xD;&#xA;    }&#xD;&#xA;    static getName(command, mappedElement, dtoPrefix = null) {&#xD;&#xA;        if (mappedElement.typeReference != null)&#xD;&#xA;            mappedElement = mappedElement.typeReference.getType();&#xD;&#xA;        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];&#xD;&#xA;        let domainName = mappedElement.getName();&#xD;&#xA;        let baseName = command.getMetadata(&quot;baseName&quot;)&#xD;&#xA;            ? `${command.getMetadata(&quot;baseName&quot;)}${domainName}`&#xD;&#xA;            : domainName;&#xD;&#xA;        let dtoName = `${originalVerb}${baseName}`;&#xD;&#xA;        if (dtoPrefix)&#xD;&#xA;            dtoName = `${dtoPrefix}${dtoName}`;&#xD;&#xA;        return dtoName;&#xD;&#xA;    }&#xD;&#xA;    static getOrCreateCrudDto(dtoName, mappedElement, autoAddPrimaryKey, mappingTypeSettingId, folder, inbound = false) {&#xD;&#xA;        let dto = CrudHelper.getOrCreateDto(dtoName, folder);&#xD;&#xA;        //dtoField.typeReference.setType(dto.id);&#xD;&#xA;        const entityCtor = mappedElement&#xD;&#xA;            .getChildren(&quot;Class Constructor&quot;)&#xD;&#xA;            .sort((a, b) =&gt; {&#xD;&#xA;            // In descending order:&#xD;&#xA;            return b.getChildren(&quot;Parameter&quot;).length - a.getChildren(&quot;Parameter&quot;).length;&#xD;&#xA;        })[0];&#xD;&#xA;        if (inbound &amp;&amp; entityCtor != null) {&#xD;&#xA;            dto.setMapping([mappedElement.id, entityCtor.id], CrudConstants.mapToDomainConstructorForDtosSettingId);&#xD;&#xA;            CrudHelper.addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto, folder);&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            dto.setMapping(mappedElement.id, mappingTypeSettingId);&#xD;&#xA;            CrudHelper.addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder);&#xD;&#xA;        }&#xD;&#xA;        return dto;&#xD;&#xA;    }&#xD;&#xA;    static getOrCreateDto(elementName, parentElement) {&#xD;&#xA;        const expectedDtoName = elementName.replace(/Dto$/, &quot;&quot;) + &quot;Dto&quot;;&#xD;&#xA;        let existingDto = parentElement.getChildren(&quot;DTO&quot;).filter(x =&gt; x.getName() === expectedDtoName)[0];&#xD;&#xA;        if (existingDto) {&#xD;&#xA;            return existingDto;&#xD;&#xA;        }&#xD;&#xA;        let dto = createElement(&quot;DTO&quot;, expectedDtoName, parentElement.id);&#xD;&#xA;        return dto;&#xD;&#xA;    }&#xD;&#xA;    static addDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto, folder) {&#xD;&#xA;        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, &quot;Parameter&quot;).filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== &quot;Domain Service&quot;);&#xD;&#xA;        childrenToAdd.forEach(e =&gt; {&#xD;&#xA;            if (e.mapPath != null) {&#xD;&#xA;                if (dto.getChildren(&quot;Parameter&quot;).some(x =&gt; x.getMapping()?.getElement()?.id == e.id)) {&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            else if (ctor.getChildren(&quot;Parameter&quot;).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let field = createElement(&quot;DTO-Field&quot;, toPascalCase(e.name), dto.id);&#xD;&#xA;            field.setMapping(e.mapPath);&#xD;&#xA;            if (DomainHelper.isComplexTypeById(e.typeId)) {&#xD;&#xA;                let dtoName = dto.getName().replace(/Dto$/, &quot;&quot;) + field.getName() + &quot;Dto&quot;;&#xD;&#xA;                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);&#xD;&#xA;                field.typeReference.setType(newDto.id);&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                field.typeReference.setType(e.typeId);&#xD;&#xA;            }&#xD;&#xA;            field.typeReference.setIsCollection(e.isCollection);&#xD;&#xA;            field.typeReference.setIsNullable(e.isNullable);&#xD;&#xA;        });&#xD;&#xA;        dto.collapse();&#xD;&#xA;    }&#xD;&#xA;    static addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder) {&#xD;&#xA;        let dtoUpdated = false;&#xD;&#xA;        let domainElement = mappedElement;&#xD;&#xA;        let attributesWithMapPaths = CrudHelper.getAttributesWithMapPath(domainElement);&#xD;&#xA;        let isCreateMode = dto.getMetadata(&quot;originalVerb&quot;)?.toLowerCase()?.startsWith(&quot;create&quot;) == true;&#xD;&#xA;        for (var keyName of Object.keys(attributesWithMapPaths)) {&#xD;&#xA;            let entry = attributesWithMapPaths[keyName];&#xD;&#xA;            if (isCreateMode &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            if (dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName() == entry.name)) {&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            let field = createElement(&quot;DTO-Field&quot;, entry.name, dto.id);&#xD;&#xA;            field.setMapping(entry.mapPath);&#xD;&#xA;            if (DomainHelper.isComplexTypeById(entry.typeId)) {&#xD;&#xA;                let dtoName = dto.getName().replace(/Dto$/, &quot;&quot;) + field.getName() + &quot;Dto&quot;;&#xD;&#xA;                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);&#xD;&#xA;                field.typeReference.setType(newDto.id);&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                field.typeReference.setType(entry.typeId);&#xD;&#xA;            }&#xD;&#xA;            field.typeReference.setIsNullable(entry.isNullable);&#xD;&#xA;            field.typeReference.setIsCollection(entry.isCollection);&#xD;&#xA;            dtoUpdated = true;&#xD;&#xA;        }&#xD;&#xA;        if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {&#xD;&#xA;            CrudHelper.addPrimaryKeys(dto, domainElement, true);&#xD;&#xA;        }&#xD;&#xA;        if (dtoUpdated) {&#xD;&#xA;            dto.collapse();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static isOwnerForeignKey(attributeName, domainElement) {&#xD;&#xA;        for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {&#xD;&#xA;            if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {&#xD;&#xA;                return true;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return false;&#xD;&#xA;    }&#xD;&#xA;    static addPrimaryKeys(dto, entity, map) {&#xD;&#xA;        const primaryKeys = CrudHelper.getPrimaryKeysWithMapPath(entity);&#xD;&#xA;        for (const primaryKey of primaryKeys) {&#xD;&#xA;            const name = CrudHelper.getDomainAttributeNameFormat(primaryKey.name);&#xD;&#xA;            if (dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            const dtoField = createElement(&quot;DTO-Field&quot;, CrudHelper.getFieldFormat(name), dto.id);&#xD;&#xA;            dtoField.typeReference.setType(primaryKey.typeId);&#xD;&#xA;            if (map &amp;&amp; primaryKey.mapPath != null) {&#xD;&#xA;                console.log(`Doing mapping for ${dtoField.id}`);&#xD;&#xA;                dtoField.setMapping(primaryKey.mapPath);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getPrimaryKeysWithMapPath(entity) {&#xD;&#xA;        let keydict = Object.create(null);&#xD;&#xA;        let keys = entity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;        keys.forEach(key =&gt; keydict[key.id] = {&#xD;&#xA;            id: key.id,&#xD;&#xA;            name: key.getName(),&#xD;&#xA;            typeId: key.typeReference.typeId,&#xD;&#xA;            mapPath: [key.id],&#xD;&#xA;            isNullable: false,&#xD;&#xA;            isCollection: false&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);&#xD;&#xA;        return Object.values(keydict);&#xD;&#xA;        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {&#xD;&#xA;            if (!curEntity) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            let nextEntity = generalization.typeReference.getType();&#xD;&#xA;            let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;            baseKeys.forEach(key =&gt; {&#xD;&#xA;                keydict[key.id] = {&#xD;&#xA;                    id: key.id,&#xD;&#xA;                    name: key.getName(),&#xD;&#xA;                    typeId: key.typeReference.typeId,&#xD;&#xA;                    mapPath: generalizationStack.concat([key.id]),&#xD;&#xA;                    isNullable: key.typeReference.isNullable,&#xD;&#xA;                    isCollection: key.typeReference.isCollection&#xD;&#xA;                };&#xD;&#xA;            });&#xD;&#xA;            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getAttributesWithMapPath(entity) {&#xD;&#xA;        let attrDict = Object.create(null);&#xD;&#xA;        let attributes = entity.getChildren(&quot;Attribute&quot;)&#xD;&#xA;            .filter(x =&gt; !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp;&#xD;&#xA;            !DomainHelper.isManagedForeignKey(x) &amp;&amp; // essentially also an attribute set by infrastructure&#xD;&#xA;            !CrudHelper.legacyPartitionKey(x) &amp;&amp;&#xD;&#xA;            (x[&quot;hasMetadata&quot;] &amp;&amp; (!x.hasMetadata(&quot;set-by-infrastructure&quot;) || x.getMetadata(&quot;set-by-infrastructure&quot;)?.toLocaleLowerCase() != &quot;true&quot;)));&#xD;&#xA;        attributes.forEach(attr =&gt; attrDict[attr.id] = {&#xD;&#xA;            id: attr.id,&#xD;&#xA;            name: attr.getName(),&#xD;&#xA;            typeId: attr.typeReference.typeId,&#xD;&#xA;            mapPath: [attr.id],&#xD;&#xA;            isNullable: false,&#xD;&#xA;            isCollection: false&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);&#xD;&#xA;        return attrDict;&#xD;&#xA;        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {&#xD;&#xA;            if (!curEntity) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            let nextEntity = generalization.typeReference.getType();&#xD;&#xA;            let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp; !CrudHelper.legacyPartitionKey(x));&#xD;&#xA;            baseKeys.forEach(attr =&gt; {&#xD;&#xA;                attrDict[attr.id] = {&#xD;&#xA;                    id: attr.id,&#xD;&#xA;                    name: attr.getName(),&#xD;&#xA;                    typeId: attr.typeReference.typeId,&#xD;&#xA;                    mapPath: generalizationStack.concat([attr.id]),&#xD;&#xA;                    isNullable: attr.typeReference.isNullable,&#xD;&#xA;                    isCollection: attr.typeReference.isCollection&#xD;&#xA;                };&#xD;&#xA;            });&#xD;&#xA;            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getFieldFormat(str) {&#xD;&#xA;        return toPascalCase(str);&#xD;&#xA;    }&#xD;&#xA;    static getDomainAttributeNameFormat(str) {&#xD;&#xA;        let convention = CrudHelper.getDomainAttributeNamingConvention();&#xD;&#xA;        switch (convention) {&#xD;&#xA;            case &quot;pascal-case&quot;:&#xD;&#xA;                return toPascalCase(str);&#xD;&#xA;            case &quot;camel-case&quot;:&#xD;&#xA;                return toCamelCase(str);&#xD;&#xA;            default:&#xD;&#xA;                return str;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getDomainAttributeNamingConvention() {&#xD;&#xA;        const domainSettingsId = &quot;c4d1e35c-7c0d-4926-afe0-18f17563ce17&quot;;&#xD;&#xA;        return application.getSettings(domainSettingsId)&#xD;&#xA;            ?.getField(&quot;Attribute Naming Convention&quot;)?.value ?? &quot;pascal-case&quot;;&#xD;&#xA;    }&#xD;&#xA;    // Just in case someone still uses this convention. Used to filter out those attributes when mapping&#xD;&#xA;    // to domain entities that are within a Cosmos DB paradigm.&#xD;&#xA;    static legacyPartitionKey(attribute) {&#xD;&#xA;        return attribute.hasStereotype(&quot;Partition Key&quot;) &amp;&amp; attribute.getName() === &quot;PartitionKey&quot;;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;./onMapFunctions.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/crudHelper.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../../typings/elementmacro.context.api.d.ts&quot; /&gt;&#xD;&#xA;const stringTypeId = &quot;d384db9c-a279-45e1-801e-e4e8099625f2&quot;;&#xD;&#xA;function onMapDto(element, folder, autoAddPrimaryKey = true, dtoPrefix = null, inbound = false) {&#xD;&#xA;    if (element.isMapped) {&#xD;&#xA;        let mappedFields = element.getChildren(&quot;DTO-Field&quot;).filter(x =&gt; x.getMapping());&#xD;&#xA;        let unmappedFields = element.getChildren(&quot;DTO-Field&quot;).filter(x =&gt; !x.getMapping());&#xD;&#xA;        for (let mappedField of mappedFields) {&#xD;&#xA;            // Unfortunately have to take into account Intent's ability to disambiguate newly created fields... (the &quot;1&quot;)&#xD;&#xA;            let matchedUnmappedField = unmappedFields&#xD;&#xA;                .filter(x =&gt; `${x.getName()}1` === mappedField.getName() ||&#xD;&#xA;                x.getName() === mappedField.getName())[0];&#xD;&#xA;            if (!matchedUnmappedField) {&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            matchedUnmappedField.setMapping(mappedField.getMapping().getElement().id, mappedField.getMapping().mappingSettingsId);&#xD;&#xA;            mappedField.delete();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    let fields = element.getChildren(&quot;DTO-Field&quot;)&#xD;&#xA;        .filter(x =&gt; x.typeReference.getType()?.specialization != &quot;DTO&quot; &amp;&amp; x.getMapping()?.getElement()?.specialization.startsWith(&quot;Association&quot;));&#xD;&#xA;    fields.forEach(f =&gt; {&#xD;&#xA;        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;&#xD;&#xA;        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement().typeReference.getType(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, targetMappingSettingId, folder, inbound);&#xD;&#xA;        f.typeReference.setType(newDto.id);&#xD;&#xA;    });&#xD;&#xA;    let complexAttributes = element.getChildren(&quot;DTO-Field&quot;)&#xD;&#xA;        .filter(x =&gt; x.typeReference.getType()?.specialization != &quot;DTO&quot;&#xD;&#xA;        &amp;&amp; (DomainHelper.isComplexType(x.getMapping()?.getElement()?.typeReference?.getType())));&#xD;&#xA;    complexAttributes.forEach(f =&gt; {&#xD;&#xA;        let targetMappingSettingId = f.getParent().getMapping().mappingSettingsId;&#xD;&#xA;        let newDto = CrudHelper.getOrCreateCrudDto(CrudHelper.getName(element, f.getMapping().getElement(), dtoPrefix), f.getMapping().getElement().typeReference.getType(), false, targetMappingSettingId, folder, inbound);&#xD;&#xA;        f.typeReference.setType(newDto.id);&#xD;&#xA;    });&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;servicesHelper.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;mappingStore.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;elementManager.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../services-cqrs-crud/_common/onMapDto.ts&quot; /&gt;&#xD;&#xA;var RepositoryCrudType;&#xD;&#xA;(function (RepositoryCrudType) {&#xD;&#xA;    RepositoryCrudType[RepositoryCrudType[&quot;Create&quot;] = 0] = &quot;Create&quot;;&#xD;&#xA;    RepositoryCrudType[RepositoryCrudType[&quot;Read&quot;] = 1] = &quot;Read&quot;;&#xD;&#xA;    RepositoryCrudType[RepositoryCrudType[&quot;Update&quot;] = 2] = &quot;Update&quot;;&#xD;&#xA;    RepositoryCrudType[RepositoryCrudType[&quot;Delete&quot;] = 3] = &quot;Delete&quot;;&#xD;&#xA;})(RepositoryCrudType || (RepositoryCrudType = {}));&#xD;&#xA;const mapToDomainOperationSettingId = &quot;7c31c459-6229-4f10-bf13-507348cd8828&quot;;&#xD;&#xA;class RepositoryServiceHelper {&#xD;&#xA;    static _createService(repository, folder) {&#xD;&#xA;        let serviceName = repository.getName();&#xD;&#xA;        serviceName = RepositoryServiceHelper.sanitizeServiceName(serviceName);&#xD;&#xA;        const existing = folder.getPackage().getChildren(&quot;Service&quot;).find(x =&gt; x.getName() == serviceName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        let serviceElement = createElement(&quot;Service&quot;, serviceName, folder.getPackage().id);&#xD;&#xA;        //const httpServiceSettingsStereotypeId = &quot;c29224ec-d473-4b95-ad4a-ec55c676c4fd&quot;;&#xD;&#xA;        // let httpServiceSettings = serviceElement.getStereotype(httpServiceSettingsStereotypeId) ?? serviceElement.addStereotype(httpServiceSettingsStereotypeId);&#xD;&#xA;        // httpServiceSettings.getProperty(&quot;Route&quot;).setValue(`api/${toKebabCase(serviceName)}`);&#xD;&#xA;        return serviceElement;&#xD;&#xA;    }&#xD;&#xA;    static sanitizeServiceName(name) {&#xD;&#xA;        name = removeSuffix(name, &quot;Repository&quot;);&#xD;&#xA;        name += &quot;Service&quot;;&#xD;&#xA;        name = toPascalCase(name);&#xD;&#xA;        return name;&#xD;&#xA;    }&#xD;&#xA;    static createAppServiceOperationAction(operation, folder, service, syncElement = false) {&#xD;&#xA;        let operationName = operation.getName();&#xD;&#xA;        operationName = removeSuffix(operationName, &quot;Async&quot;);&#xD;&#xA;        operationName = toPascalCase(operationName);&#xD;&#xA;        if (!service) {&#xD;&#xA;            service = RepositoryServiceHelper._createService(operation.getParent(), folder);&#xD;&#xA;        }&#xD;&#xA;        // look up if there is an existing operation with the same name&#xD;&#xA;        const existing = service.getChildren().find(x =&gt; x.getName() == operationName);&#xD;&#xA;        // and return the existing one if the sync is disable (which is is by default)&#xD;&#xA;        if (existing &amp;&amp; !syncElement) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        let operationElement = existing ?? createElement(&quot;Operation&quot;, operationName, service.id);&#xD;&#xA;        let mappingStore = new MappingStore();&#xD;&#xA;        RepositoryServiceHelper.createAction(operation.getChildren(&quot;Parameter&quot;), operationElement, false, folder, mappingStore, existing != null);&#xD;&#xA;        // only add the association if not an existing operation&#xD;&#xA;        if (!existing) {&#xD;&#xA;            let callOp = createAssociation(&quot;Call Service Operation&quot;, operationElement.id, operation.id);&#xD;&#xA;            let mapping = callOp.createAdvancedMapping(operationElement.id, operation.id);&#xD;&#xA;            mapping.addMappedEnd(&quot;Invocation Mapping&quot;, [operationElement.id], [operation.id]);&#xD;&#xA;            for (let entry of mappingStore.getMappings().reverse()) {&#xD;&#xA;                //console.warn(&quot;source: &quot; + entry.sourcePath + &quot; to target: &quot; + entry.targetPath);&#xD;&#xA;                mapping.addMappedEnd(&quot;Data Mapping&quot;, entry.sourcePath, entry.targetPath);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        if (!DomainHelper.isComplexType(operation.typeReference?.getType())) {&#xD;&#xA;            operationElement.typeReference.setType(operation.typeReference.getTypeId());&#xD;&#xA;            operationElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());&#xD;&#xA;            operationElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            var resultDto = RepositoryServiceHelper.createRepositoryClassTypeDto(operation, operation.typeReference?.getType(), folder);&#xD;&#xA;            operationElement.typeReference.setType(resultDto.id);&#xD;&#xA;            operationElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());&#xD;&#xA;            operationElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());&#xD;&#xA;        }&#xD;&#xA;        return operationElement;&#xD;&#xA;    }&#xD;&#xA;    static createCqrsAction(operation, folder, syncElement = false) {&#xD;&#xA;        let operationName = operation.getName();&#xD;&#xA;        operationName = removeSuffix(operationName, &quot;Async&quot;, &quot;Command&quot;, &quot;Query&quot;);&#xD;&#xA;        operationName = toPascalCase(operationName);&#xD;&#xA;        let metadata = RepositoryServiceHelper.getRepositoryOperationMetadata(operation);&#xD;&#xA;        let actionTypeName;&#xD;&#xA;        switch (metadata.crudType) {&#xD;&#xA;            default:&#xD;&#xA;                actionTypeName = &quot;Command&quot;;&#xD;&#xA;                break;&#xD;&#xA;            case RepositoryCrudType.Read:&#xD;&#xA;                actionTypeName = &quot;Query&quot;;&#xD;&#xA;                break;&#xD;&#xA;        }&#xD;&#xA;        const actionName = `${operationName}${actionTypeName}`;&#xD;&#xA;        // if sync is set to true, then don't return right away&#xD;&#xA;        const existing = folder.getChildren().find(x =&gt; x.getName() == actionName);&#xD;&#xA;        if (existing &amp;&amp; !syncElement) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        const actionElement = existing ?? createElement(actionTypeName, actionName, folder.id);&#xD;&#xA;        let mappingStore = new MappingStore();&#xD;&#xA;        RepositoryServiceHelper.createAction(operation.getChildren(&quot;Parameter&quot;), actionElement, true, folder, mappingStore, existing != null);&#xD;&#xA;        // don't recreate the association if it the entity exists exists&#xD;&#xA;        if (!existing) {&#xD;&#xA;            let callOp = createAssociation(&quot;Call Service Operation&quot;, actionElement.id, operation.id);&#xD;&#xA;            let mapping = callOp.createAdvancedMapping(actionElement.id, operation.id);&#xD;&#xA;            mapping.addMappedEnd(&quot;Invocation Mapping&quot;, [actionElement.id], [operation.id]);&#xD;&#xA;            for (let entry of mappingStore.getMappings().reverse()) {&#xD;&#xA;                //console.warn(&quot;source: &quot; + entry.sourcePath + &quot; to target: &quot; + entry.targetPath);&#xD;&#xA;                mapping.addMappedEnd(&quot;Data Mapping&quot;, entry.sourcePath, entry.targetPath);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        if (!DomainHelper.isComplexType(operation.typeReference?.getType())) {&#xD;&#xA;            actionElement.typeReference.setType(operation.typeReference.getTypeId());&#xD;&#xA;            actionElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());&#xD;&#xA;            actionElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            var resultDto = RepositoryServiceHelper.createRepositoryClassTypeDto(operation, operation.typeReference?.getType(), folder);&#xD;&#xA;            actionElement.typeReference.setType(resultDto.id);&#xD;&#xA;            actionElement.typeReference.setIsCollection(operation.typeReference.getIsCollection());&#xD;&#xA;            actionElement.typeReference.setIsNullable(operation.typeReference.getIsNullable());&#xD;&#xA;        }&#xD;&#xA;        return actionElement;&#xD;&#xA;    }&#xD;&#xA;    static getRepositoryOperationMetadata(operation) {&#xD;&#xA;        let mappedElement = operation.getMapping()?.getElement();&#xD;&#xA;        mappedElement;&#xD;&#xA;        let crudType;&#xD;&#xA;        let httpSettings = mappedElement?.getStereotype(&quot;Http Settings&quot;);&#xD;&#xA;        let httpVerb = httpSettings?.getProperty(&quot;Verb&quot;)?.getValue();&#xD;&#xA;        let httpRoute = httpSettings?.getProperty(&quot;Route&quot;)?.getValue();&#xD;&#xA;        const routeParamRegex = /\{([a-zA-Z0-9_\-]+)\}/g;&#xD;&#xA;        let httpRouteParams = httpRoute ? [...httpRoute.matchAll(routeParamRegex)].map(match =&gt; match[1]) : [];&#xD;&#xA;        if (httpVerb) {&#xD;&#xA;            switch (httpVerb.toUpperCase()) {&#xD;&#xA;                case &quot;POST&quot;:&#xD;&#xA;                    crudType = RepositoryCrudType.Create;&#xD;&#xA;                    break;&#xD;&#xA;                case &quot;PUT&quot;:&#xD;&#xA;                    crudType = RepositoryCrudType.Update;&#xD;&#xA;                    break;&#xD;&#xA;                case &quot;DELETE&quot;:&#xD;&#xA;                    crudType = RepositoryCrudType.Delete;&#xD;&#xA;                    break;&#xD;&#xA;                case &quot;GET&quot;:&#xD;&#xA;                    crudType = RepositoryCrudType.Read;&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        else if (mappedElement &amp;&amp; (mappedElement.specialization === &quot;Command&quot; ||&#xD;&#xA;            mappedElement.specialization === &quot;Query&quot; ||&#xD;&#xA;            mappedElement.specialization === &quot;Operation&quot;)) {&#xD;&#xA;            for (let association of mappedElement.getAssociations()) {&#xD;&#xA;                switch (association.specialization) {&#xD;&#xA;                    case &quot;Create Entity Action&quot;:&#xD;&#xA;                        crudType = RepositoryCrudType.Create;&#xD;&#xA;                        break;&#xD;&#xA;                    case &quot;Update Entity Action&quot;:&#xD;&#xA;                        crudType = RepositoryCrudType.Update;&#xD;&#xA;                        break;&#xD;&#xA;                    case &quot;Delete Entity Action&quot;:&#xD;&#xA;                        crudType = RepositoryCrudType.Delete;&#xD;&#xA;                        break;&#xD;&#xA;                    case &quot;Query Entity Action&quot;:&#xD;&#xA;                        crudType = RepositoryCrudType.Read;&#xD;&#xA;                        break;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        else if (!crudType) {&#xD;&#xA;            let mappedElementNameLower = (mappedElement ? mappedElement.getName() : operation.getName()).toLocaleLowerCase();&#xD;&#xA;            if (mappedElementNameLower.indexOf(&quot;create&quot;) &gt; -1) {&#xD;&#xA;                crudType = RepositoryCrudType.Create;&#xD;&#xA;            }&#xD;&#xA;            else if (mappedElementNameLower.indexOf(&quot;update&quot;) &gt; -1) {&#xD;&#xA;                crudType = RepositoryCrudType.Update;&#xD;&#xA;            }&#xD;&#xA;            else if (mappedElementNameLower.indexOf(&quot;delete&quot;) &gt; -1) {&#xD;&#xA;                crudType = RepositoryCrudType.Delete;&#xD;&#xA;            }&#xD;&#xA;            else if (mappedElementNameLower.indexOf(&quot;get&quot;) &gt; -1 || mappedElementNameLower.indexOf(&quot;find&quot;) &gt; -1) {&#xD;&#xA;                crudType = RepositoryCrudType.Read;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return {&#xD;&#xA;            crudType: crudType,&#xD;&#xA;            httpVerb: httpVerb,&#xD;&#xA;            httpRoute: httpRoute,&#xD;&#xA;            httpRouteParams: httpRouteParams&#xD;&#xA;        };&#xD;&#xA;    }&#xD;&#xA;    static createAction(repositoryFields, actionElement, flattenFieldsFromComplexTypes, folder, mappingStore, isExistingElement = false) {&#xD;&#xA;        // console.warn(&quot;recreateAction called with actionElement: &quot; + actionElement.getName());&#xD;&#xA;        // console.warn(&quot;repositoryFields.length: &quot; + repositoryFields.length);&#xD;&#xA;        // console.warn(&quot;actionElement specializationId:&quot; + actionElement.specialization);&#xD;&#xA;        const childSpecialization = actionElement.specialization == &quot;Operation&quot; ? &quot;Parameter&quot; : &quot;DTO-Field&quot;;&#xD;&#xA;        //console.warn(&quot;childSpecialization: &quot; + childSpecialization);&#xD;&#xA;        let elementManager = new ElementManager(actionElement, { childSpecialization: childSpecialization });&#xD;&#xA;        for (let repositoryField of repositoryFields) {&#xD;&#xA;            let paramRefType = repositoryField.typeReference?.getType()?.specialization;&#xD;&#xA;            //console.warn(&quot;Field specialization: &quot; + childSpecialization);&#xD;&#xA;            //console.warn(&quot;paramRefType: &quot; + paramRefType);&#xD;&#xA;            switch (paramRefType) {&#xD;&#xA;                case &quot;Class&quot;:&#xD;&#xA;                case &quot;Data Contract&quot;:&#xD;&#xA;                case &quot;Value Object&quot;:&#xD;&#xA;                    let repositoryRefType = repositoryField.typeReference.getType();&#xD;&#xA;                    if (flattenFieldsFromComplexTypes &amp;&amp; !repositoryField.typeReference?.isCollection) {&#xD;&#xA;                        mappingStore.pushTargetPath(repositoryField.id);&#xD;&#xA;                        RepositoryServiceHelper.createAction(repositoryRefType.getChildren(&quot;Attribute&quot;), elementManager.getElement(), false, folder, mappingStore, isExistingElement);&#xD;&#xA;                        mappingStore.popTargetPath();&#xD;&#xA;                    }&#xD;&#xA;                    else {&#xD;&#xA;                        //console.warn(&quot;in the else:&quot;);&#xD;&#xA;                        let actionField = elementManager.addChild(repositoryField.getName(), null);&#xD;&#xA;                        //console.warn(&quot;Pushing source: &quot; + actionField.getName());&#xD;&#xA;                        //console.warn(&quot;Pushing target: &quot; + repositoryField.getName());&#xD;&#xA;                        mappingStore.pushSourcePath(actionField.id);&#xD;&#xA;                        mappingStore.pushTargetPath(repositoryField.id);&#xD;&#xA;                        let actionDto = RepositoryServiceHelper.replicateDto(repositoryRefType, folder, mappingStore, isExistingElement);&#xD;&#xA;                        mappingStore.popSourcePath();&#xD;&#xA;                        mappingStore.popTargetPath();&#xD;&#xA;                        actionField.typeReference.setType(actionDto.id);&#xD;&#xA;                        actionField.typeReference.setIsCollection(repositoryField.typeReference.isCollection);&#xD;&#xA;                        actionField.typeReference.setIsNullable(repositoryField.typeReference.isNullable);&#xD;&#xA;                        if (repositoryField.hasMetadata(&quot;endpoint-input-id&quot;) &amp;&amp; !actionField.hasMetadata(&quot;endpoint-input-id&quot;)) {&#xD;&#xA;                            actionField.addMetadata(&quot;endpoint-input-id&quot;, repositoryField.getMetadata(&quot;endpoint-input-id&quot;));&#xD;&#xA;                        }&#xD;&#xA;                        if (repositoryField.typeReference?.isCollection) {&#xD;&#xA;                            //console.warn(&quot;setting values and stuff&quot;);&#xD;&#xA;                            //console.warn(&quot;actionDto.getValue: &quot; + actionDto.getValue());&#xD;&#xA;                            actionField.setValue(actionDto.getValue());&#xD;&#xA;                            if (!isExistingElement) {&#xD;&#xA;                                //console.warn(&quot;Adding mapping&quot;);&#xD;&#xA;                                mappingStore.addMapping(actionField.id, repositoryField.id);&#xD;&#xA;                            }&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;                default:&#xD;&#xA;                    // Non-Complex type&#xD;&#xA;                    // if mapping directly to a class, skip over the primary keys &#xD;&#xA;                    if (repositoryField.hasStereotype(&quot;Primary Key&quot;)) {&#xD;&#xA;                        continue;&#xD;&#xA;                    }&#xD;&#xA;                    let fieldName = repositoryField.getName();&#xD;&#xA;                    if (elementManager.getElement().getChildren().some(x =&gt; x.getName() === fieldName) &amp;&amp; !isExistingElement) {&#xD;&#xA;                        let parentName = repositoryField.getParent().getName();&#xD;&#xA;                        fieldName = parentName + fieldName;&#xD;&#xA;                    }&#xD;&#xA;                    // console.warn(&quot;Adding simple field: &quot; + fieldName);&#xD;&#xA;                    // console.warn(&quot;repositoryField.typeReference: &quot; + repositoryField.typeReference.getType().getName());&#xD;&#xA;                    let actionField = elementManager.addChild(fieldName, repositoryField.typeReference);&#xD;&#xA;                    actionField.setValue(repositoryField.getValue());&#xD;&#xA;                    //console.warn(&quot;isExistingElement: &quot; + isExistingElement);&#xD;&#xA;                    if (!isExistingElement) {&#xD;&#xA;                        //console.warn(&quot;adding child mapping for action:&quot; + actionField.getName());&#xD;&#xA;                        //console.warn(&quot;adding child mapping for repo:&quot; + repositoryField.getName());&#xD;&#xA;                        mappingStore.addMapping(actionField.id, repositoryField.id);&#xD;&#xA;                    }&#xD;&#xA;                    if (repositoryField.hasMetadata(&quot;endpoint-input-id&quot;) &amp;&amp; !actionField.hasMetadata(&quot;endpoint-input-id&quot;)) {&#xD;&#xA;                        actionField.addMetadata(&quot;endpoint-input-id&quot;, repositoryField.getMetadata(&quot;endpoint-input-id&quot;));&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        elementManager.collapse();&#xD;&#xA;    }&#xD;&#xA;    static getBaseNameForElement(owningAggregate, entity, entityIsMany) {&#xD;&#xA;        // Keeping 'owningAggregate' in case we still need to use it as part of the name one day&#xD;&#xA;        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());&#xD;&#xA;        return entityName;&#xD;&#xA;    }&#xD;&#xA;    static createRepositoryClassTypeDto(operation, entity, folder) {&#xD;&#xA;        let owningAggregate = DomainHelper.getOwningAggregate(entity);&#xD;&#xA;        let baseName = this.getBaseNameForElement(owningAggregate, entity, false);&#xD;&#xA;        let expectedDtoName = `${operation.getName()}${baseName}Dto`;&#xD;&#xA;        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedDtoName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        let dto = createElement(&quot;DTO&quot;, expectedDtoName, folder.id);&#xD;&#xA;        dto.setMetadata(&quot;baseName&quot;, baseName);&#xD;&#xA;        dto.setMapping(entity.id);&#xD;&#xA;        let primaryKeys = DomainHelper.getPrimaryKeys(entity);&#xD;&#xA;        if (owningAggregate) {&#xD;&#xA;            let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);&#xD;&#xA;            foreignKeys.forEach(fk =&gt; {&#xD;&#xA;                let field = createElement(&quot;DTO-Field&quot;, ServicesHelper.getFieldFormat(fk.name), dto.id);&#xD;&#xA;                field.typeReference.setType(fk.typeId);&#xD;&#xA;                if (fk.mapPath) {&#xD;&#xA;                    field.setMapping(fk.mapPath);&#xD;&#xA;                }&#xD;&#xA;            });&#xD;&#xA;        }&#xD;&#xA;        ServicesHelper.addDtoFieldsFromDomain(dto, primaryKeys);&#xD;&#xA;        let attributesWithMapPaths = DomainHelper.getAttributesWithMapPath(entity);&#xD;&#xA;        for (var attr of attributesWithMapPaths) {&#xD;&#xA;            if (dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getMapping()?.getElement()?.id == attr.id)) {&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            let field = createElement(&quot;DTO-Field&quot;, attr.name, dto.id);&#xD;&#xA;            field.typeReference.setType(attr.typeId);&#xD;&#xA;            field.setMapping(attr.mapPath);&#xD;&#xA;        }&#xD;&#xA;        onMapDto(dto, folder);&#xD;&#xA;        dto.collapse();&#xD;&#xA;        return dto;&#xD;&#xA;    }&#xD;&#xA;    static replicateDto(repositoryDto, folder, mappingStore, isExistingElement = false) {&#xD;&#xA;        console.warn(&quot;replicateDto:&quot; + repositoryDto.getName());&#xD;&#xA;        var expectedName = `${repositoryDto.getName()}Dto`;&#xD;&#xA;        // check to see if there is a DTO with the same name, and only if there is and we are working with an existing element do we update&#xD;&#xA;        // this is to preserve backwards compatibility&#xD;&#xA;        let existingDto = folder.getChildren().find(x =&gt; x.getName() == expectedName);&#xD;&#xA;        let newDto = (existingDto &amp;&amp; isExistingElement) ? existingDto : createElement(&quot;DTO&quot;, expectedName, folder.id);&#xD;&#xA;        let elementManager = new ElementManager(newDto, { childSpecialization: &quot;DTO-Field&quot; });&#xD;&#xA;        repositoryDto.getChildren(&quot;Attribute&quot;).forEach(repositoryField =&gt; {&#xD;&#xA;            let existingField = newDto.getChildren().find(c =&gt; c.getName() == repositoryField.getName());&#xD;&#xA;            //let actionField =  (existingField &amp;&amp; isExistingElement) ? existingField :  createElement(&quot;DTO-Field&quot;, repositoryField.getName(), newDto.id);&#xD;&#xA;            let actionField = (existingField &amp;&amp; isExistingElement) ? existingField : elementManager.addChild(repositoryField.getName(), null);&#xD;&#xA;            let fieldRefType = repositoryField.typeReference?.getType()?.specialization;&#xD;&#xA;            console.warn(&quot;actionField: &quot; + actionField.getName());&#xD;&#xA;            console.warn(&quot;repositoryField: &quot; + repositoryField.getName());&#xD;&#xA;            switch (fieldRefType) {&#xD;&#xA;                case &quot;Class&quot;:&#xD;&#xA;                case &quot;Data Contract&quot;:&#xD;&#xA;                case &quot;Value Object&quot;:&#xD;&#xA;                    ``;&#xD;&#xA;                    // Complex type&#xD;&#xA;                    mappingStore.pushSourcePath(actionField.id);&#xD;&#xA;                    mappingStore.pushTargetPath(repositoryField.id);&#xD;&#xA;                    let nestedDto = RepositoryServiceHelper.replicateDto(repositoryField.typeReference.getType(), folder, mappingStore, isExistingElement);&#xD;&#xA;                    mappingStore.popSourcePath();&#xD;&#xA;                    mappingStore.popTargetPath();&#xD;&#xA;                    actionField.typeReference.setType(nestedDto.id);&#xD;&#xA;                    if (repositoryField.typeReference?.isCollection) {&#xD;&#xA;                        actionField.setValue(nestedDto.getValue());&#xD;&#xA;                        mappingStore.addMapping(actionField.id, repositoryField.id);&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;                default:&#xD;&#xA;                    // Non-Complex type&#xD;&#xA;                    // if mapping directly to a class, skip over the primary keys &#xD;&#xA;                    if (repositoryField.hasStereotype(&quot;Primary Key&quot;)) {&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                    actionField.typeReference.setType(repositoryField.typeReference.getTypeId());&#xD;&#xA;                    actionField.setValue(repositoryField.getValue());&#xD;&#xA;                    mappingStore.addMapping(actionField.id, repositoryField.id);&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;            actionField.typeReference.setIsCollection(repositoryField.typeReference.isCollection);&#xD;&#xA;            actionField.typeReference.setIsNullable(repositoryField.typeReference.isNullable);&#xD;&#xA;        });&#xD;&#xA;        console.warn(&quot;Returning dto:&quot; + newDto.getName());&#xD;&#xA;        return newDto;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;../../common/openSelectItemDialog.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/repositoryServiceHelper.ts&quot; /&gt;&#xD;&#xA;async function execute(repositoryOperation) {&#xD;&#xA;    let servicePackages = getPackages().filter(pkg =&gt; pkg.specialization === &quot;Services Package&quot;);&#xD;&#xA;    let selectedPackage;&#xD;&#xA;    if (servicePackages.length == 1) {&#xD;&#xA;        selectedPackage = servicePackages[0];&#xD;&#xA;    }&#xD;&#xA;    else {&#xD;&#xA;        selectedPackage = await openSelectItemDialog(getPackageSelectItemOptions(servicePackages, &quot;Service Package&quot;));&#xD;&#xA;    }&#xD;&#xA;    const repository = repositoryOperation.getParent();&#xD;&#xA;    const folderName = pluralize(repository.getName().replace(&quot;Repository&quot;, &quot;&quot;));&#xD;&#xA;    const folder = selectedPackage.getChildren(&quot;Folder&quot;).find(x =&gt; x.getName() == pluralize(folderName)) ?? createElement(&quot;Folder&quot;, pluralize(folderName), selectedPackage.id);&#xD;&#xA;    let newOperation = RepositoryServiceHelper.createAppServiceOperationAction(repositoryOperation, folder, null, true);&#xD;&#xA;    const diagramElement = folder.getChildren(&quot;Diagram&quot;).find(x =&gt; x.getName() == folderName) ?? createElement(&quot;Diagram&quot;, folderName, folder.id);&#xD;&#xA;    diagramElement.loadDiagram();&#xD;&#xA;    const diagram = getCurrentDiagram();&#xD;&#xA;    let newPosition = null;&#xD;&#xA;    let repoElement = diagram.getVisual(repository.id);&#xD;&#xA;    // This is an attempt to reposition the newly created elements due to the lack of&#xD;&#xA;    // directly manipulating the visuals on the diagram but it ends up skewing diagonally.&#xD;&#xA;    if (repoElement) {&#xD;&#xA;        newPosition = {&#xD;&#xA;            x: repoElement.getPosition().x - (repoElement.getSize().width / 1.5),&#xD;&#xA;            y: repoElement.getPosition().y + (repoElement.getSize().height / 2)&#xD;&#xA;        };&#xD;&#xA;    }&#xD;&#xA;    diagram.layoutVisuals(newOperation.getParent(), newPosition, true);&#xD;&#xA;}&#xD;&#xA;/**&#xD;&#xA; * Used by Intent.Modelers.Services.DomainInteractions&#xD;&#xA; *&#xD;&#xA; * Source code here:&#xD;&#xA; * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-crud/create-appservice-repository-operation-macro-advanced-mapping/create-appservice-repository-operation-macro-advanced-mapping.ts&#xD;&#xA; */&#xD;&#xA;await execute(element);&#xD;&#xA;" isActive="true" />
            <property name="1d9dd994-46c3-4fdc-a24b-c69f689ca283" display="Dependencies" isActive="true" />
          </properties>
        </stereotype>
      </stereotypes>
      <metadata />
      <childElements />
    </childElement>
  </childElements>
</class>