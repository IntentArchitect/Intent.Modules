<?xml version="1.0" encoding="utf-8"?>
<class id="61a8411f-b5bc-4a00-9a37-a967e0893d9d" type="Script" typeId="101fd5b6-3159-4810-9490-a103ef323e9c">
  <name>Crud Api</name>
  <display>Crud Api</display>
  <isAbstract>false</isAbstract>
  <genericTypes />
  <isMapped>false</isMapped>
  <parentFolderId>f36cb21a-faf9-46ff-85e7-41f38345253d</parentFolderId>
  <packageId>bff48d8d-9246-4ad7-9dda-9703b7139b86</packageId>
  <packageName>Intent.Modelers.Services.DomainInteractions</packageName>
  <stereotypes>
    <stereotype stereotypeDefinitionId="da7d632f-b07f-4c83-ab01-bc6175006aa5" name="Script Settings">
      <addedByDefault>true</addedByDefault>
      <definitionPackageName>Intent.ModuleBuilder</definitionPackageName>
      <definitionPackageId>9972b2a9-b749-4bba-b5c8-824bf694c6ef</definitionPackageId>
      <properties>
        <property name="4708b6ef-0671-4ea1-a920-ccec2c9eb3ea" display="Type" value="Inline Script" isActive="true" />
        <property name="3256efdd-5d71-46f3-bd51-ef08a8d95526" display="Script" value="/// &lt;reference path=&quot;../../../typings/elementmacro.context.api.d.ts&quot; /&gt;&#xD;&#xA;var _a, _b;&#xD;&#xA;const privateSettersOnly = ((_b = (_a = application.getSettings(&quot;c4d1e35c-7c0d-4926-afe0-18f17563ce17&quot;)) === null || _a === void 0 ? void 0 : _a.getField(&quot;0cf704e1-9a61-499a-bb91-b20717e334f5&quot;)) === null || _b === void 0 ? void 0 : _b.value) == &quot;true&quot;;&#xD;&#xA;async function notifyUserOfLimitations(entity, dialogOptions) {&#xD;&#xA;    if ((privateSettersOnly &amp;&amp; !hasConstructor(entity)) &amp;&amp; dialogOptions.canCreate) {&#xD;&#xA;        await dialogService.warn(`Partial CQRS Operation Creation.&#xD;&#xA;Some CQRS operations were created successfully, but was limited due to private setters being enabled, and no constructor is present for entity '${entity.getName()}'.&#xD;&#xA;&#xD;&#xA;To avoid this limitation in the future, either disable private setters or add a constructor element to the entity.`);&#xD;&#xA;    }&#xD;&#xA;    else if (!entityHasPrimaryKey(entity) &amp;&amp; (dialogOptions.canDelete || dialogOptions.canQueryById || dialogOptions.canUpdate || dialogOptions.selectedDomainOperationIds.length &gt; 0)) {&#xD;&#xA;        await dialogService.warn(`Partial CQRS Operation Creation.&#xD;&#xA;Some CQRS operations were created successfully, but was limited due to no Primary Key on entity '${entity.getName()}'.&#xD;&#xA;&#xD;&#xA;To avoid this limitation in the future, model a Primary Key on the entity.`);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;function hasConstructor(entity) {&#xD;&#xA;    return entity.getChildren(&quot;Class Constructor&quot;).length &gt; 0;&#xD;&#xA;}&#xD;&#xA;function entityHasPrimaryKey(entity) {&#xD;&#xA;    const primaryKeys = DomainHelper.getPrimaryKeys(entity);&#xD;&#xA;    return primaryKeys.length &gt; 0;&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;../../typings/elementmacro.context.api.d.ts&quot; /&gt;&#xD;&#xA;function getSurrogateKeyType() {&#xD;&#xA;    var _a, _b, _c;&#xD;&#xA;    const commonTypes = {&#xD;&#xA;        guid: &quot;6b649125-18ea-48fd-a6ba-0bfff0d8f488&quot;,&#xD;&#xA;        long: &quot;33013006-E404-48C2-AC46-24EF5A5774FD&quot;,&#xD;&#xA;        int: &quot;fb0a362d-e9e2-40de-b6ff-5ce8167cbe74&quot;&#xD;&#xA;    };&#xD;&#xA;    const javaTypes = {&#xD;&#xA;        long: &quot;e9e575eb-f8de-4ce4-9838-2d09665a752d&quot;,&#xD;&#xA;        int: &quot;b3e5cb3b-8a26-4346-810b-9789afa25a82&quot;&#xD;&#xA;    };&#xD;&#xA;    const typeNameToIdMap = new Map();&#xD;&#xA;    typeNameToIdMap.set(&quot;guid&quot;, commonTypes.guid);&#xD;&#xA;    typeNameToIdMap.set(&quot;int&quot;, lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);&#xD;&#xA;    typeNameToIdMap.set(&quot;long&quot;, lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);&#xD;&#xA;    let typeName = (_c = (_b = (_a = application.getSettings(&quot;ac0a788e-d8b3-4eea-b56d-538608f1ded9&quot;)) === null || _a === void 0 ? void 0 : _a.getField(&quot;Key Type&quot;)) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : &quot;int&quot;;&#xD;&#xA;    if (typeNameToIdMap.has(typeName)) {&#xD;&#xA;        return typeNameToIdMap.get(typeName);&#xD;&#xA;    }&#xD;&#xA;    return typeNameToIdMap.get(&quot;guid&quot;);&#xD;&#xA;}&#xD;&#xA;;&#xD;&#xA;/// &lt;reference path=&quot;getSurrogateKeyType.ts&quot;/&gt;&#xD;&#xA;/// &lt;reference path=&quot;attributeWithMapPath.ts&quot;/&gt;&#xD;&#xA;class DomainHelper {&#xD;&#xA;    static isAggregateRoot(element) {&#xD;&#xA;        let result = !element.getAssociations(&quot;Association&quot;)&#xD;&#xA;            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    static getCommandOperations(entity) {&#xD;&#xA;        const queryOperationNames = [&quot;Get&quot;, &quot;Find&quot;, &quot;Filter&quot;, &quot;Query&quot;, &quot;Is&quot;, &quot;Must&quot;, &quot;Can&quot;];&#xD;&#xA;        const operations = entity.getChildren(&quot;Operation&quot;).filter(operation =&gt; operation.typeReference.getType() == null ||&#xD;&#xA;            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));&#xD;&#xA;        return operations;&#xD;&#xA;    }&#xD;&#xA;    static isComplexType(element) {&#xD;&#xA;        return (element === null || element === void 0 ? void 0 : element.specialization) === &quot;Data Contract&quot; ||&#xD;&#xA;            (element === null || element === void 0 ? void 0 : element.specialization) === &quot;Value Object&quot; ||&#xD;&#xA;            (element === null || element === void 0 ? void 0 : element.specialization) === &quot;Class&quot;;&#xD;&#xA;    }&#xD;&#xA;    static isComplexTypeById(typeId) {&#xD;&#xA;        let element = lookup(typeId);&#xD;&#xA;        return DomainHelper.isComplexType(element);&#xD;&#xA;    }&#xD;&#xA;    static getOwningAggregate(entity) {&#xD;&#xA;        var _a;&#xD;&#xA;        if (!entity || entity.specialization != &quot;Class&quot;) {&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;        let invalidAssociations = entity.getAssociations(&quot;Association&quot;).filter(x =&gt; x.typeReference.getType() == null);&#xD;&#xA;        if (invalidAssociations.length &gt; 0) {&#xD;&#xA;            console.warn(&quot;Invalid associations found:&quot;);&#xD;&#xA;            invalidAssociations.forEach(x =&gt; {&#xD;&#xA;                console.warn(&quot;Invalid associations: &quot; + x.getName());&#xD;&#xA;            });&#xD;&#xA;        }&#xD;&#xA;        let result = (_a = entity.getAssociations(&quot;Association&quot;)&#xD;&#xA;            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;&#xD;&#xA;            // Let's only target collections for now as part of the nested compositional crud support&#xD;&#xA;            // as one-to-one relationships are more expensive to address and possibly not going to&#xD;&#xA;            // be needed.&#xD;&#xA;            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();&#xD;&#xA;        return result;&#xD;&#xA;        function isOwnedBy(association) {&#xD;&#xA;            return association.isSourceEnd() &amp;&amp;&#xD;&#xA;                !association.typeReference.isNullable &amp;&amp;&#xD;&#xA;                !association.typeReference.isCollection;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static ownerIsAggregateRoot(entity) {&#xD;&#xA;        let result = DomainHelper.getOwningAggregate(entity);&#xD;&#xA;        return result ? true : false;&#xD;&#xA;    }&#xD;&#xA;    static hasPrimaryKey(entity) {&#xD;&#xA;        let keys = entity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;        return keys.length &gt; 0;&#xD;&#xA;    }&#xD;&#xA;    static getPrimaryKeys(entity) {&#xD;&#xA;        if (!entity) {&#xD;&#xA;            throw new Error(&quot;entity not specified&quot;);&#xD;&#xA;        }&#xD;&#xA;        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);&#xD;&#xA;        return Object.values(primaryKeys);&#xD;&#xA;    }&#xD;&#xA;    static isUserSuppliedPrimaryKey(pk) {&#xD;&#xA;        if (pk == null)&#xD;&#xA;            return false;&#xD;&#xA;        if (!pk.hasStereotype(&quot;Primary Key&quot;))&#xD;&#xA;            return false;&#xD;&#xA;        var pkStereotype = pk.getStereotype(&quot;Primary Key&quot;);&#xD;&#xA;        if (!pkStereotype.hasProperty(&quot;Data source&quot;)) {&#xD;&#xA;            return false;&#xD;&#xA;        }&#xD;&#xA;        return pkStereotype.getProperty(&quot;Data source&quot;).value == &quot;User supplied&quot;;&#xD;&#xA;    }&#xD;&#xA;    static getPrimaryKeysMap(entity) {&#xD;&#xA;        let keydict = Object.create(null);&#xD;&#xA;        let keys = entity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;        keys.forEach(key =&gt; keydict[key.id] = {&#xD;&#xA;            id: key.id,&#xD;&#xA;            name: key.getName(),&#xD;&#xA;            typeId: key.typeReference.typeId,&#xD;&#xA;            mapPath: [key.id],&#xD;&#xA;            isNullable: false,&#xD;&#xA;            isCollection: false&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);&#xD;&#xA;        return keydict;&#xD;&#xA;        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {&#xD;&#xA;            if (!curEntity) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            let nextEntity = generalization.typeReference.getType();&#xD;&#xA;            let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;            baseKeys.forEach(key =&gt; {&#xD;&#xA;                keydict[key.id] = {&#xD;&#xA;                    id: key.id,&#xD;&#xA;                    name: key.getName(),&#xD;&#xA;                    typeId: key.typeReference.typeId,&#xD;&#xA;                    mapPath: generalizationStack.concat([key.id]),&#xD;&#xA;                    isNullable: key.typeReference.isNullable,&#xD;&#xA;                    isCollection: key.typeReference.isCollection&#xD;&#xA;                };&#xD;&#xA;            });&#xD;&#xA;            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getForeignKeys(entity, owningAggregate) {&#xD;&#xA;        var _a;&#xD;&#xA;        if (!entity) {&#xD;&#xA;            throw new Error(&quot;entity not specified&quot;);&#xD;&#xA;        }&#xD;&#xA;        if (!owningAggregate) {&#xD;&#xA;            throw new Error(&quot;nestedCompOwner not specified&quot;);&#xD;&#xA;        }&#xD;&#xA;        // Use the new Associated property on the FK stereotype method for FK Attribute lookup&#xD;&#xA;        let foreignKeys = [];&#xD;&#xA;        for (let attr of entity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Foreign Key&quot;))) {&#xD;&#xA;            let associationId = (_a = attr.getStereotype(&quot;Foreign Key&quot;).getProperty(&quot;Association&quot;)) === null || _a === void 0 ? void 0 : _a.getValue();&#xD;&#xA;            if (owningAggregate.getAssociations(&quot;Association&quot;).some(x =&gt; x.id == associationId)) {&#xD;&#xA;                foreignKeys.push(attr);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        // Backward compatible lookup method&#xD;&#xA;        if (foreignKeys.length == 0) {&#xD;&#xA;            let foundFk = entity.getChildren(&quot;Attribute&quot;)&#xD;&#xA;                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype(&quot;Foreign Key&quot;))[0];&#xD;&#xA;            if (foundFk) {&#xD;&#xA;                foreignKeys.push(foundFk);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return foreignKeys.map(x =&gt; ({&#xD;&#xA;            name: DomainHelper.getAttributeNameFormat(x.getName()),&#xD;&#xA;            typeId: x.typeReference.typeId,&#xD;&#xA;            id: x.id,&#xD;&#xA;            mapPath: [x.id],&#xD;&#xA;            isCollection: x.typeReference.isCollection,&#xD;&#xA;            isNullable: x.typeReference.isNullable,&#xD;&#xA;            element: x&#xD;&#xA;        }));&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Returns true if the attribute is a foreign key on a compositional one-to-many relationship (i.e. is managed by the DB and should not be set).&#xD;&#xA;     * @param attribute&#xD;&#xA;     * @returns&#xD;&#xA;     */&#xD;&#xA;    static isManagedForeignKey(attribute) {&#xD;&#xA;        var _a, _b;&#xD;&#xA;        let fkAssociation = (_b = (_a = attribute.getStereotype(&quot;Foreign Key&quot;)) === null || _a === void 0 ? void 0 : _a.getProperty(&quot;Association&quot;)) === null || _b === void 0 ? void 0 : _b.getSelected();&#xD;&#xA;        return fkAssociation != null &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsCollection() &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsNullable();&#xD;&#xA;    }&#xD;&#xA;    static getChildrenOfType(entity, type) {&#xD;&#xA;        let attrDict = Object.create(null);&#xD;&#xA;        let attributes = entity.getChildren(type);&#xD;&#xA;        attributes.forEach(attr =&gt; attrDict[attr.id] = {&#xD;&#xA;            id: attr.id,&#xD;&#xA;            name: attr.getName(),&#xD;&#xA;            typeId: attr.typeReference.typeId,&#xD;&#xA;            mapPath: [attr.id],&#xD;&#xA;            isNullable: attr.typeReference.isNullable,&#xD;&#xA;            isCollection: attr.typeReference.isCollection&#xD;&#xA;        });&#xD;&#xA;        return Object.values(attrDict);&#xD;&#xA;    }&#xD;&#xA;    static getAttributesWithMapPath(entity) {&#xD;&#xA;        let attrDict = Object.create(null);&#xD;&#xA;        let attributes = entity&#xD;&#xA;            .getChildren(&quot;Attribute&quot;)&#xD;&#xA;            .filter(x =&gt; {&#xD;&#xA;            var _a;&#xD;&#xA;            return !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp;&#xD;&#xA;                !DomainHelper.legacyPartitionKey(x) &amp;&amp;&#xD;&#xA;                (x[&quot;hasMetadata&quot;] &amp;&amp; (!x.hasMetadata(&quot;set-by-infrastructure&quot;) || ((_a = x.getMetadata(&quot;set-by-infrastructure&quot;)) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != &quot;true&quot;));&#xD;&#xA;        });&#xD;&#xA;        attributes.forEach(attr =&gt; attrDict[attr.id] = {&#xD;&#xA;            id: attr.id,&#xD;&#xA;            name: attr.getName(),&#xD;&#xA;            typeId: attr.typeReference.typeId,&#xD;&#xA;            mapPath: [attr.id],&#xD;&#xA;            isNullable: false,&#xD;&#xA;            isCollection: false&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);&#xD;&#xA;        return Object.values(attrDict);&#xD;&#xA;        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {&#xD;&#xA;            if (!curEntity) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            let nextEntity = generalization.typeReference.getType();&#xD;&#xA;            let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp; !DomainHelper.legacyPartitionKey(x));&#xD;&#xA;            baseKeys.forEach(attr =&gt; {&#xD;&#xA;                attrDict[attr.id] = {&#xD;&#xA;                    id: attr.id,&#xD;&#xA;                    name: attr.getName(),&#xD;&#xA;                    typeId: attr.typeReference.typeId,&#xD;&#xA;                    mapPath: generalizationStack.concat([attr.id]),&#xD;&#xA;                    isNullable: attr.typeReference.isNullable,&#xD;&#xA;                    isCollection: attr.typeReference.isCollection&#xD;&#xA;                };&#xD;&#xA;            });&#xD;&#xA;            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getMandatoryAssociationsWithMapPath(entity) {&#xD;&#xA;        return traverseInheritanceHierarchy(entity, [], []);&#xD;&#xA;        function traverseInheritanceHierarchy(entity, results, generalizationStack) {&#xD;&#xA;            entity&#xD;&#xA;                .getAssociations(&quot;Association&quot;)&#xD;&#xA;                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;&#xD;&#xA;                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)&#xD;&#xA;                .forEach(association =&gt; {&#xD;&#xA;                return results.push({&#xD;&#xA;                    id: association.id,&#xD;&#xA;                    name: association.getName(),&#xD;&#xA;                    typeId: null,&#xD;&#xA;                    mapPath: generalizationStack.concat([association.id]),&#xD;&#xA;                    isNullable: false,&#xD;&#xA;                    isCollection: false&#xD;&#xA;                });&#xD;&#xA;            });&#xD;&#xA;            let generalizations = entity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return results;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getAttributeNameFormat(str) {&#xD;&#xA;        let convention = DomainHelper.getDomainAttributeNamingConvention();&#xD;&#xA;        switch (convention) {&#xD;&#xA;            case &quot;pascal-case&quot;:&#xD;&#xA;                return toPascalCase(str);&#xD;&#xA;            case &quot;camel-case&quot;:&#xD;&#xA;                return toCamelCase(str);&#xD;&#xA;        }&#xD;&#xA;        return str;&#xD;&#xA;    }&#xD;&#xA;    static getDomainAttributeNamingConvention() {&#xD;&#xA;        var _a, _b, _c;&#xD;&#xA;        const domainSettingsId = &quot;c4d1e35c-7c0d-4926-afe0-18f17563ce17&quot;;&#xD;&#xA;        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField(&quot;Attribute Naming Convention&quot;)) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : &quot;pascal-case&quot;;&#xD;&#xA;    }&#xD;&#xA;    static getSurrogateKeyType() {&#xD;&#xA;        return getSurrogateKeyType();&#xD;&#xA;    }&#xD;&#xA;    // Just in case someone still uses this convention. Used to filter out those attributes when mapping&#xD;&#xA;    // to domain entities that are within a Cosmos DB paradigm.&#xD;&#xA;    static legacyPartitionKey(attribute) {&#xD;&#xA;        return attribute.hasStereotype(&quot;Partition Key&quot;) &amp;&amp; attribute.getName() === &quot;PartitionKey&quot;;&#xD;&#xA;    }&#xD;&#xA;    static requiresForeignKey(associationEnd) {&#xD;&#xA;        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);&#xD;&#xA;    }&#xD;&#xA;    static isManyToVariantsOfOne(associationEnd) {&#xD;&#xA;        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;&#xD;&#xA;    }&#xD;&#xA;    static isSelfReferencingZeroToOne(associationEnd) {&#xD;&#xA;        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;&#xD;&#xA;            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;&#xD;&#xA;    }&#xD;&#xA;    static getOwningAggregateRecursive(entity) {&#xD;&#xA;        let owners = DomainHelper.getOwnersRecursive(entity);&#xD;&#xA;        if (owners.length == 0)&#xD;&#xA;            return null;&#xD;&#xA;        const uniqueIds = new Set(owners.map(item =&gt; item.id));&#xD;&#xA;        if (uniqueIds.size !== 1) {&#xD;&#xA;            throw new Error(`Entity : '${entity.getName()}' has more than 1 owner.`);&#xD;&#xA;        }&#xD;&#xA;        return owners[0];&#xD;&#xA;    }&#xD;&#xA;    static getOwnersRecursive(entity) {&#xD;&#xA;        if (!entity || entity.specialization != &quot;Class&quot;) {&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;        let results = entity.getAssociations(&quot;Association&quot;).filter(x =&gt; DomainHelper.isOwnedByAssociation(x));&#xD;&#xA;        let result = [];&#xD;&#xA;        for (let i = 0; i &lt; results.length; i++) {&#xD;&#xA;            let owner = results[i].typeReference.getType();&#xD;&#xA;            if (DomainHelper.isAggregateRoot(owner)) {&#xD;&#xA;                result.push(owner);&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                result.push(...DomainHelper.getOwnersRecursive(owner));&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    static isOwnedByAssociation(association) {&#xD;&#xA;        return association.isSourceEnd() &amp;&amp;&#xD;&#xA;            !association.typeReference.isNullable &amp;&amp;&#xD;&#xA;            !association.typeReference.isCollection;&#xD;&#xA;    }&#xD;&#xA;    static getOwningAggregateKeyChain(entity) {&#xD;&#xA;        if (!entity || entity.specialization != &quot;Class&quot;) {&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;        let results = entity.getAssociations(&quot;Association&quot;).filter(x =&gt; DomainHelper.isOwnedByAssociation(x));&#xD;&#xA;        let result = [];&#xD;&#xA;        if (results.length == 0)&#xD;&#xA;            return result;&#xD;&#xA;        let owner = results[0].typeReference.getType();&#xD;&#xA;        let pks = DomainHelper.getPrimaryKeys(owner);&#xD;&#xA;        pks.forEach(pk =&gt; {&#xD;&#xA;            let attribute = lookup(pk.id);&#xD;&#xA;            //expectedName would typically be CountryId if you have a Agg: Country with a Pk: Id&#xD;&#xA;            let expectedName = attribute.getParent().getName();&#xD;&#xA;            if (!attribute.getName().startsWith(expectedName)) {&#xD;&#xA;                expectedName += attribute.getName();&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                expectedName = attribute.getName();&#xD;&#xA;            }&#xD;&#xA;            result.push({ attribute: attribute, expectedName: expectedName });&#xD;&#xA;        });&#xD;&#xA;        if (!DomainHelper.isAggregateRoot(owner)) {&#xD;&#xA;            result.unshift(...DomainHelper.getOwningAggregateKeyChain(owner));&#xD;&#xA;        }&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;common.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/domainHelper.ts&quot; /&gt;&#xD;&#xA;class CrudCreationContext {&#xD;&#xA;    constructor(element, dialogOptions, primaryKeys) {&#xD;&#xA;        this.element = element;&#xD;&#xA;        this.dialogOptions = dialogOptions;&#xD;&#xA;        this.primaryKeys = primaryKeys;&#xD;&#xA;    }&#xD;&#xA;    hasPrimaryKey() {&#xD;&#xA;        return this.primaryKeys.length &gt; 0;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;async function presentCrudOptionsDialog(preselectedClass) {&#xD;&#xA;    let dialogResult = null;&#xD;&#xA;    if (!preselectedClass) {&#xD;&#xA;        dialogResult = await openCrudCreationDialog();&#xD;&#xA;        if (!dialogResult) {&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    else {&#xD;&#xA;        dialogResult = {&#xD;&#xA;            selectedEntity: preselectedClass,&#xD;&#xA;            canCreate: true,&#xD;&#xA;            canUpdate: true,&#xD;&#xA;            canQueryById: true,&#xD;&#xA;            canQueryAll: true,&#xD;&#xA;            canDelete: true,&#xD;&#xA;            canDomain: true,&#xD;&#xA;            selectedDomainOperationIds: []&#xD;&#xA;        };&#xD;&#xA;    }&#xD;&#xA;    return dialogResult;&#xD;&#xA;}&#xD;&#xA;async function openCrudCreationDialog() {&#xD;&#xA;    var _a, _b;&#xD;&#xA;    let classes = lookupTypesOf(&quot;Class&quot;);&#xD;&#xA;    if (classes.length == 0) {&#xD;&#xA;        await dialogService.info(&quot;No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.&quot;);&#xD;&#xA;        return null;&#xD;&#xA;    }&#xD;&#xA;    let dialogResult = await dialogService.openForm({&#xD;&#xA;        title: &quot;CRUD Creation Options&quot;,&#xD;&#xA;        fields: [&#xD;&#xA;            {&#xD;&#xA;                id: &quot;entityId&quot;,&#xD;&#xA;                fieldType: &quot;select&quot;,&#xD;&#xA;                label: &quot;Entity for CRUD operations&quot;,&#xD;&#xA;                selectOptions: classes.map(x =&gt; {&#xD;&#xA;                    return {&#xD;&#xA;                        id: x.id,&#xD;&#xA;                        description: x.getName(),&#xD;&#xA;                        additionalInfo: getClassAdditionalInfo(x)&#xD;&#xA;                    };&#xD;&#xA;                }),&#xD;&#xA;                isRequired: true&#xD;&#xA;            },&#xD;&#xA;            {&#xD;&#xA;                id: &quot;create&quot;,&#xD;&#xA;                fieldType: &quot;checkbox&quot;,&#xD;&#xA;                label: &quot;Create&quot;,&#xD;&#xA;                value: &quot;true&quot;,&#xD;&#xA;                hint: &quot;Generate the \&quot;Create\&quot; operation&quot;&#xD;&#xA;            },&#xD;&#xA;            {&#xD;&#xA;                id: &quot;update&quot;,&#xD;&#xA;                fieldType: &quot;checkbox&quot;,&#xD;&#xA;                label: &quot;Update&quot;,&#xD;&#xA;                value: &quot;true&quot;,&#xD;&#xA;                hint: &quot;Generate the \&quot;Update\&quot; operation&quot;&#xD;&#xA;            },&#xD;&#xA;            {&#xD;&#xA;                id: &quot;queryById&quot;,&#xD;&#xA;                fieldType: &quot;checkbox&quot;,&#xD;&#xA;                label: &quot;Query By Id&quot;,&#xD;&#xA;                value: &quot;true&quot;,&#xD;&#xA;                hint: &quot;Generate the \&quot;Query By Id\&quot; operation&quot;&#xD;&#xA;            },&#xD;&#xA;            {&#xD;&#xA;                id: &quot;queryAll&quot;,&#xD;&#xA;                fieldType: &quot;checkbox&quot;,&#xD;&#xA;                label: &quot;Query All&quot;,&#xD;&#xA;                value: &quot;true&quot;,&#xD;&#xA;                hint: &quot;Generate the \&quot;Query All\&quot; operation&quot;&#xD;&#xA;            },&#xD;&#xA;            {&#xD;&#xA;                id: &quot;delete&quot;,&#xD;&#xA;                fieldType: &quot;checkbox&quot;,&#xD;&#xA;                label: &quot;Delete&quot;,&#xD;&#xA;                value: &quot;true&quot;,&#xD;&#xA;                hint: &quot;Generate the \&quot;Delete\&quot; operation&quot;&#xD;&#xA;            },&#xD;&#xA;            {&#xD;&#xA;                id: &quot;domain&quot;,&#xD;&#xA;                fieldType: &quot;checkbox&quot;,&#xD;&#xA;                label: &quot;Domain Operations&quot;,&#xD;&#xA;                value: &quot;true&quot;,&#xD;&#xA;                hint: &quot;Generate operations for Domain Entity operations&quot;&#xD;&#xA;            }&#xD;&#xA;        ]&#xD;&#xA;    });&#xD;&#xA;    let foundEntity = lookup(dialogResult.entityId);&#xD;&#xA;    var result = {&#xD;&#xA;        selectedEntity: foundEntity,&#xD;&#xA;        canCreate: dialogResult.create == &quot;true&quot;,&#xD;&#xA;        canUpdate: dialogResult.update == &quot;true&quot;,&#xD;&#xA;        canQueryById: dialogResult.queryById == &quot;true&quot;,&#xD;&#xA;        canQueryAll: dialogResult.queryAll == &quot;true&quot;,&#xD;&#xA;        canDelete: dialogResult.delete == &quot;true&quot;,&#xD;&#xA;        canDomain: dialogResult.domain == &quot;true&quot;,&#xD;&#xA;        selectedDomainOperationIds: []&#xD;&#xA;    };&#xD;&#xA;    if (result.canDomain &amp;&amp; foundEntity.getChildren(&quot;Operation&quot;).length &gt; 0) {&#xD;&#xA;        dialogResult = await dialogService.openForm({&#xD;&#xA;            title: &quot;Select Domain Operations&quot;,&#xD;&#xA;            fields: [&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;tree&quot;,&#xD;&#xA;                    fieldType: &quot;tree-view&quot;,&#xD;&#xA;                    label: &quot;Domain Operations&quot;,&#xD;&#xA;                    hint: &quot;Generate operations from selected domain entity operations&quot;,&#xD;&#xA;                    treeViewOptions: {&#xD;&#xA;                        rootId: foundEntity.id,&#xD;&#xA;                        submitFormTriggers: [&quot;double-click&quot;, &quot;enter&quot;],&#xD;&#xA;                        isMultiSelect: true,&#xD;&#xA;                        selectableTypes: [&#xD;&#xA;                            {&#xD;&#xA;                                specializationId: &quot;Class&quot;,&#xD;&#xA;                                autoExpand: true,&#xD;&#xA;                                autoSelectChildren: false,&#xD;&#xA;                                isSelectable: (x) =&gt; false&#xD;&#xA;                            },&#xD;&#xA;                            {&#xD;&#xA;                                specializationId: &quot;Operation&quot;,&#xD;&#xA;                                isSelectable: (x) =&gt; true&#xD;&#xA;                            }&#xD;&#xA;                        ]&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            ]&#xD;&#xA;        });&#xD;&#xA;        result.selectedDomainOperationIds = (_b = (_a = dialogResult.tree) === null || _a === void 0 ? void 0 : _a.filter((x) =&gt; x != &quot;0&quot;)) !== null &amp;&amp; _b !== void 0 ? _b : [];&#xD;&#xA;    }&#xD;&#xA;    return result;&#xD;&#xA;    function getClassAdditionalInfo(element) {&#xD;&#xA;        let aggregateEntity = DomainHelper.getOwningAggregate(element);&#xD;&#xA;        let prefix = aggregateEntity ? `: ${aggregateEntity.getName()}  ` : &quot;&quot;;&#xD;&#xA;        return `${prefix}(${element.getParents().map(item =&gt; item.getName()).join(&quot;/&quot;)})`;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;attributeWithMapPath.ts&quot; /&gt;&#xD;&#xA;class ServicesConstants {&#xD;&#xA;}&#xD;&#xA;ServicesConstants.dtoToEntityMappingId = &quot;942eae46-49f1-450e-9274-a92d40ac35fa&quot;; //&quot;01d74d4f-e478-4fde-a2f0-9ea92255f3c5&quot;;&#xD;&#xA;ServicesConstants.dtoFromEntityMappingId = &quot;1f747d14-681c-4a20-8c68-34223f41b825&quot;;&#xD;&#xA;ServicesConstants.dtoToDomainOperation = &quot;8d1f6a8a-77c8-43a2-8e60-421559725419&quot;;&#xD;&#xA;class ServicesHelper {&#xD;&#xA;    static addDtoFieldsFromDomain(dto, attributes) {&#xD;&#xA;        var _a;&#xD;&#xA;        for (let key of attributes) {&#xD;&#xA;            if (dto &amp;&amp; !dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {&#xD;&#xA;                let field = createElement(&quot;DTO-Field&quot;, ServicesHelper.getFieldFormat(key.name), dto.id);&#xD;&#xA;                field.typeReference.setType(key.typeId);&#xD;&#xA;                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {&#xD;&#xA;                    field.setMapping(key.mapPath);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getParameterFormat(str) {&#xD;&#xA;        return toCamelCase(str);&#xD;&#xA;    }&#xD;&#xA;    static getRoutingFormat(str) {&#xD;&#xA;        return pluralize(str);&#xD;&#xA;    }&#xD;&#xA;    static getFieldFormat(str) {&#xD;&#xA;        return toPascalCase(str);&#xD;&#xA;    }&#xD;&#xA;    static formatName(str, type) {&#xD;&#xA;        switch (type) {&#xD;&#xA;            case &quot;property&quot;:&#xD;&#xA;            case &quot;class&quot;:&#xD;&#xA;                return toPascalCase(str);&#xD;&#xA;            case &quot;parameter&quot;:&#xD;&#xA;                return toCamelCase(str);&#xD;&#xA;            default:&#xD;&#xA;                return str;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;../common/domainHelper.ts&quot; /&gt;&#xD;&#xA;class CrudConstants {&#xD;&#xA;}&#xD;&#xA;CrudConstants.mapFromDomainMappingSettingId = &quot;1f747d14-681c-4a20-8c68-34223f41b825&quot;;&#xD;&#xA;CrudConstants.mapToDomainConstructorForDtosSettingId = &quot;8d1f6a8a-77c8-43a2-8e60-421559725419&quot;;&#xD;&#xA;CrudConstants.dtoFromEntityMappingId = &quot;1f747d14-681c-4a20-8c68-34223f41b825&quot;;&#xD;&#xA;class CrudHelper {&#xD;&#xA;    // Super basic selection dialog.&#xD;&#xA;    static async openBasicSelectEntityDialog(options) {&#xD;&#xA;        let classes = lookupTypesOf(&quot;Class&quot;).filter(x =&gt; CrudHelper.filterClassSelection(x, options));&#xD;&#xA;        if (classes.length == 0) {&#xD;&#xA;            await dialogService.info(&quot;No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.&quot;);&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({&#xD;&#xA;            id: x.id,&#xD;&#xA;            name: getFriendlyDisplayNameForClassSelection(x),&#xD;&#xA;            additionalInfo: `(${x.getParents().map(item =&gt; item.getName()).join(&quot;/&quot;)})`&#xD;&#xA;        })));&#xD;&#xA;        if (classId == null) {&#xD;&#xA;            await dialogService.error(`No class found with id &quot;${classId}&quot;.`);&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;        let foundEntity = lookup(classId);&#xD;&#xA;        return foundEntity;&#xD;&#xA;        function getFriendlyDisplayNameForClassSelection(element) {&#xD;&#xA;            let aggregateEntity = DomainHelper.getOwningAggregate(element);&#xD;&#xA;            return !aggregateEntity ? element.getName() : `${element.getName()} (${aggregateEntity.getName()})`;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static async openCrudCreationDialog(options) {&#xD;&#xA;        var _a, _b;&#xD;&#xA;        let classes = lookupTypesOf(&quot;Class&quot;).filter(x =&gt; CrudHelper.filterClassSelection(x, options));&#xD;&#xA;        if (classes.length == 0) {&#xD;&#xA;            await dialogService.info(&quot;No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.&quot;);&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;        let dialogResult = await dialogService.openForm({&#xD;&#xA;            title: &quot;CRUD Creation Options&quot;,&#xD;&#xA;            fields: [&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;entityId&quot;,&#xD;&#xA;                    fieldType: &quot;select&quot;,&#xD;&#xA;                    label: &quot;Entity for CRUD operations&quot;,&#xD;&#xA;                    selectOptions: classes.map(x =&gt; {&#xD;&#xA;                        return {&#xD;&#xA;                            id: x.id,&#xD;&#xA;                            description: x.getName(),&#xD;&#xA;                            additionalInfo: getClassAdditionalInfo(x)&#xD;&#xA;                        };&#xD;&#xA;                    }),&#xD;&#xA;                    isRequired: true&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;create&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Create&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate the \&quot;Create\&quot; operation&quot;&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;update&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Update&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate the \&quot;Update\&quot; operation&quot;&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;queryById&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Query By Id&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate the \&quot;Query By Id\&quot; operation&quot;&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;queryAll&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Query All&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate the \&quot;Query All\&quot; operation&quot;&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;delete&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Delete&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate the \&quot;Delete\&quot; operation&quot;&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    id: &quot;domain&quot;,&#xD;&#xA;                    fieldType: &quot;checkbox&quot;,&#xD;&#xA;                    label: &quot;Domain Operations&quot;,&#xD;&#xA;                    value: &quot;true&quot;,&#xD;&#xA;                    hint: &quot;Generate operations for Domain Entity operations&quot;&#xD;&#xA;                }&#xD;&#xA;            ]&#xD;&#xA;        });&#xD;&#xA;        let foundEntity = lookup(dialogResult.entityId);&#xD;&#xA;        var result = {&#xD;&#xA;            selectedEntity: foundEntity,&#xD;&#xA;            canCreate: dialogResult.create == &quot;true&quot;,&#xD;&#xA;            canUpdate: dialogResult.update == &quot;true&quot;,&#xD;&#xA;            canQueryById: dialogResult.queryById == &quot;true&quot;,&#xD;&#xA;            canQueryAll: dialogResult.queryAll == &quot;true&quot;,&#xD;&#xA;            canDelete: dialogResult.delete == &quot;true&quot;,&#xD;&#xA;            canDomain: dialogResult.domain == &quot;true&quot;,&#xD;&#xA;            selectedDomainOperationIds: []&#xD;&#xA;        };&#xD;&#xA;        if (result.canDomain &amp;&amp; foundEntity.getChildren(&quot;Operation&quot;).length &gt; 0) {&#xD;&#xA;            dialogResult = await dialogService.openForm({&#xD;&#xA;                title: &quot;Select Domain Operations&quot;,&#xD;&#xA;                fields: [&#xD;&#xA;                    {&#xD;&#xA;                        id: &quot;tree&quot;,&#xD;&#xA;                        fieldType: &quot;tree-view&quot;,&#xD;&#xA;                        label: &quot;Domain Operations&quot;,&#xD;&#xA;                        hint: &quot;Generate operations from selected domain entity operations&quot;,&#xD;&#xA;                        treeViewOptions: {&#xD;&#xA;                            rootId: foundEntity.id,&#xD;&#xA;                            submitFormTriggers: [&quot;double-click&quot;, &quot;enter&quot;],&#xD;&#xA;                            isMultiSelect: true,&#xD;&#xA;                            selectableTypes: [&#xD;&#xA;                                {&#xD;&#xA;                                    specializationId: &quot;Class&quot;,&#xD;&#xA;                                    autoExpand: true,&#xD;&#xA;                                    autoSelectChildren: false,&#xD;&#xA;                                    isSelectable: (x) =&gt; false&#xD;&#xA;                                },&#xD;&#xA;                                {&#xD;&#xA;                                    specializationId: &quot;Operation&quot;,&#xD;&#xA;                                    isSelectable: (x) =&gt; true&#xD;&#xA;                                }&#xD;&#xA;                            ]&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                ]&#xD;&#xA;            });&#xD;&#xA;            result.selectedDomainOperationIds = (_b = (_a = dialogResult.tree) === null || _a === void 0 ? void 0 : _a.filter((x) =&gt; x != &quot;0&quot;)) !== null &amp;&amp; _b !== void 0 ? _b : [];&#xD;&#xA;        }&#xD;&#xA;        return result;&#xD;&#xA;        function getClassAdditionalInfo(element) {&#xD;&#xA;            let aggregateEntity = DomainHelper.getOwningAggregate(element);&#xD;&#xA;            let prefix = aggregateEntity ? `: ${aggregateEntity.getName()}  ` : &quot;&quot;;&#xD;&#xA;            return `${prefix}(${element.getParents().map(item =&gt; item.getName()).join(&quot;/&quot;)})`;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static filterClassSelection(element, options) {&#xD;&#xA;        var _a;&#xD;&#xA;        if (!((_a = options === null || options === void 0 ? void 0 : options.allowAbstract) !== null &amp;&amp; _a !== void 0 ? _a : false) &amp;&amp; element.getIsAbstract()) {&#xD;&#xA;            return false;&#xD;&#xA;        }&#xD;&#xA;        if (element.hasStereotype(&quot;Repository&quot;)) {&#xD;&#xA;            return true;&#xD;&#xA;        }&#xD;&#xA;        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {&#xD;&#xA;            return DomainHelper.hasPrimaryKey(element);&#xD;&#xA;        }&#xD;&#xA;        if (DomainHelper.isAggregateRoot(element)) {&#xD;&#xA;            let generalizations = element.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return true;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            let parentEntity = generalization.typeReference.getType();&#xD;&#xA;            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack&#xD;&#xA;            return CrudHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false, allowAbstract: true });&#xD;&#xA;        }&#xD;&#xA;        return false;&#xD;&#xA;    }&#xD;&#xA;    static getName(command, mappedElement, dtoPrefix = null) {&#xD;&#xA;        if (mappedElement.typeReference != null)&#xD;&#xA;            mappedElement = mappedElement.typeReference.getType();&#xD;&#xA;        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];&#xD;&#xA;        let domainName = mappedElement.getName();&#xD;&#xA;        let baseName = command.getMetadata(&quot;baseName&quot;)&#xD;&#xA;            ? `${command.getMetadata(&quot;baseName&quot;)}${domainName}`&#xD;&#xA;            : domainName;&#xD;&#xA;        let dtoName = `${originalVerb}${baseName}`;&#xD;&#xA;        if (dtoPrefix)&#xD;&#xA;            dtoName = `${dtoPrefix}${dtoName}`;&#xD;&#xA;        return dtoName;&#xD;&#xA;    }&#xD;&#xA;    static getOrCreateCrudDto(dtoName, mappedElement, autoAddPrimaryKey, mappingTypeSettingId, folder, inbound = false) {&#xD;&#xA;        let dto = CrudHelper.getOrCreateDto(dtoName, folder);&#xD;&#xA;        //dtoField.typeReference.setType(dto.id);&#xD;&#xA;        const entityCtor = mappedElement&#xD;&#xA;            .getChildren(&quot;Class Constructor&quot;)&#xD;&#xA;            .sort((a, b) =&gt; {&#xD;&#xA;            // In descending order:&#xD;&#xA;            return b.getChildren(&quot;Parameter&quot;).length - a.getChildren(&quot;Parameter&quot;).length;&#xD;&#xA;        })[0];&#xD;&#xA;        if (inbound &amp;&amp; entityCtor != null) {&#xD;&#xA;            dto.setMapping([mappedElement.id, entityCtor.id], CrudConstants.mapToDomainConstructorForDtosSettingId);&#xD;&#xA;            CrudHelper.addDtoFieldsForCtor(autoAddPrimaryKey, entityCtor, dto, folder);&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            dto.setMapping(mappedElement.id, mappingTypeSettingId);&#xD;&#xA;            CrudHelper.addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder);&#xD;&#xA;        }&#xD;&#xA;        return dto;&#xD;&#xA;    }&#xD;&#xA;    static getOrCreateDto(elementName, parentElement) {&#xD;&#xA;        const expectedDtoName = elementName.replace(/Dto$/, &quot;&quot;) + &quot;Dto&quot;;&#xD;&#xA;        let existingDto = parentElement.getChildren(&quot;DTO&quot;).filter(x =&gt; x.getName() === expectedDtoName)[0];&#xD;&#xA;        if (existingDto) {&#xD;&#xA;            return existingDto;&#xD;&#xA;        }&#xD;&#xA;        let dto = createElement(&quot;DTO&quot;, expectedDtoName, parentElement.id);&#xD;&#xA;        return dto;&#xD;&#xA;    }&#xD;&#xA;    static addDtoFieldsForCtor(autoAddPrimaryKey, ctor, dto, folder) {&#xD;&#xA;        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, &quot;Parameter&quot;).filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== &quot;Domain Service&quot;);&#xD;&#xA;        childrenToAdd.forEach(e =&gt; {&#xD;&#xA;            if (e.mapPath != null) {&#xD;&#xA;                if (dto.getChildren(&quot;Parameter&quot;).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            else if (ctor.getChildren(&quot;Parameter&quot;).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let field = createElement(&quot;DTO-Field&quot;, toPascalCase(e.name), dto.id);&#xD;&#xA;            field.setMapping(e.mapPath);&#xD;&#xA;            if (DomainHelper.isComplexTypeById(e.typeId)) {&#xD;&#xA;                let dtoName = dto.getName().replace(/Dto$/, &quot;&quot;) + field.getName() + &quot;Dto&quot;;&#xD;&#xA;                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);&#xD;&#xA;                field.typeReference.setType(newDto.id);&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                field.typeReference.setType(e.typeId);&#xD;&#xA;            }&#xD;&#xA;            field.typeReference.setIsCollection(e.isCollection);&#xD;&#xA;            field.typeReference.setIsNullable(e.isNullable);&#xD;&#xA;        });&#xD;&#xA;        dto.collapse();&#xD;&#xA;    }&#xD;&#xA;    static addDtoFields(autoAddPrimaryKey, mappedElement, dto, folder) {&#xD;&#xA;        var _a, _b;&#xD;&#xA;        let dtoUpdated = false;&#xD;&#xA;        let domainElement = mappedElement;&#xD;&#xA;        let attributesWithMapPaths = CrudHelper.getAttributesWithMapPath(domainElement);&#xD;&#xA;        let isCreateMode = ((_b = (_a = dto.getMetadata(&quot;originalVerb&quot;)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith(&quot;create&quot;)) == true;&#xD;&#xA;        for (var keyName of Object.keys(attributesWithMapPaths)) {&#xD;&#xA;            let entry = attributesWithMapPaths[keyName];&#xD;&#xA;            if (isCreateMode &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            if (dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName() == entry.name)) {&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            let field = createElement(&quot;DTO-Field&quot;, entry.name, dto.id);&#xD;&#xA;            field.setMapping(entry.mapPath);&#xD;&#xA;            if (DomainHelper.isComplexTypeById(entry.typeId)) {&#xD;&#xA;                let dtoName = dto.getName().replace(/Dto$/, &quot;&quot;) + field.getName() + &quot;Dto&quot;;&#xD;&#xA;                let newDto = CrudHelper.getOrCreateCrudDto(dtoName, field.getMapping().getElement().typeReference.getType(), autoAddPrimaryKey, CrudConstants.mapFromDomainMappingSettingId, folder, true);&#xD;&#xA;                field.typeReference.setType(newDto.id);&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                field.typeReference.setType(entry.typeId);&#xD;&#xA;            }&#xD;&#xA;            field.typeReference.setIsNullable(entry.isNullable);&#xD;&#xA;            field.typeReference.setIsCollection(entry.isCollection);&#xD;&#xA;            dtoUpdated = true;&#xD;&#xA;        }&#xD;&#xA;        if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {&#xD;&#xA;            CrudHelper.addPrimaryKeys(dto, domainElement, true);&#xD;&#xA;        }&#xD;&#xA;        if (dtoUpdated) {&#xD;&#xA;            dto.collapse();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static isOwnerForeignKey(attributeName, domainElement) {&#xD;&#xA;        for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {&#xD;&#xA;            if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {&#xD;&#xA;                return true;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return false;&#xD;&#xA;    }&#xD;&#xA;    static addPrimaryKeys(dto, entity, map) {&#xD;&#xA;        const primaryKeys = CrudHelper.getPrimaryKeysWithMapPath(entity);&#xD;&#xA;        for (const primaryKey of primaryKeys) {&#xD;&#xA;            const name = CrudHelper.getDomainAttributeNameFormat(primaryKey.name);&#xD;&#xA;            if (dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            const dtoField = createElement(&quot;DTO-Field&quot;, CrudHelper.getFieldFormat(name), dto.id);&#xD;&#xA;            dtoField.typeReference.setType(primaryKey.typeId);&#xD;&#xA;            if (map &amp;&amp; primaryKey.mapPath != null) {&#xD;&#xA;                console.log(`Doing mapping for ${dtoField.id}`);&#xD;&#xA;                dtoField.setMapping(primaryKey.mapPath);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getPrimaryKeysWithMapPath(entity) {&#xD;&#xA;        let keydict = Object.create(null);&#xD;&#xA;        let keys = entity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;        keys.forEach(key =&gt; keydict[key.id] = {&#xD;&#xA;            id: key.id,&#xD;&#xA;            name: key.getName(),&#xD;&#xA;            typeId: key.typeReference.typeId,&#xD;&#xA;            mapPath: [key.id],&#xD;&#xA;            isNullable: false,&#xD;&#xA;            isCollection: false&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);&#xD;&#xA;        return Object.values(keydict);&#xD;&#xA;        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {&#xD;&#xA;            if (!curEntity) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            let nextEntity = generalization.typeReference.getType();&#xD;&#xA;            let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;            baseKeys.forEach(key =&gt; {&#xD;&#xA;                keydict[key.id] = {&#xD;&#xA;                    id: key.id,&#xD;&#xA;                    name: key.getName(),&#xD;&#xA;                    typeId: key.typeReference.typeId,&#xD;&#xA;                    mapPath: generalizationStack.concat([key.id]),&#xD;&#xA;                    isNullable: key.typeReference.isNullable,&#xD;&#xA;                    isCollection: key.typeReference.isCollection&#xD;&#xA;                };&#xD;&#xA;            });&#xD;&#xA;            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getAttributesWithMapPath(entity) {&#xD;&#xA;        let attrDict = Object.create(null);&#xD;&#xA;        let attributes = entity.getChildren(&quot;Attribute&quot;)&#xD;&#xA;            .filter(x =&gt; {&#xD;&#xA;            var _a;&#xD;&#xA;            return !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp;&#xD;&#xA;                !DomainHelper.isManagedForeignKey(x) &amp;&amp; // essentially also an attribute set by infrastructure&#xD;&#xA;                !CrudHelper.legacyPartitionKey(x) &amp;&amp;&#xD;&#xA;                (x[&quot;hasMetadata&quot;] &amp;&amp; (!x.hasMetadata(&quot;set-by-infrastructure&quot;) || ((_a = x.getMetadata(&quot;set-by-infrastructure&quot;)) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != &quot;true&quot;));&#xD;&#xA;        });&#xD;&#xA;        attributes.forEach(attr =&gt; attrDict[attr.id] = {&#xD;&#xA;            id: attr.id,&#xD;&#xA;            name: attr.getName(),&#xD;&#xA;            typeId: attr.typeReference.typeId,&#xD;&#xA;            mapPath: [attr.id],&#xD;&#xA;            isNullable: false,&#xD;&#xA;            isCollection: false&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);&#xD;&#xA;        return attrDict;&#xD;&#xA;        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {&#xD;&#xA;            if (!curEntity) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            let nextEntity = generalization.typeReference.getType();&#xD;&#xA;            let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;).filter(x =&gt; !x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp; !CrudHelper.legacyPartitionKey(x));&#xD;&#xA;            baseKeys.forEach(attr =&gt; {&#xD;&#xA;                attrDict[attr.id] = {&#xD;&#xA;                    id: attr.id,&#xD;&#xA;                    name: attr.getName(),&#xD;&#xA;                    typeId: attr.typeReference.typeId,&#xD;&#xA;                    mapPath: generalizationStack.concat([attr.id]),&#xD;&#xA;                    isNullable: attr.typeReference.isNullable,&#xD;&#xA;                    isCollection: attr.typeReference.isCollection&#xD;&#xA;                };&#xD;&#xA;            });&#xD;&#xA;            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getFieldFormat(str) {&#xD;&#xA;        return toPascalCase(str);&#xD;&#xA;    }&#xD;&#xA;    static getDomainAttributeNameFormat(str) {&#xD;&#xA;        let convention = CrudHelper.getDomainAttributeNamingConvention();&#xD;&#xA;        switch (convention) {&#xD;&#xA;            case &quot;pascal-case&quot;:&#xD;&#xA;                return toPascalCase(str);&#xD;&#xA;            case &quot;camel-case&quot;:&#xD;&#xA;                return toCamelCase(str);&#xD;&#xA;            default:&#xD;&#xA;                return str;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    static getDomainAttributeNamingConvention() {&#xD;&#xA;        var _a, _b, _c;&#xD;&#xA;        const domainSettingsId = &quot;c4d1e35c-7c0d-4926-afe0-18f17563ce17&quot;;&#xD;&#xA;        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField(&quot;Attribute Naming Convention&quot;)) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : &quot;pascal-case&quot;;&#xD;&#xA;    }&#xD;&#xA;    // Just in case someone still uses this convention. Used to filter out those attributes when mapping&#xD;&#xA;    // to domain entities that are within a Cosmos DB paradigm.&#xD;&#xA;    static legacyPartitionKey(attribute) {&#xD;&#xA;        return attribute.hasStereotype(&quot;Partition Key&quot;) &amp;&amp; attribute.getName() === &quot;PartitionKey&quot;;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;class ElementManager {&#xD;&#xA;    constructor(innerElement, settings) {&#xD;&#xA;        var _a;&#xD;&#xA;        this.innerElement = innerElement;&#xD;&#xA;        this.settings = settings;&#xD;&#xA;        this.mappedElement = (_a = innerElement.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();&#xD;&#xA;    }&#xD;&#xA;    get id() { return this.innerElement.id; }&#xD;&#xA;    ;&#xD;&#xA;    setReturnType(typeId, isCollection, isNullable) {&#xD;&#xA;        this.innerElement.typeReference.setType(typeId);&#xD;&#xA;        if (isCollection != null) {&#xD;&#xA;            this.innerElement.typeReference.setIsCollection(isCollection);&#xD;&#xA;        }&#xD;&#xA;        if (isNullable != null) {&#xD;&#xA;            this.innerElement.typeReference.setIsNullable(isNullable);&#xD;&#xA;        }&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;    addChild(name, type) {&#xD;&#xA;        var _a;&#xD;&#xA;        let existingField = this.innerElement.getChildren(this.settings.childSpecialization)&#xD;&#xA;            .find(c =&gt; { var _a; return c.getName().toLowerCase() == ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : &quot;property&quot;).toLowerCase(); });&#xD;&#xA;        let field = existingField !== null &amp;&amp; existingField !== void 0 ? existingField : createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : &quot;property&quot;), this.innerElement.id);&#xD;&#xA;        const typeReferenceDetails = type == null&#xD;&#xA;            ? null&#xD;&#xA;            : typeof (type) === &quot;string&quot;&#xD;&#xA;                ? { id: type, isNullable: false, isCollection: false }&#xD;&#xA;                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };&#xD;&#xA;        if (typeReferenceDetails != null) {&#xD;&#xA;            field.typeReference.setType(typeReferenceDetails.id);&#xD;&#xA;            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);&#xD;&#xA;            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);&#xD;&#xA;        }&#xD;&#xA;        return field;&#xD;&#xA;    }&#xD;&#xA;    addChildrenFrom(elements, options) {&#xD;&#xA;        let order = 0;&#xD;&#xA;        elements.forEach(e =&gt; {&#xD;&#xA;            if (e.mapPath != null) {&#xD;&#xA;                if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            else if (this.innerElement.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let field = this.addChild(e.name, e.typeId);&#xD;&#xA;            field.typeReference.setIsCollection(e.isCollection);&#xD;&#xA;            field.typeReference.setIsNullable(e.isNullable);&#xD;&#xA;            if (options === null || options === void 0 ? void 0 : options.addToTop) {&#xD;&#xA;                field.setOrder(order++);&#xD;&#xA;            }&#xD;&#xA;            if (this.mappedElement != null &amp;&amp; e.mapPath) {&#xD;&#xA;                field.setMapping(e.mapPath);&#xD;&#xA;            }&#xD;&#xA;        });&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;    mapToElement(param1, mappingSettingsId) {&#xD;&#xA;        let elementIds;&#xD;&#xA;        let element;&#xD;&#xA;        if (Array.isArray(param1)) {&#xD;&#xA;            elementIds = param1;&#xD;&#xA;            element = lookup(elementIds[elementIds.length - 1]);&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            elementIds = [param1.id];&#xD;&#xA;            element = param1;&#xD;&#xA;        }&#xD;&#xA;        this.mappedElement = element;&#xD;&#xA;        this.innerElement.setMapping(elementIds, mappingSettingsId);&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;    getElement() {&#xD;&#xA;        return this.innerElement;&#xD;&#xA;    }&#xD;&#xA;    collapse() {&#xD;&#xA;        this.innerElement.collapse();&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;common.ts&quot; /&gt;&#xD;&#xA;var MappingType;&#xD;&#xA;(function (MappingType) {&#xD;&#xA;    MappingType[MappingType[&quot;Navigation&quot;] = 1] = &quot;Navigation&quot;;&#xD;&#xA;    MappingType[MappingType[&quot;TypeMap&quot;] = 2] = &quot;TypeMap&quot;;&#xD;&#xA;})(MappingType || (MappingType = {}));&#xD;&#xA;class EntityProjector {&#xD;&#xA;    addMapping(type, sourceRelative, targetRelative, changeCurrent = false) {&#xD;&#xA;        let result = { targetPops: 0, sourcePops: 0 };&#xD;&#xA;        this.mappings.push({ type: type, sourcePath: this.sourcePath.concat(sourceRelative), targetPath: this.targetPath.concat(targetRelative), targetPropertyStart: targetRelative[0] });&#xD;&#xA;        if (type == MappingType.Navigation &amp;&amp; changeCurrent) {&#xD;&#xA;            this.sourcePath.push(...sourceRelative);&#xD;&#xA;            this.targetPath.push(...targetRelative);&#xD;&#xA;            result.sourcePops = sourceRelative.length;&#xD;&#xA;            result.targetPops = targetRelative.length;&#xD;&#xA;        }&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    popMapping(pops) {&#xD;&#xA;        for (let i = 0; i &lt; pops.sourcePops; i++) {&#xD;&#xA;            this.sourcePath.pop();&#xD;&#xA;        }&#xD;&#xA;        for (let i = 0; i &lt; pops.targetPops; i++) {&#xD;&#xA;            this.targetPath.pop();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    constructor() {&#xD;&#xA;        this.mappings = [];&#xD;&#xA;        this.sourcePath = []; //Dto&#xD;&#xA;        this.targetPath = []; //Entity&#xD;&#xA;        this.isChild = false;&#xD;&#xA;        this.addMandatoryRelationships = false;&#xD;&#xA;    }&#xD;&#xA;    getMappings() {&#xD;&#xA;        return this.mappings;&#xD;&#xA;    }&#xD;&#xA;    getTarget() {&#xD;&#xA;        return this.target;&#xD;&#xA;    }&#xD;&#xA;    getEntityConstructor(entity) {&#xD;&#xA;        return entity&#xD;&#xA;            .getChildren(&quot;Class Constructor&quot;)&#xD;&#xA;            .sort((a, b) =&gt; {&#xD;&#xA;            // In descending order:&#xD;&#xA;            return b.getChildren(&quot;Parameter&quot;).length - a.getChildren(&quot;Parameter&quot;).length;&#xD;&#xA;        })[0];&#xD;&#xA;    }&#xD;&#xA;    createOrGetCreateCommand(entity, folder) {&#xD;&#xA;        let owningAggregate = DomainHelper.getOwningAggregate(entity);&#xD;&#xA;        let baseName = this.getBaseNameForElement(owningAggregate, entity, false);&#xD;&#xA;        const commandName = `Create${baseName}Command`;&#xD;&#xA;        let existing = folder.getChildren().find(x =&gt; x.getName() == commandName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        this.addMandatoryRelationships = true;&#xD;&#xA;        let dto = this.getOrCreateElement(commandName, &quot;Command&quot;, folder);&#xD;&#xA;        this.sourcePath.push(dto.id);&#xD;&#xA;        this.targetPath.push(entity.id);&#xD;&#xA;        const entityCtor = this.getEntityConstructor(entity);&#xD;&#xA;        if (entityCtor != null) {&#xD;&#xA;            entity = entityCtor;&#xD;&#xA;            this.targetPath.push(entityCtor.id);&#xD;&#xA;        }&#xD;&#xA;        //Not this is the entity or the ctor depending&#xD;&#xA;        this.target = entity;&#xD;&#xA;        let result = this.populateContract(dto, entity, true, folder);&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    createOrGetCallOperation(operation, entity, folder) {&#xD;&#xA;        let operationName = operation.getName();&#xD;&#xA;        operationName = removeSuffix(operationName, &quot;Async&quot;);&#xD;&#xA;        operationName = toPascalCase(operationName);&#xD;&#xA;        const commandName = `${operationName}${entity.getName()}Command`;&#xD;&#xA;        const existing = folder.getChildren().find(x =&gt; x.getName() == commandName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        let dto = this.getOrCreateElement(commandName, &quot;Command&quot;, folder);&#xD;&#xA;        this.sourcePath.push(dto.id);&#xD;&#xA;        this.targetPath.push(entity.id);&#xD;&#xA;        this.targetPath.push(operation.id);&#xD;&#xA;        //Not this is the entity or the ctor depending&#xD;&#xA;        this.target = operation;&#xD;&#xA;        let result = this.populateContract(dto, operation, false, folder);&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    createOrGetUpdateCommand(entity, folder) {&#xD;&#xA;        let owningAggregate = DomainHelper.getOwningAggregate(entity);&#xD;&#xA;        let baseName = this.getBaseNameForElement(owningAggregate, entity, false);&#xD;&#xA;        const commandName = `Update${baseName}Command`;&#xD;&#xA;        let existing = folder.getChildren().find(x =&gt; x.getName() == commandName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        let dto = this.getOrCreateElement(commandName, &quot;Command&quot;, folder);&#xD;&#xA;        this.addMandatoryRelationships = true;&#xD;&#xA;        this.sourcePath.push(dto.id);&#xD;&#xA;        this.targetPath.push(entity.id);&#xD;&#xA;        this.target = entity;&#xD;&#xA;        let result = this.populateContract(dto, entity, false, folder);&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    createOrGetDeleteCommand(entity, folder) {&#xD;&#xA;        let owningAggregate = DomainHelper.getOwningAggregate(entity);&#xD;&#xA;        let baseName = this.getBaseNameForElement(owningAggregate, entity, false);&#xD;&#xA;        const commandName = `Delete${baseName}Command`;&#xD;&#xA;        let existing = folder.getChildren().find(x =&gt; x.getName() == commandName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        let dto = this.getOrCreateElement(commandName, &quot;Command&quot;, folder);&#xD;&#xA;        let attributes = this.getAttributesWithMapPath(entity, (x) =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;        this.addDtoFieldsInternal(attributes, false, entity, dto, folder, true);&#xD;&#xA;        dto.collapse();&#xD;&#xA;        return dto;&#xD;&#xA;    }&#xD;&#xA;    createOrGetFindByIdQuery(entity, folder, resultDto) {&#xD;&#xA;        let owningAggregate = DomainHelper.getOwningAggregate(entity);&#xD;&#xA;        let baseName = this.getBaseNameForElement(owningAggregate, entity, false);&#xD;&#xA;        let expectedQueryName = `Get${baseName}ByIdQuery`;&#xD;&#xA;        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        let query = createElement(&quot;Query&quot;, expectedQueryName, folder.id);&#xD;&#xA;        query.typeReference.setType(resultDto.id);&#xD;&#xA;        let attributes = this.getAttributesWithMapPath(entity, (x) =&gt; x.hasStereotype(&quot;Primary Key&quot;));&#xD;&#xA;        this.addDtoFieldsInternal(attributes, false, entity, query, folder, true);&#xD;&#xA;        query.collapse();&#xD;&#xA;        return query;&#xD;&#xA;    }&#xD;&#xA;    createOrGetFindAllQuery(entity, folder, resultDto) {&#xD;&#xA;        let owningAggregate = DomainHelper.getOwningAggregate(entity);&#xD;&#xA;        let baseName = this.getBaseNameForElement(owningAggregate, entity, true);&#xD;&#xA;        let expectedQueryName = `Get${baseName}Query`;&#xD;&#xA;        let existing = folder.getChildren().find(x =&gt; x.getName() == expectedQueryName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        let query = createElement(&quot;Query&quot;, expectedQueryName, folder.id);&#xD;&#xA;        query.typeReference.setType(resultDto.id);&#xD;&#xA;        query.typeReference.setIsCollection(true);&#xD;&#xA;        query.collapse();&#xD;&#xA;        return query;&#xD;&#xA;    }&#xD;&#xA;    createOrGetOperationDto(operationManager, entity, folder, createMode, inbound = false, addMandatoryRelationships = false) {&#xD;&#xA;        let operation = operationManager.getElement();&#xD;&#xA;        let dtoName = `${operation.getName()}Dto`;&#xD;&#xA;        let existing = folder.getChildren().find(x =&gt; x.getName() == dtoName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        this.addMandatoryRelationships = addMandatoryRelationships;&#xD;&#xA;        let dto = this.getOrCreateElement(dtoName, &quot;DTO&quot;, folder);&#xD;&#xA;        let dtoParam = operationManager.addChild(&quot;dto&quot;, dto.id);&#xD;&#xA;        this.sourcePath.push(operation.id);&#xD;&#xA;        this.sourcePath.push(dtoParam.id);&#xD;&#xA;        this.targetPath.push(entity.id);&#xD;&#xA;        if (inbound) {&#xD;&#xA;            const entityCtor = this.getEntityConstructor(entity);&#xD;&#xA;            if (entityCtor != null) {&#xD;&#xA;                entity = entityCtor;&#xD;&#xA;                this.targetPath.push(entityCtor.id);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        //Not this is the entity or the ctor depending&#xD;&#xA;        this.target = entity;&#xD;&#xA;        let result = this.populateContract(dto, entity, createMode, folder);&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    createOrGetDto(entity, folder, inbound = false) {&#xD;&#xA;        let owningAggregate = DomainHelper.getOwningAggregate(entity);&#xD;&#xA;        let baseName = this.getBaseNameForElement(owningAggregate, entity, false);&#xD;&#xA;        let dtoName = `${baseName}Dto`;&#xD;&#xA;        let existing = folder.getChildren().find(x =&gt; x.getName() == dtoName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        let dto = this.getOrCreateElement(dtoName, &quot;DTO&quot;, folder);&#xD;&#xA;        this.sourcePath.push(dto.id);&#xD;&#xA;        this.targetPath.push(entity.id);&#xD;&#xA;        if (inbound) {&#xD;&#xA;            const entityCtor = this.getEntityConstructor(entity);&#xD;&#xA;            if (entityCtor != null) {&#xD;&#xA;                entity = entityCtor;&#xD;&#xA;                this.targetPath.push(entityCtor.id);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        //Not this is the entity or the ctor depending&#xD;&#xA;        this.target = entity;&#xD;&#xA;        let result = this.populateContract(dto, entity, false, folder);&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    populateContract(contract, entity, createMode, folder) {&#xD;&#xA;        if (entity.specialization == &quot;Class Constructor&quot; || entity.specialization == &quot;Operation&quot;) {&#xD;&#xA;            this.addMapping(MappingType.TypeMap, [contract.id], [entity.id]);&#xD;&#xA;            this.addDtoFieldsForCtor(createMode, entity, contract, folder);&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            this.addMapping(MappingType.TypeMap, [contract.id], [entity.id]);&#xD;&#xA;            this.addDtoFields(createMode, entity, contract, folder, false);&#xD;&#xA;        }&#xD;&#xA;        return contract;&#xD;&#xA;    }&#xD;&#xA;    getOrCreateContract(elementName, elementType, entity, createMode, folder, inbound = false) {&#xD;&#xA;        let dto = this.getOrCreateElement(elementName, elementType, folder);&#xD;&#xA;        const entityCtor = entity&#xD;&#xA;            .getChildren(&quot;Class Constructor&quot;)&#xD;&#xA;            .sort((a, b) =&gt; {&#xD;&#xA;            // In descending order:&#xD;&#xA;            return b.getChildren(&quot;Parameter&quot;).length - a.getChildren(&quot;Parameter&quot;).length;&#xD;&#xA;        })[0];&#xD;&#xA;        if (inbound &amp;&amp; entityCtor != null) {&#xD;&#xA;            this.addMapping(MappingType.TypeMap, [dto.id], [entity.id, entityCtor.id]);&#xD;&#xA;            this.addDtoFieldsForCtor(createMode, entityCtor, dto, folder);&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            this.addMapping(MappingType.TypeMap, [dto.id], [entity.id]);&#xD;&#xA;            this.addDtoFields(createMode, entity, dto, folder, inbound);&#xD;&#xA;        }&#xD;&#xA;        return dto;&#xD;&#xA;    }&#xD;&#xA;    addDtoFields(createMode, entity, dto, folder, inbound = false) {&#xD;&#xA;        let dtoUpdated = false;&#xD;&#xA;        let domainElement = entity;&#xD;&#xA;        let attributesWithMapPaths = createMode ?&#xD;&#xA;            this.getAttributesWithMapPath(domainElement, (x) =&gt; this.standardAttributeFilter(x) &amp;&amp; !this.generatedPKFilter(x)) :&#xD;&#xA;            this.getAttributesWithMapPath(domainElement, this.standardAttributeFilter);&#xD;&#xA;        this.addDtoFieldsInternal(attributesWithMapPaths, createMode, entity, dto, folder, inbound);&#xD;&#xA;    }&#xD;&#xA;    addDtoFieldsInternal(attributes, createMode, entity, dto, folder, inbound = false) {&#xD;&#xA;        let dtoUpdated = false;&#xD;&#xA;        let domainElement = entity;&#xD;&#xA;        for (let keyName of Object.keys(attributes)) {&#xD;&#xA;            let entry = attributes[keyName];&#xD;&#xA;            if (createMode &amp;&amp; this.isChild == true &amp;&amp; CrudHelper.isOwnerForeignKey(entry.name, domainElement)) {&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            if (dto.getChildren(&quot;DTO-Field&quot;).some(x =&gt; x.getName() == entry.name)) {&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            let field = createElement(&quot;DTO-Field&quot;, entry.name, dto.id);&#xD;&#xA;            console.warn(&quot;Field : &quot; + entry.name + &quot; , mappath =&quot; + entry.mapPath);&#xD;&#xA;            let pops = this.addMapping(MappingType.Navigation, [field.id], entry.mapPath, DomainHelper.isComplexTypeById(entry.typeId));&#xD;&#xA;            if (DomainHelper.isComplexTypeById(entry.typeId)) {&#xD;&#xA;                let dtoName = dto.getName().replace(/(?:Dto|Command|Query)$/, &quot;&quot;) + field.getName() + &quot;Dto&quot;;&#xD;&#xA;                let entityField = lookup(entry.id);&#xD;&#xA;                let newDto = this.getOrCreateContract(dtoName, &quot;DTO&quot;, entityField.typeReference.getType(), createMode, folder, inbound);&#xD;&#xA;                field.typeReference.setType(newDto.id);&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                field.typeReference.setType(entry.typeId);&#xD;&#xA;            }&#xD;&#xA;            this.popMapping(pops);&#xD;&#xA;            field.typeReference.setIsNullable(entry.isNullable);&#xD;&#xA;            field.typeReference.setIsCollection(entry.isCollection);&#xD;&#xA;            dtoUpdated = true;&#xD;&#xA;        }&#xD;&#xA;        if (this.addMandatoryRelationships) {&#xD;&#xA;            this.isChild = true;&#xD;&#xA;            let requiredAssociations = DomainHelper.getMandatoryAssociationsWithMapPath(entity);&#xD;&#xA;            for (let entry of requiredAssociations) {&#xD;&#xA;                let field = createElement(&quot;DTO-Field&quot;, entry.name, dto.id);&#xD;&#xA;                let pops = this.addMapping(MappingType.Navigation, [field.id], entry.mapPath, true);&#xD;&#xA;                let dtoName = dto.getName().replace(/(?:Dto|Command|Query)$/, &quot;&quot;) + field.getName() + &quot;Dto&quot;;&#xD;&#xA;                let entityField = lookup(entry.id);&#xD;&#xA;                let newDto = this.getOrCreateContract(dtoName, &quot;DTO&quot;, entityField.typeReference.getType(), createMode, folder, inbound);&#xD;&#xA;                field.typeReference.setType(newDto.id);&#xD;&#xA;                this.popMapping(pops);&#xD;&#xA;                field.typeReference.setIsNullable(entry.isNullable);&#xD;&#xA;                field.typeReference.setIsCollection(entry.isCollection);&#xD;&#xA;                dtoUpdated = true;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        if (dtoUpdated) {&#xD;&#xA;            dto.collapse();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    addDtoFieldsForCtor(createMode, ctor, dto, folder) {&#xD;&#xA;        let childrenToAdd = DomainHelper.getChildrenOfType(ctor, &quot;Parameter&quot;).filter(x =&gt; x.typeId != null &amp;&amp; lookup(x.typeId).specialization !== &quot;Domain Service&quot;);&#xD;&#xA;        childrenToAdd.forEach(e =&gt; {&#xD;&#xA;            if (e.mapPath != null) {&#xD;&#xA;                if (dto.getChildren(&quot;Parameter&quot;).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            else if (ctor.getChildren(&quot;Parameter&quot;).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let field = createElement(&quot;DTO-Field&quot;, toPascalCase(e.name), dto.id);&#xD;&#xA;            let pops = this.addMapping(MappingType.Navigation, [field.id], e.mapPath, DomainHelper.isComplexTypeById(e.typeId));&#xD;&#xA;            if (DomainHelper.isComplexTypeById(e.typeId)) {&#xD;&#xA;                let dtoName = dto.getName().replace(/(?:Dto|Command|Query)$/, &quot;&quot;) + field.getName() + &quot;Dto&quot;;&#xD;&#xA;                let entityField = lookup(e.id);&#xD;&#xA;                let newDto = this.getOrCreateContract(dtoName, &quot;DTO&quot;, entityField.typeReference.getType(), createMode, folder, false);&#xD;&#xA;                field.typeReference.setType(newDto.id);&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                field.typeReference.setType(e.typeId);&#xD;&#xA;            }&#xD;&#xA;            this.popMapping(pops);&#xD;&#xA;            field.typeReference.setIsCollection(e.isCollection);&#xD;&#xA;            field.typeReference.setIsNullable(e.isNullable);&#xD;&#xA;        });&#xD;&#xA;        dto.collapse();&#xD;&#xA;    }&#xD;&#xA;    getBaseNameForElement(owningAggregate, entity, entityIsMany) {&#xD;&#xA;        // Keeping 'owningAggregate' in case we still need to use it as part of the name one day&#xD;&#xA;        let entityName = entityIsMany ? toPascalCase(pluralize(entity.getName())) : toPascalCase(entity.getName());&#xD;&#xA;        return entityName;&#xD;&#xA;    }&#xD;&#xA;    getOrCreateElement(elementName, elementType, parentElement) {&#xD;&#xA;        let existingDto = parentElement.getChildren(elementType).filter(x =&gt; x.getName() === elementName)[0];&#xD;&#xA;        if (existingDto) {&#xD;&#xA;            return existingDto;&#xD;&#xA;        }&#xD;&#xA;        let dto = createElement(elementType, elementName, parentElement.id);&#xD;&#xA;        return dto;&#xD;&#xA;    }&#xD;&#xA;    standardAttributeFilter(x) {&#xD;&#xA;        var _a;&#xD;&#xA;        return !CrudHelper.legacyPartitionKey(x) &amp;&amp;&#xD;&#xA;            (x[&quot;hasMetadata&quot;] &amp;&amp; (!x.hasMetadata(&quot;set-by-infrastructure&quot;) || ((_a = x.getMetadata(&quot;set-by-infrastructure&quot;)) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) !== &quot;true&quot;));&#xD;&#xA;    }&#xD;&#xA;    generatedPKFilter(x) {&#xD;&#xA;        return x.hasStereotype(&quot;Primary Key&quot;) &amp;&amp; (!x.getStereotype(&quot;Primary Key&quot;).hasProperty(&quot;Data source&quot;) || x.getStereotype(&quot;Primary Key&quot;).getProperty(&quot;Data source&quot;).value != &quot;User supplied&quot;);&#xD;&#xA;    }&#xD;&#xA;    getAttributesWithMapPath(entity, attributeFilter) {&#xD;&#xA;        if (attributeFilter == null) {&#xD;&#xA;            attributeFilter = (x) =&gt; this.standardAttributeFilter(x) &amp;&amp; !x.hasStereotype(&quot;Primary Key&quot;);&#xD;&#xA;        }&#xD;&#xA;        let attrDict = Object.create(null);&#xD;&#xA;        let attributes = entity.getChildren(&quot;Attribute&quot;)&#xD;&#xA;            .filter(attributeFilter);&#xD;&#xA;        attributes.forEach(attr =&gt; attrDict[attr.id] = {&#xD;&#xA;            id: attr.id,&#xD;&#xA;            name: attr.getName(),&#xD;&#xA;            typeId: attr.typeReference.typeId,&#xD;&#xA;            mapPath: [attr.id],&#xD;&#xA;            isNullable: attr.typeReference.isNullable,&#xD;&#xA;            isCollection: attr.typeReference.isCollection&#xD;&#xA;        });&#xD;&#xA;        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);&#xD;&#xA;        return attrDict;&#xD;&#xA;        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {&#xD;&#xA;            if (!curEntity) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalizations = curEntity.getAssociations(&quot;Generalization&quot;).filter(x =&gt; x.isTargetEnd());&#xD;&#xA;            if (generalizations.length == 0) {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            let generalization = generalizations[0];&#xD;&#xA;            generalizationStack.push(generalization.id);&#xD;&#xA;            let nextEntity = generalization.typeReference.getType();&#xD;&#xA;            let baseKeys = nextEntity.getChildren(&quot;Attribute&quot;)&#xD;&#xA;                .filter(attributeFilter);&#xD;&#xA;            baseKeys.forEach(attr =&gt; {&#xD;&#xA;                attrDict[attr.id] = {&#xD;&#xA;                    id: attr.id,&#xD;&#xA;                    name: attr.getName(),&#xD;&#xA;                    typeId: attr.typeReference.typeId,&#xD;&#xA;                    mapPath: generalizationStack.concat([attr.id]),&#xD;&#xA;                    isNullable: attr.typeReference.isNullable,&#xD;&#xA;                    isCollection: attr.typeReference.isCollection&#xD;&#xA;                };&#xD;&#xA;            });&#xD;&#xA;            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;common.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;crud-dialog.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/servicesHelper.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/CrudHelper.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;../../common/elementManager.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;project-from-entity.ts&quot; /&gt;&#xD;&#xA;class CrudStrategy {&#xD;&#xA;    constructor() {&#xD;&#xA;        this.resultDto = null;&#xD;&#xA;        this.owningAggregate = null;&#xD;&#xA;        this.entity = null;&#xD;&#xA;        this.context = null;&#xD;&#xA;        this.targetFolder = null;&#xD;&#xA;        this.primaryKeys = null;&#xD;&#xA;    }&#xD;&#xA;    async askUser(element, preselectedClass) {&#xD;&#xA;        let dialogOptions = await presentCrudOptionsDialog(preselectedClass);&#xD;&#xA;        if (dialogOptions == null || dialogOptions.selectedEntity == null)&#xD;&#xA;            return null;&#xD;&#xA;        const primaryKeys = DomainHelper.getPrimaryKeys(dialogOptions.selectedEntity);&#xD;&#xA;        let context = new CrudCreationContext(element, dialogOptions, primaryKeys);&#xD;&#xA;        return context;&#xD;&#xA;    }&#xD;&#xA;    getOrCreateEntityFolder(folderOrPackage, entity) {&#xD;&#xA;        var _a;&#xD;&#xA;        if (folderOrPackage.specialization == &quot;Folder&quot;) {&#xD;&#xA;            return element;&#xD;&#xA;        }&#xD;&#xA;        const folderName = this.getAggregateRootFolderName(entity);&#xD;&#xA;        const folder = (_a = element.getChildren().find(x =&gt; x.getName() == pluralize(folderName))) !== null &amp;&amp; _a !== void 0 ? _a : createElement(&quot;Folder&quot;, pluralize(folderName), element.id);&#xD;&#xA;        return folder;&#xD;&#xA;    }&#xD;&#xA;    getAggregateRootFolderName(entity) {&#xD;&#xA;        return pluralize(this.owningAggregate != null ? this.owningAggregate.getName() : entity.getName());&#xD;&#xA;    }&#xD;&#xA;    async execute(element, preselectedClass) {&#xD;&#xA;        var _a;&#xD;&#xA;        this.context = await this.askUser(element, preselectedClass);&#xD;&#xA;        if (this.context == null)&#xD;&#xA;            return;&#xD;&#xA;        let dialogOptions = this.context.dialogOptions;&#xD;&#xA;        this.entity = dialogOptions.selectedEntity;&#xD;&#xA;        this.primaryKeys = this.context.primaryKeys;&#xD;&#xA;        let hasPrimaryKey = this.context.hasPrimaryKey();&#xD;&#xA;        if (!await this.validate()) {&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;        this.owningAggregate = DomainHelper.getOwningAggregateRecursive(this.entity);&#xD;&#xA;        this.targetFolder = this.getOrCreateEntityFolder(this.context.element, this.entity);&#xD;&#xA;        this.initialize(this.context);&#xD;&#xA;        if (dialogOptions.canQueryById || dialogOptions.canQueryAll) {&#xD;&#xA;            let projector = new EntityProjector();&#xD;&#xA;            this.resultDto = projector.createOrGetDto(this.entity, this.targetFolder);&#xD;&#xA;            if (projector.getMappings().length &gt; 0) {&#xD;&#xA;                this.addBasicMapping(projector.getMappings());&#xD;&#xA;            }&#xD;&#xA;            this.resultDto.collapse();&#xD;&#xA;        }&#xD;&#xA;        if ((!privateSettersOnly || hasConstructor(this.entity)) &amp;&amp; dialogOptions.canCreate) {&#xD;&#xA;            let x = this.doCreate();&#xD;&#xA;            if (this.owningAggregate != null) {&#xD;&#xA;                this.AddAggregateKeys(x);&#xD;&#xA;            }&#xD;&#xA;            x.collapse();&#xD;&#xA;        }&#xD;&#xA;        if ((hasPrimaryKey &amp;&amp; !privateSettersOnly) &amp;&amp; dialogOptions.canUpdate) {&#xD;&#xA;            let x = this.doUpdate();&#xD;&#xA;            if (this.owningAggregate != null) {&#xD;&#xA;                this.AddAggregateKeys(x);&#xD;&#xA;            }&#xD;&#xA;            x.collapse();&#xD;&#xA;        }&#xD;&#xA;        if (hasPrimaryKey &amp;&amp; dialogOptions.canQueryById) {&#xD;&#xA;            let x = this.doGetById();&#xD;&#xA;            if (this.owningAggregate != null) {&#xD;&#xA;                this.AddAggregateKeys(x);&#xD;&#xA;            }&#xD;&#xA;            x.collapse();&#xD;&#xA;        }&#xD;&#xA;        if (dialogOptions.canQueryAll) {&#xD;&#xA;            let x = this.doGetAll();&#xD;&#xA;            if (this.owningAggregate != null) {&#xD;&#xA;                this.AddAggregateKeys(x);&#xD;&#xA;            }&#xD;&#xA;            x.collapse();&#xD;&#xA;        }&#xD;&#xA;        if (hasPrimaryKey &amp;&amp; dialogOptions.canDelete) {&#xD;&#xA;            let x = this.doDelete();&#xD;&#xA;            if (this.owningAggregate != null) {&#xD;&#xA;                this.AddAggregateKeys(x);&#xD;&#xA;            }&#xD;&#xA;            x.collapse();&#xD;&#xA;        }&#xD;&#xA;        if (dialogOptions.canDomain) {&#xD;&#xA;            const operations = DomainHelper.getCommandOperations(this.entity);&#xD;&#xA;            for (const operation of operations) {&#xD;&#xA;                if (!this.context.dialogOptions.selectedDomainOperationIds.some(x =&gt; x == operation.id)) {&#xD;&#xA;                    continue;&#xD;&#xA;                }&#xD;&#xA;                let operationResultDto = null;&#xD;&#xA;                if (operation.typeReference != null) {&#xD;&#xA;                    if (DomainHelper.isComplexType((_a = operation.typeReference) === null || _a === void 0 ? void 0 : _a.getType())) {&#xD;&#xA;                        let projector2 = new EntityProjector();&#xD;&#xA;                        let from = lookup(operation.typeReference.getTypeId());&#xD;&#xA;                        operationResultDto = projector2.createOrGetDto(from, this.targetFolder);&#xD;&#xA;                        if (projector2.getMappings().length &gt; 0) {&#xD;&#xA;                            this.addBasicMapping(projector2.getMappings());&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;                let x = this.doOperation(operation, operationResultDto);&#xD;&#xA;                if (this.owningAggregate != null) {&#xD;&#xA;                    this.AddAggregateKeys(x);&#xD;&#xA;                }&#xD;&#xA;                x.collapse();&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        this.doAddDiagram();&#xD;&#xA;        await notifyUserOfLimitations(dialogOptions.selectedEntity, dialogOptions);&#xD;&#xA;    }&#xD;&#xA;    async validate() {&#xD;&#xA;        if (DomainHelper.getOwnersRecursive(this.entity).length &gt; 1) {&#xD;&#xA;            const owners = DomainHelper.getOwnersRecursive(this.entity).map(item =&gt; item.getName()).join(&quot;, &quot;);&#xD;&#xA;            await dialogService.warn(`Entity has multiple owners.&#xD;&#xA;The entity '${this.entity.getName()}' has multiple Aggregate owning it [${owners}].&#xD;&#xA;&#xD;&#xA;Compositional Entities (black diamond) must have 1 owner. Please adjust the associations accordingly.`);&#xD;&#xA;            return false;&#xD;&#xA;        }&#xD;&#xA;        return true;&#xD;&#xA;    }&#xD;&#xA;    doAdvancedMappingCreate(projector, source) {&#xD;&#xA;        if (projector.getMappings().length &gt; 0) {&#xD;&#xA;            let target = projector.getTarget();&#xD;&#xA;            let action = createAssociation(&quot;Create Entity Action&quot;, source.id, target.id);&#xD;&#xA;            let mapping = action.createAdvancedMapping(source.id, this.entity.id);&#xD;&#xA;            mapping.addMappedEnd(&quot;Invocation Mapping&quot;, [source.id], [target.id]);&#xD;&#xA;            this.addAdvancedMappingEnds(&quot;Data Mapping&quot;, source, mapping, projector.getMappings());&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    doAdvancedMappingDelete(mappings, source) {&#xD;&#xA;        if (mappings.length &gt; 0) {&#xD;&#xA;            let action = createAssociation(&quot;Delete Entity Action&quot;, source.id, this.entity.id);&#xD;&#xA;            let mapping = action.createAdvancedMapping(source.id, this.entity.id);&#xD;&#xA;            this.addAdvancedMappingEnds(&quot;Filter Mapping&quot;, source, mapping, mappings);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    doAdvancedMappingGetById(mappings, source) {&#xD;&#xA;        if (mappings.length &gt; 0) {&#xD;&#xA;            let action = createAssociation(&quot;Query Entity Action&quot;, source.id, this.entity.id);&#xD;&#xA;            let queryMapping = action.createAdvancedMapping(source.id, this.entity.id, &quot;25f25af9-c38b-4053-9474-b0fabe9d7ea7&quot;);&#xD;&#xA;            this.addAdvancedMappingEnds(&quot;Filter Mapping&quot;, source, queryMapping, mappings);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    doAdvancedMappingUpdate(projector, source) {&#xD;&#xA;        if (projector.getMappings().length &gt; 0) {&#xD;&#xA;            let action = createAssociation(&quot;Update Entity Action&quot;, source.id, this.entity.id);&#xD;&#xA;            //remove PKs from Update&#xD;&#xA;            let updateMappingEnds = projector.getMappings().filter(x =&gt; {&#xD;&#xA;                const last = x.targetPath[x.targetPath.length - 1];&#xD;&#xA;                return !this.primaryKeys.some(pk =&gt; pk.id == last);&#xD;&#xA;            });&#xD;&#xA;            let queryMappingEnds = this.createQueryMappingEnds(source);&#xD;&#xA;            // Query Entity Mapping&#xD;&#xA;            let queryMapping = action.createAdvancedMapping(source.id, this.entity.id, &quot;25f25af9-c38b-4053-9474-b0fabe9d7ea7&quot;);&#xD;&#xA;            this.addAdvancedMappingEnds(&quot;Filter Mapping&quot;, source, queryMapping, queryMappingEnds);&#xD;&#xA;            // Update Entity Mapping&#xD;&#xA;            let updateMapping = action.createAdvancedMapping(source.id, this.entity.id, &quot;01721b1a-a85d-4320-a5cd-8bd39247196a&quot;);&#xD;&#xA;            this.addAdvancedMappingEnds(&quot;Data Mapping&quot;, source, updateMapping, updateMappingEnds);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    doAdvancedMappingGetAll(source) {&#xD;&#xA;        let action = createAssociation(&quot;Query Entity Action&quot;, source.id, this.entity.id);&#xD;&#xA;        action.typeReference.setIsCollection(true);&#xD;&#xA;        action.createAdvancedMapping(source.id, this.entity.id, &quot;25f25af9-c38b-4053-9474-b0fabe9d7ea7&quot;);&#xD;&#xA;    }&#xD;&#xA;    doAdvancedMappingCallOperation(projector, source) {&#xD;&#xA;        if (projector.getMappings().length &gt; 0) {&#xD;&#xA;            let target = projector.getTarget();&#xD;&#xA;            let action = createAssociation(&quot;Update Entity Action&quot;, source.id, this.entity.id);&#xD;&#xA;            //remove PKs from Update&#xD;&#xA;            let updateMappingEnds = projector.getMappings().filter(x =&gt; {&#xD;&#xA;                const last = x.targetPath[x.targetPath.length - 1];&#xD;&#xA;                return !this.primaryKeys.some(pk =&gt; pk.id == last);&#xD;&#xA;            });&#xD;&#xA;            let queryMappingEnds = this.createQueryMappingEnds(source);&#xD;&#xA;            // Query Entity Mapping&#xD;&#xA;            let queryMapping = action.createAdvancedMapping(source.id, this.entity.id, &quot;25f25af9-c38b-4053-9474-b0fabe9d7ea7&quot;);&#xD;&#xA;            this.addAdvancedMappingEnds(&quot;Filter Mapping&quot;, source, queryMapping, queryMappingEnds);&#xD;&#xA;            // Update Entity Mapping&#xD;&#xA;            let updateMapping = action.createAdvancedMapping(source.id, this.entity.id, &quot;01721b1a-a85d-4320-a5cd-8bd39247196a&quot;);&#xD;&#xA;            updateMapping.addMappedEnd(&quot;Invocation Mapping&quot;, [source.id], [target.id]);&#xD;&#xA;            this.addAdvancedMappingEnds(&quot;Data Mapping&quot;, source, updateMapping, updateMappingEnds);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    createQueryMappingEnds(source) {&#xD;&#xA;        let queryMappingEnds = [];&#xD;&#xA;        for (const pk of Object.values(this.primaryKeys)) {&#xD;&#xA;            var dtoField = source.getChildren().find(x =&gt; x.getName() == pk.name);&#xD;&#xA;            queryMappingEnds.push({ type: MappingType.Navigation, sourcePath: [dtoField.id], targetPath: pk.mapPath, targetPropertyStart: pk.mapPath[0] });&#xD;&#xA;        }&#xD;&#xA;        return queryMappingEnds;&#xD;&#xA;    }&#xD;&#xA;    addDiagram(whatToAdd, diagramFolder) {&#xD;&#xA;        var _a;&#xD;&#xA;        if (diagramFolder == null) {&#xD;&#xA;            diagramFolder = this.targetFolder;&#xD;&#xA;        }&#xD;&#xA;        let entity = this.entity;&#xD;&#xA;        if (DomainHelper.isAggregateRoot(entity)) {&#xD;&#xA;            const aggregateRootFolderName = this.getAggregateRootFolderName(entity);&#xD;&#xA;            const diagramElement = (_a = diagramFolder.getChildren(&quot;Diagram&quot;).find(x =&gt; x.getName() == aggregateRootFolderName)) !== null &amp;&amp; _a !== void 0 ? _a : createElement(&quot;Diagram&quot;, aggregateRootFolderName, diagramFolder.id);&#xD;&#xA;            diagramElement.loadDiagram();&#xD;&#xA;            const diagram = getCurrentDiagram();&#xD;&#xA;            diagram.layoutVisuals(whatToAdd, null, true);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    addBasicMapping(mappings) {&#xD;&#xA;        mappings.forEach(m =&gt; {&#xD;&#xA;            var _a;&#xD;&#xA;            let dtoPart = lookup(m.sourcePath.slice(-1)[0]);&#xD;&#xA;            //Work around for SetMapping clearing type in some scenarios.&#xD;&#xA;            let previousType = (_a = dtoPart.typeReference) === null || _a === void 0 ? void 0 : _a.getTypeId();&#xD;&#xA;            //Some property paths are multiple entries like &quot;base.id&quot;&#xD;&#xA;            if (m.type == MappingType.Navigation) {&#xD;&#xA;                //console.warn(m.type + &quot;:&quot; + m.sourcePath.map(x =&gt; lookup(x).getName()).join('.') + &quot;-&gt;&quot; + m.targetPath.map(x =&gt; lookup(x).getName()).join('.'));&#xD;&#xA;                const index = m.targetPath.indexOf(m.targetPropertyStart);&#xD;&#xA;                if (index === -1)&#xD;&#xA;                    return; // value not found&#xD;&#xA;                dtoPart.setMapping(m.targetPath.slice(index));&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                dtoPart.setMapping(m.targetPath.slice(-1)[0]);&#xD;&#xA;            }&#xD;&#xA;            if (previousType != null) {&#xD;&#xA;                dtoPart.typeReference.setType(previousType);&#xD;&#xA;            }&#xD;&#xA;        });&#xD;&#xA;    }&#xD;&#xA;    addAdvancedMappingEnds(mappingType, element, mapping, mappings) {&#xD;&#xA;        mappings.forEach(m =&gt; {&#xD;&#xA;            var _a, _b, _c;&#xD;&#xA;            if (m.type == MappingType.Navigation) {&#xD;&#xA;                //console.warn(m.type + &quot;:&quot; + m.sourcePath.map(x =&gt; lookup(x).getName()).join('.') + &quot;-&gt;&quot; + m.targetPath.map(x =&gt; lookup(x).getName()).join('.'));&#xD;&#xA;                let dtoPart = lookup(m.sourcePath.slice(-1)[0]);&#xD;&#xA;                let mappedElementId = m.targetPath.slice(-1)[0];&#xD;&#xA;                let element = lookup(mappedElementId);&#xD;&#xA;                if (element.specialization == &quot;Class Constructor&quot;) {&#xD;&#xA;                    mapping.addMappedEnd(&quot;Invocation Mapping&quot;, [element.id], m.targetPath);&#xD;&#xA;                }&#xD;&#xA;                else {&#xD;&#xA;                    if ((((_b = (_a = dtoPart.typeReference) === null || _a === void 0 ? void 0 : _a.getType()) === null || _b === void 0 ? void 0 : _b.specialization) != &quot;DTO&quot; || ((_c = dtoPart.typeReference) === null || _c === void 0 ? void 0 : _c.getIsCollection()))) {&#xD;&#xA;                        mapping.addMappedEnd(mappingType, m.sourcePath, m.targetPath);&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        });&#xD;&#xA;    }&#xD;&#xA;    AddAggregateKeys(element) {&#xD;&#xA;        //Have to do the reverse so setOrder works&#xD;&#xA;        let keys = DomainHelper.getOwningAggregateKeyChain(this.entity).reverse();&#xD;&#xA;        keys.forEach((pk) =&gt; {&#xD;&#xA;            if (!element.getChildren().some(x =&gt; x.getName().toLowerCase() == pk.expectedName.toLowerCase())) {&#xD;&#xA;                let field = this.addMissingAggregateKey(element, pk.expectedName);&#xD;&#xA;                field.typeReference.setType(pk.attribute.typeReference.getTypeId());&#xD;&#xA;                field.setOrder(0);&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                let field = element.getChildren().find(x =&gt; x.getName().toLowerCase() == pk.expectedName.toLowerCase());&#xD;&#xA;                field.setOrder(0);&#xD;&#xA;            }&#xD;&#xA;        });&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;strategy-base.ts&quot; /&gt;&#xD;&#xA;class CQRSCrudStrategy extends CrudStrategy {&#xD;&#xA;    initialize(context) {&#xD;&#xA;    }&#xD;&#xA;    doCreate() {&#xD;&#xA;        let projector = new EntityProjector();&#xD;&#xA;        let command = projector.createOrGetCreateCommand(this.entity, this.targetFolder);&#xD;&#xA;        const surrogateKey = this.primaryKeys.length === 1;&#xD;&#xA;        if (surrogateKey) {&#xD;&#xA;            command.typeReference.setType(this.primaryKeys[0].typeId);&#xD;&#xA;        }&#xD;&#xA;        this.doAdvancedMappingCreate(projector, command);&#xD;&#xA;        return command;&#xD;&#xA;    }&#xD;&#xA;    doUpdate() {&#xD;&#xA;        let projector = new EntityProjector();&#xD;&#xA;        let command = projector.createOrGetUpdateCommand(this.entity, this.targetFolder);&#xD;&#xA;        this.doAdvancedMappingUpdate(projector, command);&#xD;&#xA;        return command;&#xD;&#xA;    }&#xD;&#xA;    doDelete() {&#xD;&#xA;        let projector = new EntityProjector();&#xD;&#xA;        let command = projector.createOrGetDeleteCommand(this.entity, this.targetFolder);&#xD;&#xA;        this.doAdvancedMappingDelete(projector.getMappings(), command);&#xD;&#xA;        return command;&#xD;&#xA;    }&#xD;&#xA;    doGetById() {&#xD;&#xA;        let projector = new EntityProjector();&#xD;&#xA;        let query = projector.createOrGetFindByIdQuery(this.entity, this.targetFolder, this.resultDto);&#xD;&#xA;        this.doAdvancedMappingGetById(projector.getMappings(), query);&#xD;&#xA;        return query;&#xD;&#xA;    }&#xD;&#xA;    doGetAll() {&#xD;&#xA;        let projector = new EntityProjector();&#xD;&#xA;        let query = projector.createOrGetFindAllQuery(this.entity, this.targetFolder, this.resultDto);&#xD;&#xA;        this.doAdvancedMappingGetAll(query);&#xD;&#xA;        return query;&#xD;&#xA;    }&#xD;&#xA;    doOperation(operation, operationResultDto) {&#xD;&#xA;        let projector = new EntityProjector();&#xD;&#xA;        let command = projector.createOrGetCallOperation(operation, this.entity, this.targetFolder);&#xD;&#xA;        if (operationResultDto) {&#xD;&#xA;            command.typeReference.setType(operationResultDto.id);&#xD;&#xA;        }&#xD;&#xA;        this.doAdvancedMappingCallOperation(projector, command);&#xD;&#xA;        return command;&#xD;&#xA;    }&#xD;&#xA;    doAddDiagram() {&#xD;&#xA;        this.addDiagram(this.targetFolder);&#xD;&#xA;    }&#xD;&#xA;    addMissingAggregateKey(element, name) {&#xD;&#xA;        return createElement(&quot;DTO-Field&quot;, name, element.id);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;strategy-base.ts&quot; /&gt;&#xD;&#xA;class TraditionalServicesStrategy extends CrudStrategy {&#xD;&#xA;    initialize(context) {&#xD;&#xA;        const intentPackage = element.getPackage();&#xD;&#xA;        let entity = context.dialogOptions.selectedEntity;&#xD;&#xA;        const serviceName = `${toPascalCase(pluralize(this.owningAggregate != null ? this.owningAggregate.getName() : entity.getName()))}Service`;&#xD;&#xA;        const existingService = element.specialization == &quot;Service&quot; ? element : intentPackage.getChildren(&quot;Service&quot;).find(x =&gt; x.getName() == serviceName);&#xD;&#xA;        this.service = existingService !== null &amp;&amp; existingService !== void 0 ? existingService : createElement(&quot;Service&quot;, serviceName, intentPackage.id);&#xD;&#xA;    }&#xD;&#xA;    doCreate() {&#xD;&#xA;        let operationName = `Create${this.entity.getName()}`;&#xD;&#xA;        const existing = this.operationExists(operationName);&#xD;&#xA;        if (existing) {&#xD;&#xA;            existing.typeReference.setType(this.primaryKeys[0].typeId);&#xD;&#xA;            return existing;&#xD;&#xA;        }&#xD;&#xA;        let operationManager = new ElementManager(createElement(&quot;Operation&quot;, operationName, this.service.id), {&#xD;&#xA;            childSpecialization: &quot;Parameter&quot;,&#xD;&#xA;            childType: &quot;parameter&quot;&#xD;&#xA;        });&#xD;&#xA;        let projector = new EntityProjector();&#xD;&#xA;        projector.createOrGetOperationDto(operationManager, this.entity, this.targetFolder, true, true, true);&#xD;&#xA;        if (this.primaryKeys.length == 1) {&#xD;&#xA;            operationManager.setReturnType(this.primaryKeys[0].typeId);&#xD;&#xA;        }&#xD;&#xA;        this.doAdvancedMappingCreate(projector, operationManager.getElement());&#xD;&#xA;        return operationManager.getElement();&#xD;&#xA;    }&#xD;&#xA;    doUpdate() {&#xD;&#xA;        let operationName = `Update${this.entity.getName()}`;&#xD;&#xA;        const existing = this.operationExists(operationName);&#xD;&#xA;        if (existing)&#xD;&#xA;            return existing;&#xD;&#xA;        let operationManager = new ElementManager(createElement(&quot;Operation&quot;, operationName, this.service.id), {&#xD;&#xA;            childSpecialization: &quot;Parameter&quot;,&#xD;&#xA;            childType: &quot;parameter&quot;&#xD;&#xA;        });&#xD;&#xA;        let operation = operationManager.getElement();&#xD;&#xA;        for (const pk of Object.values(this.primaryKeys)) {&#xD;&#xA;            var param = createElement(&quot;Parameter&quot;, pk.name, operation.id);&#xD;&#xA;            param.typeReference.setType(pk.typeId);&#xD;&#xA;        }&#xD;&#xA;        let projector = new EntityProjector();&#xD;&#xA;        projector.createOrGetOperationDto(operationManager, this.entity, this.targetFolder, true, true, true);&#xD;&#xA;        this.doAdvancedMappingUpdate(projector, operationManager.getElement());&#xD;&#xA;        return operationManager.getElement();&#xD;&#xA;    }&#xD;&#xA;    doDelete() {&#xD;&#xA;        let operationName = `Delete${this.entity.getName()}`;&#xD;&#xA;        const existing = this.operationExists(operationName);&#xD;&#xA;        if (existing)&#xD;&#xA;            return existing;&#xD;&#xA;        let operation = createElement(&quot;Operation&quot;, operationName, this.service.id);&#xD;&#xA;        let mappings = this.addPkParameters(operation);&#xD;&#xA;        this.doAdvancedMappingDelete(mappings, operation);&#xD;&#xA;        return operation;&#xD;&#xA;    }&#xD;&#xA;    doGetById() {&#xD;&#xA;        let operationName = `Find${this.entity.getName()}ById`;&#xD;&#xA;        const existing = this.operationExists(operationName);&#xD;&#xA;        if (existing)&#xD;&#xA;            return existing;&#xD;&#xA;        let operation = createElement(&quot;Operation&quot;, operationName, this.service.id);&#xD;&#xA;        let mappings = this.addPkParameters(operation);&#xD;&#xA;        operation.typeReference.setType(this.resultDto.id);&#xD;&#xA;        this.doAdvancedMappingGetById(mappings, operation);&#xD;&#xA;        return operation;&#xD;&#xA;    }&#xD;&#xA;    doGetAll() {&#xD;&#xA;        let operationName = `Find${pluralize(this.entity.getName())}`;&#xD;&#xA;        const existing = this.operationExists(operationName);&#xD;&#xA;        if (existing)&#xD;&#xA;            return existing;&#xD;&#xA;        let operation = createElement(&quot;Operation&quot;, operationName, this.service.id);&#xD;&#xA;        operation.typeReference.setType(this.resultDto.id);&#xD;&#xA;        operation.typeReference.setIsCollection(true);&#xD;&#xA;        this.doAdvancedMappingGetAll(operation);&#xD;&#xA;        return operation;&#xD;&#xA;    }&#xD;&#xA;    doOperation(domainOperation, operationResultDto) {&#xD;&#xA;        let operationName = domainOperation.getName();&#xD;&#xA;        const existing = this.operationExists(operationName);&#xD;&#xA;        if (existing)&#xD;&#xA;            return existing;&#xD;&#xA;        let operationManager = new ElementManager(createElement(&quot;Operation&quot;, operationName, this.service.id), {&#xD;&#xA;            childSpecialization: &quot;Parameter&quot;,&#xD;&#xA;            childType: &quot;parameter&quot;&#xD;&#xA;        });&#xD;&#xA;        let operation = operationManager.getElement();&#xD;&#xA;        for (const pk of Object.values(this.primaryKeys)) {&#xD;&#xA;            var param = createElement(&quot;Parameter&quot;, pk.name, operation.id);&#xD;&#xA;            param.typeReference.setType(pk.typeId);&#xD;&#xA;        }&#xD;&#xA;        let projector = new EntityProjector();&#xD;&#xA;        projector.createOrGetOperationDto(operationManager, domainOperation, this.targetFolder, false, true);&#xD;&#xA;        if (operationResultDto) {&#xD;&#xA;            operationManager.setReturnType(operationResultDto.id);&#xD;&#xA;        }&#xD;&#xA;        this.doAdvancedMappingCallOperation(projector, operationManager.getElement());&#xD;&#xA;        return operation;&#xD;&#xA;    }&#xD;&#xA;    addPkParameters(operation) {&#xD;&#xA;        let mappings = [];&#xD;&#xA;        for (const pk of Object.values(this.primaryKeys)) {&#xD;&#xA;            var param = createElement(&quot;Parameter&quot;, pk.name, operation.id);&#xD;&#xA;            param.typeReference.setType(pk.typeId);&#xD;&#xA;            mappings.push({ type: MappingType.Navigation, sourcePath: [param.id], targetPath: pk.mapPath, targetPropertyStart: pk.mapPath[0] });&#xD;&#xA;        }&#xD;&#xA;        return mappings;&#xD;&#xA;    }&#xD;&#xA;    operationExists(operationName) {&#xD;&#xA;        return this.service.getChildren().find(x =&gt; x.getName() === operationName);&#xD;&#xA;    }&#xD;&#xA;    doAddDiagram() {&#xD;&#xA;        this.addDiagram(this.service);&#xD;&#xA;    }&#xD;&#xA;    addMissingAggregateKey(element, name) {&#xD;&#xA;        return createElement(&quot;Parameter&quot;, toCamelCase(name), element.id);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;/// &lt;reference path=&quot;strategy-cqrs.ts&quot; /&gt;&#xD;&#xA;/// &lt;reference path=&quot;strategy-traditional.ts&quot; /&gt;&#xD;&#xA;let CrudApi = {&#xD;&#xA;    createCQRSService,&#xD;&#xA;    createTraditionalService&#xD;&#xA;};&#xD;&#xA;async function createCQRSService(element, preselectedClass) {&#xD;&#xA;    let strategy = new CQRSCrudStrategy();&#xD;&#xA;    await strategy.execute(element, preselectedClass);&#xD;&#xA;}&#xD;&#xA;async function createTraditionalService(element, preselectedClass) {&#xD;&#xA;    let strategy = new TraditionalServicesStrategy();&#xD;&#xA;    await strategy.execute(element, preselectedClass);&#xD;&#xA;}&#xD;&#xA;" isActive="true" />
        <property name="41cc0d56-3141-40fe-ae97-c024866d441e" display="File Path" isActive="false" />
        <property name="540780ad-f54e-4bd5-95f3-20a58fd59105" display="Dependencies" isActive="true" />
      </properties>
    </stereotype>
  </stereotypes>
  <metadata />
  <childElements />
</class>