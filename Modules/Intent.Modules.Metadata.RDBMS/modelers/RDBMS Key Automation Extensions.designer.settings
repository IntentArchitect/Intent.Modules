<?xml version="1.0" encoding="utf-8"?>
<settings version="3.1.1">
  <id>ee1b6efd-1cc6-441c-a50e-edc50f5ac6a3</id>
  <name>RDBMS Key Automation Extensions</name>
  <designerReferences />
  <packageSettings />
  <packageExtensions>
    <packageExtension type="Domain Package" typeId="1a824508-4623-45d9-accc-f572091ade5a">
      <requiredPackages />
      <creationOptions />
      <scriptOptions />
      <typeOrder />
      <macros>
        <macro trigger="on-loaded">
          <script>const primaryKeyStereotypeId = "b99aac21-9ca4-467f-a3a6-046255a9eed6";
const relationalDatabaseId = "51a7bcf5-0eb9-4c9a-855e-3ead1048729c";
const foreignKeyStereotypeId = "793a5128-57a1-440b-a206-af5722b752a6";
const foreignKeyStereotypeAssociationProperty = "Association";
const metadataKey = {
    association: "association",
    autoManageKeys: "auto-manage-keys",
    fkOriginalName: "fk-original-name",
    isBeingDeletedByScript: "is-being-deleted-by-script",
    isManagedKey: "is-managed-key",
};
/// &lt;reference path="../../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../_common/constants.ts" /&gt;
function execute() {
    setDatabaseParadigm();
    setupForeignKeyAttributes();
}
function setDatabaseParadigm() {
    if (!element.hasMetadata("database-paradigm-selected") &amp;&amp;
        !element.hasStereotype(relationalDatabaseId) &amp;&amp;
        !element.hasStereotype("Document Database")) {
        element.addStereotype(relationalDatabaseId);
    }
    element.setMetadata("database-paradigm-selected", "true");
}
function setupForeignKeyAttributes() {
    lookupTypesOf("Attribute").forEach(attr =&gt; {
        processSingleForeignKeyAttribute(attr);
    });
}
function processSingleForeignKeyAttribute(attr) {
    var _a, _b;
    if (!attr.hasMetadata(metadataKey.association) ||
        attr.getPackage().specialization !== "Domain Package" ||
        !attr.getPackage().hasStereotype(relationalDatabaseId)) {
        return;
    }
    const associationTarget = (_b = (_a = attr.getStereotype(foreignKeyStereotypeId)) === null || _a === void 0 ? void 0 : _a.getProperty(foreignKeyStereotypeAssociationProperty)) === null || _b === void 0 ? void 0 : _b.getValue();
    if (associationTarget == null) {
        if (!attr.hasStereotype(foreignKeyStereotypeId)) {
            attr.addStereotype(foreignKeyStereotypeId);
        }
        const associationId = attr.getMetadata(metadataKey.association);
        attr
            .getStereotype(foreignKeyStereotypeId)
            .getProperty(foreignKeyStereotypeAssociationProperty)
            .setValue(associationId);
    }
    if (!attr.hasMetadata(metadataKey.fkOriginalName)) {
        attr.setMetadata(metadataKey.fkOriginalName, attr.getName());
    }
}
execute();
</script>
        </macro>
      </macros>
    </packageExtension>
  </packageExtensions>
  <elementSettings />
  <elementExtensions>
    <elementExtension type="Attribute" typeId="0090fb93-483e-41af-a11d-5ad2dc796adf">
      <mappingSettings />
      <macros>
        <macro trigger="on-changed">
          <script>function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
const primaryKeyStereotypeId = "b99aac21-9ca4-467f-a3a6-046255a9eed6";
const relationalDatabaseId = "51a7bcf5-0eb9-4c9a-855e-3ead1048729c";
const foreignKeyStereotypeId = "793a5128-57a1-440b-a206-af5722b752a6";
const foreignKeyStereotypeAssociationProperty = "Association";
const metadataKey = {
    association: "association",
    autoManageKeys: "auto-manage-keys",
    fkOriginalName: "fk-original-name",
    isBeingDeletedByScript: "is-being-deleted-by-script",
    isManagedKey: "is-managed-key",
};
/// &lt;reference path="../../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="../_common/constants.ts" /&gt;
function execute() {
    var _a, _b, _c, _d, _e;
    if (((_b = (_a = application === null || application === void 0 ? void 0 : application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Creation Mode")) === null || _b === void 0 ? void 0 : _b.value) != "explicit" ||
        element.getParent().getMetadata(metadataKey.autoManageKeys) === "false" ||
        element.getPackage().specialization !== "Domain Package" ||
        !element.getPackage().hasStereotype(relationalDatabaseId)) {
        return;
    }
    if (element.getName().toLocaleLowerCase() == "id" &amp;&amp;
        element.hasStereotype("Primary Key") &amp;&amp;
        element.typeReference.getType()) {
        if (((_c = element.typeReference.getType()) === null || _c === void 0 ? void 0 : _c.id) != getSurrogateKeyType()) {
            element.setMetadata(metadataKey.isManagedKey, "false");
        }
        else {
            element.setMetadata(metadataKey.isManagedKey, "true");
        }
    }
    let associationTarget = (_e = (_d = element.getStereotype(foreignKeyStereotypeId)) === null || _d === void 0 ? void 0 : _d.getProperty(foreignKeyStereotypeAssociationProperty)) === null || _e === void 0 ? void 0 : _e.getValue();
    if (associationTarget &amp;&amp; element.getMetadata(metadataKey.association) != associationTarget.id) {
        element.setMetadata(metadataKey.association, associationTarget.id);
    }
}
execute();
</script>
        </macro>
        <macro trigger="on-deleted">
          <script>const primaryKeyStereotypeId = "b99aac21-9ca4-467f-a3a6-046255a9eed6";
const relationalDatabaseId = "51a7bcf5-0eb9-4c9a-855e-3ead1048729c";
const foreignKeyStereotypeId = "793a5128-57a1-440b-a206-af5722b752a6";
const foreignKeyStereotypeAssociationProperty = "Association";
const metadataKey = {
    association: "association",
    autoManageKeys: "auto-manage-keys",
    fkOriginalName: "fk-original-name",
    isBeingDeletedByScript: "is-being-deleted-by-script",
    isManagedKey: "is-managed-key",
};
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/**
 * Applies camelCasing or PascalCasing naming convention according to the setting configured for the current application.
 */
function applyAttributeNamingConvention(str) {
    var _a, _b, _c;
    let convention = (_c = (_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
    }
    return str;
}
/// &lt;reference path="../../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="../../../common/applyAttributeNamingConvention.ts" /&gt;
/// &lt;reference path="../_common/constants.ts" /&gt;
function updateForeignKeys(thisEnd) {
    var _a, _b;
    if (((_b = (_a = application === null || application === void 0 ? void 0 : application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Creation Mode")) === null || _b === void 0 ? void 0 : _b.value) != "explicit") {
        return;
    }
    let otherEnd = thisEnd.getOtherEnd();
    if (!otherEnd.typeReference.getType().getPackage().hasStereotype(relationalDatabaseId)) {
        return;
    }
    let thisEndType = thisEnd.getOtherEnd().typeReference.getType();
    let otherEndType = thisEnd.typeReference.getType();
    if ((thisEndType === null || thisEndType === void 0 ? void 0 : thisEndType.specialization) !== "Class" || (otherEndType === null || otherEndType === void 0 ? void 0 : otherEndType.specialization) !== "Class") {
        return;
    }
    const targetEndId = thisEnd.isTargetEnd() ? thisEnd.id : otherEnd.id;
    if (requiresForeignKey(thisEnd)) {
        updateForeignKeyAttribute(thisEnd, thisEndType, otherEndType, targetEndId);
        return;
    }
    thisEndType.getChildren()
        .filter(x =&gt; x.getMetadata(metadataKey.association) == targetEndId)
        .forEach(x =&gt; {
        x.setMetadata(metadataKey.isBeingDeletedByScript, "true");
        x.delete();
    });
    function updateForeignKeyAttribute(thisEnd, thisEndType, otherEndType, targetEndId) {
        const pkAttributes = getPrimaryKeys(otherEndType);
        pkAttributes.forEach((pk, index) =&gt; {
            var _a;
            let fkAttribute = (_a = thisEndType.getChildren().filter(x =&gt; x.getMetadata(metadataKey.association) == targetEndId)[index]) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Attribute", "", thisEndType.id);
            // This check to avoid a loop where the Domain script is updating the conventions and this keeps renaming it back.
            let fkNameToUse = `${toCamelCase(thisEnd.getName())}${toPascalCase(pk.name)}`;
            if (fkAttribute.getName().toLocaleLowerCase() !== fkNameToUse.toLocaleLowerCase()) {
                if (!fkAttribute.hasMetadata(metadataKey.fkOriginalName) || (fkAttribute.getMetadata(metadataKey.fkOriginalName) == fkAttribute.getName())) {
                    fkAttribute.setName(fkNameToUse);
                    fkAttribute.setMetadata(metadataKey.fkOriginalName, fkAttribute.getName());
                }
            }
            fkAttribute.setMetadata(metadataKey.association, targetEndId);
            fkAttribute.setMetadata(metadataKey.isManagedKey, "true");
            let fkStereotype = fkAttribute.getStereotype(foreignKeyStereotypeId);
            if (fkStereotype == null) {
                fkAttribute.addStereotype(foreignKeyStereotypeId);
                fkStereotype = fkAttribute.getStereotype(foreignKeyStereotypeId);
            }
            fkStereotype.getProperty(foreignKeyStereotypeAssociationProperty).setValue(thisEnd.isTargetEnd() ? thisEnd.id : thisEnd.getOtherEnd().id);
            fkAttribute.typeReference.setType(pk.typeId);
            fkAttribute.typeReference.setIsNullable(thisEnd.typeReference.isNullable);
        });
        thisEndType.getChildren().filter(x =&gt; x.getMetadata(metadataKey.association) == targetEndId).forEach((attr, index) =&gt; {
            if (index &gt;= pkAttributes.length) {
                attr.setMetadata(metadataKey.isBeingDeletedByScript, "true");
                attr.delete();
            }
        });
        if (otherEndType.id !== thisEndType.id) {
            otherEndType.getChildren()
                .filter(x =&gt; x.getMetadata(metadataKey.association) == targetEndId)
                .forEach(x =&gt; {
                x.setMetadata(metadataKey.isBeingDeletedByScript, "true");
                x.delete();
            });
        }
    }
    function requiresForeignKey(associationEnd) {
        const isManyToVariantsOfOne = () =&gt; !associationEnd.typeReference.isCollection &amp;&amp;
            associationEnd.getOtherEnd().typeReference.isCollection;
        const isSelfReferencingZeroToOne = () =&gt; !associationEnd.typeReference.isCollection &amp;&amp;
            associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
        const isAggregationalOneToOne = () =&gt; associationEnd.isTargetEnd() &amp;&amp;
            !associationEnd.typeReference.isCollection &amp;&amp;
            !associationEnd.getOtherEnd().typeReference.isCollection &amp;&amp;
            associationEnd.getOtherEnd().typeReference.isNullable;
        return isManyToVariantsOfOne() || isSelfReferencingZeroToOne() || isAggregationalOneToOne();
    }
    function getPrimaryKeys(element) {
        let currentClass = element;
        while ((currentClass === null || currentClass === void 0 ? void 0 : currentClass.specialization) === "Class") {
            const pkAttributes = currentClass.getChildren("Attribute").filter(x =&gt; x.hasStereotype(primaryKeyStereotypeId));
            if (pkAttributes.length &gt; 0) {
                return pkAttributes.map(x =&gt; ({ name: x.getName(), typeId: x.typeReference.getTypeId() }));
            }
            const derivedTypes = currentClass
                .getAssociations("Generalization")
                .filter(generalization =&gt; generalization.isTargetEnd())
                .map(generalization =&gt; generalization.typeReference.getType());
            if (derivedTypes.length &gt; 1) {
                console.error(`Could not compute possible foreign keys as "${currentClass.getName()}" [${currentClass.id}] is derived from more than one class.`);
                return [createImplicitPrimaryKey()];
            }
            currentClass = derivedTypes[0];
            if ((currentClass === null || currentClass === void 0 ? void 0 : currentClass.id) === (element === null || element === void 0 ? void 0 : element.id)) {
                console.error(`Could not compute possible foreign keys as "${element.getName()}" [${element.id}] has cyclic inheritance.`);
                return [createImplicitPrimaryKey()];
            }
        }
        return [createImplicitPrimaryKey()];
        function createImplicitPrimaryKey() {
            return {
                name: applyAttributeNamingConvention("Id"),
                typeId: getSurrogateKeyType()
            };
        }
    }
}
/// &lt;reference path="../../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../_common/constants.ts" /&gt;
/// &lt;reference path="../_common/updateForeignKeys.ts" /&gt;
function execute() {
    if (element.hasMetadata(metadataKey.isBeingDeletedByScript) ||
        !element.hasMetadata(metadataKey.isManagedKey) ||
        !element.getPackage().hasStereotype(relationalDatabaseId)) {
        return;
    }
    const classElement = element.getParent();
    if (element.hasStereotype(primaryKeyStereotypeId)) {
        classElement.setMetadata(metadataKey.autoManageKeys, "false");
    }
    for (const association of classElement.getAssociations("Association")) {
        updateForeignKeys(association.getOtherEnd());
    }
}
execute();
</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10">
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Auto Manage Keys</text>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <script>function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
const primaryKeyStereotypeId = "b99aac21-9ca4-467f-a3a6-046255a9eed6";
const relationalDatabaseId = "51a7bcf5-0eb9-4c9a-855e-3ead1048729c";
const foreignKeyStereotypeId = "793a5128-57a1-440b-a206-af5722b752a6";
const foreignKeyStereotypeAssociationProperty = "Association";
const metadataKey = {
    association: "association",
    autoManageKeys: "auto-manage-keys",
    fkOriginalName: "fk-original-name",
    isBeingDeletedByScript: "is-being-deleted-by-script",
    isManagedKey: "is-managed-key",
};
/// &lt;reference path="../../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="constants.ts" /&gt;
function updatePrimaryKeys(element) {
    if (element.getMetadata(metadataKey.autoManageKeys) === "false" ||
        element.getPackage().specialization !== "Domain Package" ||
        !element.getPackage().hasStereotype(relationalDatabaseId)) {
        updateDerivedTypePks(element);
        return;
    }
    const pkAttributes = element.getChildren("Attribute").filter(x =&gt; x.hasStereotype(primaryKeyStereotypeId));
    if (derivedFromTypeHasPk(element)) {
        for (const pkAttribute of pkAttributes.filter(x =&gt; x.getMetadata(metadataKey.isManagedKey) === "true")) {
            pkAttribute.setMetadata(metadataKey.isBeingDeletedByScript, "true");
            pkAttribute.delete();
        }
        updateDerivedTypePks(element);
        return;
    }
    if (pkAttributes.length &gt; 0) {
        updateDerivedTypePks(element);
        return;
    }
    const pkAttribute = createElement("Attribute", "id", element.id);
    pkAttribute.setOrder(0);
    pkAttribute.typeReference.setType(getSurrogateKeyType());
    pkAttribute.addStereotype(primaryKeyStereotypeId);
    pkAttribute.setMetadata(metadataKey.isManagedKey, "true");
    function derivedFromTypeHasPk(element) {
        return element.getAssociations("Generalization")
            .some(generalization =&gt; {
            if (!generalization.isTargetEnd()) {
                return false;
            }
            const baseType = generalization.typeReference.getType();
            if (baseType.getChildren("Attribute").some(attribute =&gt; attribute.hasStereotype(primaryKeyStereotypeId))) {
                return true;
            }
            return derivedFromTypeHasPk(baseType);
        });
    }
    function updateDerivedTypePks(element) {
        var derivedTypes = element.getAssociations("Generalization")
            .filter(generalization =&gt; generalization.isSourceEnd())
            .map(generalization =&gt; generalization.typeReference.getType());
        for (const derivedType of derivedTypes) {
            updatePrimaryKeys(derivedType);
        }
    }
}
/**
 * Applies camelCasing or PascalCasing naming convention according to the setting configured for the current application.
 */
function applyAttributeNamingConvention(str) {
    var _a, _b, _c;
    let convention = (_c = (_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
    }
    return str;
}
/// &lt;reference path="../../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="../../../common/applyAttributeNamingConvention.ts" /&gt;
/// &lt;reference path="../_common/constants.ts" /&gt;
function updateForeignKeys(thisEnd) {
    var _a, _b;
    if (((_b = (_a = application === null || application === void 0 ? void 0 : application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Creation Mode")) === null || _b === void 0 ? void 0 : _b.value) != "explicit") {
        return;
    }
    let otherEnd = thisEnd.getOtherEnd();
    if (!otherEnd.typeReference.getType().getPackage().hasStereotype(relationalDatabaseId)) {
        return;
    }
    let thisEndType = thisEnd.getOtherEnd().typeReference.getType();
    let otherEndType = thisEnd.typeReference.getType();
    if ((thisEndType === null || thisEndType === void 0 ? void 0 : thisEndType.specialization) !== "Class" || (otherEndType === null || otherEndType === void 0 ? void 0 : otherEndType.specialization) !== "Class") {
        return;
    }
    const targetEndId = thisEnd.isTargetEnd() ? thisEnd.id : otherEnd.id;
    if (requiresForeignKey(thisEnd)) {
        updateForeignKeyAttribute(thisEnd, thisEndType, otherEndType, targetEndId);
        return;
    }
    thisEndType.getChildren()
        .filter(x =&gt; x.getMetadata(metadataKey.association) == targetEndId)
        .forEach(x =&gt; {
        x.setMetadata(metadataKey.isBeingDeletedByScript, "true");
        x.delete();
    });
    function updateForeignKeyAttribute(thisEnd, thisEndType, otherEndType, targetEndId) {
        const pkAttributes = getPrimaryKeys(otherEndType);
        pkAttributes.forEach((pk, index) =&gt; {
            var _a;
            let fkAttribute = (_a = thisEndType.getChildren().filter(x =&gt; x.getMetadata(metadataKey.association) == targetEndId)[index]) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Attribute", "", thisEndType.id);
            // This check to avoid a loop where the Domain script is updating the conventions and this keeps renaming it back.
            let fkNameToUse = `${toCamelCase(thisEnd.getName())}${toPascalCase(pk.name)}`;
            if (fkAttribute.getName().toLocaleLowerCase() !== fkNameToUse.toLocaleLowerCase()) {
                if (!fkAttribute.hasMetadata(metadataKey.fkOriginalName) || (fkAttribute.getMetadata(metadataKey.fkOriginalName) == fkAttribute.getName())) {
                    fkAttribute.setName(fkNameToUse);
                    fkAttribute.setMetadata(metadataKey.fkOriginalName, fkAttribute.getName());
                }
            }
            fkAttribute.setMetadata(metadataKey.association, targetEndId);
            fkAttribute.setMetadata(metadataKey.isManagedKey, "true");
            let fkStereotype = fkAttribute.getStereotype(foreignKeyStereotypeId);
            if (fkStereotype == null) {
                fkAttribute.addStereotype(foreignKeyStereotypeId);
                fkStereotype = fkAttribute.getStereotype(foreignKeyStereotypeId);
            }
            fkStereotype.getProperty(foreignKeyStereotypeAssociationProperty).setValue(thisEnd.isTargetEnd() ? thisEnd.id : thisEnd.getOtherEnd().id);
            fkAttribute.typeReference.setType(pk.typeId);
            fkAttribute.typeReference.setIsNullable(thisEnd.typeReference.isNullable);
        });
        thisEndType.getChildren().filter(x =&gt; x.getMetadata(metadataKey.association) == targetEndId).forEach((attr, index) =&gt; {
            if (index &gt;= pkAttributes.length) {
                attr.setMetadata(metadataKey.isBeingDeletedByScript, "true");
                attr.delete();
            }
        });
        if (otherEndType.id !== thisEndType.id) {
            otherEndType.getChildren()
                .filter(x =&gt; x.getMetadata(metadataKey.association) == targetEndId)
                .forEach(x =&gt; {
                x.setMetadata(metadataKey.isBeingDeletedByScript, "true");
                x.delete();
            });
        }
    }
    function requiresForeignKey(associationEnd) {
        const isManyToVariantsOfOne = () =&gt; !associationEnd.typeReference.isCollection &amp;&amp;
            associationEnd.getOtherEnd().typeReference.isCollection;
        const isSelfReferencingZeroToOne = () =&gt; !associationEnd.typeReference.isCollection &amp;&amp;
            associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
        const isAggregationalOneToOne = () =&gt; associationEnd.isTargetEnd() &amp;&amp;
            !associationEnd.typeReference.isCollection &amp;&amp;
            !associationEnd.getOtherEnd().typeReference.isCollection &amp;&amp;
            associationEnd.getOtherEnd().typeReference.isNullable;
        return isManyToVariantsOfOne() || isSelfReferencingZeroToOne() || isAggregationalOneToOne();
    }
    function getPrimaryKeys(element) {
        let currentClass = element;
        while ((currentClass === null || currentClass === void 0 ? void 0 : currentClass.specialization) === "Class") {
            const pkAttributes = currentClass.getChildren("Attribute").filter(x =&gt; x.hasStereotype(primaryKeyStereotypeId));
            if (pkAttributes.length &gt; 0) {
                return pkAttributes.map(x =&gt; ({ name: x.getName(), typeId: x.typeReference.getTypeId() }));
            }
            const derivedTypes = currentClass
                .getAssociations("Generalization")
                .filter(generalization =&gt; generalization.isTargetEnd())
                .map(generalization =&gt; generalization.typeReference.getType());
            if (derivedTypes.length &gt; 1) {
                console.error(`Could not compute possible foreign keys as "${currentClass.getName()}" [${currentClass.id}] is derived from more than one class.`);
                return [createImplicitPrimaryKey()];
            }
            currentClass = derivedTypes[0];
            if ((currentClass === null || currentClass === void 0 ? void 0 : currentClass.id) === (element === null || element === void 0 ? void 0 : element.id)) {
                console.error(`Could not compute possible foreign keys as "${element.getName()}" [${element.id}] has cyclic inheritance.`);
                return [createImplicitPrimaryKey()];
            }
        }
        return [createImplicitPrimaryKey()];
        function createImplicitPrimaryKey() {
            return {
                name: applyAttributeNamingConvention("Id"),
                typeId: getSurrogateKeyType()
            };
        }
    }
}
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.RDBMS
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/rdbms/key-automation-extensions/class-auto-manage-keys.ts/class-auto-manage-keys.ts
 */
/// &lt;reference path="../_common/updatePrimaryKeys.ts" /&gt;
/// &lt;reference path="../_common/updateForeignKeys.ts" /&gt;
function execute() {
    var _a, _b;
    if (!element.getPackage().hasStereotype(relationalDatabaseId)) {
        return;
    }
    element.removeMetadata(metadataKey.autoManageKeys);
    if (((_b = (_a = application === null || application === void 0 ? void 0 : application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Creation Mode")) === null || _b === void 0 ? void 0 : _b.value) != "explicit") {
        return;
    }
    updatePrimaryKeys(element);
    for (const association of element.getAssociations("Association")) {
        updateForeignKeys(association);
        updateForeignKeys(association.getOtherEnd());
    }
}
execute();
</script>
        </option>
      </scriptOptions>
      <typeOrder />
      <mappingSettings />
      <macros>
        <macro trigger="on-changed">
          <script>function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
const primaryKeyStereotypeId = "b99aac21-9ca4-467f-a3a6-046255a9eed6";
const relationalDatabaseId = "51a7bcf5-0eb9-4c9a-855e-3ead1048729c";
const foreignKeyStereotypeId = "793a5128-57a1-440b-a206-af5722b752a6";
const foreignKeyStereotypeAssociationProperty = "Association";
const metadataKey = {
    association: "association",
    autoManageKeys: "auto-manage-keys",
    fkOriginalName: "fk-original-name",
    isBeingDeletedByScript: "is-being-deleted-by-script",
    isManagedKey: "is-managed-key",
};
/// &lt;reference path="../../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="constants.ts" /&gt;
function updatePrimaryKeys(element) {
    if (element.getMetadata(metadataKey.autoManageKeys) === "false" ||
        element.getPackage().specialization !== "Domain Package" ||
        !element.getPackage().hasStereotype(relationalDatabaseId)) {
        updateDerivedTypePks(element);
        return;
    }
    const pkAttributes = element.getChildren("Attribute").filter(x =&gt; x.hasStereotype(primaryKeyStereotypeId));
    if (derivedFromTypeHasPk(element)) {
        for (const pkAttribute of pkAttributes.filter(x =&gt; x.getMetadata(metadataKey.isManagedKey) === "true")) {
            pkAttribute.setMetadata(metadataKey.isBeingDeletedByScript, "true");
            pkAttribute.delete();
        }
        updateDerivedTypePks(element);
        return;
    }
    if (pkAttributes.length &gt; 0) {
        updateDerivedTypePks(element);
        return;
    }
    const pkAttribute = createElement("Attribute", "id", element.id);
    pkAttribute.setOrder(0);
    pkAttribute.typeReference.setType(getSurrogateKeyType());
    pkAttribute.addStereotype(primaryKeyStereotypeId);
    pkAttribute.setMetadata(metadataKey.isManagedKey, "true");
    function derivedFromTypeHasPk(element) {
        return element.getAssociations("Generalization")
            .some(generalization =&gt; {
            if (!generalization.isTargetEnd()) {
                return false;
            }
            const baseType = generalization.typeReference.getType();
            if (baseType.getChildren("Attribute").some(attribute =&gt; attribute.hasStereotype(primaryKeyStereotypeId))) {
                return true;
            }
            return derivedFromTypeHasPk(baseType);
        });
    }
    function updateDerivedTypePks(element) {
        var derivedTypes = element.getAssociations("Generalization")
            .filter(generalization =&gt; generalization.isSourceEnd())
            .map(generalization =&gt; generalization.typeReference.getType());
        for (const derivedType of derivedTypes) {
            updatePrimaryKeys(derivedType);
        }
    }
}
/**
 * Applies camelCasing or PascalCasing naming convention according to the setting configured for the current application.
 */
function applyAttributeNamingConvention(str) {
    var _a, _b, _c;
    let convention = (_c = (_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
    }
    return str;
}
/// &lt;reference path="../../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="../../../common/applyAttributeNamingConvention.ts" /&gt;
/// &lt;reference path="../_common/constants.ts" /&gt;
function updateForeignKeys(thisEnd) {
    var _a, _b;
    if (((_b = (_a = application === null || application === void 0 ? void 0 : application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Creation Mode")) === null || _b === void 0 ? void 0 : _b.value) != "explicit") {
        return;
    }
    let otherEnd = thisEnd.getOtherEnd();
    if (!otherEnd.typeReference.getType().getPackage().hasStereotype(relationalDatabaseId)) {
        return;
    }
    let thisEndType = thisEnd.getOtherEnd().typeReference.getType();
    let otherEndType = thisEnd.typeReference.getType();
    if ((thisEndType === null || thisEndType === void 0 ? void 0 : thisEndType.specialization) !== "Class" || (otherEndType === null || otherEndType === void 0 ? void 0 : otherEndType.specialization) !== "Class") {
        return;
    }
    const targetEndId = thisEnd.isTargetEnd() ? thisEnd.id : otherEnd.id;
    if (requiresForeignKey(thisEnd)) {
        updateForeignKeyAttribute(thisEnd, thisEndType, otherEndType, targetEndId);
        return;
    }
    thisEndType.getChildren()
        .filter(x =&gt; x.getMetadata(metadataKey.association) == targetEndId)
        .forEach(x =&gt; {
        x.setMetadata(metadataKey.isBeingDeletedByScript, "true");
        x.delete();
    });
    function updateForeignKeyAttribute(thisEnd, thisEndType, otherEndType, targetEndId) {
        const pkAttributes = getPrimaryKeys(otherEndType);
        pkAttributes.forEach((pk, index) =&gt; {
            var _a;
            let fkAttribute = (_a = thisEndType.getChildren().filter(x =&gt; x.getMetadata(metadataKey.association) == targetEndId)[index]) !== null &amp;&amp; _a !== void 0 ? _a : createElement("Attribute", "", thisEndType.id);
            // This check to avoid a loop where the Domain script is updating the conventions and this keeps renaming it back.
            let fkNameToUse = `${toCamelCase(thisEnd.getName())}${toPascalCase(pk.name)}`;
            if (fkAttribute.getName().toLocaleLowerCase() !== fkNameToUse.toLocaleLowerCase()) {
                if (!fkAttribute.hasMetadata(metadataKey.fkOriginalName) || (fkAttribute.getMetadata(metadataKey.fkOriginalName) == fkAttribute.getName())) {
                    fkAttribute.setName(fkNameToUse);
                    fkAttribute.setMetadata(metadataKey.fkOriginalName, fkAttribute.getName());
                }
            }
            fkAttribute.setMetadata(metadataKey.association, targetEndId);
            fkAttribute.setMetadata(metadataKey.isManagedKey, "true");
            let fkStereotype = fkAttribute.getStereotype(foreignKeyStereotypeId);
            if (fkStereotype == null) {
                fkAttribute.addStereotype(foreignKeyStereotypeId);
                fkStereotype = fkAttribute.getStereotype(foreignKeyStereotypeId);
            }
            fkStereotype.getProperty(foreignKeyStereotypeAssociationProperty).setValue(thisEnd.isTargetEnd() ? thisEnd.id : thisEnd.getOtherEnd().id);
            fkAttribute.typeReference.setType(pk.typeId);
            fkAttribute.typeReference.setIsNullable(thisEnd.typeReference.isNullable);
        });
        thisEndType.getChildren().filter(x =&gt; x.getMetadata(metadataKey.association) == targetEndId).forEach((attr, index) =&gt; {
            if (index &gt;= pkAttributes.length) {
                attr.setMetadata(metadataKey.isBeingDeletedByScript, "true");
                attr.delete();
            }
        });
        if (otherEndType.id !== thisEndType.id) {
            otherEndType.getChildren()
                .filter(x =&gt; x.getMetadata(metadataKey.association) == targetEndId)
                .forEach(x =&gt; {
                x.setMetadata(metadataKey.isBeingDeletedByScript, "true");
                x.delete();
            });
        }
    }
    function requiresForeignKey(associationEnd) {
        const isManyToVariantsOfOne = () =&gt; !associationEnd.typeReference.isCollection &amp;&amp;
            associationEnd.getOtherEnd().typeReference.isCollection;
        const isSelfReferencingZeroToOne = () =&gt; !associationEnd.typeReference.isCollection &amp;&amp;
            associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
        const isAggregationalOneToOne = () =&gt; associationEnd.isTargetEnd() &amp;&amp;
            !associationEnd.typeReference.isCollection &amp;&amp;
            !associationEnd.getOtherEnd().typeReference.isCollection &amp;&amp;
            associationEnd.getOtherEnd().typeReference.isNullable;
        return isManyToVariantsOfOne() || isSelfReferencingZeroToOne() || isAggregationalOneToOne();
    }
    function getPrimaryKeys(element) {
        let currentClass = element;
        while ((currentClass === null || currentClass === void 0 ? void 0 : currentClass.specialization) === "Class") {
            const pkAttributes = currentClass.getChildren("Attribute").filter(x =&gt; x.hasStereotype(primaryKeyStereotypeId));
            if (pkAttributes.length &gt; 0) {
                return pkAttributes.map(x =&gt; ({ name: x.getName(), typeId: x.typeReference.getTypeId() }));
            }
            const derivedTypes = currentClass
                .getAssociations("Generalization")
                .filter(generalization =&gt; generalization.isTargetEnd())
                .map(generalization =&gt; generalization.typeReference.getType());
            if (derivedTypes.length &gt; 1) {
                console.error(`Could not compute possible foreign keys as "${currentClass.getName()}" [${currentClass.id}] is derived from more than one class.`);
                return [createImplicitPrimaryKey()];
            }
            currentClass = derivedTypes[0];
            if ((currentClass === null || currentClass === void 0 ? void 0 : currentClass.id) === (element === null || element === void 0 ? void 0 : element.id)) {
                console.error(`Could not compute possible foreign keys as "${element.getName()}" [${element.id}] has cyclic inheritance.`);
                return [createImplicitPrimaryKey()];
            }
        }
        return [createImplicitPrimaryKey()];
        function createImplicitPrimaryKey() {
            return {
                name: applyAttributeNamingConvention("Id"),
                typeId: getSurrogateKeyType()
            };
        }
    }
}
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.RDBMS
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/rdbms/key-automation-extensions/class-on-changed/class-on-changed.ts
 */
/// &lt;reference path="../_common/updatePrimaryKeys.ts" /&gt;
/// &lt;reference path="../_common/updateForeignKeys.ts" /&gt;
function execute() {
    var _a, _b;
    if (((_b = (_a = application === null || application === void 0 ? void 0 : application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Creation Mode")) === null || _b === void 0 ? void 0 : _b.value) != "explicit" ||
        !element.getPackage().hasStereotype(relationalDatabaseId)) {
        return;
    }
    updatePrimaryKeys(element);
    updateForeignKeysAndForDerived(element);
    function updateForeignKeysAndForDerived(forElement) {
        for (const association of forElement.getAssociations("Association")) {
            updateForeignKeys(association);
            updateForeignKeys(association.getOtherEnd());
        }
        var associationIds = forElement.getAssociations("Association")
            .map(thisEnd =&gt; thisEnd.isTargetEnd() ? thisEnd.id : thisEnd.getOtherEnd().id);
        var fkAttributesToDelete = forElement.getChildren("Attribute")
            .filter(association =&gt; association.hasStereotype(foreignKeyStereotypeId) &amp;&amp;
            association.hasMetadata(metadataKey.association) &amp;&amp;
            !associationIds.some(id =&gt; id === association.getMetadata(metadataKey.association)));
        for (const fkAttribute of fkAttributesToDelete) {
            fkAttribute.setMetadata(metadataKey.isBeingDeletedByScript, "true");
            fkAttribute.delete();
        }
        var derivedTypes = forElement.getAssociations("Generalization")
            .filter(generalization =&gt; generalization.isSourceEnd())
            .map(generalization =&gt; generalization.typeReference.getType());
        for (const derivedType of derivedTypes) {
            updateForeignKeysAndForDerived(derivedType);
        }
    }
}
execute();
</script>
        </macro>
        <macro trigger="on-created">
          <script>function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
const primaryKeyStereotypeId = "b99aac21-9ca4-467f-a3a6-046255a9eed6";
const relationalDatabaseId = "51a7bcf5-0eb9-4c9a-855e-3ead1048729c";
const foreignKeyStereotypeId = "793a5128-57a1-440b-a206-af5722b752a6";
const foreignKeyStereotypeAssociationProperty = "Association";
const metadataKey = {
    association: "association",
    autoManageKeys: "auto-manage-keys",
    fkOriginalName: "fk-original-name",
    isBeingDeletedByScript: "is-being-deleted-by-script",
    isManagedKey: "is-managed-key",
};
/// &lt;reference path="../../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../../common/getSurrogateKeyType.ts" /&gt;
/// &lt;reference path="constants.ts" /&gt;
function updatePrimaryKeys(element) {
    if (element.getMetadata(metadataKey.autoManageKeys) === "false" ||
        element.getPackage().specialization !== "Domain Package" ||
        !element.getPackage().hasStereotype(relationalDatabaseId)) {
        updateDerivedTypePks(element);
        return;
    }
    const pkAttributes = element.getChildren("Attribute").filter(x =&gt; x.hasStereotype(primaryKeyStereotypeId));
    if (derivedFromTypeHasPk(element)) {
        for (const pkAttribute of pkAttributes.filter(x =&gt; x.getMetadata(metadataKey.isManagedKey) === "true")) {
            pkAttribute.setMetadata(metadataKey.isBeingDeletedByScript, "true");
            pkAttribute.delete();
        }
        updateDerivedTypePks(element);
        return;
    }
    if (pkAttributes.length &gt; 0) {
        updateDerivedTypePks(element);
        return;
    }
    const pkAttribute = createElement("Attribute", "id", element.id);
    pkAttribute.setOrder(0);
    pkAttribute.typeReference.setType(getSurrogateKeyType());
    pkAttribute.addStereotype(primaryKeyStereotypeId);
    pkAttribute.setMetadata(metadataKey.isManagedKey, "true");
    function derivedFromTypeHasPk(element) {
        return element.getAssociations("Generalization")
            .some(generalization =&gt; {
            if (!generalization.isTargetEnd()) {
                return false;
            }
            const baseType = generalization.typeReference.getType();
            if (baseType.getChildren("Attribute").some(attribute =&gt; attribute.hasStereotype(primaryKeyStereotypeId))) {
                return true;
            }
            return derivedFromTypeHasPk(baseType);
        });
    }
    function updateDerivedTypePks(element) {
        var derivedTypes = element.getAssociations("Generalization")
            .filter(generalization =&gt; generalization.isSourceEnd())
            .map(generalization =&gt; generalization.typeReference.getType());
        for (const derivedType of derivedTypes) {
            updatePrimaryKeys(derivedType);
        }
    }
}
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.RDBMS
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/rdbms/key-automation-extensions/class-on-created/class-on-created.ts
 */
/// &lt;reference path="../_common/updatePrimaryKeys.ts" /&gt;
function execute() {
    var _a, _b;
    if (((_b = (_a = application === null || application === void 0 ? void 0 : application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Creation Mode")) === null || _b === void 0 ? void 0 : _b.value) != "explicit" ||
        !element.getPackage().hasStereotype(relationalDatabaseId)) {
        return;
    }
    updatePrimaryKeys(element);
}
execute();
</script>
        </macro>
      </macros>
    </elementExtension>
  </elementExtensions>
  <associationSettings />
  <associationExtensions />
</settings>